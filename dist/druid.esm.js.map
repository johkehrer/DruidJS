{"version":3,"file":"druid.esm.js","sources":["../metrics/euclidean.js","../metrics/euclidean_squared.js","../metrics/cosine.js","../metrics/manhattan.js","../metrics/chebyshev.js","../metrics/canberra.js","../metrics/jaccard.js","../metrics/hamming.js","../metrics/sokal_michener.js","../metrics/yule.js","../matrix/k_nearest_neighbors.js","../matrix/distance_matrix.js","../matrix/linspace.js","../matrix/norm.js","../matrix/normalize.js","../numerical/kahan_sum.js","../numerical/neumair_sum.js","../linear_algebra/qr.js","../linear_algebra/qr_householder.js","../linear_algebra/simultaneous_poweriteration.js","../linear_algebra/inner_product.js","../matrix/Matrix.js","../util/randomizer.js","../util/max.js","../util/min.js","../datastructure/Heap.js","../datastructure/DisjointSet.js","../knn/BallTree.js","../knn/KNN.js","../dimred/DR.js","../dimred/PCA.js","../dimred/MDS.js","../dimred/ISOMAP.js","../dimred/FASTMAP.js","../dimred/LDA.js","../dimred/LLE.js","../dimred/LTSA.js","../dimred/TSNE.js","../optimization/powell.js","../dimred/UMAP.js","../dimred/TriMap.js","../clustering/Hierarchical_Clustering.js","../clustering/KMeans.js","../clustering/KMedoids.js","../clustering/OPTICS.js","../dimred/LSP.js","../dimred/TopoMap.js","../dimred/SAMMON.js","../dimred/SQDMDS.js"],"sourcesContent":["import { euclidean_squared } from \"../metrics/index.js\";\n/**\n * Computes the euclidean distance (<code>l<sub>2</sub></code>) between <code>a</code> and <code>b</code>.\n * @memberof module:metrics\n * @alias euclidean\n * @param {Number[]} a\n * @param {Number[]} b\n * @returns {Number} the euclidean distance between <code>a</code> and <code>b</code>.\n */\nexport default function (a, b) {\n    return Math.sqrt(euclidean_squared(a, b));\n}\n","/**\n * Computes the squared euclidean distance (l<sub>2</sub><sup>2</sup>) between <code>a</code> and <code>b</code>.\n * @memberof module:metrics\n * @alias euclidean_squared\n * @param {Number[]} a\n * @param {Number[]} b\n * @returns {Number} the squared euclidean distance between <code>a</code> and <code>b</code>.\n */\nexport default function (a, b) {\n    if (a.length != b.length) return undefined;\n    const n = a.length;\n    let sum = 0;\n    for (let i = 0; i < n; ++i) {\n        const a_b = a[i] - b[i];\n        sum += a_b * a_b;\n    }\n    return sum;\n}\n","/**\n * Computes the cosine distance (not similarity) between {@link a} and {@link b}.\n * @memberof module:metrics\n * @alias cosine\n * @param {Number[]} a\n * @param {Number[]} b\n * @returns {Number} The cosine distance between {@link a} and {@link b}.\n * \n * @example\n * import * as druid from \"@saehrimnir/druidjs\";\n * \n * druid.cosine([1,0],[1,1]) == 0.7853981633974484 == π/4;\n * \n */\nexport default function (a, b) {\n    if (a.length !== b.length) return undefined;\n    let n = a.length;\n    let sum = 0;\n    let sum_a = 0;\n    let sum_b = 0;\n    for (let i = 0; i < n; ++i) {\n        sum += a[i] * b[i];\n        sum_a += a[i] * a[i];\n        sum_b += b[i] * b[i];\n    }\n    return Math.acos(sum / (Math.sqrt(sum_a) * Math.sqrt(sum_b)));\n}\n","/**\n * Computes the manhattan distance (<code>l<sub>1</sub></code>) between <code>a</code> and <code>b</code>.\n * @memberof module:metrics\n * @alias manhattan\n * @param {Array<Number>} a\n * @param {Array<Number>} b\n * @returns {Number} the manhattan distance between <code>a</code> and <code>b</code>.\n */ \nexport default function (a, b) {\n    if (a.length != b.length) return undefined;\n    const n = a.length;\n    let sum = 0;\n    for (let i = 0; i < n; ++i) {\n        sum += Math.abs(a[i] - b[i]);\n    }\n    return sum;\n}\n","/**\n * Computes the chebyshev distance (L<sub>∞</sub>) between {@link a} and {@link b}.\n * @memberof module:metrics\n * @alias chebyshev\n * @param {Number[]} a\n * @param {Number[]} b\n * @returns {Number} the chebyshev distance between {@link a} and {@link b}.\n */\nexport default function (a, b) {\n    if (a.length != b.length) return undefined;\n    const n = a.length;\n    let res = [];\n    for (let i = 0; i < n; ++i) {\n        res.push(Math.abs(a[i] - b[i]));\n    }\n    return Math.max(...res);\n}\n","/**\n * Computes the canberra distance between <code>a</code> and <code>b</code>.\n * @memberof module:metrics\n * @alias canberra\n * @param {Number[]} a \n * @param {Number[]} b \n * @returns {Number} the canberra distance between <code>a</code> and <code>b</code>.\n * @see {@link https://en.wikipedia.org/wiki/Canberra_distance}\n */\nexport default function(a, b) {\n    if (a.length !== b.length) return undefined;\n    const n = a.length;\n    let sum = 0;\n    for (let i = 0; i < n; ++i) {\n        sum += (Math.abs(a[i] - b[i]) / (Math.abs(a[i]) + Math.abs(b[i])))\n    }\n    return sum;\n}","/**\n * Computes the jaccard distance between <code>a</code> and <code>b</code>.\n * @memberof module:metrics\n * @alias jaccard\n * @param {Number[]} a\n * @param {Number[]} b\n * @returns {Number} the jaccard distance between <code>a</code> and <code>b</code>.\n */\nexport default function (a, b) {\n    if (a.length != b.length) return undefined;\n    const n = a.length;\n    let num_non_zero = 0;\n    let num_equal = 0;\n    for (let i = 0; i < n; ++i) {\n        const x = a[i] != 0;\n        const y = b[i] != 0;\n        num_non_zero += x || y;\n        num_equal += x && y;\n    }\n    return (num_non_zero - num_equal) / num_non_zero;\n}\n","/**\n * Computes the hamming distance between <code>a</code> and <code>b</code>.\n * @memberof module:metrics\n * @alias hamming\n * @param {Number[]} a\n * @param {Number[]} b\n * @returns {Number} the hamming distance between <code>a</code> and <code>b</code>.\n */\nexport default function (a, b) {\n    if (a.length != b.length) return undefined;\n    const n = a.length;\n    let disagree = 0;\n    for (let i = 0; i < n; ++i) {\n        const x = a[i];\n        const y = b[i];\n        disagree += x != y;\n    }\n    return disagree / n;\n}\n","/**\n * Computes the Sokal-Michener distance between <code>a</code> and <code>b</code>.\n * @memberof module:metrics\n * @alias sokal_michener\n * @param {Number[]} a \n * @param {Number[]} b \n * @returns {Number} the Sokal-Michener distance between <code>a</code> and <code>b</code>.  \n */\nexport default function(a, b) {\n    if (a.length != b.length) return undefined\n    const n = a.length;\n    let num_not_equal = 0;\n    for (let i = 0; i < n; ++i) {\n        const x = a[i] != 0;\n        const y = b[i] != 0;\n        num_not_equal += x != y;\n    }\n    return (2 * num_not_equal) / (n + num_not_equal);\n}","/**\n * Computes the yule distance between <code>a</code> and <code>b</code>.\n * @memberof module:metrics\n * @alias yule\n * @param {Number[]} a\n * @param {Number[]} b\n * @returns {Number} the yule distance between <code>a</code> and <code>b</code>.\n */\nexport default function (a, b) {\n    if (a.length != b.length) return undefined;\n    const n = a.length;\n    let num_true_true = 0;\n    let num_true_false = 0;\n    let num_false_true = 0;\n    for (let i = 0; i < n; ++i) {\n        const x = a[i] != 0;\n        const y = b[i] != 0;\n        num_true_true += x && y;\n        num_true_false += x && !y;\n        num_false_true += !x && x;\n    }\n    const num_false_false = n - num_true_true - num_true_false - num_false_true;\n    return num_true_false == 0 || num_false_true == 0 ? 0 : (2 * num_true_false * num_false_true) / (num_true_true * num_false_false + num_true_false * num_false_true);\n}\n","import { distance_matrix } from \"../matrix/index.js\";\nimport { euclidean } from \"../metrics/index.js\";\n\n/**\n * Computes the k-nearest neighbors of each row of {@link A}.\n * @memberof module:matrix\n * @alias k_nearest_neigbhors\n * @param {Matrix} A - Either the data matrix, or a distance matrix.\n * @param {Number} k - The number of neighbors to compute.\n * @param {Function|\"precomputed\"} [metric=euclidean]\n * @returns {Array<Object>} -\n */\nexport default function (A, k, metric = euclidean) {\n    const rows = A.shape[0];\n    let D = metric == \"precomputed\" ? A : distance_matrix(A, metric);\n    let nN = new Array(rows);\n    for (let row = 0; row < rows; ++row) {\n        nN[row] = Array.from(D.row(row))\n            .map((distance, col) => {\n                return {\n                    i: row,\n                    j: col,\n                    distance: distance,\n                };\n            })\n            .sort((a, b) => a.distance - b.distance)\n            .slice(1, k + 1);\n    }\n    return nN;\n}\n","import { euclidean } from \"../metrics/index.js\";\nimport { Matrix } from \"./index.js\";\n\n/**\n * Computes the distance matrix of datamatrix {@link A}.\n * @memberof module:matrix\n * @alias distance_matrix\n * @param {Matrix} A - Matrix.\n * @param {Function} [metric=euclidean] - The diistance metric.\n * @returns {Matrix} D - The distance matrix of {@link A}.\n */\nexport default function (A, metric = euclidean) {\n    let n = A.shape[0];\n    const D = new Matrix(n, n);\n    for (let i = 0; i < n; ++i) {\n        const A_i = A.row(i);\n        for (let j = i + 1; j < n; ++j) {\n            const dist = metric(A_i, A.row(j));\n            D.set_entry(i, j, dist);\n            D.set_entry(j, i, dist);\n        }\n    }\n    return D;\n}\n","/**\n * Creates an Array containing {@link number} numbers from {@link start} to {@link end}.\n * If <code>{@link number} = null</null>.\n * @memberof module:matrix\n * @alias linspace\n * @param {Number} start - Start value.\n * @param {Number} end - End value.\n * @param {Number} [number = null] - Number of number between {@link start} and {@link end}.\n * @returns {Array} - An array with {@link number} entries, beginning at {@link start} ending at {@link end}.\n */\nexport default function (start, end, number = null) {\n    if (!number) {\n        number = Math.max(Math.round(end - start) + 1, 1);\n    }\n    if (number < 2) {\n        return number === 1 ? [start] : [];\n    }\n    let result = new Array(number);\n    number -= 1;\n    for (let i = number; i >= 0; --i) {\n        result[i] = (i * end + (number - i) * start) / number;\n    }\n    return result;\n}\n","import { euclidean } from \"../metrics/index.js\";\nimport { Matrix } from \"../matrix/index.js\";\n//import { neumair_sum } from \"../numerical/index\";\n\n/**\n * Computes the norm of a vector, by computing its distance to **0**.\n * @memberof module:matrix\n * @alias norm\n * @param {Matrix|Array<Number>|Float64Array} v - Vector.\n * @param {Function} [metric = euclidean] - Which metric should be used to compute the norm.\n * @returns {Number} - The norm of {@link v}.\n */\nexport default function (v, metric = euclidean) {\n    let vector = null;\n    if (v instanceof Matrix) {\n        let [rows, cols] = v.shape;\n        if (rows === 1) vector = v.row(0);\n        else if (cols === 1) vector = v.col(0);\n        else throw new Error(\"Matrix must be 1d!\");\n    } else {\n        vector = v;\n    }\n    const n = vector.length;\n    const zeros = new Float64Array(n);\n    return metric(vector, zeros);\n}\n","import { norm } from \"./index.js\";\nimport { euclidean } from \"../metrics/index.js\";\n\n/**\n * Normalizes Vector {@link v}.\n * @memberof module:matrix\n * @alias normalize\n * @param {Array<Number>|Float64Array} v - Vector\n * @param {Function} metric \n * @returns {Array<Number>|Float64Array} - The normalized vector with length 1.\n */\nexport default function(v, metric = euclidean)  {\n    const v_norm = norm(v, metric);\n    return v.map(value => value / v_norm);\n}","/**\n * Numerical stable summation with the Kahan summation algorithm.\n * @memberof module:numerical\n * @alias kahan_sum\n * @param {Array} summands - Array of values to sum up.\n * @returns {number} The sum.\n * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm}\n */\nexport default function (summands) {\n    let n = summands.length;\n    let sum = 0;\n    let compensation = 0;\n    let y, t;\n\n    for (let i = 0; i < n; ++i) {\n        y = summands[i] - compensation;\n        t = sum + y;\n        compensation = t - sum - y;\n        sum = t;\n    }\n    return sum;\n}\n","/**\n * Numerical stable summation with the Neumair summation algorithm.\n * @memberof module:numerical\n * @alias neumair_sum\n * @param {Number[]} summands - Array of values to sum up.\n * @returns {Number} The sum.\n * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements}\n */\nexport default function (summands) {\n    const n = summands.length;\n    let sum = 0;\n    let compensation = 0;\n\n    for (let i = 0; i < n; ++i) {\n        const summand = summands[i];\n        const t = sum + summand;\n        if (Math.abs(sum) >= Math.abs(summand)) {\n            compensation += sum - t + summand;\n        } else {\n            compensation += summand - t + sum;\n        }\n        sum = t;\n    }\n    return sum + compensation;\n}\n","import { Matrix, norm } from \"../matrix/index.js\";\nimport { euclidean } from \"../metrics/index.js\";\nimport { neumair_sum } from \"../numerical/index.js\";\n\n/**\n * Computes the QR Decomposition of the Matrix `A` using Gram-Schmidt process.\n * @memberof module:linear_algebra\n * @alias qr\n * @param {Matrix} A\n * @returns {{R: Matrix, Q: Matrix}}\n * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_the_Gram%E2%80%93Schmidt_process}\n */\nexport default function (A) {\n    const [rows, cols] = A.shape;\n    const Q = new Matrix(rows, cols, \"identity\");\n    const R = new Matrix(cols, cols, 0);\n\n    for (let j = 0; j < cols; ++j) {\n        let v = A.col(j);\n        for (let i = 0; i < j; ++i) {\n            const q = Q.col(i);\n            const q_dot_v = neumair_sum(q.map((q_, k) => q_ * v[k]));\n            for (let k = 0; k < rows; ++k) {\n                v[k] -= q_dot_v * q[k];\n            }\n            R.set_entry(i, j, q_dot_v);\n        }\n        const v_norm = norm(v, euclidean);\n        for (let k = 0; k < rows; ++k) {\n            Q.set_entry(k, j, v[k] / v_norm);\n        }\n        R.set_entry(j, j, v_norm);\n    }\n    return { R, Q };\n}\n","import { Matrix, norm } from \"../matrix/index.js\";\n\n/**\n * Computes the QR Decomposition of the Matrix {@link A} with householder transformations.\n * @memberof module:linear_algebra\n * @alias qr_householder\n * @param {Matrix} A\n * @returns {{R: Matrix, Q: Matrix}}\n * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections}\n * @see {@link http://mlwiki.org/index.php/Householder_Transformation}\n */\nexport default function (A) {\n    const [rows, cols] = A.shape;\n    const Q = new Matrix(rows, rows, \"I\");\n    const R = A.clone();\n\n    for (let j = 0; j < cols; ++j) {\n        const x = Matrix.from(R.col(j).slice(j));\n        const x_norm = norm(x);\n        const x0 = x.entry(0, 0);\n        const rho = -Math.sign(x0);\n        const u1 = x0 - rho * x_norm;\n        const u = x.divide(u1).set_entry(0, 0, 1);\n        const beta = (-rho * u1) / x_norm;\n\n        const u_outer_u = u.outer(u);\n        const R_block = R.get_block(j, 0);\n        const new_R = R_block.sub(u_outer_u.dot(R_block).mult(beta));\n        const Q_block = Q.get_block(0, j);\n        const new_Q = Q_block.sub(Q_block.dot(u_outer_u).mult(beta));\n        R.set_block(j, 0, new_R);\n        Q.set_block(0, j, new_Q);\n    }\n    return { R, Q };\n}\n","import { qr as qr_gramschmidt } from \"./index.js\";\nimport { Matrix } from \"../matrix/index.js\";\nimport { Randomizer } from \"../util/index.js\";\nimport { euclidean_squared } from \"../metrics/index.js\";\n\n/**\n * Computes the `k` biggest Eigenvectors and Eigenvalues from Matrix `A` with the QR-Algorithm.\n * @memberof module:linear_algebra\n * @alias simultaneous_poweriteration\n * @param {Matrix} A - The Matrix\n * @param {Number} k - The number of eigenvectors and eigenvalues to compute.\n * @param {Object} parameters - Object containing parameterization of the simultanious poweriteration method.\n * @param {Number} [parameters.max_iterations=100] - The number of maxiumum iterations the algorithm should run.\n * @param {Number|Randomizer} [parameters.seed=1212] - The seed value or a randomizer used in the algorithm.\n * @param {Function} [parameters.qr=qr_gramschmidt] - The QR technique to use.\n * @param {Number} [parameters.tol=1e-8] - Tolerated error for stopping criteria.\n * @returns {{eigenvalues: Number[], eigenvectors: Number[][]}} the `k` biggest eigenvectors and eigenvalues of Matrix `A`.\n */\nexport default function (A, k = 2, {seed = 1212, max_iterations = 100, qr = qr_gramschmidt, tol = 1e-8} = {}) {\n    const randomizer = seed instanceof Randomizer ? seed : new Randomizer(seed);\n    if (!(A instanceof Matrix)) A = Matrix.from(A);\n    const n = A.shape[0];\n    let { Q, R } = qr(new Matrix(n, k, () => (randomizer.random - .5) * 2));\n    while (max_iterations--) {\n        const oldQ = Q;\n        const Z = A.dot(Q);\n        const QR = qr(Z);\n        Q = QR.Q;\n        R = QR.R;\n        const error = euclidean_squared(Q.values, oldQ.values);\n        if (error < tol) {\n            break;\n        }\n    }\n\n    const eigenvalues = R.diag;\n    const eigenvectors = Q.transpose().to2dArray;\n    return { eigenvalues, eigenvectors };\n}\n","import { neumair_sum } from \"../numerical/index.js\";\n\n/**\n * Computes the inner product between two arrays of the same length.\n * @memberof module:linear_algebra\n * @alias inner_product\n * @param {Array|Float64Array} a - Array a\n * @param {Array|Float64Array} b - Array b\n * @returns The inner product between {@link a} and {@link b}\n */\nexport default function (a, b) {\n    const N = a.length;\n    if (N != b.length) {\n        throw new Error(\"Array a and b must have the same length!\")\n    }\n    let sum = 0;\n    for (let i = 0; i < N; ++i) {\n        sum += a * b;\n    }\n    return sum;\n}\n","import { neumair_sum } from \"../numerical/index.js\";\nimport { simultaneous_poweriteration } from \"../linear_algebra/index.js\";\nimport { Randomizer } from \"../util/index.js\";\n/**\n * @class\n * @alias Matrix\n * @requires module:numerical/neumair_sum\n */\nexport class Matrix {\n    /**\n     * creates a new Matrix. Entries are stored in a Float64Array.\n     * @memberof module:matrix\n     * @param {number} rows - The amount of rows of the matrix.\n     * @param {number} cols - The amount of columns of the matrix.\n     * @param {(function|string|number)} value=0 - Can be a function with row and col as parameters, a number, or \"zeros\", \"identity\" or \"I\", or \"center\".\n     *  - **function**: for each entry the function gets called with the parameters for the actual row and column.\n     *  - **string**: allowed are\n     *      - \"zero\", creates a zero matrix.\n     *      - \"identity\" or \"I\", creates an identity matrix.\n     *      - \"center\", creates an center matrix.\n     *  - **number**: create a matrix filled with the given value.\n     * @example\n     *\n     * let A = new Matrix(10, 10, () => Math.random()); //creates a 10 times 10 random matrix.\n     * let B = new Matrix(3, 3, \"I\"); // creates a 3 times 3 identity matrix.\n     * @returns {Matrix} returns a {@link rows} times {@link cols} Matrix filled with {@link value}.\n     */\n    constructor(rows = null, cols = null, value = null) {\n        this._rows = rows;\n        this._cols = cols;\n        this._data = null;\n        if (rows && cols) {\n            if (!value) {\n                this._data = new Float64Array(rows * cols);\n                return this;\n            }\n            if (typeof value === \"function\") {\n                this._data = new Float64Array(rows * cols);\n                for (let row = 0; row < rows; ++row) {\n                    for (let col = 0; col < cols; ++col) {\n                        this._data[row * cols + col] = value(row, col);\n                    }\n                }\n                return this;\n            }\n            if (typeof value === \"string\") {\n                if (value === \"zeros\") {\n                    return new Matrix(rows, cols, 0);\n                }\n                if (value === \"identity\" || value === \"I\") {\n                    this._data = new Float64Array(rows * cols);\n                    for (let row = 0; row < rows; ++row) {\n                        this._data[row * cols + row] = 1;\n                    }\n                    return this;\n                }\n                if (value === \"center\" && rows == cols) {\n                    this._data = new Float64Array(rows * cols);\n                    value = (i, j) => (i === j ? 1 : 0) - 1 / rows;\n                    for (let row = 0; row < rows; ++row) {\n                        for (let col = 0; col < cols; ++col) {\n                            this._data[row * cols + col] = value(row, col);\n                        }\n                    }\n                    return this;\n                }\n            }\n            if (typeof value === \"number\") {\n                this._data = new Float64Array(rows * cols);\n                for (let row = 0; row < rows; ++row) {\n                    for (let col = 0; col < cols; ++col) {\n                        this._data[row * cols + col] = value;\n                    }\n                }\n                return this;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Creates a Matrix out of {@link A}.\n     * @param {(Matrix|Array|Float64Array|number)} A - The matrix, array, or number, which should converted to a Matrix.\n     * @param {\"row\"|\"col\"|\"diag\"} [type = \"row\"] - If {@link A} is a Array or Float64Array, then type defines if it is a row- or a column vector.\n     * @returns {Matrix}\n     *\n     * @example\n     * let A = Matrix.from([[1, 0], [0, 1]]); //creates a two by two identity matrix.\n     * let S = Matrix.from([1, 2, 3], \"diag\"); // creates a 3 by 3 matrix with 1, 2, 3 on its diagonal. [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n     */\n    static from(A, type = \"row\") {\n        if (A instanceof Matrix) {\n            return A.clone();\n        } else if (Matrix.isArray(A)) {\n            let m = A.length;\n            if (m === 0) throw new Error(\"Array is empty\");\n            // 1d\n            if (!Matrix.isArray(A[0])) {\n                if (type === \"row\") {\n                    return new Matrix(1, m, (_, j) => A[j]);\n                } else if (type === \"col\") {\n                    return new Matrix(m, 1, (i) => A[i]);\n                } else if (type === \"diag\") {\n                    return new Matrix(m, m, (i, j) => (i == j ? A[i] : 0));\n                } else {\n                    throw new Error(\"1d array has NaN entries\");\n                }\n                // 2d\n            } else {\n                let n = A[0].length;\n                for (let row = 0; row < m; ++row) {\n                    if (A[row].length !== n) {\n                        throw new Error(\"various array lengths\");\n                    }\n                }\n                return new Matrix(m, n, (i, j) => A[i][j]);\n            }\n        } else if (typeof A === \"number\") {\n            return new Matrix(1, 1, A);\n        } else {\n            throw new Error(\"error\");\n        }\n    }\n\n    /**\n     * Returns the {@link row}<sup>th</sup> row from the Matrix.\n     * @param {Number} row\n     * @returns {Float64Array}\n     */\n    row(row) {\n        const data = this.values;\n        const cols = this._cols;\n        return data.subarray(row * cols, (row + 1) * cols);\n    }\n\n    /**\n     * Returns an generator yielding each row of the Matrix.\n     * @yields {Float64Array}\n     */\n    *iterate_rows() {\n        const cols = this._cols;\n        const rows = this._rows;\n        const data = this.values;\n        for (let row = 0; row < rows; ++row) {\n            yield data.subarray(row * cols, (row + 1) * cols);\n        }\n    }\n\n    /**\n     * Makes a {@link Matrix} object an iterable object.\n     * @yields {Float64Array}\n     */\n    *[Symbol.iterator]() {\n        for (const row of this.iterate_rows()) {\n            yield row;\n        }\n    }\n\n    /**\n     * Sets the entries of {@link row}<sup>th</sup> row from the Matrix to the entries from {@link values}.\n     * @param {Number} row\n     * @param {Array} values\n     * @returns {Matrix}\n     */\n    set_row(row, values) {\n        const cols = this._cols;\n        if (Matrix.isArray(values) && values.length === cols) {\n            const offset = row * cols;\n            for (let col = 0; col < cols; ++col) {\n                this.values[offset + col] = values[col];\n            }\n        } else if (values instanceof Matrix && values.shape[1] === cols && values.shape[0] === 1) {\n            const offset = row * cols;\n            for (let col = 0; col < cols; ++col) {\n                this.values[offset + col] = values._data[col];\n            }\n        } else {\n            throw new Error(\"Values not valid! Needs to be either an Array, a Float64Array, or a fitting Matrix!\")\n        }\n        return this;\n    }\n\n    /**\n     * Swaps the rows {@link row1} and {@link row2} of the Matrix.\n     * @param {Number} row1\n     * @param {Number} row2\n     * @returns {Matrix}\n     */\n    swap_rows(row1, row2) {\n        const cols = this._cols;\n        const data = this.values;\n        for (let i = row1 * cols, j = row2 * cols, col = 0; col < cols; ++col, ++i, ++j) {\n            const t = data[i];\n            data[i] = data[j];\n            data[j] = t;\n        }\n    }\n\n    /**\n     * Returns the {@link col}<sup>th</sup> column from the Matrix.\n     * @param {Number} col\n     * @returns {Array}\n     */\n    col(col) {\n        const result_col = new Float64Array(this._rows);\n        for (let row = 0; row < this._rows; ++row) {\n            result_col[row] = this.values[row * this._cols + col];\n        }\n        return result_col;\n    }\n\n    /**\n     * Returns the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix.\n     * @param {int} row\n     * @param {int} col\n     * @returns {float64}\n     */\n    entry(row, col) {\n        return this.values[row * this._cols + col];\n    }\n\n    /**\n     * Sets the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix to the given {@link value}.\n     * @param {int} row\n     * @param {int} col\n     * @param {float64} value\n     * @returns {Matrix}\n     */\n    set_entry(row, col, value) {\n        this.values[row * this._cols + col] = value;\n        return this;\n    }\n\n    /**\n     * Adds a given {@link value} to the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix.\n     * @param {int} row\n     * @param {int} col\n     * @param {float64} value\n     * @returns {Matrix}\n     */\n    add_entry(row, col, value) {\n      this.values[row * this._cols + col] += value;\n      return this;\n    }\n\n    /**\n     * Subtracts a given {@link value} from the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix.\n     * @param {int} row\n     * @param {int} col\n     * @param {float64} value\n     * @returns {Matrix}\n     */\n    sub_entry(row, col, value) {\n      this.values[row * this._cols + col] -= value;\n      return this;\n    }\n\n    /**\n     * Returns a new transposed Matrix.\n     * @returns {Matrix}\n     */\n    transpose() {\n        let B = new Matrix(this._cols, this._rows, (row, col) => this.entry(col, row));\n        return B;\n    }\n\n    /**\n     * Returns a new transposed Matrix. Short-form of {@function transpose}.\n     * @returns {Matrix}\n     */\n    get T() {\n        return this.transpose();\n    }\n\n    /**\n     * Returns the inverse of the Matrix.\n     * @returns {Matrix}\n     */\n    inverse() {\n        const rows = this._rows;\n        const cols = this._cols;\n        const A = this.clone();\n        const B = new Matrix(rows, cols, 'I');\n\n        // foreach column\n        for (let col = 0; col < cols; ++col) {\n            // Search for maximum in this column (pivot)\n            let max_idx = col;\n            let max_val = Math.abs(A.entry(col, col));\n            for (let row = col + 1; row < rows; ++row) {\n                const val = Math.abs(A.entry(row, col));\n                if (max_val < val) {\n                    max_idx = row;\n                    max_val = val;\n                }\n            }\n            if (max_val === 0) {\n                throw new Error('Cannot compute inverse of Matrix, determinant is zero');\n            }\n            // Swap maximum row with current row\n            if (max_idx !== col) {\n                A.swap_rows(col, max_idx);\n                B.swap_rows(col, max_idx);\n            }\n\n            // eliminate non-zero values on the other rows at column c\n            const A_col = A.row(col);\n            const B_col = B.row(col);\n            for (let row = 0; row < rows; ++row) {\n                if (row !== col) {\n                    // eliminate value at column c and row r\n                    const A_row = A.row(row);\n                    const B_row = B.row(row);\n                    if (A_row[col] !== 0) {\n                        const f = A_row[col] / A_col[col];\n                        // sub (f * row c) from row r to eliminate the value at column c\n                        for (let s = col; s < cols; ++s) {\n                            A_row[s] -= (f * A_col[s]);\n                        }\n                        for (let s = 0; s < cols; ++s) {\n                            B_row[s] -= (f * B_col[s]);\n                        }\n                    }\n                } else {\n                    // normalize value at Acc to 1 (diagonal):\n                    // divide each value of row r=c by the value at Acc\n                    const f = A_col[col];\n                    for (let s = col; s < cols; ++s) {\n                        A_col[s] /= f;\n                    }\n                    for (let s = 0; s < cols; ++s) {\n                        B_col[s] /= f;\n                    }\n                }\n            }\n        }\n        return B;\n    }\n\n    /**\n     * Returns the dot product. If {@link B} is an Array or Float64Array then an Array gets returned. If {@link B} is a Matrix then a Matrix gets returned.\n     * @param {(Matrix|Array|Float64Array)} B the right side\n     * @returns {(Matrix|Array)}\n     */\n    dot(B) {\n        if (B instanceof Matrix) {\n            let A = this;\n            const [rows_A, cols_A] = A.shape;\n            const [rows_B, cols_B] = B.shape;\n            if (cols_A !== rows_B) {\n                throw new Error(`A.dot(B): A is a ${A.shape.join(\" ⨯ \")}-Matrix, B is a ${B.shape.join(\" ⨯ \")}-Matrix:\n                A has ${cols_A} cols and B ${rows_B} rows.\n                Must be equal!`);\n            }\n            const C = new Matrix(rows_A, cols_B, (row, col) => {\n                const A_i = A.row(row);\n                const B_val = B.values;\n                let sum = 0;\n                for (let i = 0, j = col; i < cols_A; ++i, j += cols_B) {\n                    sum += A_i[i] * B_val[j];\n                }\n                return sum;\n            });\n            return C;\n        } else if (Matrix.isArray(B)) {\n            let rows = this._rows;\n            if (B.length !== rows) {\n                throw new Error(`A.dot(B): A has ${rows} cols and B has ${B.length} rows. Must be equal!`);\n            }\n            let C = new Array(rows);\n            for (let row = 0; row < rows; ++row) {\n                C[row] = neumair_sum(this.row(row).map((e) => e * B[row]));\n            }\n            return C;\n        } else {\n            throw new Error(`B must be Matrix or Array`);\n        }\n    }\n\n    /**\n     * Transposes the current matrix and returns the dot product with {@link B}.\n     * If {@link B} is an Array or Float64Array then an Array gets returned.\n     * If {@link B} is a Matrix then a Matrix gets returned.\n     * @param {(Matrix|Array|Float64Array)} B the right side\n     * @returns {(Matrix|Array)}\n     */\n    transDot(B) {\n        if (B instanceof Matrix) {\n            let A = this;\n            const [cols_A, rows_A] = A.shape; // transpose matrix\n            const [rows_B, cols_B] = B.shape;\n            if (cols_A !== rows_B) {\n                throw new Error(`A.dot(B): A is a ${[rows_A, cols_A].join(\" ⨯ \")}-Matrix, B is a ${B.shape.join(\" ⨯ \")}-Matrix:\n                A has ${cols_A} cols and B ${rows_B} rows, which must be equal!`);\n            }\n            // let B = new Matrix(this._cols, this._rows, (row, col) => this.entry(col, row));\n            // this.values[row * this._cols + col];\n            const C = new Matrix(rows_A, cols_B, (row, col) => {\n                const A_val = A.values;\n                const B_val = B.values;\n                let sum = 0;\n                for (let i = 0, j = row, k = col; i < cols_A; ++i, j += rows_A, k += cols_B) {\n                    sum += A_val[j] * B_val[k];\n                }\n                return sum;\n            });\n            return C;\n        } else if (Matrix.isArray(B)) {\n            let rows = this._cols;\n            if (B.length !== rows) {\n                throw new Error(`A.dot(B): A has ${rows} cols and B has ${B.length} rows. Must be equal!`);\n            }\n            let C = new Array(rows);\n            for (let row = 0; row < rows; ++row) {\n                C[row] = neumair_sum(this.col(row).map((e) => e * B[row]));\n            }\n            return C;\n        } else {\n            throw new Error(`B must be Matrix or Array`);\n        }\n    }\n\n    /**\n     * Returns the dot product with the transposed version of {@link B}.\n     * If {@link B} is an Array or Float64Array then an Array gets returned.\n     * If {@link B} is a Matrix then a Matrix gets returned.\n     * @param {(Matrix|Array|Float64Array)} B the right side\n     * @returns {(Matrix|Array)}\n     */\n    dotTrans(B) {\n        if (B instanceof Matrix) {\n            let A = this;\n            const [rows_A, cols_A] = A.shape;\n            const [cols_B, rows_B] = B.shape;\n            if (cols_A !== rows_B) {\n                throw new Error(`A.dot(B): A is a ${A.shape.join(\" ⨯ \")}-Matrix, B is a ${[rows_B, cols_B].join(\" ⨯ \")}-Matrix:\n                A has ${cols_A} cols and B ${rows_B} rows, which must be equal!`);\n            }\n            const C = new Matrix(rows_A, cols_B, (row, col) => {\n                const A_i = A.row(row);\n                const B_i = B.row(col);\n                let sum = 0;\n                for (let i = 0; i < cols_A; ++i) {\n                    sum += A_i[i] * B_i[i];\n                }\n                return sum;\n            });\n            return C;\n        } else if (Matrix.isArray(B)) {\n            let rows = this._rows;\n            if (B.length !== rows) {\n                throw new Error(`A.dot(B): A has ${rows} cols and B has ${B.length} rows. Must be equal!`);\n            }\n            let C = new Array(rows);\n            for (let row = 0; row < rows; ++row) {\n                C[row] = neumair_sum(this.row(row).map((e) => e * B[row]));\n            }\n            return C;\n        } else {\n            throw new Error(`B must be Matrix or Array`);\n        }\n    }\n\n    /**\n     * Computes the outer product from {@link this} and {@link B}.\n     * @param {Matrix} B\n     * @returns {Matrix}\n     */\n    outer(B) {\n        let A = this;\n        let l = A._data.length;\n        let r = B._data.length;\n        if (l != r) return undefined;\n        let C = new Matrix();\n        C.shape = [\n            l,\n            l,\n            (i, j) => {\n                if (i <= j) {\n                    return A._data[i] * B._data[j];\n                } else {\n                    return C.entry(j, i);\n                }\n            },\n        ];\n        return C;\n    }\n\n    /**\n     * Appends matrix {@link B} to the matrix.\n     * @param {Matrix} B - matrix to append.\n     * @param {\"horizontal\"|\"vertical\"|\"diag\"} [type = \"horizontal\"] - type of concatenation.\n     * @returns {Matrix}\n     * @example\n     *\n     * let A = Matrix.from([[1, 1], [1, 1]]); // 2 by 2 matrix filled with ones.\n     * let B = Matrix.from([[2, 2], [2, 2]]); // 2 by 2 matrix filled with twos.\n     *\n     * A.concat(B, \"horizontal\"); // 2 by 4 matrix. [[1, 1, 2, 2], [1, 1, 2, 2]]\n     * A.concat(B, \"vertical\"); // 4 by 2 matrix. [[1, 1], [1, 1], [2, 2], [2, 2]]\n     * A.concat(B, \"diag\"); // 4 by 4 matrix. [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 2, 2], [0, 0, 2, 2]]\n     */\n    concat(B, type = \"horizontal\") {\n        const A = this;\n        const [rows_A, cols_A] = A.shape;\n        const [rows_B, cols_B] = B.shape;\n        if (type == \"horizontal\") {\n            if (rows_A != rows_B) {\n                throw new Error(`A.concat(B, \"horizontal\"): A and B need same number of rows, A has ${rows_A} rows, B has ${rows_B} rows.`);\n            }\n            const X = new Matrix(rows_A, cols_A + cols_B, \"zeros\");\n            X.set_block(0, 0, A);\n            X.set_block(0, cols_A, B);\n            return X;\n        } else if (type == \"vertical\") {\n            if (cols_A != cols_B) {\n                throw new Error(`A.concat(B, \"vertical\"): A and B need same number of columns, A has ${cols_A} columns, B has ${cols_B} columns.`);\n            }\n            const X = new Matrix(rows_A + rows_B, cols_A, \"zeros\");\n            X.set_block(0, 0, A);\n            X.set_block(rows_A, 0, B);\n            return X;\n        } else if (type == \"diag\") {\n            const X = new Matrix(rows_A + rows_B, cols_A + cols_B, \"zeros\");\n            X.set_block(0, 0, A);\n            X.set_block(rows_A, cols_A, B);\n            return X;\n        } else {\n            throw new Error(`type must be \"horizontal\" or \"vertical\", but type is ${type}!`);\n        }\n    }\n\n    /**\n     * Writes the entries of B in A at an offset position given by {@link offset_row} and {@link offset_col}.\n     * @param {int} offset_row\n     * @param {int} offset_col\n     * @param {Matrix} B\n     * @returns {Matrix}\n     */\n    set_block(offset_row, offset_col, B) {\n        const rows = Math.min(this._rows - offset_row, B.shape[0]);\n        const cols = Math.min(this._cols - offset_col, B.shape[1]);\n        for (let row = 0; row < rows; ++row) {\n            for (let col = 0; col < cols; ++col) {\n                this.set_entry(row + offset_row, col + offset_col, B.entry(row, col));\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Extracts the entries from the {@link start_row}<sup>th</sup> row to the {@link end_row}<sup>th</sup> row, the {@link start_col}<sup>th</sup> column to the {@link end_col}<sup>th</sup> column of the matrix.\n     * If {@link end_row} or {@link end_col} is empty, the respective value is set to {@link this.rows} or {@link this.cols}.\n     * @param {Number} start_row\n     * @param {Number} start_col\n     * @param {Number} [end_row = null]\n     * @param {Number} [end_col = null]\n     * @returns {Matrix} Returns a end_row - start_row times end_col - start_col matrix, with respective entries from the matrix.\n     * @example\n     *\n     * let A = Matrix.from([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); // a 3 by 3 matrix.\n     *\n     * A.get_block(1, 1); // [[5, 6], [8, 9]]\n     * A.get_block(0, 0, 1, 1); // [[1]]\n     * A.get_block(1, 1, 2, 2); // [[5]]\n     * A.get_block(0, 0, 2, 2); // [[1, 2], [4, 5]]\n     */\n    get_block(start_row, start_col, end_row = null, end_col = null) {\n        const [rows, cols] = this.shape;\n        end_row = end_row ?? rows;\n        end_col = end_col ?? cols;\n        if (end_row <= start_row || end_col <= start_col) {\n            throw new Error(`\n                end_row must be greater than start_row, and\n                end_col must be greater than start_col, but\n                end_row = ${end_row}, start_row = ${start_row}, end_col = ${end_col}, and start_col = ${start_col}!`);\n        }\n        const X = new Matrix(end_row - start_row, end_col - start_col, \"zeros\");\n        for (let row = start_row, new_row = 0; row < end_row; ++row, ++new_row) {\n            for (let col = start_col, new_col = 0; col < end_col; ++col, ++new_col) {\n                X.set_entry(new_row, new_col, this.entry(row, col));\n            }\n        }\n        return X;\n        //return new Matrix(end_row - start_row, end_col - start_col, (i, j) => this.entry(i + start_row, j + start_col));\n    }\n\n    /**\n     * Returns a new array gathering entries defined by the indices given by argument.\n     * @param {Array<Number>} row_indices - Array consists of indices of rows for gathering entries of this matrix\n     * @param {Array<Number>} col_indices  - Array consists of indices of cols for gathering entries of this matrix\n     * @returns {Matrix}\n     */\n    gather(row_indices, col_indices) {\n        const N = row_indices.length;\n        const D = col_indices.length;\n\n        const R = new Matrix(N, D);\n        for (let i = 0; i < N; ++i) {\n            const row_index = row_indices[i];\n            for (let j = 0; j < N; ++j) {\n                const col_index = col_indices[j];\n                R.set_entry(i, j, this.entry(row_index, col_index));\n            }\n        }\n\n        return R;\n    }\n\n    /**\n     * Applies a function to each entry of the matrix.\n     * @private\n     * @param {Function} f function takes 2 parameters, the value of the actual entry and a value given by the function {@link v}. The result of {@link f} gets writen to the Matrix.\n     * @param {Function} v function takes 2 parameters for row and col, and returns a value witch should be applied to the colth entry of the rowth row of the matrix.\n     */\n    _apply_array(f, v) {\n        const data = this.values;\n        const [rows, cols] = this.shape;\n        for (let i = 0, row = 0; row < rows; ++row) {\n            for (let col = 0; col < cols; ++col, ++i) {\n                data[i] = f(data[i], v(row, col));\n            }\n        }\n        return this;\n    }\n\n    _apply_rowwise_array(values, f) {\n        return this._apply_array(f, (_, j) => values[j]);\n    }\n\n    _apply_colwise_array(values, f) {\n        const data = this.values;\n        const [rows, cols] = this.shape;\n        for (let i = 0, row = 0; row < rows; ++row) {\n            const val = values[row];\n            for (let col = 0; col < cols; ++col, ++i) {\n                data[i] = f(data[i], val);\n            }\n        }\n        return this;\n    }\n\n    _apply(value, f) {\n        const data = this.values;\n        const [rows, cols] = this.shape;\n        if (value instanceof Matrix) {\n            const values = value.values;\n            const [value_rows, value_cols] = value.shape;\n            if (value_rows === 1) {\n                if (cols !== value_cols) {\n                    throw new Error(`cols !== value_cols`);\n                }\n                for (let i = 0, row = 0; row < rows; ++row) {\n                    for (let col = 0; col < cols; ++col, ++i) {\n                        data[i] = f(data[i], values[col]);\n                    }\n                }\n            } else if (value_cols === 1) {\n                if (rows !== value_rows) {\n                    throw new Error(`rows !== value_rows`);\n                }\n                for (let i = 0, row = 0; row < rows; ++row) {\n                    const v =  values[row];\n                    for (let col = 0; col < cols; ++col, ++i) {\n                        data[i] = f(data[i], v);\n                    }\n                }\n            } else if (rows == value_rows && cols == value_cols) {\n                for (let i = 0, n = rows * cols; i < n; ++i) {\n                    data[i] = f(data[i], values[i]);\n                }\n            } else {\n                throw new Error(`error`);\n            }\n        } else if (Matrix.isArray(value)) {\n            if (value.length === rows) {\n                for (let i = 0, row = 0; row < rows; ++row) {\n                    const v = value[row];\n                    for (let col = 0; col < cols; ++col, ++i) {\n                        data[i] = f(data[i], v);\n                    }\n                }\n            } else if (value.length === cols) {\n                for (let i = 0, row = 0; row < rows; ++row) {\n                    for (let col = 0; col < cols; ++col, ++i) {\n                        data[i] = f(data[i], value[col]);\n                    }\n                }\n            } else {\n                throw new Error(`error`);\n            }\n        } else { // scalar value\n            for (let i = 0, n = rows * cols; i < n; ++i) {\n                data[i] = f(data[i], value);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Clones the Matrix.\n     * @returns {Matrix}\n     */\n    clone() {\n        let B = new Matrix();\n        B._rows = this._rows;\n        B._cols = this._cols;\n        B._data = this.values.slice(0);\n        return B;\n    }\n\n    /**\n     * Entrywise multiplication with {@link value}.\n     * @param {Matrix|Array|Number} value\n     * @param {Object} [options]\n     * @param {Boolean} [options.inline = false]  - If true, applies multiplication to the element, otherwise it creates first a copy and applies the multiplication on the copy.\n     * @returns {Matrix}\n     * @example\n     *\n     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.\n     * let B = A.clone(); // B == A;\n     *\n     * A.mult(2); // [[2, 4], [6, 8]];\n     * A.mult(B); // [[1, 4], [9, 16]];\n     */\n    mult(value, { inline = false } = {}) {\n        const A = inline ? this : this.clone();\n        return A._apply(value, (a, b) => a * b);\n    }\n\n    /**\n     * Entrywise division with {@link value}.\n     * @param {Matrix|Array|Number} value\n     * @param {Object} [options]\n     * @param {Boolean} [options.inline = false] - If true, applies division to the element, otherwise it creates first a copy and applies the division on the copy.\n     * @returns {Matrix}\n     * @example\n     *\n     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.\n     * let B = A.clone(); // B == A;\n     *\n     * A.divide(2); // [[0.5, 1], [1.5, 2]];\n     * A.divide(B); // [[1, 1], [1, 1]];\n     */\n    divide(value, { inline = false } = {}) {\n        const A = inline ? this : this.clone();\n        return A._apply(value, (a, b) => a / b);\n    }\n\n    /**\n     * Entrywise addition with {@link value}.\n     * @param {Matrix|Array|Number} value\n     * @param {Object} [options]\n     * @param {Boolean} [options.inline = false]  - If true, applies addition to the element, otherwise it creates first a copy and applies the addition on the copy.\n     * @returns {Matrix}\n     * @example\n     *\n     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.\n     * let B = A.clone(); // B == A;\n     *\n     * A.add(2); // [[3, 4], [5, 6]];\n     * A.add(B); // [[2, 4], [6, 8]];\n     */\n    add(value, {inline = false} = {}) {\n        const A = inline ? this : this.clone();\n        return A._apply(value, (a, b) => a + b);\n    }\n\n    /**\n     * Entrywise subtraction with {@link value}.\n     * @param {Matrix|Array|Number} value\n     * @param {Object} [options]\n     * @param {Boolean} [options.inline = false] - If true, applies subtraction to the element, otherwise it creates first a copy and applies the subtraction on the copy.\n     * @returns {Matrix}\n     * @example\n     *\n     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.\n     * let B = A.clone(); // B == A;\n     *\n     * A.sub(2); // [[-1, 0], [1, 2]];\n     * A.sub(B); // [[0, 0], [0, 0]];\n     */\n    sub(value, { inline = false } = {}) {\n        const A = inline ? this : this.clone();\n        return A._apply(value, (a, b) => a - b);\n    }\n\n    /**\n     * Returns the number of rows and columns of the Matrix.\n     * @returns {Array} An Array in the form [rows, columns].\n     */\n    get shape() {\n        return [this._rows, this._cols];\n    }\n\n    /**\n     * Returns the matrix in the given shape with the given function which returns values for the entries of the matrix.\n     * @param {Array} parameter - takes an Array in the form [rows, cols, value], where rows and cols are the number of rows and columns of the matrix, and value is a function which takes two parameters (row and col) which has to return a value for the colth entry of the rowth row.\n     * @returns {Matrix}\n     */\n    set shape([rows, cols, value = () => 0]) {\n        this._rows = rows;\n        this._cols = cols;\n        this._data = new Float64Array(rows * cols);\n        for (let i = 0, row = 0; row < rows; ++row) {\n            for (let col = 0; col < cols; ++col, ++i) {\n                this._data[i] = value(row, col);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Returns the Matrix as a Array of Float64Arrays.\n     * @returns {Array<Float64Array>}\n     */\n    get to2dArray() {\n        const result = [];\n        for (const row of this.iterate_rows()) {\n            result.push(row);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the Matrix as a Array of Arrays.\n     * @returns {Array<Array>}\n     */\n    get asArray() {\n        const result = [];\n        for (const row of this.iterate_rows()) {\n            result.push(Array.from(row));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the diagonal of the Matrix.\n     * @returns {Float64Array}\n     */\n    get diag() {\n        const rows = this._rows;\n        const cols = this._cols;\n        const min_row_col = Math.min(rows, cols);\n        let result = new Float64Array(min_row_col);\n        for (let i = 0; i < min_row_col; ++i) {\n            result[i] = this.entry(i, i);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the mean of all entries of the Matrix.\n     * @returns {Number}\n     */\n    get mean() {\n        const sum = this.sum;\n        const n = this._rows * this._cols;\n        return sum / n;\n    }\n\n    /**\n     * Returns the sum oof all entries of the Matrix.\n     * @returns {Number}\n     */\n    get sum() {\n        const data = this.values;\n        return neumair_sum(data);\n    }\n\n    /**\n     * Returns the entries of the Matrix.\n     * @returns {Float64Array}\n     */\n    get values() {\n        const data = this._data;\n        return data;\n    }\n\n    /**\n     * Returns the mean of each row of the matrix.\n     * @returns {Float64Array}\n     */\n    get meanRows() {\n        const data = this.values;\n        const rows = this._rows;\n        const cols = this._cols;\n        const result = Float64Array.from({ length: rows });\n        for (let i = 0, row = 0; row < rows; ++row) {\n            let sum = 0;\n            for (let col = 0; col < cols; ++col, ++i) {\n                sum += data[i];\n            }\n            result[row] = sum / cols;\n        }\n        return result;\n    }\n\n    /** Returns the mean of each column of the matrix.\n     * @returns {Float64Array}\n     */\n    get meanCols() {\n        const data = this.values;\n        const rows = this._rows;\n        const cols = this._cols;\n        const result = Float64Array.from({ length: cols });\n        for (let col = 0; col < cols; ++col) {\n            let sum = 0;\n            for (let i = col, row = 0; row < rows; ++row, i += cols) {\n                sum += data[i];\n            }\n            result[col] = sum / rows;\n        }\n        return result;\n    }\n\n    /**\n     * Solves the equation {@link A}x = {@link b} using the conjugate gradient method. Returns the result x.\n     * @param {Matrix} A - Matrix\n     * @param {Matrix} b - Matrix\n     * @param {Randomizer} [randomizer=null]\n     * @param {Number} [tol=1e-3]\n     * @returns {Matrix}\n     */\n    static solve_CG(A, b, randomizer, tol = 1e-3) {\n        if (randomizer === null) {\n            randomizer = new Randomizer();\n        }\n        const rows = A.shape[0];\n        const cols = b.shape[1];\n        let result = new Matrix(rows, 0);\n        for (let i = 0; i < cols; ++i) {\n            const b_i = Matrix.from(b.col(i)).T;\n            let x = new Matrix(rows, 1, () => randomizer.random);\n            let r = b_i.sub(A.dot(x));\n            let d = r.clone();\n            do {\n                const z = A.dot(d);\n                const alpha = r.transDot(r).entry(0, 0) / d.transDot(z).entry(0, 0);\n                x = x.add(d.mult(alpha));\n                const r_next = r.sub(z.mult(alpha));\n                const beta = r_next.transDot(r_next).entry(0, 0) / r.transDot(r).entry(0, 0);\n                d = r_next.add(d.mult(beta));\n                r = r_next;\n            } while (Math.abs(r.mean) > tol);\n            result = result.concat(x, \"horizontal\");\n        }\n        return result;\n    }\n\n    /**\n     * Solves the equation {@link A}x = {@link b}. Returns the result x.\n     * @param {Matrix} A - Matrix or LU Decomposition\n     * @param {Matrix} b - Matrix\n     * @returns {Matrix}\n     */\n    static solve(A, b) {\n        let { L: L, U: U } = \"L\" in A && \"U\" in A ? A : Matrix.LU(A);\n        let rows = L.shape[0];\n        let x = b.clone();\n\n        // forward\n        for (let row = 0; row < rows; ++row) {\n            for (let col = 0; col < row - 1; ++col) {\n                x.sub_entry(0, row, L.entry(row, col) * x.entry(1, col));\n            }\n            x.set_entry(0, row, x.entry(0, row) / L.entry(row, row));\n        }\n\n        // backward\n        for (let row = rows - 1; row >= 0; --row) {\n            for (let col = rows - 1; col > row; --col) {\n                x.sub_entry(0, row, U.entry(row, col) * x.entry(0, col));\n            }\n            x.set_entry(0, row, x.entry(0, row) / U.entry(row, row));\n        }\n\n        return x;\n    }\n\n    /**\n     * {@link L}{@link U} decomposition of the Matrix {@link A}. Creates two matrices, so that the dot product LU equals A.\n     * @param {Matrix} A\n     * @returns {{L: Matrix, U: Matrix}} result - Returns the left triangle matrix {@link L} and the upper triangle matrix {@link U}.\n     */\n    static LU(A) {\n        const rows = A.shape[0];\n        const L = new Matrix(rows, rows, \"zeros\");\n        const U = new Matrix(rows, rows, \"identity\");\n\n        for (let j = 0; j < rows; ++j) {\n            for (let i = j; i < rows; ++i) {\n                let sum = 0;\n                for (let k = 0; k < j; ++k) {\n                    sum += L.entry(i, k) * U.entry(k, j);\n                }\n                L.set_entry(i, j, A.entry(i, j) - sum);\n            }\n            for (let i = j; i < rows; ++i) {\n                if (L.entry(j, j) === 0) {\n                    return undefined;\n                }\n                let sum = 0;\n                for (let k = 0; k < j; ++k) {\n                    sum += L.entry(j, k) * U.entry(k, i);\n                }\n                U.set_entry(j, i, (A.entry(j, i) - sum) / L.entry(j, j));\n            }\n        }\n\n        return { L: L, U: U };\n    }\n\n    /**\n     * Computes the determinante of {@link A}, by using the LU decomposition of {@link A}.\n     * @param {Matrix} A\n     * @returns {Number} det - Returns the determinate of the Matrix {@link A}.\n     */\n    static det(A) {\n        const rows = A.shape[0];\n        const { L, U } = Matrix.LU(A);\n        const L_diag = L.diag;\n        const U_diag = U.diag;\n        let det = L_diag[0] * U_diag[0];\n        for (let row = 1; row < rows; ++row) {\n            det *= L_diag[row] * U_diag[row];\n        }\n        return det;\n    }\n\n    /**\n     * Computes the {@link k} components of the SVD decomposition of the matrix {@link M}\n     * @param {Matrix} M\n     * @param {int} [k=2]\n     * @returns {{U: Matrix, Sigma: Matrix, V: Matrix}}\n     */\n    static SVD(M, k = 2) {\n        let MtM = M.transDot(M);\n        let MMt = M.dotTrans(M);\n        let { eigenvectors: V, eigenvalues: Sigma } = simultaneous_poweriteration(MtM, k);\n        let { eigenvectors: U } = simultaneous_poweriteration(MMt, k);\n        return { U: U, Sigma: Sigma.map((sigma) => Math.sqrt(sigma)), V: V };\n\n        //Algorithm 1a: Householder reduction to bidiagonal form:\n        /* const [m, n] = A.shape;\n        let U = new Matrix(m, n, (i, j) => i == j ? 1 : 0);\n        console.log(U.to2dArray)\n        let V = new Matrix(n, m, (i, j) => i == j ? 1 : 0);\n        console.log(V.to2dArray)\n        let B = Matrix.bidiagonal(A.clone(), U, V);\n        console.log(U,V,B)\n        return { U: U, \"Sigma\": B, V: V }; */\n    }\n\n    static isArray(A) {\n      return Array.isArray(A) || A instanceof Float64Array || A instanceof Float32Array;\n    }\n}\n","import { linspace, Matrix } from \"../matrix/index.js\";\n\n/**\n * @class\n * @memberof module:utils\n * @alias Randomizer\n */\nexport class Randomizer {\n    /**\n     * Mersenne Twister random number generator.\n     * @constructor\n     * @param {Number} [_seed=new Date().getTime()] - The seed for the random number generator. If <code>_seed == null</code> then the actual time gets used as seed.\n     * @see https://github.com/bmurray7/mersenne-twister-examples/blob/master/javascript-mersenne-twister.js\n     */\n    constructor(_seed) {\n        this._N = 624;\n        this._M = 397;\n        this._MATRIX_A = 0x9908b0df;\n        this._UPPER_MASK = 0x80000000;\n        this._LOWER_MASK = 0x7fffffff;\n        this._mt = new Array(this._N);\n        this._mti = this.N + 1;\n\n        this.seed = _seed || new Date().getTime();\n        return this;\n    }\n\n    set seed(_seed) {\n        this._seed = _seed;\n        let mt = this._mt;\n\n        mt[0] = _seed >>> 0;\n        for (this._mti = 1; this._mti < this._N; this._mti += 1) {\n            let mti = this._mti;\n            let s = mt[mti - 1] ^ (mt[mti - 1] >>> 30);\n            mt[mti] = ((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253 + mti;\n            mt[mti] >>>= 0;\n        }\n    }\n\n    /**\n     * Returns the seed of the random number generator.\n     * @returns {Number} - The seed.\n     */\n    get seed() {\n        return this._seed;\n    }\n\n    /**\n     * Returns a float between 0 and 1.\n     * @returns {Number} - A random number between [0, 1]\n     */\n    get random() {\n        return this.random_int * (1.0 / 4294967296.0);\n    }\n\n    /**\n     * Returns an integer between 0 and MAX_INTEGER.\n     * @returns {Integer} - A random integer.\n     */\n    get random_int() {\n        let y,\n            mag01 = new Array(0x0, this._MATRIX_A);\n        if (this._mti >= this._N) {\n            let kk;\n\n            /* if (this._mti == this._N + 1) {\n                this.seed = 5489;\n            } */\n\n            let N_M = this._N - this._M;\n            let M_N = this._M - this._N;\n\n            for (kk = 0; kk < N_M; ++kk) {\n                y = (this._mt[kk] & this._UPPER_MASK) | (this._mt[kk + 1] & this._LOWER_MASK);\n                this._mt[kk] = this._mt[kk + this._M] ^ (y >>> 1) ^ mag01[y & 0x1];\n            }\n            for (; kk < this._N - 1; ++kk) {\n                y = (this._mt[kk] & this._UPPER_MASK) | (this._mt[kk + 1] & this._LOWER_MASK);\n                this._mt[kk] = this._mt[kk + M_N] ^ (y >>> 1) ^ mag01[y & 0x1];\n            }\n\n            y = (this._mt[this._N - 1] & this._UPPER_MASK) | (this._mt[0] & this._LOWER_MASK);\n            this._mt[this._N - 1] = this._mt[this._M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n            this._mti = 0;\n        }\n\n        y = this._mt[(this._mti += 1)];\n        y ^= y >>> 11;\n        y ^= (y << 7) & 0x9d2c5680;\n        y ^= (y << 15) & 0xefc60000;\n        y ^= y >>> 18;\n\n        return y >>> 0;\n    }\n\n    gauss_random() {\n        let x, y, r;\n        if (this._val != null) {\n            x = this._val, this._val = null;\n            return x;\n        } else do {\n            x = 2 * this.random - 1;\n            y = 2 * this.random - 1;\n            r = x * x + y * y;\n        } while (!r || r > 1);\n        const c = Math.sqrt(-2 * Math.log(r) / r);\n        this._val = y * c; // cache this for next function call for efficiency\n        return x * c;\n    }\n\n    /**\n     * Returns samples from an input Matrix or Array.\n     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.\n     * @param {Number} n - The number of samples.\n     * @returns {Array} - A random selection form {@link A} of {@link n} samples.\n     */\n    choice(A, n) {\n        if (A instanceof Matrix) {\n            let rows = A.shape[0];\n            if (n > rows) {\n                throw new Error(\"n bigger than A!\");\n            }\n            let sample = new Array(n);\n            let index_list = linspace(0, rows - 1);\n            for (let i = 0, l = index_list.length; i < n; ++i, --l) {\n                let random_index = this.random_int % l;\n                sample[i] = index_list.splice(random_index, 1)[0];\n            }\n            return sample.map((d) => A.row(d));\n        } else if (Array.isArray(A) || A instanceof Float64Array) {\n            let rows = A.length;\n            if (n > rows) {\n                throw new Error(\"n bigger than A!\");\n            }\n            let sample = new Array(n);\n            let index_list = linspace(0, rows - 1);\n            for (let i = 0, l = index_list.length; i < n; ++i, --l) {\n                let random_index = this.random_int % l;\n                sample[i] = index_list.splice(random_index, 1)[0];\n            }\n            return sample.map((d) => A[d]);\n        }\n    }\n\n    /**\n     * @static\n     * Returns samples from an input Matrix or Array.\n     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.\n     * @param {Number} n - The number of samples.\n     * @param {Number} seed - The seed for the random number generator.\n     * @returns {Array} - A random selection form {@link A} of {@link n} samples.\n     */\n    static choice(A, n, seed = 1212) {\n        const R = new Randomizer(seed);\n        return R.choice(A, n);\n        /* let rows = A.shape[0];\n        if (n > rows) {\n            throw new Error(\"n bigger than A!\");\n        }\n        let rand = new Randomizer(seed);\n        let sample = new Array(n);\n        let index_list = linspace(0, rows - 1);\n        for (let i = 0, l = index_list.length; i < n; ++i, --l) {\n            let random_index = rand.random_int % l;\n            sample[i] = index_list.splice(random_index, 1)[0];\n        }\n        //return result;\n        //return new Matrix(n, cols, (row, col) => A.entry(sample[row], col))\n        return sample.map((d) => A.row(d)); */\n    }\n}\n","/**\n * Returns maximum in Array {@link values}.\n * @memberof module:utils\n * @alias max\n * @param {Array} values \n * @returns {Number}\n */\nexport default function (values) {\n    let max;\n    for (const value of values) {\n        if (value != null && (max < value || (max === undefined && value >= value))) {\n            max = value;\n        }\n    }\n    return max;\n}","/**\n * Returns maximum in Array {@link values}.\n * @memberof module:utils\n * @alias min\n * @param {Array} values\n * @returns {Number}\n */\nexport default function (values) {\n    let min;\n    for (const value of values) {\n        if (value != null && (min > value || (min === undefined && value <= value))) {\n            min = value;\n        }\n    }\n    return min;\n}","/**\n * @class\n * @alias Heap\n */\nexport class Heap {\n    /**\n     * A heap is a datastructure holding its elements in a specific way, so that the top element would be the first entry of an ordered list.\n     * @constructor\n     * @memberof module:datastructure\n     * @alias Heap\n     * @param {Array=} elements - Contains the elements for the Heap. {@link elements} can be null.\n     * @param {Function} [accessor = (d) => d] - Function returns the value of the element.\n     * @param {(\"min\"|\"max\"|Function)} [comparator = \"min\"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. (\"min\" for a Min-Heap, \"max\" for a Max_heap)\n     * @returns {Heap}\n     * @see {@link https://en.wikipedia.org/wiki/Binary_heap}\n     */\n    constructor(elements = null, accessor = d => d, comparator = \"min\") {\n        if (elements) {\n            return Heap.heapify(elements, accessor, comparator);\n        } else {\n            this._accessor = accessor;\n            this._container = [];\n            if (comparator == \"min\") {\n                this._comparator = (a, b) => a < b;\n            } else if (comparator == \"max\") {\n                this._comparator = (a, b) => a > b;\n            } else {\n                this._comparator = comparator;\n            }\n            return this\n        }\n    }\n\n    /**\n     * Creates a Heap from an Array\n     * @param {Array|Set} elements - Contains the elements for the Heap.\n     * @param {Function=} [accessor = (d) => d] - Function returns the value of the element.\n     * @param {(String=|Function)} [comparator = \"min\"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. (\"min\" for a Min-Heap, \"max\" for a Max_heap)\n     * @returns {Heap}\n     */\n    static heapify(elements, accessor = d => d, comparator = \"min\") {\n        const heap = new Heap(null, accessor, comparator);\n        const container = heap._container;\n        for (const e of elements) {\n            container.push({\n                \"element\": e,\n                \"value\": accessor(e),\n            });\n        }\n        for (let i = Math.floor((elements.length / 2) - 1); i >= 0; --i) {\n            heap._heapify_down(i);\n        }\n        return heap;\n    }\n\n    /**\n     * Swaps elements of container array.\n     * @private\n     * @param {Number} index_a \n     * @param {Number} index_b \n     */\n    _swap(index_a, index_b) {\n        const container = this._container;\n        [container[index_b], container[index_a]] = [container[index_a], container[index_b]];\n        return;\n    }\n\n    /**\n     * @private\n     */\n    _heapify_up() {\n        const container = this._container;\n        let index = container.length - 1;\n        while (index > 0) {\n            let parentIndex = Math.floor((index - 1) / 2);\n            if (!this._comparator(container[index].value, container[parentIndex].value)) {\n                break;\n            } else {\n            this._swap(parentIndex, index)\n            index = parentIndex;\n            }\n        }\n    }\n\n    /**\n     * Pushes the element to the heap.\n     * @param {} element\n     * @returns {Heap}\n     */\n    push(element) {\n        const value = this._accessor(element);\n        //const node = new Node(element, value);\n        const node = {\"element\": element, \"value\": value};\n        this._container.push(node);\n        this._heapify_up();\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {Number} [start_index = 0] \n     */\n    _heapify_down(start_index=0) {\n        const container = this._container;\n        const comparator = this._comparator;\n        const length = container.length;\n        let left = 2 * start_index + 1;\n        let right = 2 * start_index + 2;\n        let index = start_index;\n        if (index > length) throw \"index higher than length\"\n        if (left < length && comparator(container[left].value, container[index].value)) {\n            index = left;\n        }\n        if (right < length && comparator(container[right].value, container[index].value)) {\n            index = right;\n        }\n        if (index !== start_index) {\n            this._swap(start_index, index);\n            this._heapify_down(index);\n        }\n    }\n\n    /**\n     * Removes and returns the top entry of the heap.\n     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).\n     */\n    pop() {\n        const container = this._container;\n        if (container.length === 0) {\n            return null;\n        } else if (container.length === 1) {\n            return container.pop();\n        }\n        this._swap(0, container.length - 1);\n        const item = container.pop();\n        this._heapify_down();\n        return item;\n    }\n\n    /**\n     * Returns the top entry of the heap without removing it.\n     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).\n     */\n    get first() {\n        return this._container.length > 0 ? this._container[0] : null;\n    }\n\n\n    /**\n     * Yields the raw data\n     * @yields {Object} Object consists of the element and its value (computed by {@link accessor}).\n     */\n    * iterate() {\n        for (let i = 0, n = this._container.length; i < n; ++i) {\n            yield this._container[i].element;\n        }\n    }\n\n    /**\n     * Returns the heap as ordered array.\n     * @returns {Array} Array consisting the elements ordered by {@link comparator}.\n     */\n    toArray() {\n        return this.data()\n            .sort((a,b) => this._comparator(a, b) ? -1 : 0)\n    }\n\n    /**\n     * Returns elements of container array.\n     * @returns {Array} Array consisting the elements.\n     */\n    data() {\n        return this._container\n            .map(d => d.element)\n    }\n\n    /**\n     * Returns the container array.\n     * @returns {Array} The container array.\n     */\n    raw_data() {\n        return this._container;\n    }\n\n    /**\n     * The size of the heap.\n     * @returns {Number}\n     */\n    get length() {\n        return this._container.length;\n    }\n\n    /**\n     * Returns false if the the heap has entries, true if the heap has no entries.\n     * @returns {Boolean}\n     */\n    get empty() {\n        return this.length === 0;\n    }\n}","/**\n * @class\n * @alias DisjointSet\n * @see {@link https://en.wikipedia.org/wiki/Disjoint-set_data_structure}\n */\nexport class DisjointSet {\n    /**\n     * @constructor\n     * @alias DisjointSet\n     * @memberof module:datastructure\n     * @param {Array=} elements \n     * @returns {DisjointSet}\n     */\n    constructor(elements = null) {\n        this._list = new Set();\n        if (elements) {\n            for (const e of elements) {\n                this.make_set(e);\n            }\n        }\n        return this;\n    }\n\n    make_set(x) {\n        const list = this._list;\n        if (!list.has(x)) {\n            list.add(x);\n            x.__disjoint_set = {};\n            x.__disjoint_set.parent = x;\n            x.__disjoint_set.children = new Set([x]);\n            x.__disjoint_set.size = 1;\n        }\n        return this;\n    }\n\n    find(x) {\n        const list = this._list;\n        if (list.has(x)) {\n            if (x.__disjoint_set.parent !== x) {\n                x.__disjoint_set.children.add(...x);\n                x.__disjoint_set.parent = this.find(x.__disjoint_set.parent);\n                return x.__disjoint_set.parent;\n            } else {\n                return x;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    union(x, y) {\n        let node_x = this.find(x);\n        let node_y = this.find(y);\n\n        if (node_x === node_y) return this;\n        if (node_x.__disjoint_set.size < node_y.__disjoint_set.size) [node_x, node_y] = [node_y, node_x];\n\n        node_y.__disjoint_set.parent = node_x;\n        // keep track of children?\n        node_y.__disjoint_set.children.forEach(node_x.__disjoint_set.children.add, node_x.__disjoint_set.children);\n        node_x.__disjoint_set.size += node_y.__disjoint_set.size;\n\n        return this;\n    }\n}","import { euclidean } from \"../metrics/index.js\";\nimport { Heap } from \"../datastructure/index.js\";\n/**\n * @class\n * @alias BallTree\n */\nexport class BallTree {\n    /**\n     * Generates a BallTree with given {@link elements}.\n     * @constructor\n     * @memberof module:knn\n     * @alias BallTree\n     * @param {Array=} elements - Elements which should be added to the BallTree\n     * @param {Function} [metric = euclidean] metric to use: (a, b) => distance\n     * @see {@link https://en.wikipedia.org/wiki/Ball_tree}\n     * @see {@link https://github.com/invisal/noobjs/blob/master/src/tree/BallTree.js}\n     * @returns {BallTree}\n     */\n    constructor(elements = null, metric = euclidean) {\n        this._Node = class {\n            constructor(pivot, child1=null, child2=null, radius=null) {\n                this.pivot = pivot;\n                this.child1 = child1;\n                this.child2 = child2;\n                this.radius = radius;\n            }\n        }\n        this._Leaf = class {\n            constructor(points) {\n                this.points = points;\n            }\n        }\n        this._metric = metric;\n        if (elements) {\n            this.add(elements);\n        }\n        return this;\n    }\n\n    /**\n     * \n     * @param {Array<*>} elements - new elements.\n     * @returns {BallTree}\n     */\n    add(elements) {\n        elements = elements.map((element, index) => {\n            return {index: index, element: element}\n        })\n        this._root = this._construct(elements);\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {Array<*>} elements \n     * @returns {Node} root of balltree.\n     */\n    _construct(elements) {\n        if (elements.length === 1) {\n            return new this._Leaf(elements);\n        } else {\n            let c = this._greatest_spread(elements);\n            let sorted_elements = elements.sort((a, b) => a.element[c] - b.element[c]);\n            let n = sorted_elements.length;\n            let p_index = Math.floor(n / 2);\n            let p = elements[p_index];\n            let L = sorted_elements.slice(0, p_index);\n            let R = sorted_elements.slice(p_index, n);\n            let radius = Math.max(...elements.map(d => this._metric(p.element, d.element)));\n            let B\n            if (L.length > 0 && R.length > 0) {         \n                B = new this._Node(p, this._construct(L), this._construct(R), radius);\n            } else {\n                B = new this._Leaf(elements);\n            }\n            return B;\n        }\n    }\n\n    /**\n     * @private\n     * @param {Node} B \n     * @returns {Number}\n     */\n    _greatest_spread(B) {\n        let d = B[0].element.length;\n        let start = new Array(d);\n\n        for (let i = 0; i < d; ++i) {\n            start[i] = [Infinity, -Infinity];\n        }\n\n        let spread = B.reduce((acc, current) => {\n            for (let i = 0; i < d; ++i) {\n                acc[i][0] = Math.min(acc[i][0], current.element[i]);\n                acc[i][1] = Math.max(acc[i][1], current.element[i]);\n            }\n            return acc;\n        }, start);\n        spread = spread.map(d => d[1] - d[0]);\n        \n        let c = 0;\n        for (let i = 0; i < d; ++i) {\n            c = spread[i] > spread[c] ? i : c;\n        }\n        return c;\n    }\n\n    /**\n     * \n     * @param {*} t - query element.\n     * @param {Number} [k = 5] - number of nearest neighbors to return.\n     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.\n     */\n    search(t, k = 5) {\n        return this._search(t, k, new Heap(null, d => this._metric(d.element, t), \"max\"), this._root);\n    }\n\n    /**\n     * @private\n     * @param {*} t - query element.\n     * @param {Number} [k = 5] - number of nearest neighbors to return.\n     * @param {Heap} Q - Heap consists of the currently found {@link k} nearest neighbors.\n     * @param {Node|Leaf} B \n     */\n    _search(t, k, Q, B) {\n        // B is Node\n        if (Q.length >= k && B.pivot && B.radius && this._metric(t, B.pivot.element) - B.radius >= Q.first.value) {\n            return Q;\n        } \n        if (B.child1) this._search(t, k, Q, B.child1);\n        if (B.child2) this._search(t, k, Q, B.child2);\n        \n        // B is leaf\n        if (B.points) {\n            for (let i = 0, n = B.points.length; i < n; ++i) {\n                let p = B.points[i];\n                if (k > Q.length) {\n                    Q.push(p);\n                } else {\n                    Q.push(p);\n                    Q.pop();\n                }\n            }\n        }\n        return Q;\n    }\n}","import { euclidean } from \"../metrics/index.js\";\nimport { Heap } from \"../datastructure/index.js\";\nimport { distance_matrix, Matrix } from \"../matrix/index.js\";\n\n/**\n * @class\n * @alias KNN\n */\nexport class KNN {\n    /**\n     * Generates a KNN list with given {@link elements}.\n     * @constructor\n     * @memberof module:knn\n     * @alias KNN\n     * @param {Array=} elements - Elements which should be added to the KNN list\n     * @param {Function|\"precomputed\"} [metric = euclidean] metric is either precomputed or a function to use: (a, b) => distance\n     * @returns {KNN}\n     */\n    constructor(elements=null, metric=euclidean) {\n        this._metric = metric;\n        this._elements = elements instanceof Matrix ? elements : Matrix.from(elements);\n        const N = this._elements.shape[0];\n        if (metric === \"precomputed\") {\n            this._D = this._elements.clone();\n        } else {\n            this._D = distance_matrix(this._elements, metric);\n        }\n        this.KNN = [];\n        for (let row = 0; row < N; ++row) {\n            const distances = this._D.row(row);\n            const H = new Heap(null, d => d.value, \"min\");\n            for (let j = 0; j < N; ++j) {\n                H.push({\n                    value: distances[j],\n                    index: j,\n                });\n            }\n            this.KNN.push(H);\n        }\n    }\n\n    /**\n     * \n     * @param {Array|Number} t - query element or index.\n     * @param {Number} [k = 5] - number of nearest neighbors to return.\n     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.\n     */\n    search(t, k = 5) {\n        const metric = this._metric;\n        const KNN = this.KNN;\n        let H;\n        if (Array.isArray(t)) {\n            if (this._metric == \"precomputed\") {\n                throw \"Search by query element is only possible when not using a precomputed distance matrix!\"\n            } \n            const elements = this._elements;\n            const N = KNN.length;\n            let nearest_element_index = null;\n            let nearest_dist = Infinity;\n            for (let i = 0; i < N; ++i) {\n                const element = elements.row(i);\n                const dist = metric(t, element);\n                if (dist < nearest_dist) {\n                    nearest_element_index = i;\n                    nearest_dist = dist;\n                }\n            }\n            H = KNN[nearest_element_index];\n        } else if (Number.isInteger(t)) {\n            H = KNN[t]\n        }\n\n        let result = []\n        for (let i = 0; i < k; ++i) {\n            result.push(H.pop())\n        }\n        result.forEach(res => H.push(res.element))\n        return result\n    }    \n}\n","import { euclidean } from \"../metrics/index.js\";\nimport { Matrix } from \"../matrix/index.js\";\nimport { Randomizer } from \"../util/index.js\";\n\n/**\n * @class\n * @alias DR\n * @borrows DR#parameter as DR#para\n * @borrows DR#parameter as DR#p\n */\nexport class DR {\n    /**\n     * Takes the default parameters and seals them, remembers the type of input {@link X}, and initializes the random number generator.\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias DR\n     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.\n     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.\n     * @param {Number} [parameters.seed = 1212] - the seed value for the random number generator.\n     * @returns {DR}\n     */\n    constructor(X, default_parameters, parameters) {\n        this._parameters = Object.assign(Object.seal(default_parameters), parameters);\n        if (Array.isArray(X)) {\n            this._type = \"array\";\n            this.X = Matrix.from(X);\n        } else if (X instanceof Matrix) {\n            this._type = \"matrix\";\n            this.X = X;\n        } else {\n            throw new Error(\"No valid type for X!\");\n        }\n        [this._N, this._D] = this.X.shape;\n        this._randomizer = new Randomizer(this._parameters.seed);\n        this._is_initialized = false;\n        return this;\n    }\n\n    /**\n     * Set and get parameters\n     * @param {String} [name = null] - Name of the parameter. If not given then returns all parameters as an Object.\n     * @param {any} [value = null] - Value of the parameter to set. If <code>name</code> is set and <code>value</code> is not given, returns the value of the respective parameter.\n     * @returns {DR|any|Object} \n     * On setting a parameter, this function returns the DR object. \n     * If <code>name</code> is set and <code>value == null</code> then return actual parameter value.\n     * If <code>name</code> is not given, then returns all parameters as an Object.\n     * \n     * @example\n     * '''\n     * const DR = new druid.TSNE(X, {d: 3}); // creates a new DR object, with parameter for <code>d</code> = 3.\n     * DR.parameter(\"d\"); // returns 3,\n     * DR.parameter(\"d\", 2); // sets parameter <code>d</code> to 2 and returns <code>DR</code>.\n     * '''\n     */\n    parameter(name = null, value = null) {\n        if (name === null) {\n            return Object.assign({}, this._parameters);\n        }\n        if (!this._parameters.hasOwnProperty(name)) {\n            throw new Error(`${name} is not a valid parameter!`);\n        }\n        if (value !== null) {\n            this._parameters[name] = value;\n            this._is_initialized = false;\n            return this;\n        } else {\n            return this._parameters[name];\n        }\n    }\n\n    para(name = null, value = null) {\n        return this.parameter(name, value);\n    }\n\n    p(name = null, value = null) {\n        return this.parameter(name, value);\n    }\n\n    /**\n     * Computes the projection.\n     * @returns {Matrix} the projection.\n     */\n    transform() {\n        this.check_init();\n        return this.projection;\n    }\n\n    /**\n     * Computes the projection.\n     * @yields {Matrix|Number[][]} the intermediate steps of the projection.\n     */\n    *generator() {\n        return this.transform();\n    }\n\n    /**\n     * If the respective DR method has an <code>init</code> function, call it before <code>transform</code>.\n     * @returns {DR}\n     */\n    check_init() {\n        if (!this._is_initialized && typeof this.init === \"function\") {\n            this.init();\n            this._is_initialized = true;\n        }\n        return this;\n    }\n\n    /**\n     * @returns {Matrix|Number[][]} the projection in the type of input <code>X</code>.\n     */\n    get projection() {\n        if (this.hasOwnProperty(\"Y\")) {\n            this.check_init();\n            return this._type === \"matrix\" ? this.Y : this.Y.to2dArray;\n        } else {\n            throw new Error(\"The dataset is not transformed yet!\");\n        }\n    }\n\n    /**\n     * Computes the projection.\n     * @param  {...unknown} args - Arguments the transform method of the respective DR method takes.\n     * @returns {Promise<Matrix|Number[][]>} the dimensionality reduced dataset.\n     */\n    async transform_async(...args) {\n        return this.transform(...args);\n    }\n\n    /**\n     * Computes the projection.\n     * @static\n     * @param  {...unknown} args - Takes the same arguments of the constructor of the respective DR method.\n     * @returns {Matrix|Array} the dimensionality reduced dataset.\n     */\n    static transform(...args) {\n        let dr = new this(...args);\n        return dr.transform();\n    }\n\n    /**\n     * Computes the projection.\n     * @static\n     * @param  {...unknown} args - Takes the same arguments of the constructor of the respective DR method.\n     * @returns {Promise} a promise yielding the dimensionality reduced dataset.\n     */\n    static async transform_async(...args) {\n        return this.transform(...args);\n    }\n\n    /**\n     * Computes the projection.\n     * @static\n     * @param  {...unknown} args - Takes the same arguments of the constructor of the respective DR method.\n     * @returns {Generator} a generator yielding the intermediate steps of the dimensionality reduction method.\n     */\n    static *generator(...args) {\n        const dr = new this(...args);\n        const generator = dr.generator();\n        for (const result of generator) {\n            yield result;\n        }\n    }\n}\n","import { simultaneous_poweriteration } from \"../linear_algebra/index.js\";\nimport { Matrix } from \"../matrix/index.js\";\nimport { DR } from \"./DR.js\";\n\n/**\n * @class\n * @alias PCA\n * @augments DR\n */\nexport class PCA extends DR {\n    /**\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias PCA\n     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.\n     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.\n     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.\n     * @returns {PCA}\n     */\n    constructor(X, parameters) {\n        super(X, { d: 2, seed: 1212, eig_args: {} }, parameters);\n        if (!this._parameters.eig_args.hasOwnProperty(\"seed\")) {\n            this._parameters.eig_args.seed = this._randomizer;\n        }\n        return this;\n    }\n\n    /**\n     * Transforms the inputdata {@link X} to dimensionality {@link d}. If parameter {@link A} is given, then project {@link A} with the principal components of {@link X}.\n     * @param {null|Matrix|Array} [A = null] - If given, the data to project.\n     * @returns {Matrix|Array} - The projected data.\n     */\n    transform(A = null) {\n        const V = this.principal_components();\n        if (A == null) {\n            const X = this.X;\n            this.Y = X.dot(V);\n            return this.projection;\n        } else if (Array.isArray(A)) {\n            return Matrix.from(A).dot(V).asArray;\n        } else if (A instanceof Matrix) {\n            return A.dot(V);\n        } else {\n            throw new Error(\"No valid type for A!\");\n        }\n    }\n\n    /**\n     * Computes the {@link d} principal components of Matrix {@link X}.\n     * @returns {Matrix}\n     */\n    principal_components() {\n        if (this.V) {\n            return this.V;\n        }\n        const { d, eig_args } = this._parameters;\n        const X = this.X;\n        const X_cent = X.sub(X.meanCols);\n        const C = X_cent.transDot(X_cent);\n        const { eigenvectors: V } = simultaneous_poweriteration(C, d, eig_args);\n        this.V = Matrix.from(V).transpose();\n        return this.V;\n    }\n\n    static principal_components(X, parameters) {\n        const dr = new this(X, parameters);\n        return dr.principal_components();\n    }\n}\n","import { simultaneous_poweriteration } from \"../linear_algebra/index.js\";\nimport { distance_matrix, Matrix } from \"../matrix/index.js\";\nimport { euclidean } from \"../metrics/index.js\";\nimport { DR } from \"./DR.js\";\n\n/**\n * @class\n * @alias MDS\n * @extends DR\n */\nexport class MDS extends DR {\n    /**\n     * Classical MDS.\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias MDS\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.\n     * @param {Function|\"precomputed\"} [parameters.metric = euclidean] - the metric which defines the distance between two points.\n     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.\n     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.\n     */\n    constructor(X, parameters) {\n        super(X, { d: 2, metric: euclidean, seed: 1212, eig_args: {} }, parameters);\n        if (!this._parameters.eig_args.hasOwnProperty(\"seed\")) {\n            this._parameters.eig_args.seed = this._randomizer;\n        }\n        return this;\n    }\n\n    /**\n     * Transforms the inputdata {@link X} to dimensionality {@link d}.\n     * @returns {Matrix|Array}\n     */\n    transform() {\n        const X = this.X;\n        const rows = X.shape[0];\n        const { d, metric, eig_args } = this._parameters;\n        const A = metric === \"precomputed\" ? X : distance_matrix(X, metric);\n        const ai_ = A.meanCols;\n        const a_j = A.meanRows;\n        const a__ = A.mean;\n\n        this._d_X = A;\n        const B = new Matrix(rows, rows, (i, j) => A.entry(i, j) - ai_[i] - a_j[j] + a__);\n\n        const { eigenvectors: V } = simultaneous_poweriteration(B, d, eig_args);\n        this.Y = Matrix.from(V).transpose();\n\n        return this.projection;\n    }\n\n    /**\n     * @returns {Number} - the stress of the projection.\n     */\n    stress() {\n        const N = this.X.shape[0];\n        const Y = this.Y;\n        const d_X = this._d_X;\n        const d_Y = new Matrix();\n        d_Y.shape = [\n            N,\n            N,\n            (i, j) => {\n                return i < j ? euclidean(Y.row(i), Y.row(j)) : d_Y.entry(j, i);\n            },\n        ];\n        let top_sum = 0;\n        let bottom_sum = 0;\n        for (let i = 0; i < N; ++i) {\n            for (let j = i + 1; j < N; ++j) {\n                top_sum += Math.pow(d_X.entry(i, j) - d_Y.entry(i, j), 2);\n                bottom_sum += Math.pow(d_X.entry(i, j), 2);\n            }\n        }\n        return Math.sqrt(top_sum / bottom_sum);\n    }\n}\n","import { simultaneous_poweriteration } from \"../linear_algebra/index.js\";\nimport { Matrix } from \"../matrix/index.js\";\nimport { Heap } from \"../datastructure/index.js\";\nimport { DR } from \"./DR.js\";\nimport euclidean from \"../metrics/euclidean.js\";\n\n/**\n * @class\n * @alias ISOMAP\n * @extends DR\n */\nexport class ISOMAP extends DR {\n    /**\n     * Isometric feature mapping (ISOMAP).\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias ISOMAP\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Number} parameters.neighbors - the number of neighbors {@link ISOMAP} should use to project the data.\n     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.\n     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.\n     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.\n     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.\n     * @see {@link https://doi.org/10.1126/science.290.5500.2319}\n     */\n    constructor(X, parameters) {\n        super(X, { neighbors: undefined, d: 2, metric: euclidean, seed: 1212, eig_args: {} }, parameters);\n        this.parameter(\"neighbors\", Math.min(this._parameters.neighbors ?? Math.max(Math.floor(this.X.shape[0] / 10), 2), this._N - 1));\n        if (!this._parameters.eig_args.hasOwnProperty(\"seed\")) {\n            this._parameters.eig_args.seed = this._randomizer;\n        }\n        return this;\n    }\n\n    /**\n     * Computes the projection.\n     * @returns {Matrix} Returns the projection.\n     */\n    transform() {\n        this.check_init();\n        const X = this.X;\n        const rows = this._N;\n        const { d, metric, eig_args, neighbors } = this._parameters;\n        // TODO: make knn extern and parameter for constructor or transform?\n        const D = new Matrix();\n        D.shape = [rows, rows, (i, j) => (i <= j ? metric(X.row(i), X.row(j)) : D.entry(j, i))];\n        const kNearestNeighbors = [];\n        for (let i = 0; i < rows; ++i) {\n            const row = [];\n            for (let j = 0; j < rows; ++j) {\n                row.push({\n                    index: j,\n                    distance: D.entry(i, j),\n                });\n            }\n            const H = new Heap(row, (d) => d.distance, \"min\");\n            kNearestNeighbors.push(H.toArray().slice(1, neighbors + 1));\n        }\n\n        /*D = dijkstra(kNearestNeighbors);*/\n        // compute shortest paths\n        // TODO: make extern\n        /** @see {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm} */\n        const G = new Matrix(rows, rows, (i, j) => {\n            const other = kNearestNeighbors[i].find((n) => n.index === j);\n            return other ? other.distance : Infinity;\n        });\n\n        for (let i = 0; i < rows; ++i) {\n            for (let j = 0; j < rows; ++j) {\n                let min_val = G.entry(i, j);\n                for (let k = 0; k < rows; ++k) {\n                    min_val = Math.min(min_val, G.entry(i, k) + G.entry(k, j));\n                }\n                G.set_entry(i, j, min_val);\n            }\n        }\n\n        let ai_ = new Float64Array(rows);\n        let a_j = new Float64Array(rows);\n        let a__ = 0;\n        const A = new Matrix(rows, rows, (i, j) => {\n            let val = G.entry(i, j);\n            val = val === Infinity ? 0 : val;\n            ai_[i] += val;\n            a_j[j] += val;\n            a__ += val;\n            return val;\n        });\n\n        ai_ = ai_.map((v) => v / rows);\n        a_j = a_j.map((v) => v / rows);\n        a__ /= rows ** 2;\n        const B = new Matrix(rows, rows, (i, j) => A.entry(i, j) - ai_[i] - a_j[j] + a__);\n\n        // compute d eigenvectors\n        const { eigenvectors: V } = simultaneous_poweriteration(B, d, eig_args);\n        this.Y = Matrix.from(V).transpose();\n        // return embedding\n        return this.projection;\n    }\n}\n","import { Matrix } from \"../matrix/index.js\";\nimport { euclidean } from \"../metrics/index.js\";\nimport { DR } from \"./DR.js\";\n/**\n * @class\n * @alias FASTMAP\n * @extends DR\n */\nexport class FASTMAP extends DR {\n    /**\n     * FastMap: a fast algorithm for indexing, data-mining and visualization of traditional and multimedia datasets\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias FASTMAP\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.\n     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.\n     * @param {Number} [parameters.seed = 1212] - the dimensionality of the projection.\n     * @returns {FASTMAP}\n     * @see {@link https://doi.org/10.1145/223784.223812}\n     */\n    constructor(X, parameters) {\n        super(X, { d: 2, metric: euclidean, seed: 1212 }, parameters);\n        return this;\n    }\n\n    /**\n     * Chooses two points which are the most distant in the actual projection.\n     * @private\n     * @param {Function} dist\n     * @returns {Array} An array consisting of first index, second index, and distance between the two points.\n     */\n    _choose_distant_objects(dist) {\n        const X = this.X;\n        const N = X.shape[0];\n        let a_index = (this._randomizer.random_int % N) - 1;\n        let b_index = null;\n        let max_dist = -Infinity;\n        for (let i = 0; i < N; ++i) {\n            const d_ai = dist(a_index, i);\n            if (d_ai > max_dist) {\n                max_dist = d_ai;\n                b_index = i;\n            }\n        }\n        max_dist = -Infinity;\n        for (let i = 0; i < N; ++i) {\n            const d_bi = dist(b_index, i);\n            if (d_bi > max_dist) {\n                max_dist = d_bi;\n                a_index = i;\n            }\n        }\n        return [a_index, b_index, max_dist];\n    }\n\n    /**\n     * Computes the projection.\n     * @returns {Matrix} The {@link d}-dimensional projection of the data matrix {@link X}.\n     */\n    transform() {\n        const X = this.X;\n        const N = X.shape[0];\n        const { d, metric } = this._parameters;\n        const Y = new Matrix(N, d, 0);\n        let dist = (a, b) => metric(X.row(a), X.row(b));\n\n        for (let _col = 0; _col < d; ++_col) {\n            let old_dist = dist;\n            // choose pivot objects\n            const [a_index, b_index, d_ab] = this._choose_distant_objects(dist);\n            if (d_ab !== 0) {\n                // project the objects on the line (O_a, O_b)\n                for (let i = 0; i < N; ++i) {\n                    const d_ai = dist(a_index, i);\n                    const d_bi = dist(b_index, i);\n                    const y_i = (d_ai ** 2 + d_ab ** 2 - d_bi ** 2) / (2 * d_ab);\n                    Y.set_entry(i, _col, y_i);\n                }\n                // consider the projections of the objects on a\n                // hyperplane perpendicluar to the line (a, b);\n                // the distance function D'() between two\n                // projections is given by Eq.4\n                dist = (a, b) => Math.sqrt(old_dist(a, b) ** 2 - (Y.entry(a, _col) - Y.entry(b, _col)) ** 2);\n            }\n        }\n        // return embedding.\n        this.Y = Y;\n        return this.projection;\n    }\n}\n","import { Matrix } from \"../matrix/index.js\";\nimport { simultaneous_poweriteration } from \"../linear_algebra/index.js\";\nimport { DR } from \"./DR.js\";\n\n/**\n * @class\n * @alias LDA\n * @extends DR\n */\nexport class LDA extends DR {\n    /**\n     * Linear Discriminant Analysis.\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias LDA\n     * @param {Matrix} X - The high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Array} parameters.labels - The labels / classes for each data point.\n     * @param {number} [parameters.d = 2] - The dimensionality of the projection.\n     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.\n     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.\n     * @see {@link https://onlinelibrary.wiley.com/doi/10.1111/j.1469-1809.1936.tb02137.x}\n     */\n    constructor(X, parameters) {\n        super(X, { labels: null, d: 2, seed: 1212, eig_args: {} }, parameters);\n        if (!this._parameters.eig_args.hasOwnProperty(\"seed\")) {\n            this._parameters.eig_args.seed = this._randomizer;\n        }\n        return this;\n    }\n\n    /**\n     * Transforms the inputdata {@link X} to dimenionality {@link d}.\n     */\n    transform() {\n        const X = this.X;\n        const [rows, cols] = X.shape;\n        const { d, labels, eig_args } = this._parameters;\n        if (labels === null || labels.length != rows) {\n            throw new Error(\"LDA needs parameter label to every datapoint to work!\");\n        }\n        const unique_labels = {};\n        let label_id = 0;\n        labels.forEach((l, i) => {\n            if (l in unique_labels) {\n                unique_labels[l].count++;\n                unique_labels[l].rows.push(X.row(i));\n            } else {\n                unique_labels[l] = {\n                    id: label_id++,\n                    count: 1,\n                    rows: [X.row(i)],\n                };\n            }\n        });\n\n        // create X_mean and vector means;\n        const X_mean = X.mean;\n        const V_mean = new Matrix(label_id, cols);\n        for (const label in unique_labels) {\n            const V = Matrix.from(unique_labels[label].rows);\n            const v_mean = V.meanCols;\n            for (let j = 0; j < cols; ++j) {\n                V_mean.set_entry(unique_labels[label].id, j, v_mean[j]);\n            }\n        }\n        // scatter_between\n        let S_b = new Matrix(cols, cols);\n        for (const label in unique_labels) {\n            const v = V_mean.row(unique_labels[label].id);\n            const m = new Matrix(cols, 1, (j) => v[j] - X_mean);\n            const N = unique_labels[label].count;\n            S_b = S_b.add(m.dotTrans(m).mult(N));\n        }\n\n        // scatter_within\n        let S_w = new Matrix(cols, cols);\n        for (const label in unique_labels) {\n            const v = V_mean.row(unique_labels[label].id);\n            const m = new Matrix(cols, 1, (j) => v[j]);\n            const R = unique_labels[label].rows;\n            for (let i = 0, n = unique_labels[label].count; i < n; ++i) {\n                const row_v = new Matrix(cols, 1, (j, _) => R[i][j] - m.entry(j, 0));\n                S_w = S_w.add(row_v.dotTrans(row_v));\n            }\n        }\n\n        let { eigenvectors: V } = simultaneous_poweriteration(S_w.inverse().dot(S_b), d, eig_args);\n        V = Matrix.from(V).transpose();\n        this.Y = X.dot(V);\n\n        // return embedding\n        return this.projection;\n    }\n}\n","import { Matrix } from \"../matrix/index.js\";\nimport { euclidean } from \"../metrics/index.js\";\nimport { simultaneous_poweriteration } from \"../linear_algebra/index.js\";\nimport { k_nearest_neighbors } from \"../matrix/index.js\";\nimport { neumair_sum } from \"../numerical/index.js\";\nimport { DR } from \"./DR.js\";\n\n/**\n * @class\n * @alias LLE\n * @extends DR\n */\nexport class LLE extends DR {\n    /**\n     * Locally Linear Embedding.\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias LLE\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Number} neighbors - the label / class of each data point.\n     * @param {Number} [d = 2] - the dimensionality of the projection.\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.\n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\n     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.\n     * @see {@link https://doi.org/10.1126/science.290.5500.2323}\n     */\n    constructor(X, parameters) {\n        super(X, { neighbors: undefined, d: 2, metric: euclidean, seed: 1212, eig_args: {} }, parameters);\n        this.parameter(\"neighbors\", Math.min(parameters.neighbors ?? Math.max(Math.floor(this._N / 10), 2), this._N - 1));\n        if (!this._parameters.eig_args.hasOwnProperty(\"seed\")) {\n            this._parameters.eig_args.seed = this._randomizer;\n        }\n        return this;\n    }\n\n    /**\n     * Transforms the inputdata {@link X} to dimenionality {@link d}.\n     */\n    transform() {\n        const X = this.X;\n        const rows = this._N;\n        const cols = this._D;\n        const { neighbors, d, eig_args, metric } = this._parameters;\n        const nN = k_nearest_neighbors(X, neighbors, metric);\n        const O = new Matrix(neighbors, 1, 1);\n        const W = new Matrix(rows, rows);\n\n        for (let row = 0; row < rows; ++row) {\n            const nN_row = nN[row];\n            const Z = new Matrix(neighbors, cols, (i, j) => X.entry(nN_row[i].j, j) - X.entry(row, j));\n            const C = Z.dotTrans(Z);\n            if (neighbors > cols) {\n                const C_trace = neumair_sum(C.diag) / 1000;\n                for (let j = 0; j < neighbors; ++j) {\n                    C.add_entry(j, j, C_trace);\n                }\n            }\n            // reconstruct;\n            let w = Matrix.solve_CG(C, O, this._randomizer);\n            w = w.divide(w.sum);\n            for (let j = 0; j < neighbors; ++j) {\n                W.set_entry(row, nN_row[j].j, w.entry(j, 0));\n            }\n        }\n        // comp embedding\n        const I = new Matrix(rows, rows, \"identity\");\n        const IW = I.sub(W);\n        const M = IW.transDot(IW);\n        const { eigenvectors: V } = simultaneous_poweriteration(M.T.inverse(), d + 1, eig_args);\n        this.Y = Matrix.from(V.slice(1, 1 + d)).T;\n\n        // return embedding\n        return this.projection;\n    }\n}\n","import { Matrix, k_nearest_neighbors } from \"../matrix/index.js\";\nimport { euclidean } from \"../metrics/index.js\";\nimport { simultaneous_poweriteration } from \"../linear_algebra/index.js\";\nimport { DR } from \"./DR.js\";\n\n/**\n * @class\n * @alias LTSA\n * @extends DR\n */\nexport class LTSA extends DR {\n    /**\n     * Local Tangent Space Alignment\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias LTSA\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Number} parameters.neighbors - the number of neighbors {@link LTSA} should use to project the data.\n     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.\n     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.\n     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.\n     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.\n     * @see {@link https://epubs.siam.org/doi/abs/10.1137/S1064827502419154}\n     */\n    constructor(X, parameters) {\n        super(X, { neighbors: undefined, d: 2, metric: euclidean, seed: 1212, eig_args: {} }, parameters);\n        this.parameter(\"neighbors\", Math.min(parameters.neighbors ?? Math.max(Math.floor(this._N / 10), 2), this._N - 1));\n        if (!this._parameters.eig_args.hasOwnProperty(\"seed\")) {\n            this._parameters.eig_args.seed = this._randomizer;\n        }\n        if (this._D <= this.parameter(\"d\")) {\n            throw new Error(`Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${this.parameter(\"d\")})!`);\n        }\n        return this;\n    }\n\n    /**\n     * Transforms the inputdata {@link X} to dimenionality {@link d}.\n     */\n    transform() {\n        const X = this.X;\n        const [rows, D] = X.shape;\n        const { d, neighbors, metric, eig_args } = this._parameters;\n        // 1.1 determine k nearest neighbors\n        const nN = k_nearest_neighbors(X, neighbors, metric);\n        // center matrix\n        const O = new Matrix(D, D, \"center\");\n        const B = new Matrix(rows, rows, 0);\n\n        for (let row = 0; row < rows; ++row) {\n            // 1.2 compute the d largest eigenvectors of the correlation matrix\n            const I_i = [row, ...nN[row].map((n) => n.j)];\n            let X_i = Matrix.from(I_i.map((n) => X.row(n)));\n            // center X_i\n            X_i = X_i.dot(O);\n            // correlation matrix\n            const C = X_i.dotTrans(X_i);\n            const { eigenvectors: g } = simultaneous_poweriteration(C, d, eig_args);\n            //g.push(linspace(0, k).map(_ => 1 / Math.sqrt(k + 1)));\n            const G_i_t = Matrix.from(g);\n            // 2. Constructing alignment matrix\n            const W_i = G_i_t.transDot(G_i_t)\n                .add(1 / Math.sqrt(neighbors + 1));\n            for (let i = 0; i < neighbors + 1; ++i) {\n                for (let j = 0; j < neighbors + 1; ++j) {\n                    B.add_entry(I_i[i], I_i[j], W_i.entry(i, j) - (i === j ? 1 : 0));\n                }\n            }\n        }\n\n        // 3. Aligning global coordinates\n        const { eigenvectors: Y } = simultaneous_poweriteration(B, d + 1, eig_args);\n        this.Y = Matrix.from(Y.slice(1)).transpose();\n\n        // return embedding\n        return this.projection;\n    }\n}\n","import { Matrix } from \"../matrix/index.js\";\nimport { euclidean_squared } from \"../metrics/index.js\";\nimport { DR } from \"./DR.js\";\n\n/**\n * @class\n * @alias TSNE\n * @extends DR\n */\nexport class TSNE extends DR {\n    /**\n     *\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias TSNE\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Number} [parameters.perplexity = 50] - perplexity.\n     * @param {Number} [parameters.epsilon = 10] - learning parameter.\n     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.\n     * @param {Function|\"precomputed\"} [parameters.metric = euclidean_squared] - the metric which defines the distance between two points.\n     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.\n     * @returns {TSNE}\n     */\n    constructor(X, parameters) {\n        super(X, { perplexity: 50, epsilon: 10, d: 2, metric: euclidean_squared, seed: 1212 }, parameters);\n        [this._N, this._D] = this.X.shape;\n        this._iter = 0;\n        this.Y = new Matrix(this._N, this.parameter(\"d\"), () => this._randomizer.gauss_random() * 1e-4);\n        return this;\n    }\n\n    /**\n     *\n     * @returns {TSNE}\n     */\n    init() {\n        // init\n        const Htarget = Math.log(this.parameter(\"perplexity\"));\n        const N = this._N;\n        const D = this._D;\n        const {metric} = this._parameters;\n        const X = this.X;\n        let Delta;\n        if (metric ==\"precomputed\") {\n            Delta = druid.Matrix.from(X);\n        } else {\n            Delta = new Matrix(N, N);\n            for (let i = 0; i < N; ++i) {\n                const X_i = X.row(i);\n                for (let j = i + 1; j < N; ++j) {\n                    const distance = metric(X_i, X.row(j));\n                    Delta.set_entry(i, j, distance);\n                    Delta.set_entry(j, i, distance);\n                }\n            }\n        }\n\n        const P = new Matrix(N, N, 0);\n\n        this._ystep = new Matrix(N, D, 0);\n        this._gains = new Matrix(N, D, 1);\n\n        // search for fitting sigma\n        const tol = 1e-4;\n        const maxtries = 50;\n        for (let i = 0; i < N; ++i) {\n            const dist_i = Delta.row(i);\n            const prow = P.row(i);\n            let betamin = -Infinity;\n            let betamax = Infinity;\n            let beta = 1;\n            let cnt = maxtries;\n            let done = false;\n            let psum;\n\n            while (!done && cnt--) {\n                // compute entropy and kernel row with beta precision\n                psum = 0;\n                let dp_sum = 0;\n                for (let j = 0; j < N; ++j) {\n                    const dist = dist_i[j];\n                    const pj = (i !== j) ? Math.exp(-dist * beta) : 0;\n                    dp_sum += dist * pj;\n                    prow[j] = pj;\n                    psum += pj;\n                }\n                // compute entropy\n                const H = psum > 0 ? Math.log(psum) + beta * dp_sum / psum : 0;\n                if (H > Htarget) {\n                    betamin = beta;\n                    beta = betamax === Infinity ? beta * 2 : (beta + betamax) / 2;\n                } else {\n                    betamax = beta;\n                    beta = betamin === -Infinity ? beta / 2 : (beta + betamin) / 2;\n                }\n                done = Math.abs(H - Htarget) < tol;\n            }\n            // normalize p\n            for (let j = 0; j < N; ++j) {\n                prow[j] /= psum;\n            }\n        }\n\n        // compute probabilities\n        const N2 = N * 2;\n        for (let i = 0; i < N; ++i) {\n            for (let j = i; j < N; ++j) {\n                const p = Math.max((P.entry(i, j) + P.entry(j, i)) / N2, 1e-100);\n                P.set_entry(i, j, p);\n                P.set_entry(j, i, p);\n            }\n        }\n        this._P = P;\n        return this;\n    }\n\n    /**\n     *\n     * @param {Number} [iterations=500] - Number of iterations.\n     * @returns {Matrix|Number[][]} the projection.\n     */\n    transform(iterations = 500) {\n        this.check_init();\n        for (let i = 0; i < iterations; ++i) {\n            this.next();\n        }\n        return this.projection;\n    }\n\n    /**\n     *\n     * @param {Number} [iterations=500] - number of iterations.\n     * @yields {Matrix|Number[][]} - the projection.\n     */\n    *generator(iterations = 500) {\n        this.check_init();\n        for (let i = 0; i < iterations; ++i) {\n            this.next();\n            yield this.projection;\n        }\n        return this.projection;\n    }\n\n    /**\n     * performs a optimization step\n     * @private\n     * @returns {Matrix}\n     */\n    next() {\n        const iter = ++this._iter;\n        const P = this._P;\n        const ystep = this._ystep;\n        const gains = this._gains;\n        const N = this._N;\n        const { d: dim, epsilon} = this._parameters;\n        let Y = this.Y;\n\n        //calc cost gradient;\n        const pmul = iter < 100 ? 4 : 1;\n\n        // compute Q dist (unnormalized)\n        const Qu = new Matrix(N, N, \"zeros\");\n        let qsum = 0;\n        for (let i = 0; i < N; ++i) {\n            for (let j = i + 1; j < N; ++j) {\n                let dsum = 0;\n                for (let d = 0; d < dim; ++d) {\n                    const dhere = Y.entry(i, d) - Y.entry(j, d);\n                    dsum += dhere * dhere;\n                }\n                const qu = 1 / (1 + dsum);\n                Qu.set_entry(i, j, qu);\n                Qu.set_entry(j, i, qu);\n                qsum += 2 * qu;\n            }\n        }\n\n        // normalize Q dist\n        const Q = new Matrix(N, N, 0);\n        for (let i = 0; i < N; ++i) {\n            for (let j = i + 1; j < N; ++j) {\n                const val = Math.max(Qu.entry(i, j) / qsum, 1e-100);\n                Q.set_entry(i, j, val);\n                Q.set_entry(j, i, val);\n            }\n        }\n\n        const grad = new Matrix(N, dim, \"zeros\");\n        for (let i = 0; i < N; ++i) {\n            for (let j = 0; j < N; ++j) {\n                const premult = 4 * (pmul * P.entry(i, j) - Q.entry(i, j)) * Qu.entry(i, j);\n                for (let d = 0; d < dim; ++d) {\n                    grad.add_entry(i, d, premult * (Y.entry(i, d) - Y.entry(j, d)));\n                }\n            }\n        }\n\n        // perform gradient step\n        let ymean = new Float64Array(dim);\n        for (let i = 0; i < N; ++i) {\n            for (let d = 0; d < dim; ++d) {\n                const gid = grad.entry(i, d);\n                const sid = ystep.entry(i, d);\n                const gainid = gains.entry(i, d);\n\n                let newgain = Math.sign(gid) === Math.sign(sid) ? gainid * 0.8 : gainid + 0.2;\n                if (newgain < 0.01) newgain = 0.01;\n                gains.set_entry(i, d, newgain);\n\n                const momval = iter < 250 ? 0.5 : 0.8;\n                const newsid = momval * sid - epsilon * newgain * gid;\n                ystep.set_entry(i, d, newsid);\n\n                Y.add_entry(i, d, newsid);\n                ymean[d] += Y.entry(i, d);\n            }\n        }\n\n        for (let i = 0; i < N; ++i) {\n            for (let d = 0; d < dim; ++d) {\n                Y.sub_entry(i, d, ymean[d] / N);\n            }\n        }\n\n        return this.Y;\n    }\n}\n","/**\n *\n * @memberof module:optimization\n * @alias powell\n * @param {Function} f\n * @param {number[]} x0\n * @param {number} [max_iter = 300]\n * @returns {number[]}\n * @see http://optimization-js.github.io/optimization-js/optimization.js.html#line438\n */\nexport default function (f, x0, max_iter = 300) {\n    const epsilon = 1e-2;\n    const n = x0.length;\n    let alpha = 1e-3;\n    let pfx = 10000;\n    let x = x0.slice();\n    let fx = f(x);\n    let convergence = false;\n\n    while (max_iter-- >= 0 && !convergence) {\n        convergence = true;\n        for (let i = 0; i < n; ++i) {\n            x[i] += 1e-6;\n            let fxi = f(x);\n            x[i] -= 1e-6;\n            let dx = (fxi - fx) / 1e-6;\n            if (Math.abs(dx) > epsilon) {\n                convergence = false;\n            }\n            x[i] -= alpha * dx;\n            fx = f(x);\n        }\n        alpha *= pfx >= fx ? 1.05 : 0.4;\n        pfx = fx;\n    }\n    return x;\n}\n","import { Matrix } from \"../matrix/index.js\";\nimport { euclidean, euclidean_squared } from \"../metrics/index.js\";\nimport { BallTree } from \"../knn/index.js\";\nimport { neumair_sum } from \"../numerical/index.js\";\nimport { linspace } from \"../matrix/index.js\";\nimport { powell } from \"../optimization/index.js\";\nimport { DR } from \"./DR.js\";\nimport { max } from \"../util/index.js\";\nimport { KNN } from \"../knn/index.js\";\n\n/**\n * @class\n * @alias UMAP\n * @extends DR\n */\nexport class UMAP extends DR {\n    /**\n     *\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias UMAP\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Number} [parameters.n_neighbors = 15] - size of the local neighborhood.\n     * @param {Number} [parameters.local_connectivity = 1] - number of nearest neighbors connected in the local neighborhood.\n     * @param {Number} [parameters.min_dist = 1] - controls how tightly points get packed together.\n     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.\n     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points in the high-dimensional space.\n     * @param {Number} [parameters._spread = 1] - The effective scale of embedded points. (In combination with {@link parameters.min_dist})\n     * @param {Number} [parameters._set_op_mix_ratio = 1] - Interpolate between union and intersection.\n     * @param {Number} [parameters._repulsion_strength = 1]  - Weighting applied to negative samples.\n     * @param {Number} [parameters._negative_sample_rate = 5] - The number of negative samples per positive sample.\n     * @param {Number} [parameters._n_epochs = 350] - The number of training epochs.\n     * @param {Number} [parameter._initial_alpha = 1] - The initial learning rate for the optimization.\n     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.\n     * @returns {UMAP}\n     */\n    constructor(X, parameters) {\n        super(X, { n_neighbors: 15, local_connectivity: 1, min_dist: 1, d: 2, metric: euclidean, seed: 1212, _spread: 1, _set_op_mix_ratio: 1, _repulsion_strength: 1, _negative_sample_rate: 5, _n_epochs: 350, _initial_alpha: 1 }, parameters);\n        [this._N, this._D] = this.X.shape;\n        /* let n_neighbors = Math.min(this._N - 1, parameters.n_neighbors);\n        this.parameter(\"n_neighbors\", n_neighbors);\n        this.parameter(\"local_connectivity\", Math.min(this.parameter(\"local_connectivity\"), n_neighbors - 1)); */\n        if (this.parameter(\"n_neighbors\") > this._N) {\n            throw new Error(`Parameter n_neighbors (=${this.parameter(\"n_neighbors\")}) needs to be smaller than dataset size (N=${this._N})!`);\n        }\n        if (this.parameter(\"local_connectivity\") > this.parameter(\"n_neighbors\")) {\n            throw new Error(`Parameter local_connectivity (=${this.parameter(\"local_connectivity\")}) needs to be smaller than parameter n_neighbors (=${this.parameter(\"n_neighbors\")})`);\n        }\n        this._iter = 0;\n        const randomizer = this._randomizer;\n        this.Y = new Matrix(this._N, this.parameter(\"d\"), () => randomizer.random);\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {Number} spread\n     * @param {Number} min_dist\n     * @returns {Array}\n     */\n    _find_ab_params(spread, min_dist) {\n        const curve = (x, a, b) => 1 / (1 + a * Math.pow(x, 2 * b));\n        const xv = linspace(0, spread * 3, 300);\n        const yv = linspace(0, spread * 3, 300);\n\n        for (let i = 0, n = xv.length; i < n; ++i) {\n            const xv_i = xv[i];\n            yv[i] = xv_i < min_dist ? 1 : Math.exp(-(xv_i - min_dist) / spread);\n        }\n\n        const err = (p) => {\n            const error = linspace(1, 300).map((_, i) => yv[i] - curve(xv[i], p[0], p[1]));\n            return Math.sqrt(neumair_sum(error.map((e) => e * e)));\n        };\n\n        return powell(err, [1, 1]);\n    }\n\n    /**\n     * @private\n     * @param {Array<Array>} distances\n     * @param {Array<Number>} sigmas\n     * @param {Array<Number>} rhos\n     * @returns {Array}\n     */\n    _compute_membership_strengths(distances, sigmas, rhos) {\n        for (let i = 0, n = distances.length; i < n; ++i) {\n            const rho = rhos[i];\n            const curr_dist = distances[i];\n            for (let j = 0, m = curr_dist.length; j < m; ++j) {\n                const v = curr_dist[j].value - rho;\n                curr_dist[j].value = v > 0 ? Math.exp(-v / sigmas[i]) : 1.0;\n            }\n        }\n        return distances;\n    }\n\n    /**\n     * @private\n     * @param {KNN|BallTree} knn\n     * @param {Number} k\n     * @returns {Object}\n     */\n    _smooth_knn_dist(knn, k) {\n        const SMOOTH_K_TOLERANCE = 1e-5;\n        const MIN_K_DIST_SCALE = 1e-3;\n        const n_iter = 64;\n        const { local_connectivity, metric } = this._parameters;\n        const target = Math.log2(k);\n        const rhos = [];\n        const sigmas = [];\n        const X = this.X;\n        const N = X.shape[0];\n        //const distances = [...X].map(x_i => knn.search(x_i, k).raw_data().reverse());\n\n        const distances = [];\n        if (metric === \"precomputed\") {\n            for (let i = 0; i < N; ++i) {\n                distances.push(knn.search(i, k).reverse());\n            }\n        } else {\n            for (const x_i of X) {\n                distances.push(knn.search(x_i, k).raw_data().reverse());\n            }\n        }\n\n        const index = Math.floor(local_connectivity);\n        const interpolation = local_connectivity - index;\n        for (let i = 0; i < N; ++i) {\n            let lo = 0;\n            let hi = Infinity;\n            let mid = 1;\n            let rho = 0;\n\n            const search_result = distances[i];\n            const non_zero_dist = search_result.filter((d) => d.value > 0);\n            const non_zero_dist_length = non_zero_dist.length;\n            if (non_zero_dist_length >= local_connectivity) {\n                if (index > 0) {\n                    rho = non_zero_dist[index - 1].value;\n                    if (interpolation > SMOOTH_K_TOLERANCE) {\n                        rho += interpolation * (non_zero_dist[index].value - non_zero_dist[index - 1].value);\n                    }\n                } else {\n                    rho = interpolation * non_zero_dist[0].value;\n                }\n            } else if (non_zero_dist_length > 0) {\n                rho = non_zero_dist[non_zero_dist_length - 1].value;\n            }\n            for (let x = 0; x < n_iter; ++x) {\n                let psum = 0;\n                for (let j = 0; j < k; ++j) {\n                    const d = search_result[j].value - rho;\n                    psum += d > 0 ? Math.exp(-(d / mid)) : 1;\n                }\n                if (Math.abs(psum - target) < SMOOTH_K_TOLERANCE) {\n                    break;\n                }\n                if (psum > target) {\n                    [hi, mid] = [mid, (lo + hi) / 2];\n                } else {\n                    if (hi === Infinity) {\n                        [lo, mid] = [mid, mid * 2];\n                    } else {\n                        [lo, mid] = [mid, (lo + hi) / 2];\n                    }\n                }\n            }\n\n            //let mean_d = null;\n            if (rho > 0) {\n                const mean_ithd = search_result.reduce((a, b) => a + b.value, 0) / search_result.length;\n                if (mid < MIN_K_DIST_SCALE * mean_ithd) {\n                    mid = MIN_K_DIST_SCALE * mean_ithd;\n                }\n            } else {\n                const mean_d = distances.reduce((acc, res) => acc + res.reduce((a, b) => a + b.value, 0) / res.length);\n                if (mid < MIN_K_DIST_SCALE * mean_d) {\n                    mid = MIN_K_DIST_SCALE * mean_d;\n                }\n            }\n            rhos[i] = rho;\n            sigmas[i] = mid;\n        }\n        return {\n            distances: distances,\n            sigmas: sigmas,\n            rhos: rhos,\n        };\n    }\n\n    /**\n     * @private\n     * @param {Matrix} X\n     * @param {Number} n_neighbors\n     * @returns {Matrix}\n     */\n    _fuzzy_simplicial_set(X, n_neighbors) {\n        const N = X.shape[0];\n        const { metric, _set_op_mix_ratio } = this._parameters;\n        const knn = metric === \"precomputed\" ? new KNN(X, \"precomputed\") : new BallTree(X.to2dArray, metric);\n        let { distances, sigmas, rhos } = this._smooth_knn_dist(knn, n_neighbors);\n        distances = this._compute_membership_strengths(distances, sigmas, rhos);\n        const result = new Matrix(N, N, \"zeros\");\n        for (let i = 0; i < N; ++i) {\n            const distances_i = distances[i];\n            for (let j = 0; j < distances_i.length; ++j) {\n                result.set_entry(i, distances_i[j].element.index, distances_i[j].value);\n            }\n        }\n\n        const transposed_result = result.T;\n        const prod_matrix = result.mult(transposed_result);\n        return result\n            .add(transposed_result)\n            .sub(prod_matrix)\n            .mult(_set_op_mix_ratio)\n            .add(prod_matrix.mult(1 - _set_op_mix_ratio));\n    }\n\n    /**\n     * @private\n     * @param {Number} n_epochs\n     * @returns {Array}\n     */\n    _make_epochs_per_sample(n_epochs) {\n        const weights = this._weights;\n        const result = new Float32Array(weights.length).fill(-1);\n        const weight_scl = n_epochs / max(weights);\n        weights.forEach((w, i) => {\n          const sample = w * weight_scl;\n          if (sample > 0) result[i] = Math.round(n_epochs / sample);\n        })\n        return result;\n    }\n\n    /**\n     * @private\n     * @param {Matrix} graph\n     * @returns {Object}\n     */\n    _tocoo(graph) {\n        const rows = [];\n        const cols = [];\n        const data = [];\n        const [rows_n, cols_n] = graph.shape;\n        for (let row = 0; row < rows_n; ++row) {\n            for (let col = 0; col < cols_n; ++col) {\n                const entry = graph.entry(row, col);\n                if (entry !== 0) {\n                    rows.push(row);\n                    cols.push(col);\n                    data.push(entry);\n                }\n            }\n        }\n        return {\n            rows: rows,\n            cols: cols,\n            data: data,\n        };\n    }\n\n    /**\n     * Computes all necessary\n     * @returns {UMAP}\n     */\n    init() {\n        const { _spread, min_dist, n_neighbors, _n_epochs, _negative_sample_rate } = this._parameters;\n        const [a, b] = this._find_ab_params(_spread, min_dist);\n        this._a = a;\n        this._b = b;\n        this._graph = this._fuzzy_simplicial_set(this.X, n_neighbors);\n        const { rows, cols, data: weights } = this._tocoo(this._graph);\n        this._head = rows;\n        this._tail = cols;\n        this._weights = weights;\n        this._epochs_per_sample = this._make_epochs_per_sample(_n_epochs);\n        this._epochs_per_negative_sample = this._epochs_per_sample.map((d) => d * _negative_sample_rate);\n        this._epoch_of_next_sample = this._epochs_per_sample.slice();\n        this._epoch_of_next_negative_sample = this._epochs_per_negative_sample.slice();\n        return this;\n    }\n\n    graph() {\n        this.check_init();\n        return { cols: this._head, rows: this._tail, weights: this._weights };\n    }\n\n    /**\n     *\n     * @param {Number} [iterations=350] - number of iterations.\n     * @returns {Matrix|Array}\n     */\n    transform(iterations = 350) {\n        if (this.parameter(\"_n_epochs\") != iterations) {\n            this.parameter(\"_n_epochs\", iterations);\n            this.init();\n        }\n        this.check_init();\n        for (let i = 0; i < iterations; ++i) {\n            this.next();\n        }\n        return this.projection;\n    }\n\n    /**\n     *\n     * @param {Number} [iterations=350] - number of iterations.\n     * @returns {Matrix|Array}\n     */\n    *generator(iterations = 350) {\n        if (this.parameter(\"_n_epochs\") != iterations) {\n            this.parameter(\"_n_epochs\", iterations);\n            this.init();\n        }\n        this.check_init();\n        for (let i = 0; i < iterations; ++i) {\n            this.next();\n            yield this.projection;\n        }\n        return this.projection;\n    }\n\n    /**\n     * @private\n     * @param {Number} x\n     * @returns {Number}\n     */\n    _clip(x) {\n        if (x > 4) return 4;\n        if (x < -4) return -4;\n        return x;\n    }\n\n    /**\n     * performs the optimization step.\n     * @private\n     * @param {Matrix} head_embedding\n     * @param {Matrix} tail_embedding\n     * @param {Matrix} head\n     * @param {Matrix} tail\n     * @returns {Matrix}\n     */\n    _optimize_layout(head_embedding, tail_embedding, head, tail) {\n        const randomizer = this._randomizer;\n        const { _repulsion_strength, d: dim } = this._parameters;\n        const { _alpha: alpha, _a: a, _b: b, _epochs_per_sample: epochs_per_sample, _epochs_per_negative_sample: epochs_per_negative_sample, _epoch_of_next_negative_sample: epoch_of_next_negative_sample, _epoch_of_next_sample: epoch_of_next_sample, _clip: clip } = this;\n        const tail_length = tail.length;\n\n        for (let i = 0, n = epochs_per_sample.length; i < n; ++i) {\n            if (epoch_of_next_sample[i] <= this._iter) {\n                const j = head[i];\n                const k = tail[i];\n                const current = head_embedding.row(j);\n                const other = tail_embedding.row(k);\n                const dist = euclidean_squared(current, other);\n                if (dist > 0) {\n                    const grad_coeff = (-2 * a * b * Math.pow(dist, b - 1)) / (a * Math.pow(dist, b) + 1);\n                    for (let d = 0; d < dim; ++d) {\n                        const grad_d = clip(grad_coeff * (current[d] - other[d])) * alpha;\n                        current[d] += grad_d;\n                        other[d] -= grad_d;\n                    }\n                }\n                epoch_of_next_sample[i] += epochs_per_sample[i];\n                const n_neg_samples = (this._iter - epoch_of_next_negative_sample[i]) / epochs_per_negative_sample[i];\n                for (let p = 0; p < n_neg_samples; ++p) {\n                    const k = randomizer.random_int % tail_length;\n                    const other = tail_embedding.row(tail[k]);\n                    const dist = euclidean_squared(current, other);\n                    if (dist > 0) {\n                        const grad_coeff = (2 * _repulsion_strength * b) / ((0.01 + dist) * (a * Math.pow(dist, b) + 1));\n                        for (let d = 0; d < dim; ++d) {\n                            const grad_d = clip(grad_coeff * (current[d] - other[d])) * alpha;\n                            current[d] += grad_d;\n                            other[d] -= grad_d;\n                        }\n                    } else if (j === k) {\n                        continue;\n                    }\n                }\n                epoch_of_next_negative_sample[i] += n_neg_samples * epochs_per_negative_sample[i];\n            }\n        }\n        return head_embedding;\n    }\n\n    /**\n     * @private\n     * @returns {Matrix}\n     */\n    next() {\n        const iter = ++this._iter;\n        const Y = this.Y;\n        const { _initial_alpha, _n_epochs } = this._parameters;\n        this._alpha = _initial_alpha * (1 - iter / _n_epochs);\n        this.Y = this._optimize_layout(Y, Y, this._head, this._tail);\n\n        return this.Y;\n    }\n}\n","import { Matrix, linspace } from \"../matrix/index.js\";\nimport { euclidean } from \"../metrics/index.js\";\nimport { PCA } from \"./PCA.js\";\nimport { BallTree } from \"../knn/index.js\";\nimport { DR } from \"./DR.js\";\n\n/**\n * @class\n * @alias TriMap\n * @extends DR\n */\nexport class TriMap extends DR {\n    /**\n     *\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias TriMap\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Number} [parameters.weight_adj = 500] - scaling factor.\n     * @param {Number} [parameters.c = 5] - number of triplets multiplier.\n     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.\n     * @param {Number} [parameters.tol = 1e-8] -\n     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.\n     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.\n     * @returns {TriMap}\n     * @see {@link https://arxiv.org/pdf/1910.00204v1.pdf}\n     * @see {@link https://github.com/eamid/trimap}\n     */\n    constructor(X, parameters) {\n        super(X, { weight_adj: 500, c: 5, d: 2, metric: euclidean, tol: 1e-8, seed: 1212 }, parameters);\n        return this;\n    }\n\n    /**\n     *\n     * @param {Matrix} [pca = null] - Initial Embedding (if null then PCA gets used).\n     * @param {KNN} [knn = null] - KNN Object (if null then BallTree gets used).\n     */\n    init(pca = null, knn = null) {\n        const X = this.X;\n        const N = X.shape[0];\n        const { c, d, metric, seed } = this._parameters;\n        this.n_inliers = 2 * c;\n        this.n_outliers = 1 * c;\n        this.n_random = 1 * c;\n        this.Y = pca || new PCA(X, { d, seed }).transform();\n        this.knn = knn || new BallTree(X.to2dArray, metric);\n        const { triplets, weights } = this._generate_triplets(this.n_inliers, this.n_outliers, this.n_random);\n        this.triplets = triplets;\n        this.weights = weights;\n        this.lr = (1000 * N) / triplets.shape[0];\n        this.C = Infinity;\n        this.vel = new Matrix(N, d, 0);\n        this.gain = new Matrix(N, d, 1);\n        return this;\n    }\n\n    /**\n     * Generates {@link n_inliers} x {@link n_outliers} x {@link n_random} triplets.\n     * @param {Number} n_inliers\n     * @param {Number} n_outliers\n     * @param {Number} n_random\n     */\n    _generate_triplets(n_inliers, n_outliers, n_random) {\n        const { metric, weight_adj } = this._parameters;\n        const X = this.X;\n        const N = X.shape[0];\n        const knn = this.knn;\n        const n_extra = Math.min(n_inliers + 20, N);\n        const nbrs = new Matrix(N, n_extra);\n        const knn_distances = new Matrix(N, n_extra);\n        for (let i = 0; i < N; ++i) {\n            knn.search(X.row(i), n_extra + 1)\n                .raw_data()\n                .filter((d) => d.value != 0)\n                .sort((a, b) => a.value - b.value)\n                .forEach((d, j) => {\n                    nbrs.set_entry(i, j, d.element.index);\n                    knn_distances.set_entry(i, j, d.value);\n                });\n        }\n        // scale parameter\n        const sig = new Float64Array(N);\n        for (let i = 0; i < N; ++i) {\n            sig[i] = Math.max((knn_distances.entry(i, 3) + knn_distances.entry(i, 4) + knn_distances.entry(i, 5) + knn_distances.entry(i, 6)) / 4, 1e-10);\n        }\n\n        const P = this._find_p(knn_distances, sig, nbrs);\n\n        let triplets = this._sample_knn_triplets(P, nbrs, n_inliers, n_outliers);\n        let n_triplets = triplets.shape[0];\n        const outlier_distances = new Float64Array(n_triplets);\n        for (let i = 0; i < n_triplets; ++i) {\n            const j = triplets.entry(i, 0);\n            const k = triplets.entry(i, 2);\n            outlier_distances[i] = metric(X.row(j), X.row(k));\n        }\n        let weights = this._find_weights(triplets, P, nbrs, outlier_distances, sig);\n\n        if (n_random > 0) {\n            const { random_triplets, random_weights } = this._sample_random_triplets(X, n_random, sig);\n            triplets = triplets.concat(random_triplets, \"vertical\");\n            weights = Float64Array.from([...weights, ...random_weights]);\n        }\n        n_triplets = triplets.shape[0];\n        let max_weight = -Infinity;\n        for (let i = 0; i < n_triplets; ++i) {\n            if (isNaN(weights[i])) {\n                weights[i] = 0;\n            }\n            if (max_weight < weights[i]) max_weight = weights[i];\n        }\n        let max_weight_2 = -Infinity;\n        for (let i = 0; i < n_triplets; ++i) {\n            weights[i] /= max_weight;\n            weights[i] += 0.0001;\n            weights[i] = Math.log(1 + weight_adj * weights[i]);\n            if (max_weight_2 < weights[i]) max_weight_2 = weights[i];\n        }\n        for (let i = 0; i < n_triplets; ++i) {\n            weights[i] /= max_weight_2;\n        }\n        return {\n            triplets: triplets,\n            weights: weights,\n        };\n    }\n\n    /**\n     * Calculates the similarity matrix P\n     * @private\n     * @param {Matrix} knn_distances - matrix of pairwise knn distances\n     * @param {Float64Array} sig - scaling factor for the distances\n     * @param {Matrix} nbrs - nearest neighbors\n     * @returns {Matrix} pairwise similarity matrix\n     */\n    _find_p(knn_distances, sig, nbrs) {\n        const [N, n_neighbors] = knn_distances.shape;\n        return new Matrix(N, n_neighbors, (i, j) => {\n            return Math.exp(-(knn_distances.entry(i, j) ** 2 / sig[i] / sig[nbrs.entry(i, j)]));\n        });\n    }\n\n    /**\n     * Sample nearest neighbors triplets based on the similarity values given in P.\n     * @private\n     * @param {Matrix} P - Matrix of pairwise similarities between each point and its neighbors given in matrix nbrs.\n     * @param {Matrix} nbrs - Nearest neighbors indices for each point. The similarity values are given in matrix {@link P}. Row i corresponds to the i-th point.\n     * @param {Number} n_inliers - Number of inlier points.\n     * @param {Number} n_outliers - Number of outlier points.\n     *\n     */\n    _sample_knn_triplets(P, nbrs, n_inliers, n_outliers) {\n        const N = nbrs.shape[0];\n        const triplets = new Matrix(N * n_inliers * n_outliers, 3);\n        for (let i = 0; i < N; ++i) {\n            let n_i = i * n_inliers * n_outliers;\n            const sort_indices = this.__argsort(P.row(i));\n            for (let j = 0; j < n_inliers; ++j) {\n                let n_j = j * n_outliers;\n                const sim = nbrs.entry(i, sort_indices[j]);\n                const samples = this._rejection_sample(n_outliers, N, sort_indices.slice(0, j + 1));\n                for (let k = 0; k < n_outliers; ++k) {\n                    const index = n_i + n_j + k;\n                    const out = samples[k];\n                    triplets.set_entry(index, 0, i);\n                    triplets.set_entry(index, 1, sim);\n                    triplets.set_entry(index, 2, out);\n                }\n            }\n        }\n        return triplets;\n    }\n\n    /**\n     * Should do the same as np.argsort()\n     * @private\n     * @param {Array} A\n     */\n    __argsort(A) {\n        return linspace(0, A.length - 1).sort((i, j) => A[j] - A[i]);\n    }\n\n    /**\n     * Samples {@link n_samples} integers from a given interval [0, {@link max_int}] while rejection the values that are in the {@link rejects}.\n     * @private\n     * @param {*} n_samples\n     * @param {*} max_int\n     * @param {*} rejects\n     */\n    _rejection_sample(n_samples, max_int, rejects) {\n        const randomizer = this._randomizer;\n        const interval = linspace(0, max_int - 1).filter((d) => rejects.indexOf(d) < 0);\n        return randomizer.choice(interval, Math.min(n_samples, interval.length - 2));\n    }\n\n    /**\n     * Calculates the weights for the sampled nearest neighbors triplets\n     * @private\n     * @param {Matrix} triplets - Sampled Triplets.\n     * @param {Matrix} P - Pairwise similarity matrix.\n     * @param {Matrix} nbrs - nearest Neighbors\n     * @param {Float64Array} outlier_distances - Matrix of pairwise outlier distances\n     * @param {Float64Array} sig - scaling factor for the distances.\n     */\n    _find_weights(triplets, P, nbrs, outlier_distances, sig) {\n        const n_triplets = triplets.shape[0];\n        const weights = new Float64Array(n_triplets);\n        for (let t = 0; t < n_triplets; ++t) {\n            const i = triplets.entry(t, 0);\n            const sim = nbrs.row(i).indexOf(triplets.entry(t, 1));\n            const p_sim = P.entry(i, sim);\n            let p_out = Math.exp(-(outlier_distances[t] ** 2 / (sig[i] * sig[triplets.entry(t, 2)])));\n            if (p_out < 1e-20) p_out = 1e-20;\n            weights[t] = p_sim / p_out;\n        }\n        return weights;\n    }\n\n    /**\n     * Sample uniformly ranom triplets\n     * @private\n     * @param {Matrix} X - Data matrix.\n     * @param {Number} n_random - Number of random triplets per point\n     * @param {Float64Array} sig - Scaling factor for the distances\n     */\n    _sample_random_triplets(X, n_random, sig) {\n        const metric = this.parameter(\"metric\");\n        const randomizer = this._randomizer;\n        const N = X.shape[0];\n        const random_triplets = new Matrix(N * n_random, 3);\n        const random_weights = new Float64Array(N * n_random);\n        for (let i = 0; i < N; ++i) {\n            const n_i = i * n_random;\n            const indices = [...linspace(0, i - 1), ...linspace(i + 1, N - 1)];\n            for (let j = 0; j < n_random; ++j) {\n                let [sim, out] = randomizer.choice(indices, 2);\n                let p_sim = Math.exp(-(metric(X.row(i), X.row(sim)) ** 2 / (sig[i] * sig[sim])));\n                if (p_sim < 1e-20) p_sim = 1e-20;\n                let p_out = Math.exp(-(metric(X.row(i), X.row(out)) ** 2 / (sig[i] * sig[out])));\n                if (p_out < 1e-20) p_out = 1e-20;\n\n                if (p_sim < p_out) {\n                    [sim, out] = [out, sim];\n                    [p_sim, p_out] = [p_out, p_sim];\n                }\n                const index = n_i + j;\n                random_triplets.set_entry(index, 0, i);\n                random_triplets.set_entry(index, 1, sim);\n                random_triplets.set_entry(index, 2, out);\n                random_weights[index] = p_sim / p_out;\n            }\n        }\n        return {\n            random_triplets: random_triplets,\n            random_weights: random_weights,\n        };\n    }\n\n    /**\n     * Computes the gradient for updating the embedding.\n     * @param {Matrix} Y - The embedding\n     */\n    _grad(Y) {\n        const n_inliers = this.n_inliers;\n        const n_outliers = this.n_outliers;\n        const triplets = this.triplets;\n        const weights = this.weights;\n        const [N, dim] = Y.shape;\n        const n_triplets = triplets.shape[0];\n        const grad = new Matrix(N, dim, 0);\n        let y_ij = new Float64Array(dim);\n        let y_ik = new Float64Array(dim);\n        let d_ij = 1;\n        let d_ik = 1;\n        let n_viol = 0;\n        let loss = 0;\n        const n_knn_triplets = N * n_inliers * n_outliers;\n\n        for (let t = 0; t < n_triplets; ++t) {\n            const [i, j, k] = triplets.row(t);\n            // update y_ij, y_ik, d_ij, d_ik\n            if (t % n_outliers == 0 || t >= n_knn_triplets) {\n                d_ij = 1;\n                d_ik = 1;\n                for (let d = 0; d < dim; ++d) {\n                    const Y_id = Y.entry(i, d);\n                    const Y_jd = Y.entry(j, d);\n                    const Y_kd = Y.entry(k, d);\n                    y_ij[d] = Y_id - Y_jd;\n                    y_ik[d] = Y_id - Y_kd;\n                    d_ij += y_ij[d] ** 2;\n                    d_ik += y_ik[d] ** 2;\n                }\n                // update y_ik and d_ik only\n            } else {\n                d_ik = 1;\n                for (let d = 0; d < dim; ++d) {\n                    const Y_id = Y.entry(i, d);\n                    const Y_kd = Y.entry(k, d);\n                    y_ik[d] = Y_id - Y_kd;\n                    d_ik += y_ik[d] ** 2;\n                }\n            }\n\n            if (d_ij > d_ik) ++n_viol;\n            loss += weights[t] / (1 + d_ik / d_ij);\n            const w = (weights[t] / (d_ij + d_ik)) ** 2;\n            for (let d = 0; d < dim; ++d) {\n                const gs = y_ij[d] * d_ik * w;\n                const go = y_ik[d] * d_ij * w;\n                grad.add_entry(i, d, gs - go);\n                grad.sub_entry(j, d, gs);\n                grad.add_entry(k, d, go);\n            }\n        }\n        return { grad, loss, n_viol };\n    }\n\n    /**\n     *\n     * @param {Number} max_iteration\n     */\n    transform(max_iteration = 400) {\n        this.check_init();\n        for (let iter = 0; iter < max_iteration; ++iter) {\n            this._next(iter);\n        }\n        return this.projection;\n    }\n\n    /**\n     * @param {Number} max_iteration\n     * @yields {Matrix}\n     * @returns {Matrix}\n     */\n    *generator(max_iteration = 800) {\n        this.check_init();\n        for (let iter = 0; iter < max_iteration; ++iter) {\n            this._next(iter);\n            yield this.projection;\n        }\n        return this.projection;\n    }\n\n    /**\n     * Does the iteration step.\n     * @private\n     * @param {Number} iter\n     */\n    _next(iter) {\n        const gamma = iter > 150 ? 0.5 : 0.3;\n        const old_C = this.C;\n        const vel = this.vel;\n        const Y = this.Y.add(vel.mult(gamma));\n        const { grad, loss, n_viol } = this._grad(Y);\n        this.C = loss;\n        this.Y = this._update_embedding(Y, iter, grad);\n        this.lr *= old_C > loss + this._parameters.tol ? 1.01 : 0.9;\n        return this.Y;\n    }\n\n    /**\n     * Updates the embedding.\n     * @private\n     * @param {Matrix} Y\n     * @param {Number} iter\n     * @param {Matrix} grad\n     */\n    _update_embedding(Y, iter, grad) {\n        const [N, dim] = Y.shape;\n        const gamma = iter > 150 ? 0.9 : 0.5; // moment parameter\n        const min_gain = 0.01;\n        const gain = this.gain;\n        const vel = this.vel;\n        const lr = this.lr;\n        for (let i = 0; i < N; ++i) {\n            for (let d = 0; d < dim; ++d) {\n                const new_gain = Math.sign(vel.entry(i, d)) != Math.sign(grad.entry(i, d)) ? gain.entry(i, d) + 0.2 : Math.max(gain.entry(i, d) * 0.8, min_gain);\n                gain.set_entry(i, d, new_gain);\n                vel.set_entry(i, d, gamma * vel.entry(i, d) - lr * gain.entry(i, d) * grad.entry(i, d));\n                Y.set_entry(i, d, Y.entry(i, d) + vel.entry(i, d));\n            }\n        }\n        return Y;\n    }\n}\n","import { euclidean } from \"../metrics/index.js\";\nimport { Matrix } from \"../matrix/index.js\";\n/**\n * @class\n * @alias Hierarchical_Clustering\n */\nexport class Hierarchical_Clustering {\n    /**\n     * @constructor\n     * @memberof module:clustering\n     * @alias Hierarchical_Clustering\n     * @todo needs restructuring.\n     * @param {Matrix} - Data or distance matrix if metric is 'precomputed'\n     * @param {(\"single\"|\"complete\"|\"average\")} [linkage = \"complete\"]\n     * @param {Function|\"precomputed\"} [metric = euclidean]\n     * @returns {Hierarchical_Clustering}\n     */\n    constructor(matrix, linkage = \"complete\", metric = euclidean) {\n        this._id = 0;\n        this._matrix = matrix instanceof Matrix ? matrix : Matrix.from(matrix);\n        this._metric = metric;\n        this._linkage = linkage;\n        if (metric === \"precomputed\" && this._matrix.shape[0] !== this._matrix.shape[1]) {\n            throw new Error(\"If metric is 'precomputed', then matrix has to be square!\");\n        }\n        this.init();\n        this.root = this.do();\n        return this;\n    }\n\n    /**\n     *\n     * @param {Number} value - value where to cut the tree.\n     * @param {(\"distance\"|\"depth\")} [type = \"distance\"] - type of value.\n     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}.\n     */\n    get_clusters(value, type = \"distance\") {\n        let clusters = [];\n        let accessor;\n        switch (type) {\n            case \"distance\":\n                accessor = (d) => d.dist;\n                break;\n            case \"depth\":\n                accessor = (d) => d.depth;\n                break;\n            default:\n                throw new Error(\"invalid type\");\n        }\n        this._traverse(this.root, accessor, value, clusters);\n        return clusters;\n    }\n\n    /**\n     * @private\n     * @param {} node\n     * @param {*} f\n     * @param {*} value\n     * @param {*} result\n     */\n    _traverse(node, f, value, result) {\n        if (f(node) <= value) {\n            result.push(node.leaves());\n        } else {\n            this._traverse(node.left, f, value, result);\n            this._traverse(node.right, f, value, result);\n        }\n    }\n\n    /**\n     * computes the tree.\n     */\n    init() {\n        const metric = this._metric;\n        const A = this._matrix;\n        const n = (this._n = A.shape[0]);\n        const d_min = (this._d_min = new Float64Array(n));\n        let distance_matrix;\n        if (metric !== \"precomputed\") {\n            distance_matrix = new Matrix(n, n, 0); //new Array(n);\n            for (let i = 0; i < n; ++i) {\n                d_min[i] = 0;\n                //distance_matrix[i] = new Float64Array(n);\n                for (let j = 0; j < n; ++j) {\n                    distance_matrix.set_entry(i, j, i === j ? Infinity : metric(A.row(i), A.row(j)));\n                    if (distance_matrix.entry(i, d_min[i]) > distance_matrix.entry(i, j)) {\n                        d_min[i] = j;\n                    }\n                }\n            }\n        } else {\n            distance_matrix = this._matrix.clone();\n            for (let i = 0; i < n; ++i) {\n                for (let j = 0; j < n; ++j) {\n                    if (i === j) {\n                        distance_matrix.set_entry(i, j, Infinity);\n                    } else if (distance_matrix.entry(i, d_min[i]) > distance_matrix.entry(i, j)) {\n                        d_min[i] = j;\n                    }\n                }\n            }\n        }\n        this._distance_matrix = distance_matrix;\n        const clusters = (this._clusters = new Array(n));\n        const c_size = (this._c_size = new Uint16Array(n));\n        for (let i = 0; i < n; ++i) {\n            clusters[i] = [];\n            clusters[i][0] = new Cluster(this._id++, null, null, 0, A.row(i), i, 1, 0);\n            c_size[i] = 1;\n        }\n        return this;\n    }\n\n    /**\n     * computes the tree.\n     */\n    do() {\n        const n = this._n;\n        const d_min = this._d_min;\n        const D = this._distance_matrix;\n        const clusters = this._clusters;\n        const c_size = this._c_size;\n        const linkage = this._linkage;\n        let root = null;\n        for (let p = 0, p_max = n - 1; p < p_max; ++p) {\n            let c1 = 0;\n            for (let i = 0; i < n; ++i) {\n                let D_i_min = D.entry(i, d_min[i]);\n                for (let j = i + 1; j < n; ++j) {\n                    if (D_i_min > D.entry(i, j)) {\n                        d_min[i] = j;\n                        D_i_min = D.entry(i, d_min[i]);\n                    }\n                }\n            }\n            for (let i = 0; i < n; ++i) {\n                if (D.entry(i, d_min[i]) < D.entry(c1, d_min[c1])) {\n                    c1 = i;\n                }\n            }\n            let c2 = d_min[c1];\n            let c1_cluster = clusters[c1][0];\n            let c2_cluster = clusters[c2][0];\n            let c1_cluster_indices = c1_cluster.isLeaf ? [c1_cluster.index] : c1_cluster.index;\n            let c2_cluster_indices = c2_cluster.isLeaf ? [c2_cluster.index] : c2_cluster.index;\n            let indices = c1_cluster_indices.concat(c2_cluster_indices);\n            let new_cluster = new Cluster(this._id++, c1_cluster, c2_cluster, D.entry(c1, c2), null, indices);\n            c1_cluster.parent = new_cluster;\n            c2_cluster.parent = new_cluster;\n            clusters[c1].unshift(new_cluster);\n            c_size[c1] += c_size[c2];\n            for (let j = 0; j < n; ++j) {\n                const D_c1_j = D.entry(c1, j);\n                const D_c2_j = D.entry(c2, j);\n                let value;\n                switch (linkage) {\n                    case \"single\":\n                        value = Math.min(D_c1_j, D_c2_j);\n                        break;\n                    case \"complete\":\n                        value = Math.max(D_c1_j, D_c2_j);\n                        break;\n                    case \"average\":\n                        value = (c_size[c1] * D_c1_j + c_size[c2] * D_c2_j) / (c_size[c1] + c_size[j]);\n                        break;\n                }\n                D.set_entry(j, c1, value);\n                D.set_entry(c1, j, value);\n            }\n\n            D.set_entry(c1, c1, Infinity);\n            for (let i = 0; i < n; ++i) {\n                D.set_entry(i, c2, Infinity);\n                D.set_entry(c2, i, Infinity);\n            }\n\n            /* for (let j = 0; j < n; ++j) {\n                if (d_min[j] === c2) {\n                    d_min[j] = c1;\n                }\n                if (D.entry(c1, j) < D.entry(c1, d_min[c1])) {\n                    d_min[c1] = j;\n                }\n            } */\n            root = new_cluster;\n        }\n        return root;\n    }\n}\n\nclass Cluster {\n    constructor(id, left, right, dist, centroid, index, size, depth) {\n        this.id = id;\n        this.left = left;\n        this.right = right;\n        this.dist = dist;\n        this.index = index;\n        this.size = size ?? left.size + right.size;\n        this.depth = depth ?? 1 + Math.max(left.depth, right.depth);\n        this.centroid = centroid ?? this._calculate_centroid(left, right);\n        this.parent = null;\n        return this;\n    }\n\n    _calculate_centroid(left, right) {\n        const l_size = left.size;\n        const r_size = right.size;\n        const l_centroid = left.centroid;\n        const r_centroid = right.centroid;\n        const size = this.size;\n        const n = left.centroid.length;\n        const new_centroid = new Float64Array(n);\n        for (let i = 0; i < n; ++i) {\n            new_centroid[i] = (l_size * l_centroid[i] + r_size * r_centroid[i]) / size;\n        }\n        return new_centroid;\n    }\n\n    get isLeaf() {\n        return this.depth === 0;\n    }\n\n    leaves() {\n        if (this.isLeaf) return [this];\n        const left = this.left;\n        const right = this.right;\n        return (left.isLeaf ? [left] : left.leaves()).concat(right.isLeaf ? [right] : right.leaves());\n    }\n\n    descendants() {\n        if (this.isLeaf) return [this];\n        const left_descendants = this.left.descendants();\n        const right_descendants = this.right.descendants();\n        return left_descendants.concat(right_descendants).concat([this]);\n    }\n}\n","import { euclidean } from \"../metrics/index.js\";\nimport { Randomizer } from \"../util/index.js\";\nimport { Heap } from \"../datastructure/index.js\";\nimport { linspace } from \"../matrix/index.js\";\n\n/**\n * @class\n * @alias KMeans\n */\nexport class KMeans {\n    /**\n     * @constructor\n     * @memberof module:clustering\n     * @alias KMeans\n     * @todo needs restructuring. \n     * @param {Matrix} matrix \n     * @param {Numbers} K \n     * @param {Function} [metric = euclidean] \n     * @param {Number} [seed = 1987]\n     * @param {Boolean} [init = true]\n     * @returns {KMeans}\n     */\n    constructor(matrix, K, metric = euclidean, seed=1987, init = true) {\n        this._metric = metric;\n        this._matrix = matrix;\n        this._K = K;\n        const [N, D] = matrix.shape;\n        this._N = N;\n        this._D = D;\n        if (K > N) K = N;\n        this._randomizer = new Randomizer(seed);\n        this._clusters = new Array(N).fill(undefined);\n        this._cluster_centroids = this._get_random_centroids(K);\n        if (init) this.init(K, this._cluster_centroids);\n        return this;\n    }\n\n    /**\n     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. \n     */\n    get_clusters() {\n        const K = this._K;\n        const clusters = this._clusters;\n        const result = new Array(K).fill().map(() => new Array());\n        clusters.forEach((c, i) => result[c].push(i));\n        return result;\n    }\n\n    /**\n     * @private\n     * @param {Array} points \n     * @param {Array} candidates \n     */\n    _furthest_point(points, candidates) {\n        const A = this._matrix;\n        const metric = this._metric;\n        let i = points.length;\n        let H = Heap.heapify(\n            candidates, \n            (d) => {\n                const Ad = A.row(d)\n                let sum = 0;\n                for (let j = 0; j < i; ++j) {\n                    sum += metric(Ad, points[j])\n                }\n                return sum;\n            }, \n            \"max\"\n        )\n        return H.pop().element;\n    }\n\n    _get_random_centroids(K) {\n        const N = this._N;\n        const randomizer = this._randomizer;\n        const A = this._matrix;\n        const cluster_centroids = new Array(K).fill()\n        const indices = linspace(0, N - 1);\n        const random_point = randomizer.random_int % (N - 1);\n        cluster_centroids[0] = A.row(random_point);\n        const init_points = [random_point];\n        const sample_size = Math.floor((N - K) / K);// / K\n        for (let i = 1; i < K; ++i) {\n            // sampling + kmeans++ improvement?\n            const sample = randomizer.choice(indices.filter(d => init_points.indexOf(d) == -1), sample_size);\n            const furthest_point = this._furthest_point(cluster_centroids.slice(0, i), sample);\n            init_points.push(furthest_point);\n            cluster_centroids[i] = A.row(furthest_point);\n        }\n        return cluster_centroids;\n    }\n\n    _iteration(cluster_centroids) {\n        const K = cluster_centroids.length;\n        const N = this._N;\n        const D = this._D;\n        const A = this._matrix;\n        const metric = this._metric;\n        const clusters = this._clusters;\n        let clusters_changed = false;\n        // find nearest cluster centroid.\n        for (let i = 0; i < N; ++i) {\n            const Ai = A.row(i)\n            let min_dist = Infinity;\n            let min_cluster = null;\n            for (let j = 0; j < K; ++j) {\n                let d = metric(cluster_centroids[j], Ai);\n                if (d < min_dist) {\n                    min_dist = d;\n                    min_cluster = j; \n                }\n            }\n            if (clusters[i] !== min_cluster) {\n                clusters_changed = true;\n            }\n            clusters[i] = min_cluster;\n        }\n        // update cluster centroid\n        // reset cluster centroids to 0\n        for (let i = 0; i < K; ++i) {\n            const centroid = cluster_centroids[i];\n            for (let j = 0; j < D; ++j) {\n                centroid[j] = 0;\n            }\n        }\n        // compute centroid\n        this._compute_centroid(cluster_centroids);\n\n        return {   \n            \"clusters_changed\": clusters_changed,\n            \"cluster_centroids\": cluster_centroids\n        };\n    }\n\n    _compute_centroid(cluster_centroids) {\n        const K = cluster_centroids.length;\n        const N = this._N;\n        const D = this._D;\n        const A = this._matrix;\n        const clusters = this._clusters;\n        const cluster_counter = new Array(K).fill(0);\n\n        for (let i = 0; i < N; ++i) {\n            const Ai = A.row(i);\n            const ci = clusters[i];\n            cluster_counter[ci]++;\n            const centroid = cluster_centroids[ci];\n            for (let j = 0; j < D; ++j) {\n                centroid[j] += Ai[j];\n            }\n        }\n        for (let i = 0; i < K; ++i) {\n            const n = cluster_counter[i];\n            cluster_centroids[i] = cluster_centroids[i].map(c => c / n);\n        }\n        \n    }\n\n    /**\n     * Computes {@link K} clusters out of the {@link matrix}.\n     * @param {Number} K - number of clusters.\n     */\n    init(K, cluster_centroids) {\n        if (!K) K = this._K;\n        if (!cluster_centroids) cluster_centroids = this._get_random_centroids(K);\n        let clusters_changed = false;\n        do {\n            const iteration_result = this._iteration(cluster_centroids)\n            cluster_centroids = iteration_result.cluster_centroids;\n            clusters_changed = iteration_result.clusters_changed;\n        } while (clusters_changed)\n    }\n    \n}\n","import { euclidean } from \"../metrics/index.js\";\nimport { Randomizer } from \"../util/index.js\";\nimport { linspace, Matrix } from \"../matrix/index.js\";\nimport { min } from \"../util/index.js\";\n/**\n * @class\n * @alias KMedoids\n */\nexport class KMedoids {\n    /**\n     * @constructor\n     * @memberof module:clustering\n     * @alias KMedoids\n     * @todo needs restructuring. \n     * @param {Matrix} matrix - data matrix\n     * @param {Numbers} K - number of clusters\n     * @param {number} [max_iter=null] - maximum number of iterations. Default is 10 * Math.log10(N)\n     * @param {Function} [metric = euclidean] - metric defining the dissimilarity \n     * @param {Number} [seed = 1212] - seed value for random number generator\n     * @returns {KMedoids}\n     * @see {@link https://link.springer.com/chapter/10.1007/978-3-030-32047-8_16} Faster k-Medoids Clustering: Improving the PAM, CLARA, and CLARANS Algorithms\n     */\n    constructor(matrix, K, max_iter=null, metric = euclidean, seed=1212) {\n        this._metric = metric;\n        this._matrix = matrix;\n        this._A = this._matrix.to2dArray;\n        this._K = K;\n        const [N, D] = matrix.shape;\n        this._N = N;\n        this._D = D;\n        this._max_iter = max_iter || 10 * Math.log10(N) \n        this._distance_matrix = new Matrix(N, N, \"zeros\");\n        /* for (let i = 1; i < N; ++i) {\n            for (let j = i + 1; j < N; ++j) {\n                let dist = metric(this._A[i], this._A[j]);\n                this._distance_matrix.set_entry(i, j, dist);\n                this._distance_matrix.set_entry(j, i, dist)\n            }\n        } */\n        if (K > N) K = N;\n        this._randomizer = new Randomizer(seed);\n        this._clusters = new Array(N).fill(undefined);\n        this._cluster_medoids = this._get_random_medoids(K);\n        //if (init) this.init(K, this._cluster_medoids);\n        this._is_initialized = false;\n        return this;\n    }\n\n    /**\n     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. \n     */\n    get_clusters() {\n        const K = this._K;\n        const A = this._A;\n        if (!this._is_initialized) {\n            this.init(K, this._cluster_medoids);\n        }\n        const result = new Array(K).fill().map(() => new Array());\n        A.forEach((x_j, j) => {\n            result[this._nearest_medoid(x_j, j).index_nearest].push(j);\n        })\n        result.medoids = this._cluster_medoids;\n        return result;\n    }\n\n    async* generator() {\n        const max_iter = this._max_iter;\n        yield this.get_clusters()\n        let finish = false;\n        let i = 0\n        do {\n            finish = this._iteration();\n            yield this.get_clusters();\n        } while (!finish && ++i < max_iter)\n    }\n\n    /**\n     * Algorithm 1. FastPAM1: Improved SWAP algorithm\n     */\n    /* _iteration_1() {\n        const A = this._A;\n        const N = this._N;\n        const K = this._K;\n        const medoids = this._cluster_medoids;\n        let DeltaTD = 0;\n        let m0 = null;\n        let x0 = null;\n        A.forEach((x_j, j) => {\n            if (medoids.findIndex(m => m === j) < 0) {\n                const nearest_medoid = this._nearest_medoid(x_j, j);\n                const d_j = nearest_medoid.distance_nearest; // distance to current medoid\n                const deltaTD = new Array(K).fill(-d_j); // change if making j a medoid\n                A.forEach((x_o, o) => {\n                    // disance to new medoid\n                    const d_oj = this._get_distance(o, j, x_o, x_j);\n                    const {\n                        \"index_nearest\": n,\n                        \"distance_nearest\": d_n,\n                        \"distance_second\": d_s,\n                    } = this._nearest_medoid(x_o, o); \n                    this._clusters[o] = n; // cached values\n                    deltaTD[n] += Math.min(d_oj, d_s) - d_n; // loss change\n                    if (d_oj < d_n) { // reassignment check\n                        deltaTD.forEach((d_i, i) => {\n                            if (n !== i) {\n                                deltaTD[i] = d_i + d_oj - d_n; // update loss change\n                            }\n                        });\n                    }\n                });\n                // choose best medoid i;\n                const i = deltaTD\n                    .map((d, i) => [d, i])\n                    .sort((d1, d2) => d1[0] - d2[0])[0][1];\n                const deltaTD_i = deltaTD[i];\n                // store\n                if (deltaTD_i < DeltaTD) {\n                    DeltaTD = deltaTD_i;\n                    m0 = i;\n                    x0 = j;\n                }\n            }\n        });\n\n        if (DeltaTD >= 0) {\n            return true // break loop if DeltaTD >= 0\n        }\n        // swap roles of medoid m and non-medoid x;\n        medoids[m0] = x0;\n        this._cluster_medoids = medoids;\n        return false\n    } */\n\n    /** Algorithm 2. FastPAM2: SWAP with multiple candidates\n     * \n     */\n    _iteration() {\n        const A = this._A;\n        const K = this._K;\n        const medoids = this._cluster_medoids;\n        const cache = A.map((x_o, o) => this._nearest_medoid(x_o, o));\n        // empty best candidates array\n        const DeltaTD = new Array(K).fill(0);\n        const xs = new Array(K).fill(null);\n        A.forEach((x_j, j) => {\n            if (medoids.findIndex(m => m === j) < 0) {\n                const d_j = cache[j].distance_nearest; // distance to current medoid\n                const deltaTD = new Array(K).fill(-d_j); // change if making j a medoid\n                A.forEach((x_o, o) => {\n                    if (j === o) return;\n                    const d_oj = this._get_distance(o, j, x_o, x_j); // distance to new medoid\n                    const {\"index_nearest\": n, \"distance_nearest\": d_n, \"distance_second\": d_s} = cache[o]; // cached\n                    deltaTD[n] += Math.min(d_oj, d_s) - d_n; // loss change for x_o\n                    // Reassignment check\n                    if (d_oj < d_n) { \n                        // update loss change\n                        for (let i = 0; i < K; ++i) {\n                            if (i !== n) deltaTD[i] += d_oj - d_n;\n                        }\n                    }\n                });\n                // remember best swap for i;\n                deltaTD\n                    .map((d, i) => [d, i])\n                    .filter(([d, i]) => d < DeltaTD[i])\n                    .forEach(([d, i]) => {\n                        if (d < DeltaTD[i]) {\n                            DeltaTD[i] = d;\n                            xs[i] = j;\n                        }\n                    })\n            }\n        })\n        // stop if no improvements were found\n        if (min(DeltaTD) >= 0) return true; \n\n        // execute all improvements\n        while (min(DeltaTD) < 0) {\n            // swap roles of medoid m_i and non_medoid xs_i\n            const i = DeltaTD\n                .map((d, i) => [d, i])\n                .sort(([a], [b]) => a - b)[0][1];\n            if (medoids.filter(m => m == xs[i]).length == 0) {\n                medoids[i] = xs[i];\n            }\n            // disable the swap just performed\n            DeltaTD[i] = 0; \n            // recompute TD for remaining swap candidates\n            DeltaTD\n                .map((d_j, j) => [d_j, j])\n                .filter(([d_j]) => d_j < 0)\n                .forEach(([_, j]) => {\n                    const x_j = A[j];\n                    let sum = 0;\n                    A.forEach((x_o, o) => {\n                        if (medoids.findIndex(m => m != j && m == o) >= 0) return;\n                        if (i == j) return;\n                        if (cache[o].index_nearest === medoids[j])\n                            sum += (Math.min(this._get_distance(o, j, x_o, x_j), cache[o].distance_second) - cache[o].distance_nearest); \n                        else {\n                            sum += (Math.min(this._get_distance(o, j, x_o, x_j) - cache[o].distance_nearest, 0));\n                        }\n                    });\n                    DeltaTD[j] = sum;\n                })\n        }\n        this._cluster_medoids = medoids;\n        return false;\n    }\n\n    _get_distance(i, j, x_i=null, x_j=null) {\n        if (i === j) return 0;\n        const D = this._distance_matrix;\n        const A = this._A;\n        const metric = this._metric;\n        let d_ij = D.entry(i, j);\n        if (d_ij === 0) {\n            d_ij = metric(x_i || A[i], x_j || A[j]);\n            D.set_entry(i, j, d_ij);\n            D.set_entry(j, i, d_ij);\n        }\n        return d_ij;\n    }\n\n    _nearest_medoid(x_j, j) {\n        const medoids = this._cluster_medoids;\n        const A = this._A;\n        const [nearest, second] = medoids\n            .map((m, i) => {\n                const x_m = A[m]; \n                return [this._get_distance(j, m, x_j, x_m), i];\n            })\n            .sort((m1, m2) => m1[0] - m2[0]);\n        \n        return { \n            \"distance_nearest\": nearest[0], \n            \"index_nearest\": nearest[1],\n            \"distance_second\": second[0],\n            \"index_second\": second[1],\n        };\n    }\n\n    /**\n     * Computes {@link K} clusters out of the {@link matrix}.\n     * @param {Number} K - number of clusters.\n     */\n    init(K, cluster_medoids) {\n        if (!K) K = this._K;\n        if (!cluster_medoids) cluster_medoids = this._get_random_medoids(K);\n        const max_iter = this._max_iter;\n        let finish = false;\n        let i = 0\n        do {\n            finish = this._iteration();\n        } while (!finish && ++i < max_iter)\n        return this;\n    }\n\n    /**\n     * Algorithm 3. FastPAM LAB: Linear Approximate BUILD initialization.\n     * @param {number} K - number of clusters\n     * \n     */\n    _get_random_medoids(K) {\n        const N = this._N;\n        const A = this._A;\n        const indices = linspace(0, N - 1);\n        const randomizer = this._randomizer;\n        const n = Math.min(N, 10 + Math.ceil(Math.sqrt(N)));\n        const TD = new Array(n).fill(Infinity);\n        const medoids = [];\n        // first medoid\n        let TD0 = Infinity;\n        let S = randomizer.choice(indices, n);\n        for (let j = 0; j < n; ++j) {\n            const S_j = S[j];\n            const x_j = A[S_j];\n            for (let o = 0; o < n; ++o) {\n                if (o === j) continue;\n                const x_o = A[S[o]];\n                TD[j] += this._get_distance(j, o, x_j, x_o);\n            }\n            if (TD[j] < TD0) {\n                TD0 = TD[j]; // smallest distance sum\n                medoids.push(S_j);\n            }\n        }\n        // other medoids\n        for (let i = 1; i < K; ++i) {\n            let DeltaTD = Infinity;\n            S = randomizer.choice(indices.filter(index => medoids.findIndex(d => d === index) < 0), n);\n            for (let j = 0; j < n; ++j) {\n                let deltaTD = 0;\n                const S_j = S[j];\n                const x_j = A[S_j];\n                for (let o = 0; o < n; ++o) {\n                    if (o === j) continue;\n                    const S_o = S[o];\n                    const x_o = A[S_o];\n                    let delta = this._get_distance(S_j, S_o, x_j, x_o) - min(medoids.map(m => this._get_distance(S_o, m, x_o)));\n                    if (delta < 0) {\n                        deltaTD = deltaTD + delta;\n                    }\n                }\n                // best reduction\n                if (deltaTD < DeltaTD) {\n                    DeltaTD = deltaTD;\n                    medoids.push(S_j);\n                }\n            }\n            TD0 += DeltaTD;\n        }\n        return medoids.slice(0, K);\n    }\n    \n}\n","import { euclidean } from \"../metrics/index.js\";\nimport { Heap } from \"../datastructure/index.js\";\n\n/**\n * @class\n * @alias OPTICS\n */\nexport class OPTICS {\n    /**\n     * **O**rdering **P**oints **T**o **I**dentify the **C**lustering **S**tructure.\n     * @constructor\n     * @memberof module:clustering\n     * @alias OPTICS\n     * @todo needs restructuring. \n     * @param {Matrix} matrix - the data.\n     * @param {Number} epsilon - the minimum distance which defines whether a point is a neighbor or not.\n     * @param {Number} min_points - the minimum number of points which a point needs to create a cluster. (Should be higher than 1, else each point creates a cluster.)\n     * @param {Function} [metric = euclidean] - the distance metric which defines the distance between two points of the {@link matrix}.\n     * @returns {OPTICS}\n     * @see {@link https://www.dbs.ifi.lmu.de/Publikationen/Papers/OPTICS.pdf}\n     * @see {@link https://en.wikipedia.org/wiki/OPTICS_algorithm}\n     */\n    constructor(matrix, epsilon, min_points, metric = euclidean) {\n        this._matrix = matrix;\n        this._epsilon = epsilon;\n        this._min_points = min_points;\n        this._metric = metric;\n\n        this._ordered_list = [];\n        this._clusters = [];\n        this._DB = new Array(matrix.shape[0]).fill();\n        this.init();\n        return this;\n    }\n\n    /**\n     * Computes the clustering.\n     */\n    init() {\n        const ordered_list = this._ordered_list;\n        const matrix = this._matrix;\n        const N = matrix.shape[0];\n        const DB = this._DB;\n        const clusters = this._clusters;\n        let cluster_index = this._cluster_index = 0;\n\n        for (let i = 0; i < N; ++i) {\n            DB[i] = {\n                \"element\": matrix.row(i),\n                \"index\": i,\n                \"reachability_distance\": undefined,\n                \"processed\": false,\n            }\n        }\n        for (const p of DB) {\n            if (p.processed) continue;\n            p.neighbors = this._get_neighbors(p);\n            p.processed = true;\n            clusters.push([p.index])\n            cluster_index = clusters.length - 1;\n            ordered_list.push(p);\n            if (this._core_distance(p) != undefined) {\n                const seeds = new Heap(null, d => d.reachability_distance, \"min\")\n                this._update(p, seeds);\n                this._expand_cluster(seeds, clusters[cluster_index]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * \n     * @private\n     * @param {Object} p - a point of {@link matrix}.\n     * @returns {Array} An array consisting of the {@link epsilon}-neighborhood of {@link p}.\n     */\n    _get_neighbors(p) {\n        if (\"neighbors\" in p) return p.neighbors;\n        const DB = this._DB;\n        const metric = this._metric;\n        const epsilon = this._epsilon;\n        const neighbors = [];\n        for (const q of DB) {\n            if (q.index == p.index) continue;\n            if (metric(p.element, q.element) < epsilon) {\n                neighbors.push(q);\n            }\n        }\n        return neighbors;\n    }\n\n    /**\n     * \n     * @private\n     * @param {Object} p - a point of {@link matrix}.\n     * @returns {Number} The distance to the {@link min_points}-th nearest point of {@link p}, or undefined if the {@link epsilon}-neighborhood has fewer elements than {@link min_points}.\n     */\n    _core_distance(p) {\n        const min_points = this._min_points;\n        const metric = this._metric;\n        if (p.neighbors && p.neighbors.length <= min_points) {\n            return undefined;\n        }\n        return metric(p.element, p.neighbors[min_points].element);\n    }\n\n    /**\n     * Updates the reachability distance of the points.\n     * @private\n     * @param {Object} p \n     * @param {Heap} seeds \n     */\n    _update(p, seeds) {\n        const metric = this._metric;\n        const core_distance = this._core_distance(p);\n        const neighbors = this._get_neighbors(p);//p.neighbors;\n        for (const q of neighbors) {\n            if (q.processed) continue;\n            const new_reachability_distance = Math.max(core_distance, metric(p.element, q.element));\n            //if (q.reachability_distance == undefined) { // q is not in seeds\n            if (seeds.raw_data().findIndex(d => d.element == q) < 0) {\n                q.reachability_distance = new_reachability_distance;\n                seeds.push(q);\n            } else { // q is in seeds\n                if (new_reachability_distance < q.reachability_distance) {\n                    q.reachability_distance = new_reachability_distance;\n                    seeds = Heap.heapify(seeds.data(), d => d.reachability_distance, \"min\"); // seeds change key =/\n                }\n            }\n        }\n    }\n\n    /**\n     * Expands the {@link cluster} with points in {@link seeds}.\n     * @private\n     * @param {Heap} seeds \n     * @param {Array} cluster \n     */\n    _expand_cluster(seeds, cluster) {\n        const ordered_list = this._ordered_list;\n        while (!seeds.empty) {\n            const q = seeds.pop().element;\n            q.neighbors = this._get_neighbors(q);\n            q.processed = true;\n            cluster.push(q.index);\n            ordered_list.push(q);\n            if (this._core_distance(q) != undefined) {\n                this._update(q, seeds);\n                this._expand_cluster(seeds, cluster);\n            }\n        }\n    }\n\n    /**\n     * Returns an array of clusters.\n     * @returns {Array<Array>} Array of clusters with the indices of the rows in given {@link matrix}.\n     */\n    get_clusters() {\n        const clusters = [];\n        const outliers = [];\n        const min_points = this._min_points;\n        for (const cluster of this._clusters) {\n            if (cluster.length < min_points) {\n                outliers.push(...cluster);\n            } else {\n                clusters.push(cluster);\n            }\n        }\n        clusters.push(outliers);\n        return clusters;\n    }\n\n    /**\n     * @returns {Array} Returns an array, where the ith entry defines the cluster affirmation of the ith point of {@link matrix}. (-1 stands for outlier)\n     */\n    get_cluster_affirmation() {\n        const N = this._matrix.shape[0];\n        const result = new Array(N).fill();\n        const clusters = this.get_clusters();\n        for (let i = 0, n = clusters.length; i < n; ++i) {\n            const cluster = clusters[i]\n            for (const index of cluster) {\n                result[index] = (i < n - 1) ? i : -1;\n            }\n        }\n        return result;\n    }\n}\n","import { Matrix } from \"../matrix/index.js\";\nimport { DR } from \"./DR.js\";\nimport { MDS } from \"./MDS.js\";\nimport { KMedoids } from \"../clustering/index.js\";\nimport { euclidean } from \"../metrics/index.js\";\nimport { BallTree } from \"../knn/index.js\";\n/**\n * @class\n * @alias LSP\n * @extends DR\n */\nexport class LSP extends DR {\n    /**\n     * Least Squares Projection.\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias LSP\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Number} [parameters.neighbors = Math.max(Math.floor(N / 10), 2)] - number of neighbors to consider.\n     * @param {Number} [parameters.control_points = Math.ceil(Math.sqrt(N))] - number of controlpoints\n     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.\n     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.\n     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.\n     * @returns {LSP}\n     * @see {@link https://ieeexplore.ieee.org/document/4378370}\n     * @todo accept precomputed distance matrix.\n     */\n    constructor(X, parameters) {\n        super(X, { neighbors: undefined, control_points: undefined, d: 2, metric: euclidean, seed: 1212 }, parameters);\n        this.parameter(\"neighbors\", Math.min(parameters.neighbors ?? Math.max(Math.floor(this._N / 10), 2), this._N - 1));\n        this.parameter(\"control_points\", Math.min(parameters.control_points ?? Math.ceil(Math.sqrt(this._N)), this._N - 1));\n        this._is_initialized = false;\n        return this;\n    }\n\n    /**\n     *\n     * @param {DR} DR - method used for position control points.\n     * @param {Object} DR_parameters - Object containing parameters for the DR method which projects the control points\n     * @returns {LSP}\n     */\n    init(DR = MDS, DR_parameters = {}, KNN = BallTree) {\n        if (this._is_initialized) return this;\n        const X = this.X;\n        const N = this._N;\n        const K = this.parameter(\"neighbors\");\n        const d = this.parameter(\"d\");\n        const seed = this.parameter(\"seed\");\n        const metric = this.parameter(\"metric\");\n        DR_parameters = Object.assign({d, metric, seed }, DR_parameters);\n        const nc = this.parameter(\"control_points\");\n        const control_points = new KMedoids(X, nc, null, metric).get_clusters().medoids;\n        const C = new Matrix(nc, N, \"zeros\");\n        control_points.forEach((c_i, i) => {\n            C.set_entry(i, c_i, 1);\n        });\n        const Y_C = new DR(Matrix.from(control_points.map((c_i) => X.row(c_i))), DR_parameters).transform();\n\n        const XA = X.to2dArray;\n        const knn = new KNN(XA, metric);\n        const L = new Matrix(N, N, \"I\");\n        const alpha = -1 / K;\n        XA.forEach((x_i, i) => {\n            for (const { index: j } of knn.search(x_i, K).iterate()) {\n                if (i === j) continue;\n                L.set_entry(i, j, alpha);\n            }\n        });\n        const A = L.concat(C, \"vertical\");\n\n        const z = new Matrix(N, d, \"zeros\");\n        const b = z.concat(Y_C, \"vertical\");\n\n        this._A = A;\n        this._b = b;\n        this._is_initialized = true;\n        return this;\n    }\n\n    /**\n     * Computes the projection.\n     * @returns {Matrix} Returns the projection.\n     */\n    transform() {\n        this.check_init();\n        const A = this._A;\n        const b = this._b;\n        const ATA = A.transDot(A);\n        const ATb = A.transDot(b);\n        this.Y = Matrix.solve_CG(ATA, ATb, this._randomizer);\n        return this.projection;\n    }\n}\n","import { Matrix } from \"../matrix/index.js\";\nimport { euclidean } from \"../metrics/index.js\";\nimport { DR } from \"./DR.js\";\nimport { DisjointSet } from \"../datastructure/index.js\";\n\n/**\n * @class\n * @alias TopoMap\n * @memberof module:dimensionality_reduction\n * @extends DR\n */\nexport class TopoMap extends DR {\n    /**\n     * TopoMap: A 0-dimensional Homology Preserving Projection of High-Dimensional Data.\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias TopoMap\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.\n     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.\n     * @returns {TopoMap}\n     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}\n     */\n    constructor(X, parameters) {\n        super(X, { metric: euclidean, seed: 1212 }, parameters);\n        [this._N, this._D] = this.X.shape;\n        this._distance_matrix = new Matrix(this._N, this._N, 0);\n        return this;\n    }\n\n    /**\n     * @private\n     */\n    __lazy_distance_matrix(i, j, metric) {\n        const D = this._distance_matrix;\n        const X = this.X;\n        const D_ij = D.entry(i, j);\n        if (D_ij === 0) {\n            let dist = metric(X.row(i), X.row(j));\n            D.set_entry(i, j, dist);\n            D.set_entry(j, i, dist);\n            return dist;\n        }\n        return D_ij;\n    }\n\n    /**\n     * Computes the minimum spanning tree, using a given metric\n     * @private\n     * @param {Function} metric\n     * @see {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}\n     */\n    _make_minimum_spanning_tree(metric = euclidean) {\n        const N = this._N;\n        const X = [...this.X];\n\n        let disjoint_set = new DisjointSet(X);\n        const F = [];\n        let E = [];\n        for (let i = 0; i < N; ++i) {\n            for (let j = i + 1; j < N; ++j) {\n                E.push([i, j, this.__lazy_distance_matrix(i, j, metric)]);\n            }\n        }\n        E = E.sort((a, b) => a[2] - b[2]);\n\n        for (const [u, v, w] of E) {\n            const set_u = disjoint_set.find(X[u]);\n            const set_v = disjoint_set.find(X[v]);\n            if (set_u !== set_v) {\n                F.push([u, v, w]);\n                disjoint_set.union(set_u, set_v);\n            }\n        }\n\n        return F.sort((a, b) => a[2] - b[2]);\n    }\n\n    /**\n     * initializes TopoMap. Sets all projcted points to zero, and computes a minimum spanning tree.\n     */\n    init() {\n        const { metric} = this._parameters\n        this.Y = new Matrix(this._N, 2, 0);\n        this._Emst = this._make_minimum_spanning_tree(metric);\n        this._is_initialized = true;\n        return this;\n    }\n\n    /**\n     * Returns true if Point C is left of line AB.\n     * @private\n     * @param {Array} PointA - Point A of line AB\n     * @param {Array} PointB - Point B of line AB\n     * @param {Array} PointC - Point C\n     * @returns {Boolean}\n     */\n    __hull_cross([ax, ay], [bx, by], [sx, sy]) {\n        return (bx - ax) * (sy - ay) - (by - ay) * (sx - ax) <= 0;\n    }\n\n    /**\n     * Computes the convex hull of the set of Points S\n     * @private\n     * @param {Array} S - Set of Points.\n     * @see {@link https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript}\n     * @returns {Array} convex hull of S. Starts at the bottom-most point and continues counter-clockwise.\n     */\n    __hull(S) {\n        const points = S.sort(([x1, y1], [x2, y2]) => y1 - y2 || x1 - x2);\n        const N = points.length;\n        if (N <= 2) return points;\n\n        const lower = [];\n        for (let i = 0; i < N; ++i) {\n            while (lower.length >= 2 && this.__hull_cross(lower[lower.length - 2], lower[lower.length - 1], points[i])) {\n                lower.pop();\n            }\n            lower.push(points[i]);\n        }\n        const upper = [];\n        for (let i = N - 1; i >= 0; --i) {\n            while (upper.length >= 2 && this.__hull_cross(upper[upper.length - 2], upper[upper.length - 1], points[i])) {\n                upper.pop();\n            }\n            upper.push(points[i]);\n        }\n        upper.pop();\n        lower.pop();\n        return lower.concat(upper);\n    }\n\n    /**\n     * Finds the angle to rotate Point A and B to lie on a line parallel to the x-axis.\n     * @private\n     * @param {Array} PointA\n     * @param {Array} PointB\n     * @return {Object} Object containing the sinus- and cosinus-values for a rotation.\n     */\n    __findAngle([p1x, p1y], [p2x, p2y]) {\n        const n = euclidean([p1x, p1y], [p2x, p2y]);\n        if (n === 0)\n            return {\n                sin: 0,\n                cos: 1,\n            };\n        const vec = [(p2x - p1x) / n, (p2y - p1y) / n];\n        const cos = vec[0];\n        let sin = Math.sqrt(1 - cos * cos);\n        sin = vec[1] >= 0 ? -sin : sin;\n        return {\n            sin: sin,\n            cos: cos,\n        };\n    }\n\n    /**\n     * @private\n     * @param {Array} hull\n     * @param {Array} p\n     * @param {Bool} topEdge\n     */\n    __align_hull(hull, p, topEdge) {\n        let v = -1;\n        let d2;\n        for (let i = 0; i < hull.length; ++i) {\n            const d = euclidean(hull[i], p);\n            if (v === -1) {\n                d2 = d;\n                v = i;\n            } else {\n                if (d2 > d) {\n                    d2 = d;\n                    v = i;\n                }\n            }\n        }\n\n        let v1;\n        let v2;\n        if (topEdge) {\n            v1 = hull[v];\n            v2 = hull[(v + 1) % hull.length];\n        } else {\n            if (v == 0) v = hull.length - 1;\n            v1 = hull[v];\n            v2 = hull[(v - 1) % hull.length];\n        }\n\n        const transformation = {\n            tx: -hull[v][0],\n            ty: -hull[v][1],\n        };\n\n        if (hull.length >= 2) {\n            const { sin, cos } = this.__findAngle(v1, v2);\n            transformation.sin = sin;\n            transformation.cos = cos;\n        } else {\n            transformation.sin = 0;\n            transformation.cos = 1;\n        }\n\n        return transformation;\n    }\n\n    /**\n     * @private\n     * @param {Array} Point - The point which should get transformed.\n     * @param {Object} Transformation - contains the values for translation and rotation.\n     */\n    __transform([px, py], { tx, ty, sin, cos }) {\n        let x = px + tx;\n        let y = py + ty;\n        let xx = x * cos - y * sin;\n        let yy = x * sin + y * cos;\n        return [xx, yy];\n    }\n\n    /**\n     * Calls {@link __transform} for each point in Set C\n     * @private\n     * @param {Array} C - Set of points.\n     * @param {Object} t - Transform object.\n     * @param {Number} yOffset - value to offset set C.\n     */\n    __transform_component(C, t, yOffset) {\n        const N = C.length;\n        for (let i = 0; i < N; ++i) {\n            const c = C[i];\n            const [cx, cy] = this.__transform(c, t);\n            c[0] = cx;\n            c[1] = cy + yOffset;\n        }\n    }\n\n    /**\n     * @private\n     * @param {Array} u - point u\n     * @param {Array} v - point v\n     * @param {Number} w - edge weight w\n     */\n    __align_components(u, v, w) {\n        const points_u = [...u.__disjoint_set.children];\n        const points_v = [...v.__disjoint_set.children];\n\n        const hull_u = this.__hull(points_u);\n        const hull_v = this.__hull(points_v);\n\n        const t_u = this.__align_hull(hull_u, u, false);\n        const t_v = this.__align_hull(hull_v, v, true);\n\n        this.__transform_component(points_u, t_u, 0);\n        this.__transform_component(points_v, t_v, w);\n    }\n\n    /**\n     * Transforms the inputdata {@link X} to dimensionality 2.\n     */\n    transform() {\n        if (!this._is_initialized) this.init();\n        const Emst = this._Emst;\n        const Y = this.Y.to2dArray;\n        const components = new DisjointSet(\n            Y.map((y, i) => {\n                y.i = i;\n                return y;\n            })\n        );\n\n        for (const [u, v, w] of Emst) {\n            const component_u = components.find(Y[u]);\n            const component_v = components.find(Y[v]);\n            if (component_u === component_v) continue;\n            this.__align_components(component_u, component_v, w);\n            components.union(component_u, component_v);\n        }\n        return this.projection;\n    }\n\n    *generator() {\n        if (!this._is_initialized) this.init();\n        const Emst = this._Emst;\n        const Y = this.Y.to2dArray;\n        const components = new DisjointSet(\n            Y.map((y, i) => {\n                y.i = i;\n                return y;\n            })\n        );\n\n        for (const [u, v, w] of Emst) {\n            const component_u = components.find(Y[u]);\n            const component_v = components.find(Y[v]);\n            if (component_u === component_v) continue;\n            this.__align_components(component_u, component_v, w);\n            components.union(component_u, component_v);\n            yield this.projection;\n        }\n        return this.projection;\n    }\n}\n","import { Matrix } from \"../matrix/index.js\";\nimport { euclidean } from \"../metrics/index.js\";\nimport { DR } from \"./DR.js\";\nimport { PCA, MDS } from \"./index.js\";\nimport { distance_matrix } from \"../matrix/index.js\";\n\n/**\n * @class\n * @alias SAMMON\n * @extends DR\n */\nexport class SAMMON extends DR {\n    /**\n     * SAMMON's Mapping\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @alias SAMMON\n     * @param {Matrix} X - the high-dimensional data.\n     * @param {Object} parameters - Object containing parameterization of the DR method.\n     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.\n     * @param {Function|\"precomputed\"} [parameters.metric = euclidean] - the metric which defines the distance between two points.\n     * @param {\"PCA\"|\"MDS\"|\"random\"} [parameters.init = \"random\"] - Either \"PCA\" or \"MDS\", with which SAMMON initialiates the projection. With \"random\" a random matrix gets used as starting point.\n     * @param {Object} [parameters.init_parameters] - Parameters for the {@link init}-DR method.\n     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.\n     * @returns {SAMMON}\n     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}\n     */\n    constructor(X, parameters) {\n        super(X, { magic: 0.1, d: 2, metric: euclidean, seed: 1212, init_DR: \"random\", init_parameters: {} }, parameters);\n        return this;\n    }\n\n    /**\n     * initializes the projection.\n     * @private\n     */\n    init() {\n        const N = this.X.shape[0];\n        const { d, metric, init_DR: init_DR, init_parameters: DR_parameters } = this._parameters;\n        if (init_DR === \"random\") {\n            const randomizer = this._randomizer;\n            this.Y = new Matrix(N, d, () => randomizer.random);\n        } else if ([\"PCA\", \"MDS\"].includes(init_DR)) {\n            this.Y = Matrix.from(init_DR == \"PCA\" ? PCA.transform(this.X, DR_parameters) : MDS.transform(this.X, DR_parameters));\n        } else {\n            throw new Error('init_DR needs to be either \"random\" or a DR method!')\n        }\n        this.distance_matrix = metric == \"precomputed\" ? Matrix.from(this.X) : distance_matrix(this.X, metric);\n        return this;\n    }\n\n    /**\n     * Transforms the inputdata {@link X} to dimenionality 2.\n     * @param {Number} [max_iter=200] - Maximum number of iteration steps.\n     * @returns {Matrix|Array} - The projection of {@link X}.\n     */\n    transform(max_iter = 200) {\n        if (!this._is_initialized) this.init();\n        for (let j = 0; j < max_iter; ++j) {\n            this._step();\n        }\n        return this.projection;\n    }\n\n    /**\n     * Transforms the inputdata {@link X} to dimenionality 2.\n     * @param {Number} [max_iter=200] - Maximum number of iteration steps.\n     * @returns {Generator} - A generator yielding the intermediate steps of the projection of {@link X}.\n     */\n    *generator(max_iter = 200) {\n        if (!this._is_initialized) this.init();\n\n        for (let j = 0; j < max_iter; ++j) {\n            this._step();\n            yield this.projection;\n        }\n\n        return this.projection;\n    }\n\n    _step() {\n        const MAGIC = this.parameter(\"magic\");\n        const D = this.distance_matrix;\n        const N = this.X.shape[0];\n        const { d, metric } = this._parameters;\n        let Y = this.Y;\n\n        let G = new Matrix(N, d, 0);\n\n        let sum = new Float64Array(d);\n        for (let i = 0; i < N; ++i) {\n            let e1 = new Float64Array(d);\n            let e2 = new Float64Array(d);\n            const Yi = Y.row(i);\n            for (let j = 0; j < N; ++j) {\n                if (i === j) continue;\n                const Yj = Y.row(j);\n                const delta = new Float64Array(d);\n                for (let k = 0; k < d; ++k) {\n                    delta[k] = Yi[k] - Yj[k];\n                }\n                const dY = metric(Yi, Yj);\n                const dX = D.entry(i, j);\n                const dq = dX - dY;\n                const dr = Math.max(dX * dY, 1e-2);\n                for (let k = 0; k < d; ++k) {\n                    e1[k] += (delta[k] * dq) / dr;\n                    e2[k] += (dq - (Math.pow(delta[k], 2) * (1 + dq / dY)) / dY) / dr;\n                }\n            }\n            for (let k = 0; k < d; ++k) {\n                const val = Y.entry(i, k) + ((MAGIC * e1[k]) / Math.abs(e2[k]) || 0);\n                G.set_entry(i, k, val);\n                sum[k] += val;\n            }\n        }\n        for (let k = 0; k < d; ++k) {\n            sum[k] /= N;\n        }\n\n        for (let i = 0; i < N; ++i) {\n            for (let k = 0; k < d; ++k) {\n                Y.set_entry(i, k, G.entry(i, k) - sum[k]);\n            }\n        }\n        return Y;\n    }\n}\n","import { Matrix, linspace, norm } from \"../matrix/index.js\";\nimport { euclidean, euclidean_squared } from \"../metrics/index.js\";\nimport { neumair_sum } from \"../numerical/index.js\";\nimport { DR } from \"./DR.js\";\nimport { PCA } from \"./index.js\";\n\nexport class SQDMDS extends DR {\n    /**\n     * SQuadMDS: a lean Stochastic Quartet MDS improving global structure preservation in neighbor embedding like t-SNE and UMAP.\n     * @constructor\n     * @memberof module:dimensionality_reduction\n     * @param {Matrix|Number[][]} X\n     * @param {Object} [parameters]\n     * @param {Number} [parameters.d=2]\n     * @param {Function} [parameters.metric = euclidean]\n     * @param {Number} [parameters.decay_start = 0.1] - Percentage of iterations using exaggeration phase. If random init: it is recommended to start the decay later to give the time for the global config to adjust with big steps.\n     * @param {Number} [parameters.decay_cte = 0.34] - Controls the decay of the learning parameter.\n     * @param {Object} [parameters.init_DR]\n     * @returns {SQDMDS}\n     * @see {@link https://arxiv.org/pdf/2202.12087.pdf}\n     */\n    constructor(X, parameters) {\n        super(\n            X,\n            {\n                d: 2,\n                metric: euclidean,\n                seed: 1212,\n                decay_start: 0.1,\n                decay_cte: 0.34, // 0.34\n                init_DR: {type: \"random\"}\n            },\n            parameters\n        );\n\n        return this;\n    }\n\n    /**\n     * @private\n     */\n    init() {\n        const N = this._N;\n        const d = this.parameter(\"d\");\n\n        // initialize helpers.\n        this._add = this.__add(d);\n        this._sub_div = this.__sub_div(d);\n        this._minus = this.__minus(d);\n        this._mult = this.__mult(d);\n        this._LR_init = Math.max(2, 0.005 * N);\n        this._LR = this._LR_init;\n        this._offset = -Math.exp(-1 / this.parameter(\"decay_cte\"));\n        this._momentums = new Matrix(N, d, 0);\n        this._grads = new Matrix(N, d, 0);\n        this._indices = linspace(0, N - 1);\n        // initialize projection.\n        const R = this._randomizer;\n        this.Y = new Matrix(N, d, () => R.random - 0.5);\n\n        // preparing metric for optimization.\n        const this_metric = this.parameter(\"metric\");\n        if (this_metric === \"precomputed\") {\n            this._HD_metric = function (i, j, X) {\n                return X.entry(i, j);\n            };\n            this._HD_metric_exaggeration = function (i, j, X) {\n                return Math.pow(X.entry(i, j), 2);\n            };\n        } else {\n            this._HD_metric = function (i, j, X) {\n                return this_metric(X.row(i), X.row(j));\n            };\n            if (this_metric == euclidean) {\n                this._HD_metric_exaggeration = function (i, j, X) {\n                    return euclidean_squared(X.row(i), X.row(j));\n                };\n            } else {\n                this._HD_metric_exaggeration = function (i, j, X) {\n                    return Math.pow(this_metric(X.row(i), X.row(j)), 2);\n                };\n            }\n        }\n        return;\n    }\n\n    /**\n     * Computes the projection.\n     * @param {Number} [iterations=500] - Number of iterations.\n     * @returns {Matrix|Number[][]} the projection.\n     */\n    transform(iterations = 500) {\n        this.check_init();\n        this._decay_start = Math.round(this.parameter(\"decay_start\") * iterations);\n        for (let i = 0; i < iterations; ++i) {\n            this._step(i, iterations);\n        }\n        return this.projection;\n    }\n\n    /**\n     * Computes the projection.\n     * @param {Number} [iterations=500] - number of iterations.\n     * @yields {Matrix|Number[][]} the intermediate steps of the projection.\n     */\n    *generator(iterations = 500) {\n        this.check_init();\n        this._decay_start = Math.round(this.parameter(\"decay_start\") * iterations);\n        for (let i = 0; i < iterations; ++i) {\n            this._step(i, iterations);\n            yield this.projection;\n        }\n        return this.projection;\n    }\n\n    /**\n     * Performs an optimization step.\n     * @private\n     * @param {Number} i - Acutal iteration.\n     * @param {Number} iterations - Number of iterations.\n     */\n    _step(i, iterations) {\n        const decay_start = this._decay_start;\n        if (i > decay_start) {\n            const decay_cte = this.parameter(\"decay_cte\");\n            const offset = this._offset;\n            const ratio = (i - decay_start) / (iterations - decay_start);\n            this._LR = this._LR_init * (Math.exp(-(ratio * ratio) / decay_cte) + offset);\n            this._distance_exaggeration = false;\n        } else {\n            this._distance_exaggeration = true;\n        }\n        this._nestrov_iteration(this._distance_exaggeration);\n    }\n\n    /**\n     * Creates quartets of non overlapping indices.\n     * @private\n     * @returns {Number[][]}\n     */\n    __quartets() {\n        const N = this._N;\n        const max_N = N - (N % 4);\n        const R = this._randomizer;\n        const shuffled_indices = R.choice(this._indices, max_N);\n        const result = [];\n        for (let i = 0; i < max_N; i += 4) {\n            result.push(Uint32Array.of(shuffled_indices[i], shuffled_indices[i + 1], shuffled_indices[i + 2], shuffled_indices[i + 3]));\n        }\n        return result;\n    }\n\n    /**\n     * Computes and applies gradients, and updates momentum.\n     * @private\n     * @param {Boolean} distance_exaggeration\n     */\n    _nestrov_iteration(distance_exaggeration) {\n        const momentums = this._momentums.mult(0.99, { inline: true });\n        const LR = this._LR;\n        const grads = this._fill_MDS_grads(this.Y.add(momentums), this._grads, distance_exaggeration);\n        const [n, d] = momentums.shape;\n        for (let i = 0; i < n; ++i) {\n            const g_i = grads.row(i);\n            const g_i_norm = norm(g_i);\n            if (g_i_norm == 0) continue;\n            const mul = LR / g_i_norm;\n            const m_i = momentums.row(i);\n            for (let j = 0; j < d; ++j) {\n                m_i[j] -= mul * g_i[j];\n            }\n        } // momentums -= (LR / norm) * grads\n        this.Y.add(momentums, { inline: true });\n    }\n\n    /**\n     * Computes the gradients.\n     * @param {Matrix} Y - The Projection.\n     * @param {Matrix} grads - The gradients.\n     * @param {Boolean} [exaggeration = false] - Whether or not to use early exaggeration.\n     * @param {Boolean} [zero_grad = true] - Whether or not to reset the gradient in the beginning.\n     * @returns {Matrix} the gradients.\n     */\n    _fill_MDS_grads(Y, grads, exaggeration = false, zero_grad = true) {\n        if (zero_grad) {\n            // compute new gradients\n            grads.values.fill(0);\n        }\n        const add = this._add;\n        const X = this.X;\n        let HD_metric;\n        if (exaggeration == true) {\n            HD_metric = this._HD_metric_exaggeration;\n        } else {\n            HD_metric = this._HD_metric;\n        }\n\n        const D_quartet = new Float64Array(6);\n        const quartets = this.__quartets();\n        for (const [i, j, k, l] of quartets) {\n            // compute quartet's HD distances.\n            D_quartet[0] = HD_metric(i, j, X);\n            D_quartet[1] = HD_metric(i, k, X);\n            D_quartet[2] = HD_metric(i, l, X);\n            D_quartet[3] = HD_metric(j, k, X);\n            D_quartet[4] = HD_metric(j, l, X);\n            D_quartet[5] = HD_metric(k, l, X);\n\n            const D_quartet_sum = neumair_sum(D_quartet);\n\n            if (D_quartet_sum > 0) {\n                for (let i = 0; i < 6; ++i) {\n                    D_quartet[i] /= D_quartet_sum;\n                    D_quartet[i] += 1e-11;\n                }\n            }\n            const [gi, gj, gk, gl] = this._compute_quartet_grads(Y, [i, j, k, l], D_quartet);\n\n            // add is inline, row acces the matrix\n            add(grads.row(i), gi);\n            add(grads.row(j), gj);\n            add(grads.row(k), gk);\n            add(grads.row(l), gl);\n        }\n        return grads;\n    }\n\n    /**\n     * Quartet gradients for a projection.\n     * @private\n     * @param {Matrix} Y - The acutal projection.\n     * @param {Number[]} quartet - The indices of the quartet.\n     * @param {Number[]} D_hd - The high-dimensional distances of the quartet.\n     * @returns {Number[][]} the gradients for the quartet.\n     */\n    _compute_quartet_grads(Y, quartet, [p_ab, p_ac, p_ad, p_bc, p_bd, p_cd]) {\n        const [a, b, c, d] = quartet.map((index) => Y.row(index));\n        // LD distances, add a small number just in case\n        const d_ab = euclidean(a, b) + 1e-12;\n        const d_ac = euclidean(a, c) + 1e-12;\n        const d_ad = euclidean(a, d) + 1e-12;\n        const d_bc = euclidean(b, c) + 1e-12;\n        const d_bd = euclidean(b, d) + 1e-12;\n        const d_cd = euclidean(c, d) + 1e-12;\n        const sum_LD_dist = neumair_sum([d_ab, d_ac, d_ad, d_bc, d_bd, d_cd]);\n\n        // for each element of the sum: use the same gradient function and just permute the points given in input.\n        const [gA1, gB1, gC1, gD1] = this._ABCD_grads(a, b, c, d, d_ab, d_ac, d_ad, d_bc, d_bd, d_cd, p_ab, sum_LD_dist);\n        const [gA2, gC2, gB2, gD2] = this._ABCD_grads(a, c, b, d, d_ac, d_ab, d_ad, d_bc, d_cd, d_bd, p_ac, sum_LD_dist);\n        const [gA3, gD3, gC3, gB3] = this._ABCD_grads(a, d, c, b, d_ad, d_ac, d_ab, d_cd, d_bd, d_bc, p_ad, sum_LD_dist);\n        const [gB4, gC4, gA4, gD4] = this._ABCD_grads(b, c, a, d, d_bc, d_ab, d_bd, d_ac, d_cd, d_ad, p_bc, sum_LD_dist);\n        const [gB5, gD5, gA5, gC5] = this._ABCD_grads(b, d, a, c, d_bd, d_ab, d_bc, d_ad, d_cd, d_ac, p_bd, sum_LD_dist);\n        const [gC6, gD6, gA6, gB6] = this._ABCD_grads(c, d, a, b, d_cd, d_ac, d_bc, d_ad, d_bd, d_ab, p_cd, sum_LD_dist);\n\n        const add = this._add;\n        const gA = add(gA1, gA2, gA3, gA4, gA5, gA6);\n        const gB = add(gB1, gB2, gB3, gB4, gB5, gB6);\n        const gC = add(gC1, gC2, gC3, gC4, gC5, gC6);\n        const gD = add(gD1, gD2, gD3, gD4, gD5, gD6);\n\n        return [gA, gB, gC, gD];\n    }\n\n    /**\n     * Gradients for one element of the loss function's sum.\n     * @private\n     */\n    _ABCD_grads(a, b, c, d, d_ab, d_ac, d_ad, d_bc, d_bd, d_cd, p_ab, sum_LD_dist) {\n        const ratio = d_ab / sum_LD_dist;\n        const twice_ratio = 2 * ((p_ab - ratio) / sum_LD_dist);\n        const minus = this._minus;\n        const add = this._add;\n        const mult = this._mult;\n        const sub_div = this._sub_div;\n        // no side effects because sub_div creates new arrays, and the inline functions work on this new created arrays.\n        const gA = mult(minus(mult(add(sub_div(a, b, d_ab), sub_div(a, c, d_ac), sub_div(a, d, d_ad)), ratio), sub_div(a, b, d_ab)), twice_ratio);\n        const gB = mult(minus(mult(add(sub_div(b, a, d_ab), sub_div(b, c, d_bc), sub_div(b, d, d_bd)), ratio), sub_div(b, a, d_ab)), twice_ratio);\n        const gC = mult(add(sub_div(c, a, d_ac), sub_div(c, b, d_bc), sub_div(c, d, d_cd)), ratio * twice_ratio);\n        const gD = mult(add(sub_div(d, a, d_ad), sub_div(d, b, d_bd), sub_div(d, c, d_cd)), ratio * twice_ratio);\n        return [gA, gB, gC, gD];\n    }\n\n    /**\n     * Inline!\n     */\n    __minus(d) {\n        return (a, b) => {\n            for (let i = 0; i < d; ++i) {\n                a[i] -= b[i];\n            }\n            return a;\n        };\n    }\n\n    /**\n     * Inline!\n     */\n    __add(d) {\n        return (...summands) => {\n            const n = summands.length;\n            const s1 = summands[0];\n            for (let j = 1; j < n; ++j) {\n                const summand = summands[j];\n                for (let i = 0; i < d; ++i) {\n                    s1[i] += summand[i];\n                }\n            }\n            return s1;\n        };\n    }\n\n    /**\n     * Inline!\n     */\n    __mult(d) {\n        return (a, v) => {\n            for (let i = 0; i < d; ++i) {\n                a[i] *= v;\n            }\n            return a;\n        };\n    }\n\n    /**\n     * Creates a new array <code>(x - y) / div</code>\n     */\n    __sub_div(d) {\n        return (x, y, div) => {\n            return Float64Array.from({ length: d }, (_, i) => (x[i] - y[i]) / div);\n        };\n    }\n}\n"],"names":["euclidean","a","b","Math","sqrt","euclidean_squared","length","n","sum","i","a_b","cosine","sum_a","sum_b","acos","manhattan","abs","chebyshev","res","push","max","canberra","jaccard","num_non_zero","num_equal","x","y","hamming","disagree","sokal_michener","num_not_equal","yule","num_true_true","num_true_false","num_false_true","k_nearest_neighbors","A","k","metric","rows","shape","D","distance_matrix","nN","Array","row","from","map","distance","col","j","sort","slice","Matrix","A_i","dist","set_entry","linspace","start","end","number","round","result","norm","v","vector","cols","Error","Float64Array","normalize","v_norm","value","kahan_sum","summands","t","compensation","neumair_sum","summand","qr_gramschmidt","Q","R","q","q_dot_v","q_","qr_householder","clone","x_norm","x0","entry","rho","sign","u1","u","divide","beta","u_outer_u","outer","R_block","get_block","new_R","sub","dot","mult","Q_block","new_Q","set_block","simultaneous_poweriteration","seed","max_iterations","qr","tol","randomizer","Randomizer","random","oldQ","QR","values","eigenvalues","diag","eigenvectors","transpose","to2dArray","inner_product","N","constructor","this","_rows","_cols","_data","type","isArray","m","_","data","subarray","iterate_rows","Symbol","iterator","set_row","offset","swap_rows","row1","row2","result_col","add_entry","sub_entry","T","inverse","B","max_idx","max_val","val","A_col","B_col","A_row","B_row","f","s","rows_A","cols_A","rows_B","cols_B","join","B_val","C","e","transDot","A_val","dotTrans","B_i","l","concat","X","offset_row","offset_col","min","start_row","start_col","end_row","end_col","new_row","new_col","gather","row_indices","col_indices","row_index","col_index","_apply_array","_apply_rowwise_array","_apply_colwise_array","_apply","value_rows","value_cols","inline","add","asArray","min_row_col","mean","meanRows","meanCols","solve_CG","b_i","r","d","z","alpha","r_next","solve","L","U","LU","det","L_diag","U_diag","SVD","M","MtM","MMt","V","Sigma","sigma","Float32Array","_seed","_N","_M","_MATRIX_A","_UPPER_MASK","_LOWER_MASK","_mt","_mti","Date","getTime","mt","mti","random_int","mag01","kk","N_M","M_N","gauss_random","_val","c","log","choice","sample","index_list","random_index","splice","undefined","Heap","elements","accessor","comparator","heapify","_accessor","_container","_comparator","heap","container","element","floor","_heapify_down","_swap","index_a","index_b","_heapify_up","index","parentIndex","node","start_index","left","right","pop","item","first","iterate","toArray","raw_data","empty","DisjointSet","_list","Set","make_set","list","has","__disjoint_set","parent","children","size","find","union","node_x","node_y","forEach","BallTree","_Node","pivot","child1","child2","radius","_Leaf","points","_metric","_root","_construct","_greatest_spread","sorted_elements","p_index","p","Infinity","spread","reduce","acc","current","search","_search","KNN","_elements","_D","distances","H","nearest_element_index","nearest_dist","Number","isInteger","DR","default_parameters","parameters","_parameters","Object","assign","seal","_type","_randomizer","_is_initialized","parameter","name","hasOwnProperty","para","transform","check_init","projection","generator","init","Y","transform_async","args","PCA","super","eig_args","principal_components","X_cent","MDS","ai_","a_j","a__","_d_X","stress","d_X","d_Y","top_sum","bottom_sum","pow","ISOMAP","neighbors","kNearestNeighbors","G","other","min_val","FASTMAP","_choose_distant_objects","a_index","b_index","max_dist","d_ai","d_bi","_col","old_dist","d_ab","y_i","LDA","labels","unique_labels","label_id","count","id","X_mean","V_mean","label","v_mean","S_b","S_w","row_v","LLE","O","W","nN_row","Z","C_trace","w","IW","LTSA","I_i","X_i","g","G_i_t","W_i","TSNE","perplexity","epsilon","_iter","Htarget","Delta","druid","P","_ystep","_gains","dist_i","prow","psum","betamin","betamax","cnt","done","dp_sum","pj","exp","N2","_P","iterations","next","iter","ystep","gains","dim","pmul","Qu","qsum","dsum","dhere","qu","grad","premult","ymean","gid","sid","gainid","newgain","newsid","powell","max_iter","pfx","fx","convergence","fxi","dx","UMAP","n_neighbors","local_connectivity","min_dist","_spread","_set_op_mix_ratio","_repulsion_strength","_negative_sample_rate","_n_epochs","_initial_alpha","_find_ab_params","xv","yv","xv_i","error","_compute_membership_strengths","sigmas","rhos","curr_dist","_smooth_knn_dist","knn","SMOOTH_K_TOLERANCE","MIN_K_DIST_SCALE","target","log2","reverse","x_i","interpolation","lo","hi","mid","search_result","non_zero_dist","filter","non_zero_dist_length","mean_ithd","mean_d","_fuzzy_simplicial_set","distances_i","transposed_result","prod_matrix","_make_epochs_per_sample","n_epochs","weights","_weights","fill","weight_scl","_tocoo","graph","rows_n","cols_n","_a","_b","_graph","_head","_tail","_epochs_per_sample","_epochs_per_negative_sample","_epoch_of_next_sample","_epoch_of_next_negative_sample","_clip","_optimize_layout","head_embedding","tail_embedding","head","tail","_alpha","epochs_per_sample","epochs_per_negative_sample","epoch_of_next_negative_sample","epoch_of_next_sample","clip","tail_length","grad_coeff","grad_d","n_neg_samples","TriMap","weight_adj","pca","n_inliers","n_outliers","n_random","triplets","_generate_triplets","lr","vel","gain","n_extra","nbrs","knn_distances","sig","_find_p","_sample_knn_triplets","n_triplets","outlier_distances","_find_weights","random_triplets","random_weights","_sample_random_triplets","max_weight","isNaN","max_weight_2","n_i","sort_indices","__argsort","n_j","sim","samples","_rejection_sample","out","n_samples","max_int","rejects","interval","indexOf","p_sim","p_out","indices","_grad","y_ij","y_ik","d_ij","d_ik","n_viol","loss","n_knn_triplets","Y_id","Y_jd","Y_kd","gs","go","max_iteration","_next","gamma","old_C","_update_embedding","new_gain","Hierarchical_Clustering","matrix","linkage","_id","_matrix","_linkage","root","do","get_clusters","clusters","depth","_traverse","leaves","_n","d_min","_d_min","_distance_matrix","_clusters","c_size","_c_size","Uint16Array","Cluster","p_max","c1","D_i_min","c2","c1_cluster","c2_cluster","c1_cluster_indices","isLeaf","c2_cluster_indices","new_cluster","unshift","D_c1_j","D_c2_j","centroid","_calculate_centroid","l_size","r_size","l_centroid","r_centroid","new_centroid","descendants","left_descendants","right_descendants","KMeans","K","_K","_cluster_centroids","_get_random_centroids","_furthest_point","candidates","Ad","cluster_centroids","random_point","init_points","sample_size","furthest_point","_iteration","clusters_changed","Ai","min_cluster","_compute_centroid","cluster_counter","ci","iteration_result","KMedoids","_A","_max_iter","log10","_cluster_medoids","_get_random_medoids","x_j","_nearest_medoid","index_nearest","medoids","finish","cache","x_o","o","DeltaTD","xs","findIndex","d_j","distance_nearest","deltaTD","d_oj","_get_distance","d_n","distance_second","d_s","nearest","second","x_m","m1","m2","index_second","cluster_medoids","ceil","TD","TD0","S","S_j","S_o","delta","OPTICS","min_points","_epsilon","_min_points","_ordered_list","_DB","ordered_list","DB","cluster_index","_cluster_index","reachability_distance","processed","_get_neighbors","_core_distance","seeds","_update","_expand_cluster","core_distance","new_reachability_distance","cluster","outliers","get_cluster_affirmation","LSP","control_points","DR_parameters","nc","c_i","Y_C","XA","ATA","ATb","TopoMap","__lazy_distance_matrix","D_ij","_make_minimum_spanning_tree","disjoint_set","F","E","set_u","set_v","_Emst","__hull_cross","ax","ay","bx","by","sx","sy","__hull","x1","y1","x2","y2","lower","upper","__findAngle","p1x","p1y","p2x","p2y","sin","cos","vec","__align_hull","hull","topEdge","d2","v1","v2","transformation","tx","ty","__transform","px","py","__transform_component","yOffset","cx","cy","__align_components","points_u","points_v","hull_u","hull_v","t_u","t_v","Emst","components","component_u","component_v","SAMMON","magic","init_DR","init_parameters","includes","_step","MAGIC","e1","e2","Yi","Yj","dY","dX","dq","dr","SQDMDS","decay_start","decay_cte","_add","__add","_sub_div","__sub_div","_minus","__minus","_mult","__mult","_LR_init","_LR","_offset","_momentums","_grads","_indices","this_metric","_HD_metric","_HD_metric_exaggeration","_decay_start","ratio","_distance_exaggeration","_nestrov_iteration","__quartets","max_N","shuffled_indices","Uint32Array","of","distance_exaggeration","momentums","LR","grads","_fill_MDS_grads","g_i","g_i_norm","mul","m_i","exaggeration","zero_grad","HD_metric","D_quartet","quartets","D_quartet_sum","gi","gj","gk","gl","_compute_quartet_grads","quartet","p_ab","p_ac","p_ad","p_bc","p_bd","p_cd","d_ac","d_ad","d_bc","d_bd","d_cd","sum_LD_dist","gA1","gB1","gC1","gD1","_ABCD_grads","gA2","gC2","gB2","gD2","gA3","gD3","gC3","gB3","gB4","gC4","gA4","gD4","gB5","gD5","gA5","gC5","gC6","gD6","gA6","gB6","twice_ratio","minus","sub_div","s1","div"],"mappings":"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"}