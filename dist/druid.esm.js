// https://renecutura.eu v0.4.4 Copyright 2022 Rene Cutura
/**
 * Computes the euclidean distance (l<sub>2</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias euclidean
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the euclidean distance between {@link a} and {@link b}.
 */
function euclidean(t,e){return Math.sqrt(euclidean_squared(t,e))}
/**
 * Numerical stable summation with the Kahan summation algorithm.
 * @memberof module:numerical
 * @alias kahan_sum
 * @param {Array} summands - Array of values to sum up.
 * @returns {number} The sum.
 * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm}
 */function kahan_sum(t){let e,r,s=t.length,i=0,n=0;for(let o=0;o<s;++o)e=t[o]-n,r=i+e,n=r-i-e,i=r;return i}
/**
 * Numerical stable summation with the Neumair summation algorithm.
 * @memberof module:numerical
 * @alias neumair_sum
 * @param {Array} summands - Array of values to sum up.
 * @returns {number} The sum.
 * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements}
 */function neumair_sum(t){let e=t.length,r=0,s=0;for(let i=0;i<e;++i){let e=t[i],n=r+e;Math.abs(r)>=Math.abs(e)?s+=r-n+e:s+=e-n+r,r=n}return r+s}
/**
 * Computes the squared euclidean distance (l<sub>2</sub><sup>2</sup>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias euclidean_squared
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the squared euclidean distance between {@link a} and {@link b}.
 */function euclidean_squared(t,e){if(t.length!=e.length)return;let r=t.length,s=new Array(r);for(let i=0;i<r;++i){let r=t[i],n=e[i];s[i]=(r-n)*(r-n)}return neumair_sum(s)}
/**
 * Computes the cosine distance (not similarity) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias cosine
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @example
 * druid.cosine([1,0],[1,1]) == 0.7853981633974484 == π/4
 * @returns {Number} The cosine distance between {@link a} and {@link b}.
 */function cosine(t,e){if(t.length!==e.length)return;let r=t.length,s=0,i=0,n=0;for(let o=0;o<r;++o)s+=t[o]*e[o],i+=t[o]*t[o],n+=e[o]*e[o];return Math.acos(s/(Math.sqrt(i)*Math.sqrt(n)))}
/**
 * Computes the manhattan distance (l<sub>1</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias manhattan
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the manhattan distance between {@link a} and {@link b}.
 */function manhattan(t,e){if(t.length!=e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i]);return s}
/**
 * Computes the chebyshev distance (L<sub>∞</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias chebyshev
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the chebyshev distance between {@link a} and {@link b}.
 */function chebyshev(t,e){if(t.length!=e.length)return;let r=t.length,s=[];for(let i=0;i<r;++i)s.push(Math.abs(t[i]-e[i]));return Math.max(...s)}
/**
 * Computes the canberra distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias canberra
 * @param {Array<Number>} a 
 * @param {Array<Number>} b 
 * @returns {Number} The canberra distance between {@link a} and {@link b}.
 * @see {@link https://en.wikipedia.org/wiki/Canberra_distance}
 */function canberra(t,e){if(t.length!==e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i])/(Math.abs(t[i])+Math.abs(e[i]));return s}
/**
 * Computes the jaccard distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias jaccard
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the jaccard distance between {@link a} and {@link b}.
 */function jaccard(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,i=0;for(let n=0;n<r;++n){const r=0!=t[n],o=0!=e[n];s+=r||o,i+=r&&o}return(s-i)/s}
/**
 * Computes the hamming distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias hamming
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the hamming distance between {@link a} and {@link b}.
 */function hamming(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let i=0;i<r;++i){s+=t[i]!=e[i]}return s/r}
/**
 * Computes the Sokal-Michener distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias sokal_michener
 * @param {Array<Number>} a 
 * @param {Array<Number>} b 
 * @returns {Number} the Sokal-Michener distance between {@link a} and {@link b}.  
 */function sokal_michener(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let i=0;i<r;++i){s+=0!=t[i]!=(0!=e[i])}return 2*s/(r+s)}
/**
 * Computes the yule distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias yule
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the yule distance between {@link a} and {@link b}.
 */function yule(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,i=0,n=0;for(let o=0;o<r;++o){const r=0!=t[o],a=0!=e[o];s+=r&&a,i+=r&&!a,n+=!r&&r}return 0==i||0==n?0:2*i*n/(s*(r-s-i-n)+i*n)}
/**
 * Computes the k-nearest neighbors of each row of {@link A}.
 * @memberof module:matrix
 * @alias k_nearest_neigbhors
 * @param {Matrix} A - Either the data matrix, or a distance matrix.
 * @param {Number} k - The number of neighbors to compute.
 * @param {Function|"precomputed"} metric
 */function k_nearest_neighbors(t,e,r=euclidean){const s=t.shape[0];let i="precomputed"==r?t.clone():distance_matrix(t,r),n=new Array(s);for(let t=0;t<s;++t)n[t]=Array.from(i.row(t)).map(((e,r)=>({i:t,j:r,distance:e}))).sort(((t,e)=>t.distance-e.distance)).slice(1,e+1);return n}
/**
 * Computes the distance matrix of datamatrix {@link A}.
 * @memberof module:matrix
 * @alias distance_matrix
 * @param {Matrix} A - Matrix.
 * @param {Function} [metric=euclidean] - The diistance metric.
 * @returns {Matrix} D - The distance matrix of {@link A}.
 */function distance_matrix(t,e=euclidean){let r=t.shape[0];const s=new Matrix(r,r);for(let i=0;i<r;++i){const n=t.row(i);for(let o=i+1;o<r;++o){const r=e(n,t.row(o));s.set_entry(i,o,r),s.set_entry(o,i,r)}}return s}
/**
 * Creates an Array containing {@link number} numbers from {@link start} to {@link end}.
 * If <code>{@link number} = null</null>.
 * @memberof module:matrix
 * @alias linspace
 * @param {Number} start - Start value.
 * @param {Number} end - End value.
 * @param {Number} [number = null] - Number of number between {@link start} and {@link end}.
 * @returns {Array} - An array with {@link number} entries, beginning at {@link start} ending at {@link end}.
 */function linspace(t,e,r=null){if(r||(r=Math.max(Math.round(e-t)+1,1)),r<2)return 1===r?[t]:[];let s=new Array(r);for(let i=r-=1;i>=0;--i)s[i]=(i*e+(r-i)*t)/r;return s}
//import { neumair_sum } from "../numerical/index";
/**
 * Computes the norm of a vector, by computing its distance to **0**.
 * @memberof module:matrix
 * @alias norm
 * @param {Matrix|Array<Number>|Float64Array} v - Vector. 
 * @param {Function} [metric = euclidean] - Which metric should be used to compute the norm.
 * @returns {Number} - The norm of {@link v}.
 */function norm(t,e=euclidean){let r=null;if(t instanceof Matrix){let[e,s]=t.shape;if(1===e)r=t.row(0);else{if(1!==s)throw new Error("Matrix must be 1d!");r=t.col(0)}}else r=t;const s=r.length;return e(r,Float64Array.from({length:s},(()=>0)))}
/**
 * Normalizes Vector {@link v}.
 * @memberof module:matrix
 * @alias normalize
 * @param {Array<Number>|Float64Array} v - Vector
 * @param {Function} metric 
 * @returns {Array<Number>|Float64Array} - The normalized vector with length 1.
 */function normalize(t,e=euclidean){const r=norm(t,e);return t.map((t=>t/r))}
/**
 * Computes the QR Decomposition of the Matrix {@link A} using Gram-Schmidt process.
 * @memberof module:linear_algebra
 * @alias qr
 * @param {Matrix} A
 * @returns {{R: Matrix, Q: Matrix}}
 * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_the_Gram%E2%80%93Schmidt_process}
 */function qr_gramschmidt(t){const[e,r]=t.shape,s=new Matrix(e,r,"identity"),i=new Matrix(r,r,0);for(let n=0;n<r;++n){let r=t.col(n);for(let t=0;t<n;++t){const e=s.col(t),o=neumair_sum(e.map(((t,e)=>t*r[e])));i.set_entry(t,n,o),r=r.map(((t,r)=>t-o*e[r]))}const o=norm(r,euclidean);for(let t=0;t<e;++t)s.set_entry(t,n,r[t]/o);i.set_entry(n,n,o)}return{R:i,Q:s}}
/**
 * Computes the QR Decomposition of the Matrix {@link A} with householder transformations.
 * @memberof module:linear_algebra
 * @alias qr_householder
 * @param {Matrix} A
 * @returns {{R: Matrix, Q: Matrix}}
 * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections}
 * @see {@link http://mlwiki.org/index.php/Householder_Transformation}
 */function qr_householder(t){const[e,r]=t.shape,s=new Matrix(e,e,"I"),i=t.clone();for(let t=0;t<r;++t){const e=Matrix.from(i.col(t).slice(t)),r=norm(e),n=e.entry(0,0),o=-Math.sign(n),a=n-o*r,h=e.divide(a).set_entry(0,0,1),l=-o*a/r,_=h.outer(h),c=i.get_block(t,0),u=c.sub(_.dot(c).mult(l)),f=s.get_block(0,t),d=f.sub(f.dot(_).mult(l));i.set_block(t,0,u),s.set_block(0,t,d)}return{R:i,Q:s}}
/**
 * Computes the {@link k} biggest Eigenvectors and Eigenvalues from Matrix {@link A} with the QR-Algorithm.
 * @memberof module:linear_algebra
 * @alias simultaneous_poweriteration
 * @param {Matrix} A - The Matrix
 * @param {Number} k - The number of eigenvectors and eigenvalues to compute.
 * @param {Number} [max_iterations=100] - The number of maxiumum iterations the algorithm should run.
 * @param {Number|Randomizer} [seed=1212] - The seed value or a randomizer used in the algorithm.
 * @param {Number} [tol=1e-8] - Allowed error for stopping criteria
 * @returns {{eigenvalues: Array, eigenvectors: Array}} - The {@link k} biggest eigenvectors and eigenvalues of Matrix {@link A}.
 */function simultaneous_poweriteration(t,e=2,r=100,s=1212,i=qr_gramschmidt,n=1e-8){const o=s instanceof Randomizer?s:new Randomizer(s);t instanceof Matrix||(t=Matrix.from(t));const a=t.shape[0];let{Q:h,R:l}=i(new Matrix(a,e,(()=>o.random)));for(;r--;){const e=h.clone(),r=i(t.dot(h));h=r.Q,l=r.R;if(euclidean_squared(h.values,e.values)<n)break}return{eigenvalues:l.diag,eigenvectors:h.transpose().to2dArray}}
/**
 * Computes the inner product between two arrays of the same length.
 * @memberof module:linear_algebra
 * @alias inner_product
 * @param {Array|Float64Array} a - Array a
 * @param {Array|Float64Array} b - Array b
 * @returns The inner product between {@link a} and {@link b}
 */function inner_product(t,e){const r=t.length;if(r!=e.length)throw new Error("Array a and b must have the same length!");let s=0;for(let i=0;i<r;++i)s+=t*e;return s}
/**
 * @class
 * @alias Matrix
 * @requires module:numerical/neumair_sum
 */class Matrix{
/**
     * creates a new Matrix. Entries are stored in a Float64Array.
     * @constructor
     * @memberof module:matrix
     * @alias Matrix
     * @param {number} rows - The amount of rows of the matrix.
     * @param {number} cols - The amount of columns of the matrix.
     * @param {(function|string|number)} value=0 - Can be a function with row and col as parameters, a number, or "zeros", "identity" or "I", or "center".
     *  - **function**: for each entry the function gets called with the parameters for the actual row and column.
     *  - **string**: allowed are
     *      - "zero", creates a zero matrix.
     *      - "identity" or "I", creates an identity matrix.
     *      - "center", creates an center matrix.
     *  - **number**: create a matrix filled with the given value.
     * @example
     *
     * let A = new Matrix(10, 10, () => Math.random()); //creates a 10 times 10 random matrix.
     * let B = new Matrix(3, 3, "I"); // creates a 3 times 3 identity matrix.
     * @returns {Matrix} returns a {@link rows} times {@link cols} Matrix filled with {@link value}.
     */
constructor(t=null,e=null,r=null){if(this._rows=t,this._cols=e,this._data=null,t&&e){if(!r)return this._data=new Float64Array(t*e),this;if("function"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}if("string"==typeof r){if("zeros"===r)return new Matrix(t,e,0);if("identity"===r||"I"===r){this._data=new Float64Array(t*e);for(let r=0;r<t;++r)this._data[r*e+r]=1;return this}if("center"===r&&t==e){this._data=new Float64Array(t*e),r=(e,r)=>(e===r?1:0)-1/t;for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}}if("number"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r;return this}}return this}
/**
     * Creates a Matrix out of {@link A}.
     * @param {(Matrix|Array|Float64Array|number)} A - The matrix, array, or number, which should converted to a Matrix.
     * @param {"row"|"col"|"diag"} [type = "row"] - If {@link A} is a Array or Float64Array, then type defines if it is a row- or a column vector.
     * @returns {Matrix}
     *
     * @example
     * let A = Matrix.from([[1, 0], [0, 1]]); //creates a two by two identity matrix.
     * let S = Matrix.from([1, 2, 3], "diag"); // creates a 3 by 3 matrix with 1, 2, 3 on its diagonal. [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
     */static from(t,e="row"){if(t instanceof Matrix)return t.clone();if(!(Array.isArray(t)||t instanceof Float64Array)){if("number"==typeof t)return new Matrix(1,1,t);throw new Error("error")}{let r=t.length;if(0===r)throw new Error("Array is empty");
// 1d
if(!(Array.isArray(t[0])||t[0]instanceof Float64Array)){if("row"===e)return new Matrix(1,r,((e,r)=>t[r]));
// 2d
if("col"===e)return new Matrix(r,1,(e=>t[e]));if("diag"===e)return new Matrix(r,r,((e,r)=>e==r?t[e]:0));throw new Error("1d array has NaN entries")}if(Array.isArray(t[0])||t[0]instanceof Float64Array){let e=t[0].length;for(let s=0;s<r;++s)if(t[s].length!==e)throw new Error("various array lengths");return new Matrix(r,e,((e,r)=>t[e][r]))}}}
/**
     * Returns the {@link row}<sup>th</sup> row from the Matrix.
     * @param {Number} row
     * @returns {Float64Array}
     */row(t){const e=this.values,r=this._cols;return e.subarray(t*r,(t+1)*r)}
/**
     * Returns an generator yielding each row of the Matrix.
     * @yields {Float64Array}
     */*iterate_rows(){const t=this._cols,e=this._rows,r=this.values;for(let s=0;s<e;++s)yield r.subarray(s*t,(s+1)*t)}
/**
     * Makes a {@link Matrix} object an iterable object.
     * @yields {Float64Array}
     */*[Symbol.iterator](){for(const t of this.iterate_rows())yield t}
/**
     * Sets the entries of {@link row}<sup>th</sup> row from the Matrix to the entries from {@link values}.
     * @param {int} row
     * @param {Array} values
     * @returns {Matrix}
     */set_row(t,e){let r=this._cols;if(Array.isArray(e)&&e.length===r){let s=t*r;for(let t=0;t<r;++t)this.values[s+t]=e[t]}else if(e instanceof Matrix&&e.shape[1]===r&&1===e.shape[0]){let s=t*r;for(let t=0;t<r;++t)this.values[s+t]=e._data[t]}return this}
/**
     * Returns the {@link col}<sup>th</sup> column from the Matrix.
     * @param {int} col
     * @returns {Array}
     */col(t){let e=new Float64Array(this._rows);for(let r=0;r<this._rows;++r)e[r]=this.values[r*this._cols+t];return e}
/**
     * Returns the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix.
     * @param {int} row
     * @param {int} col
     * @returns {float64}
     */entry(t,e){return this.values[t*this._cols+e]}
/**
     * Sets the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix to the given {@link value}.
     * @param {int} row
     * @param {int} col
     * @param {float64} value
     * @returns {Matrix}
     */set_entry(t,e,r){return this.values[t*this._cols+e]=r,this}
/**
     * Returns a new transposed Matrix.
     * @returns {Matrix}
     */transpose(){return new Matrix(this._cols,this._rows,((t,e)=>this.entry(e,t)))}
/**
     * Returns a new transposed Matrix. Short-form of {@function transpose}.
     * @returns {Matrix}
     */get T(){return this.transpose()}
/**
     * Returns the inverse of the Matrix.
     * @returns {Matrix}
     */inverse(){const t=this._rows,e=this._cols;let r=new Matrix(t,2*e,((t,r)=>r>=e?t===r-e?1:0:this.entry(t,r))),s=0,i=0;for(;s<t&&i<e;){var n=0;let o=-1/0;for(let e=s;e<t;++e){let t=Math.abs(r.entry(e,i));o<t&&(n=e,o=t)}if(0==r.entry(n,i))i++;else{
// swap rows
for(let t=0;t<2*e;++t){let e=r.entry(s,t),i=r.entry(n,t);r.set_entry(s,t,e),r.set_entry(n,t,i)}for(let n=s+1;n<t;++n){let t=r.entry(n,i)/r.entry(s,i);r.set_entry(n,i,0);for(let o=i+1;o<2*e;++o)r.set_entry(n,o,r.entry(n,o)-r.entry(s,o)*t)}s++,i++}}for(let s=0;s<t;++s){let t=r.entry(s,s);for(let i=s;i<2*e;++i)r.set_entry(s,i,r.entry(s,i)/t)}for(let s=t-1;s>=0;--s){let t=r.entry(s,s);for(let i=0;i<s;i++){let n=r.entry(i,s)/t;for(let t=i;t<2*e;++t){let e=r.entry(i,t);e-=r.entry(s,t)*n,r.set_entry(i,t,e)}}}return new Matrix(t,e,((t,s)=>r.entry(t,s+e)))}
/**
     * Returns the dot product. If {@link B} is an Array or Float64Array then an Array gets returned. If {@link B} is a Matrix then a Matrix gets returned.
     * @param {(Matrix|Array|Float64Array)} B the right side
     * @returns {(Matrix|Array)}
     */dot(t){if(t instanceof Matrix){let e=this;if(e.shape[1]!==t.shape[0])throw new Error(`A.dot(B): A is a ${e.shape.join(" ⨯ ")}-Matrix, B is a ${t.shape.join(" ⨯ ")}-Matrix: \n                A has ${e.shape[1]} cols and B ${t.shape[0]} rows. \n                Must be equal!`);let r=e.shape[1];return new Matrix(e.shape[0],t.shape[1],((s,i)=>{const n=e.row(s),o=t.col(i);let a=0;for(let t=0;t<r;++t)a+=n[t]*o[t];return a}))}if(Array.isArray(t)||t instanceof Float64Array){let e=this._rows;if(t.length!==e)throw new Error(`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`);let r=new Array(e);for(let s=0;s<e;++s)r[s]=neumair_sum(this.row(s).map((e=>e*t[s])));return r}throw new Error("B must be Matrix or Array")}
/**
     * Computes the outer product from {@link this} and {@link B}.
     * @param {Matrix} B
     * @returns {Matrix}
     */outer(t){let e=this,r=e._data.length;if(r!=t._data.length)return;let s=new Matrix;return s.shape=[r,r,(r,i)=>r<=i?e._data[r]*t._data[i]:s.entry(i,r)],s}
/**
     * Appends matrix {@link B} to the matrix.
     * @param {Matrix} B - matrix to append.
     * @param {"horizontal"|"vertical"|"diag"} [type = "horizontal"] - type of concatenation.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 1], [1, 1]]); // 2 by 2 matrix filled with ones.
     * let B = Matrix.from([[2, 2], [2, 2]]); // 2 by 2 matrix filled with twos.
     *
     * A.concat(B, "horizontal"); // 2 by 4 matrix. [[1, 1, 2, 2], [1, 1, 2, 2]]
     * A.concat(B, "vertical"); // 4 by 2 matrix. [[1, 1], [1, 1], [2, 2], [2, 2]]
     * A.concat(B, "diag"); // 4 by 4 matrix. [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 2, 2], [0, 0, 2, 2]]
     */concat(t,e="horizontal"){const r=this,[s,i]=r.shape,[n,o]=t.shape;if("horizontal"==e){if(s!=n)throw new Error(`A.concat(B, "horizontal"): A and B need same number of rows, A has ${s} rows, B has ${n} rows.`);const e=new Matrix(s,i+o,"zeros");return e.set_block(0,0,r),e.set_block(0,i,t),e}if("vertical"==e){if(i!=o)throw new Error(`A.concat(B, "vertical"): A and B need same number of columns, A has ${i} columns, B has ${o} columns.`);const e=new Matrix(s+n,i,"zeros");return e.set_block(0,0,r),e.set_block(s,0,t),e}if("diag"==e){const e=new Matrix(s+n,i+o,"zeros");return e.set_block(0,0,r),e.set_block(s,i,t),e}throw new Error(`type must be "horizontal" or "vertical", but type is ${e}!`)}
/**
     * Writes the entries of B in A at an offset position given by {@link offset_row} and {@link offset_col}.
     * @param {int} offset_row
     * @param {int} offset_col
     * @param {Matrix} B
     * @returns {Matrix}
     */set_block(t,e,r){let[s,i]=r.shape;for(let n=0;n<s;++n)if(!(n>this._rows))for(let s=0;s<i;++s)s>this._cols||this.set_entry(n+t,s+e,r.entry(n,s));return this}
/**
     * Extracts the entries from the {@link start_row}<sup>th</sup> row to the {@link end_row}<sup>th</sup> row, the {@link start_col}<sup>th</sup> column to the {@link end_col}<sup>th</sup> column of the matrix.
     * If {@link end_row} or {@link end_col} is empty, the respective value is set to {@link this.rows} or {@link this.cols}.
     * @param {Number} start_row
     * @param {Number} start_col
     * @param {Number} [end_row = null]
     * @param {Number} [end_col = null]
     * @returns {Matrix} Returns a end_row - start_row times end_col - start_col matrix, with respective entries from the matrix.
     * @example
     *
     * let A = Matrix.from([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); // a 3 by 3 matrix.
     *
     * A.get_block(1, 1); // [[5, 6], [8, 9]]
     * A.get_block(0, 0, 1, 1); // [[1]]
     * A.get_block(1, 1, 2, 2); // [[5]]
     * A.get_block(0, 0, 2, 2); // [[1, 2], [4, 5]]
     */get_block(t,e,r=null,s=null){const[i,n]=this.shape;if(s=s??n,(r=r??i)<=t||s<=e)throw new Error(`\n                end_row must be greater than start_row, and \n                end_col must be greater than start_col, but\n                end_row = ${r}, start_row = ${t}, end_col = ${s}, and start_col = ${e}!`);const o=new Matrix(r-t,s-e,"zeros");for(let i=t,n=0;i<r;++i,++n)for(let t=e,r=0;t<s;++t,++r)o.set_entry(n,r,this.entry(i,t));return o;
//return new Matrix(end_row - start_row, end_col - start_col, (i, j) => this.entry(i + start_row, j + start_col));
}
/**
     * Returns a new array gathering entries defined by the indices given by argument.
     * @param {Array<Number>} row_indices - Array consists of indices of rows for gathering entries of this matrix
     * @param {Array<Number>} col_indices  - Array consists of indices of cols for gathering entries of this matrix
     * @returns {Matrix}
     */gather(t,e){const r=t.length,s=e.length,i=new Matrix(r,s);for(let s=0;s<r;++s){const n=t[s];for(let t=0;t<r;++t){const r=e[t];i.set_entry(s,t,this.entry(n,r))}}return i}
/**
     * Applies a function to each entry of the matrix.
     * @private
     * @param {function} f function takes 2 parameters, the value of the actual entry and a value given by the function {@link v}. The result of {@link f} gets writen to the Matrix.
     * @param {function} v function takes 2 parameters for row and col, and returns a value witch should be applied to the colth entry of the rowth row of the matrix.
     */_apply_array(t,e){const r=this.values,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o;r[i]=t(r[i],e(n,o))}}return this}_apply_rowwise_array(t,e){return this._apply_array(e,((e,r)=>t[r]))}_apply_colwise_array(t,e){const r=this.values,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o;r[i]=e(r[i],t[n])}}return this}_apply(t,e){let r=this.values;if(t instanceof Matrix){let[s,i]=t.shape,[n,o]=this.shape;if(1===s){if(o!==i)throw new Error("cols !== value_cols");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(0,i))}else if(1===i){if(n!==s)throw new Error("rows !== value_rows");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,0))}else{if(n!=s||o!=i)throw new Error("error");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,i))}}else if(Array.isArray(t)){let s=this._rows,i=this._cols;if(t.length===s)for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[n]);else{if(t.length!==i)throw new Error("error");for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[s])}}else for(let s=0,i=this._rows*this._cols;s<i;++s)r[s]=e(r[s],t);return this}
/**
     * Clones the Matrix.
     * @returns {Matrix}
     */clone(){let t=new Matrix;return t._rows=this._rows,t._cols=this._cols,t._data=this.values.slice(0),t}
/**
     * Entrywise multiplication with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.mult(2); // [[2, 4], [6, 8]];
     * A.mult(B); // [[1, 4], [9, 16]];
     */mult(t){return this.clone()._apply(t,((t,e)=>t*e))}
/**
     * Entrywise division with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.divide(2); // [[0.5, 1], [1.5, 2]];
     * A.divide(B); // [[1, 1], [1, 1]];
     */divide(t){return this.clone()._apply(t,((t,e)=>t/e))}
/**
     * Entrywise addition with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.add(2); // [[3, 4], [5, 6]];
     * A.add(B); // [[2, 4], [6, 8]];
     */add(t){return this.clone()._apply(t,((t,e)=>t+e))}
/**
     * Entrywise subtraction with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.sub(2); // [[-1, 0], [1, 2]];
     * A.sub(B); // [[0, 0], [0, 0]];
     */sub(t){return this.clone()._apply(t,((t,e)=>t-e))}
/**
     * Returns the number of rows and columns of the Matrix.
     * @returns {Array} An Array in the form [rows, columns].
     */get shape(){return[this._rows,this._cols]}
/**
     * Returns the matrix in the given shape with the given function which returns values for the entries of the matrix.
     * @param {Array} parameter - takes an Array in the form [rows, cols, value], where rows and cols are the number of rows and columns of the matrix, and value is a function which takes two parameters (row and col) which has to return a value for the colth entry of the rowth row.
     * @returns {Matrix}
     */set shape([t,e,r=(()=>0)]){this._rows=t,this._cols=e,this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}
/**
     * Returns the Matrix as a Array of Float64Arrays.
     * @returns {Array<Float64Array>}
     */get to2dArray(){const t=[];for(const e of this.iterate_rows())t.push(e);return t}
/**
     * Returns the Matrix as a Array of Arrays.
     * @returns {Array<Array>}
     */get asArray(){const t=[];for(const e of this.iterate_rows())t.push(Array.from(e));return t}
/**
     * Returns the diagonal of the Matrix.
     * @returns {Float64Array}
     */get diag(){const t=this._rows,e=this._cols,r=Math.min(t,e);let s=new Float64Array(r);for(let t=0;t<r;++t)s[t]=this.entry(t,t);return s}
/**
     * Returns the mean of all entries of the Matrix.
     * @returns {Number}
     */get mean(){return this.sum/(this._rows*this._cols)}
/**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Number}
     */get sum(){return neumair_sum(this.values)}
/**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Float64Array}
     */get values(){return this._data}
/**
     * Returns the mean of each row of the matrix.
     * @returns {Float64Array}
     */get meanRows(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:e});for(let i=0;i<e;++i){s[i]=0;for(let e=0;e<r;++e)s[i]+=t[i*r+e];s[i]/=r}return s}
/** Returns the mean of each column of the matrix.
     * @returns {Float64Array}
     */get meanCols(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:r});for(let i=0;i<r;++i){s[i]=0;for(let n=0;n<e;++n)s[i]+=t[n*r+i];s[i]/=e}return s}
/**
     * Solves the equation {@link A}x = {@link b} using the conjugate gradient method. Returns the result x.
     * @param {Matrix} A - Matrix
     * @param {Matrix} b - Matrix
     * @param {Randomizer} [randomizer=null]
     * @param {Number} [tol=1e-3]
     * @returns {Matrix}
     */static solve_CG(t,e,r,s=.001){null===r&&(r=new Randomizer);const i=t.shape[0],n=e.shape[1];let o=new Matrix(i,0);for(let a=0;a<n;++a){const n=Matrix.from(e.col(a)).T;let h=new Matrix(i,1,(()=>r.random)),l=n.sub(t.dot(h)),_=l.clone();do{const e=t.dot(_),r=l.T.dot(l).entry(0,0)/_.T.dot(e).entry(0,0);h=h.add(_.mult(r));const s=l.sub(e.mult(r)),i=s.T.dot(s).entry(0,0)/l.T.dot(l).entry(0,0);_=s.add(_.mult(i)),l=s}while(Math.abs(l.mean)>s);o=o.concat(h,"horizontal")}return o}
/**
     * Solves the equation {@link A}x = {@link b}. Returns the result x.
     * @param {Matrix} A - Matrix or LU Decomposition
     * @param {Matrix} b - Matrix
     * @returns {Matrix}
     */static solve(t,e){let{L:r,U:s}="L"in t&&"U"in t?t:Matrix.LU(t),i=r.shape[0],n=e.clone();
// forward
for(let t=0;t<i;++t){for(let e=0;e<t-1;++e)n.set_entry(0,t,n.entry(0,t)-r.entry(t,e)*n.entry(1,e));n.set_entry(0,t,n.entry(0,t)/r.entry(t,t))}
// backward
for(let t=i-1;t>=0;--t){for(let e=i-1;e>t;--e)n.set_entry(0,t,n.entry(0,t)-s.entry(t,e)*n.entry(0,e));n.set_entry(0,t,n.entry(0,t)/s.entry(t,t))}return n}
/**
     * {@link L}{@link U} decomposition of the Matrix {@link A}. Creates two matrices, so that the dot product LU equals A.
     * @param {Matrix} A
     * @returns {{L: Matrix, U: Matrix}} result - Returns the left triangle matrix {@link L} and the upper triangle matrix {@link U}.
     */static LU(t){const e=t.shape[0],r=new Matrix(e,e,"zeros"),s=new Matrix(e,e,"identity");for(let i=0;i<e;++i){for(let n=i;n<e;++n){let e=0;for(let t=0;t<i;++t)e+=r.entry(n,t)*s.entry(t,i);r.set_entry(n,i,t.entry(n,i)-e)}for(let n=i;n<e;++n){if(0===r.entry(i,i))return;let e=0;for(let t=0;t<i;++t)e+=r.entry(i,t)*s.entry(t,n);s.set_entry(i,n,(t.entry(i,n)-e)/r.entry(i,i))}}return{L:r,U:s}}
/**
     * Computes the determinante of {@link A}, by using the LU decomposition of {@link A}.
     * @param {Matrix} A
     * @returns {Number} det - Returns the determinate of the Matrix {@link A}.
     */static det(t){const e=t.shape[0],{L:r,U:s}=Matrix.LU(t),i=r.diag,n=s.diag;let o=i[0]*n[0];for(let t=1;t<e;++t)o*=i[t]*n[t];return o}
/**
     * Computes the {@link k} components of the SVD decomposition of the matrix {@link M}
     * @param {Matrix} M
     * @param {int} [k=2]
     * @returns {{U: Matrix, Sigma: Matrix, V: Matrix}}
     */static SVD(t,e=2){const r=t.T;let s=r.dot(t),i=t.dot(r),{eigenvectors:n,eigenvalues:o}=simultaneous_poweriteration(s,e),{eigenvectors:a}=simultaneous_poweriteration(i,e);return{U:a,Sigma:o.map((t=>Math.sqrt(t))),V:n};
//Algorithm 1a: Householder reduction to bidiagonal form:
/* const [m, n] = A.shape;
        let U = new Matrix(m, n, (i, j) => i == j ? 1 : 0);
        console.log(U.to2dArray)
        let V = new Matrix(n, m, (i, j) => i == j ? 1 : 0);
        console.log(V.to2dArray)
        let B = Matrix.bidiagonal(A.clone(), U, V);
        console.log(U,V,B)
        return { U: U, "Sigma": B, V: V }; */}}
/**
 * @class
 * @memberof module:utils
 * @alias Randomizer
 */class Randomizer{
/**
     * Mersenne Twister random number generator.
     * @constructor
     * @param {Number} [_seed=new Date().getTime()] - The seed for the random number generator. If <code>_seed == null</code> then the actual time gets used as seed.
     * @see https://github.com/bmurray7/mersenne-twister-examples/blob/master/javascript-mersenne-twister.js
     */
constructor(t){return this._N=624,this._M=397,this._MATRIX_A=2567483615,this._UPPER_MASK=2147483648,this._LOWER_MASK=2147483647,this._mt=new Array(this._N),this._mti=this.N+1,this.seed=t||(new Date).getTime(),this}set seed(t){this._seed=t;let e=this._mt;for(e[0]=t>>>0,this._mti=1;this._mti<this._N;this._mti+=1){let t=this._mti,r=e[t-1]^e[t-1]>>>30;e[t]=(1812433253*((4294901760&r)>>>16)<<16)+1812433253*(65535&r)+t,e[t]>>>=0}}
/**
     * Returns the seed of the random number generator.
     * @returns {Number} - The seed.
     */get seed(){return this._seed}
/**
     * Returns a float between 0 and 1.
     * @returns {Number} - A random number between [0, 1]
     */get random(){return this.random_int*(1/4294967296)}
/**
     * Returns an integer between 0 and MAX_INTEGER.
     * @returns {Integer} - A random integer.
     */get random_int(){let t,e=new Array(0,this._MATRIX_A);if(this._mti>=this._N){let r,s=this._N-this._M,i=this._M-this._N;
/* if (this._mti == this._N + 1) {
                this.seed = 5489;
            } */for(r=0;r<s;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+this._M]^t>>>1^e[1&t];for(;r<this._N-1;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+i]^t>>>1^e[1&t];t=this._mt[this._N-1]&this._UPPER_MASK|this._mt[0]&this._LOWER_MASK,this._mt[this._N-1]=this._mt[this._M-1]^t>>>1^e[1&t],this._mti=0}return t=this._mt[this._mti+=1],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,t^=t>>>18,t>>>0}
/**
     * Returns samples from an input Matrix or Array.
     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.
     * @param {Number} n - The number of samples.
     * @returns {Array} - A random selection form {@link A} of {@link n} samples.
     */choice(t,e){if(t instanceof Matrix){let r=t.shape[0];if(e>r)throw new Error("n bigger than A!");let s=new Array(e),i=linspace(0,r-1);for(let t=0,r=i.length;t<e;++t,--r){let e=this.random_int%r;s[t]=i.splice(e,1)[0]}return s.map((e=>t.row(e)))}if(Array.isArray(t)||t instanceof Float64Array){let r=t.length;if(e>r)throw new Error("n bigger than A!");let s=new Array(e),i=linspace(0,r-1);for(let t=0,r=i.length;t<e;++t,--r){let e=this.random_int%r;s[t]=i.splice(e,1)[0]}return s.map((e=>t[e]))}}
/**
     * @static
     * Returns samples from an input Matrix or Array.
     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.
     * @param {Number} n - The number of samples.
     * @param {Number} seed - The seed for the random number generator.
     * @returns {Array} - A random selection form {@link A} of {@link n} samples.
     */static choice(t,e,r=1212){return new Randomizer(r).choice(t,e);
/* let rows = A.shape[0];
        if (n > rows) {
            throw new Error("n bigger than A!");
        }
        let rand = new Randomizer(seed);
        let sample = new Array(n);
        let index_list = linspace(0, rows - 1);
        for (let i = 0, l = index_list.length; i < n; ++i, --l) {
            let random_index = rand.random_int % l;
            sample[i] = index_list.splice(random_index, 1)[0];
        }
        //return result;
        //return new Matrix(n, cols, (row, col) => A.entry(sample[row], col))
        return sample.map((d) => A.row(d)); */}}
/**
 * Returns maximum in Array {@link values}.
 * @memberof module:utils
 * @alias max
 * @param {Array} values 
 * @returns {Number}
 */function max(t){let e;for(const r of t)null!=r&&(e<r||void 0===e&&r>=r)&&(e=r);return e}
/**
 * Returns maximum in Array {@link values}.
 * @memberof module:utils
 * @alias min
 * @param {Array} values
 * @returns {Number}
 */function min(t){let e;for(const r of t)null!=r&&(e>r||void 0===e&&r<=r)&&(e=r);return e}
/**
 * @class
 * @alias Heap
 */class Heap{
/**
     * A heap is a datastructure holding its elements in a specific way, so that the top element would be the first entry of an ordered list.
     * @constructor
     * @memberof module:datastructure
     * @alias Heap
     * @param {Array=} elements - Contains the elements for the Heap. {@link elements} can be null.
     * @param {Function} [accessor = (d) => d] - Function returns the value of the element.
     * @param {("min"|"max"|Function)} [comparator = "min"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. ("min" for a Min-Heap, "max" for a Max_heap)
     * @returns {Heap}
     * @see {@link https://en.wikipedia.org/wiki/Binary_heap}
     */
constructor(t=null,e=(t=>t),r="min"){return t?Heap.heapify(t,e,r):(this._accessor=e,this._container=[],this._comparator="min"==r?(t,e)=>t<e:"max"==r?(t,e)=>t>e:r,this)}
/**
     * Creates a Heap from an Array
     * @param {Array|Set} elements - Contains the elements for the Heap.
     * @param {Function=} [accessor = (d) => d] - Function returns the value of the element.
     * @param {(String=|Function)} [comparator = "min"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. ("min" for a Min-Heap, "max" for a Max_heap)
     * @returns {Heap}
     */static heapify(t,e=(t=>t),r="min"){const s=new Heap(null,e,r),i=s._container;for(const r of t)i.push({element:r,value:e(r)});for(let e=Math.floor(t.length/2-1);e>=0;--e)s._heapify_down(e);return s}
/**
     * Swaps elements of container array.
     * @private
     * @param {Number} index_a 
     * @param {Number} index_b 
     */_swap(t,e){const r=this._container;[r[e],r[t]]=[r[t],r[e]]}
/**
     * @private
     */_heapify_up(){const t=this._container;let e=t.length-1;for(;e>0;){let r=Math.floor((e-1)/2);if(!this._comparator(t[e].value,t[r].value))break;this._swap(r,e),e=r}}
/**
     * Pushes the element to the heap.
     * @param {} element
     * @returns {Heap}
     */push(t){const e={element:t,value:this._accessor(t)};
//const node = new Node(element, value);
return this._container.push(e),this._heapify_up(),this}
/**
     * @private
     * @param {Number} [start_index = 0] 
     */_heapify_down(t=0){const e=this._container,r=this._comparator,s=e.length;let i=2*t+1,n=2*t+2,o=t;if(o>s)throw"index higher than length";i<s&&r(e[i].value,e[o].value)&&(o=i),n<s&&r(e[n].value,e[o].value)&&(o=n),o!==t&&(this._swap(t,o),this._heapify_down(o))}
/**
     * Removes and returns the top entry of the heap.
     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).
     */pop(){const t=this._container;if(0===t.length)return null;if(1===t.length)return t.pop();this._swap(0,t.length-1);const e=t.pop();return this._heapify_down(),e}
/**
     * Returns the top entry of the heap without removing it.
     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).
     */get first(){return this._container.length>0?this._container[0]:null}
/**
     * Yields the raw data
     * @yields {Object} Object consists of the element and its value (computed by {@link accessor}).
     */*iterate(){for(let t=0,e=this._container.length;t<e;++t)yield this._container[t].element}
/**
     * Returns the heap as ordered array.
     * @returns {Array} Array consisting the elements ordered by {@link comparator}.
     */toArray(){return this.data().sort(((t,e)=>this._comparator(t,e)?-1:0))}
/**
     * Returns elements of container array.
     * @returns {Array} Array consisting the elements.
     */data(){return this._container.map((t=>t.element))}
/**
     * Returns the container array.
     * @returns {Array} The container array.
     */raw_data(){return this._container}
/**
     * The size of the heap.
     * @returns {Number}
     */get length(){return this._container.length}
/**
     * Returns false if the the heap has entries, true if the heap has no entries.
     * @returns {Boolean}
     */get empty(){return 0===this.length}}
/**
 * @class
 * @alias DisjointSet
 * @see {@link https://en.wikipedia.org/wiki/Disjoint-set_data_structure}
 */class DisjointSet{
/**
     * @constructor
     * @alias DisjointSet
     * @memberof module:datastructure
     * @param {Array=} elements 
     * @returns {DisjointSet}
     */
constructor(t=null){if(this._list=new Set,t)for(const e of t)this.make_set(e);return this}make_set(t){const e=this._list;return e.has(t)||(e.add(t),t.__disjoint_set={},t.__disjoint_set.parent=t,t.__disjoint_set.children=new Set([t]),t.__disjoint_set.size=1),this}find(t){return this._list.has(t)?t.__disjoint_set.parent!==t?(t.__disjoint_set.children.add(...t),t.__disjoint_set.parent=this.find(t.__disjoint_set.parent),t.__disjoint_set.parent):t:null}union(t,e){let r=this.find(t),s=this.find(e);return r===s||(r.__disjoint_set.size<s.__disjoint_set.size&&([r,s]=[s,r]),s.__disjoint_set.parent=r,
// keep track of children?
s.__disjoint_set.children.forEach(r.__disjoint_set.children.add,r.__disjoint_set.children),r.__disjoint_set.size+=s.__disjoint_set.size),this}}
/**
 * @class
 * @alias BallTree
 */class BallTree{
/**
     * Generates a BallTree with given {@link elements}.
     * @constructor
     * @memberof module:knn
     * @alias BallTree
     * @param {Array=} elements - Elements which should be added to the BallTree
     * @param {Function} [metric = euclidean] metric to use: (a, b) => distance
     * @see {@link https://en.wikipedia.org/wiki/Ball_tree}
     * @see {@link https://github.com/invisal/noobjs/blob/master/src/tree/BallTree.js}
     * @returns {BallTree}
     */
constructor(t=null,e=euclidean){return this._Node=class{constructor(t,e=null,r=null,s=null){this.pivot=t,this.child1=e,this.child2=r,this.radius=s}},this._Leaf=class{constructor(t){this.points=t}},this._metric=e,t&&this.add(t),this}
/**
     * 
     * @param {Array<*>} elements - new elements.
     * @returns {BallTree}
     */add(t){return t=t.map(((t,e)=>({index:e,element:t}))),this._root=this._construct(t),this}
/**
     * @private
     * @param {Array<*>} elements 
     * @returns {Node} root of balltree.
     */_construct(t){if(1===t.length)return new this._Leaf(t);{let e,r=this._greatest_spread(t),s=t.sort(((t,e)=>t.element[r]-e.element[r])),i=s.length,n=Math.floor(i/2),o=t[n],a=s.slice(0,n),h=s.slice(n,i),l=Math.max(...t.map((t=>this._metric(o.element,t.element))));return e=a.length>0&&h.length>0?new this._Node(o,this._construct(a),this._construct(h),l):new this._Leaf(t),e}}
/**
     * @private
     * @param {Node} B 
     * @returns {Number}
     */_greatest_spread(t){let e=t[0].element.length,r=new Array(e);for(let t=0;t<e;++t)r[t]=[1/0,-1/0];let s=t.reduce(((t,r)=>{for(let s=0;s<e;++s)t[s][0]=Math.min(t[s][0],r.element[s]),t[s][1]=Math.max(t[s][1],r.element[s]);return t}),r);s=s.map((t=>t[1]-t[0]));let i=0;for(let t=0;t<e;++t)i=s[t]>s[i]?t:i;return i}
/**
     * 
     * @param {*} t - query element.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.
     */search(t,e=5){return this._search(t,e,new Heap(null,(e=>this._metric(e.element,t)),"max"),this._root)}
/**
     * @private
     * @param {*} t - query element.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @param {Heap} Q - Heap consists of the currently found {@link k} nearest neighbors.
     * @param {Node|Leaf} B 
     */_search(t,e,r,s){
// B is Node
if(r.length>=e&&s.pivot&&s.radius&&this._metric(t,s.pivot.element)-s.radius>=r.first.value)return r;
// B is leaf
if(s.child1&&this._search(t,e,r,s.child1),s.child2&&this._search(t,e,r,s.child2),s.points)for(let t=0,i=s.points.length;t<i;++t){let i=s.points[t];e>r.length?r.push(i):(r.push(i),r.pop())}return r}}
/**
 * @class
 * @alias KNN
 */class KNN{
/**
     * Generates a KNN list with given {@link elements}.
     * @constructor
     * @memberof module:knn
     * @alias KNN
     * @param {Array=} elements - Elements which should be added to the KNN list
     * @param {Function|"precomputed"} [metric = euclidean] metric is either precomputed or a function to use: (a, b) => distance
     * @returns {KNN}
     */
constructor(t=null,e=euclidean){this._metric=e,this._elements=t instanceof Matrix?t:Matrix.from(t);const r=this._elements.shape[0];this._D="precomputed"===e?this._elements.clone():distance_matrix(this._elements,e),this.KNN=[];for(let t=0;t<r;++t){const e=this._D.row(t),s=new Heap(null,(t=>t.value),"min");for(let t=0;t<r;++t)s.push({value:e[t],index:t});this.KNN.push(s)}}
/**
     * 
     * @param {Array|Number} t - query element or index.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.
     */search(t,e=5){const r=this._metric,s=this.KNN;let i;if(Array.isArray(t)){if("precomputed"==this._metric)throw"Search by query element is only possible when not using a precomputed distance matrix!";const e=this._elements,n=s.length;let o=null,a=1/0;for(let s=0;s<n;++s){const i=r(t,e.row(s));i<a&&(o=s,a=i)}i=s[o]}else Number.isInteger(t)&&(i=s[t]);let n=[];for(let t=0;t<e;++t)n.push(i.pop());return n.forEach((t=>i.push(t.element))),n}}
/**
 * @class
 * @alias DR
 * @borrows DR#parameter as DR#para
 * @borrows DR#parameter as DR#p
 */class DR{
//static parameter_list = [];
get parameter_list(){return this._parameter_list}set parameter_list(t){return this._parameter_list=t,this}
/**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias DR
     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.
     * @param {number} [d = 2] - the dimensionality of the projection.
     * @param {function} [metric = euclidean] - the metric which defines the distance between two points.
     * @param {seed} [seed = 1212] - the seed value for the random number generator.
     * @returns {DR}
     */constructor(t,e=2,r=euclidean,s=1212){if(Array.isArray(t))this._type="array",this.X=Matrix.from(t);else{if(!(t instanceof Matrix))throw new Error("no valid type for X");this._type="matrix",this.X=t}return[this._N,this._D]=this.X.shape,this._d=e,this._metric=r,this._seed=s,this._randomizer=new Randomizer(s),this._is_initialized=!1,this}
/**
     * Set and get parameters
     * @param {String} name - name of the parameter.
     * @param {Number} [value = null] - value of the parameter to set, if <code>value == null</code> then return actual parameter value.
     * @memberof DR
     */parameter(t,e=null){if(!this.parameter_list.includes(t))throw new Error(`${t} is not a valid parameter!`);return e?(this[`_${t}`]=e,this._is_initialized=!1,this):this[`_${t}`]}para(t,e=null){return this.parameter(t,e)}p(t,e=null){return this.parameter(t,e)}
/**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */transform(){return this.check_init(),this.projection}*generator(){return this.transform()}check_init(){this._is_initialized||"function"!=typeof this.init||(this.init(),this._is_initialized=!0)}
/**
     * @returns {Matrix} Returns the projection.
     */get projection(){return"matrix"===this._type?this.Y:this.Y.to2dArray}async transform_async(...t){return this.transform(...t)}static transform(...t){return new this(...t).transform()}static async transform_async(...t){return this.transform(...t)}static*generator(...t){const e=new this(...t).generator();for(const t of e)yield t}}
/**
 * @class
 * @alias PCA
 * @augments DR
 */class PCA extends DR{
/**
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias PCA
     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @returns {PCA}
     */
constructor(t,e=2){return super(t,e),this}
/**
     * Transforms the inputdata {@link X} to dimensionality {@link d}. If parameter {@link A} is given, then project {@link A} with the principal components of {@link X}.
     * @param {null|Matrix|Array} [A = null] - If given, the data to project.
     * @returns {Matrix|Array} - The projected data.
     */transform(t=null){const e=this.principal_components();if(null==t){const t=this.X;return this.Y=t.dot(e),this.projection}if(Array.isArray(t))return Matrix.from(t).dot(e).asArray;if(t instanceof Matrix)return t.dot(e);throw new Error("No valid type for A!")}
/**
     * Computes the {@link d} principal components of Matrix {@link X}.
     * @returns {Matrix}
     */principal_components(){if(this.V)return this.V;const t=this.X,e=Matrix.from(t.meanCols),r=t.sub(e),s=r.transpose().dot(r),{eigenvectors:i}=simultaneous_poweriteration(s,this._d);return this.V=Matrix.from(i).transpose(),this.V}}
/**
 * @class
 * @alias MDS
 * @extends DR
 */class MDS extends DR{
/**
     * Classical MDS.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias MDS
     * @param {Matrix} X - the high-dimensional data.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     */
constructor(t,e=2,r=euclidean,s=1212){return super(t,e,r,s),this}
/**
     * Transforms the inputdata {@link X} to dimensionality {@link d}.
     * @returns {Matrix|Array}
     */transform(){const t=this.X,e=t.shape[0],r=this._metric,s="precomputed"===r?t:distance_matrix(t,r),i=s.meanCols,n=s.meanRows,o=s.mean;this._d_X=s;const a=new Matrix(e,e,((t,e)=>s.entry(t,e)-i[t]-n[e]+o)),{eigenvectors:h}=simultaneous_poweriteration(a,this._d);return this.Y=Matrix.from(h).transpose(),this.projection}
/**
     * @returns {Number} - the stress of the projection.
     */stress(){const t=this.X.shape[0],e=this.Y,r=this._d_X,s=new Matrix;s.shape=[t,t,(t,r)=>t<r?euclidean(e.row(t),e.row(r)):s.entry(r,t)];let i=0,n=0;for(let e=0;e<t;++e)for(let o=e+1;o<t;++o)i+=Math.pow(r.entry(e,o)-s.entry(e,o),2),n+=Math.pow(r.entry(e,o),2);return Math.sqrt(i/n)}}
/**
 * @class
 * @alias ISOMAP
 * @extends DR
 */class ISOMAP extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias ISOMAP
     * @param {Matrix} X - the high-dimensional data. 
     * @param {Number} neighbors - the number of neighbors {@link ISOMAP} should use to project the data.
     * @param {Number} [d = 2] - the dimensionality of the projection. 
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points. 
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     */
constructor(t,e,r=2,s=euclidean,i=1212){return super(t,r,s,i),super.parameter_list=["k"],this.parameter("k",Math.min(e??Math.max(Math.floor(this.X.shape[0]/10),2),this._N-1)),this}
/**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */transform(){this.check_init();const t=this.X,e=this._N,r=this._metric,s=new Matrix;s.shape=[e,e,(e,i)=>e<=i?r(t.row(e),t.row(i)):s.entry(i,e)];const i=[];for(let t=0;t<e;++t){const r=[];for(let i=0;i<e;++i)r.push({index:i,distance:s.entry(t,i)});const n=new Heap(r,(t=>t.distance),"min");i.push(n.toArray().slice(1,this._k+1))}
/*D = dijkstra(kNearestNeighbors);*/
// compute shortest paths
// TODO: make extern
/** @see {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm} */const n=new Matrix(e,e,((t,e)=>{const r=i[t].find((t=>t.index===e));return r?r.distance:1/0}));for(let t=0;t<e;++t)for(let r=0;r<e;++r)for(let s=0;s<e;++s)n.set_entry(t,r,Math.min(n.entry(t,r),n.entry(t,s)+n.entry(s,r)));let o=new Float64Array(e),a=new Float64Array(e),h=0,l=new Matrix(e,e,((t,e)=>{let r=n.entry(t,e);return r=r===1/0?0:r,o[t]+=r,a[e]+=r,h+=r,r}));o=o.map((t=>t/e)),a=a.map((t=>t/e)),h/=e**2;const _=new Matrix(e,e,((t,e)=>l.entry(t,e)-o[t]-a[e]+h)),{eigenvectors:c}=simultaneous_poweriteration(_,this._d);
// compute d eigenvectors
// return embedding
return this.Y=Matrix.from(c).transpose(),this.projection}}
/**
 * @class
 * @alias FASTMAP
 * @extends DR
 */class FASTMAP extends DR{
/**
     * FastMap: a fast algorithm for indexing, data-mining and visualization of traditional and multimedia datasets
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias FASTMAP
     * @param {Matrix} X - the high-dimensional data. 
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @returns {FASTMAP}
     * @see {@link https://doi.org/10.1145/223784.223812}
     */
constructor(t,e=2,r=euclidean,s=1212){return super(t,e,r,s),this}
/**
     * Chooses two points which are the most distant in the actual projection.
     * @private
     * @param {function} dist 
     * @returns {Array} An array consisting of first index, second index, and distance between the two points.
     */_choose_distant_objects(t){const e=this.X.shape[0];let r=this._randomizer.random_int%e-1,s=null,i=-1/0;for(let n=0;n<e;++n){const e=t(r,n);e>i&&(i=e,s=n)}i=-1/0;for(let n=0;n<e;++n){const e=t(s,n);e>i&&(i=e,r=n)}return[r,s,i]}
/**
     * Computes the projection.
     * @returns {Matrix} The {@link d}-dimensional projection of the data matrix {@link X}.
     */transform(){const t=this.X,e=t.shape[0],r=this._d,s=this._metric,i=new Matrix(e,r,0);let dist=(e,r)=>s(t.row(e),t.row(r));for(let t=0;t<r;++t){let r=dist;
// choose pivot objects
const[s,n,o]=this._choose_distant_objects(dist);
// record id of pivot objects
//PA[0].push(a_index);
//PA[1].push(b_index);
/* if (d_ab === 0) {
                // because all inter-object distances are zeros
                for (let i = 0; i < N; ++i) {
                    Y.set_entry(i, _col, 0);
                }
            } else { */if(0!==o){
// project the objects on the line (O_a, O_b)
for(let r=0;r<e;++r){const e=(dist(s,r)**2+o**2-dist(n,r)**2)/(2*o);i.set_entry(r,t,e)}
// consider the projections of the objects on a
// hyperplane perpendicluar to the line (a, b);
// the distance function D'() between two 
// projections is given by Eq.4
dist=(e,s)=>Math.sqrt(r(e,s)**2-(i.entry(e,t)-i.entry(s,t))**2)}}
// return embedding
return this.Y=i,this.projection}}
/**
 * @class
 * @alias LDA
 * @extends DR
 */class LDA extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LDA
     * @param {Matrix} X - the high-dimensional data.
     * @param {Array} labels - the label / class of each data point.
     * @param {number} [d = 2] - the dimensionality of the projection.
     * @param {function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     */
constructor(t,e,r=2,s=euclidean,i=1212){return super(t,r,s,i),super.parameter_list=["labels"],this.parameter("labels",e),this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){let t=this.X,[e,r]=t.shape,s=this._labels,i={},n=0;s.forEach(((e,r)=>{e in i?(i[e].count++,i[e].rows.push(t.row(r))):i[e]={id:n++,count:1,rows:[t.row(r)]}}));
// create X_mean and vector means;
let o=t.mean,a=new Matrix(n,r);for(let t in i){let e=Matrix.from(i[t].rows).meanCols;for(let s=0;s<r;++s)a.set_entry(i[t].id,s,e[s])}
// scatter_between
let h=new Matrix(r,r);for(let t in i){let e=a.row(i[t].id),s=new Matrix(r,1,(t=>e[t]-o)),n=i[t].count;h=h.add(s.dot(s.transpose()).mult(n))}
// scatter_within
let l=new Matrix(r,r);for(let t in i){let e=a.row(i[t].id),s=new Matrix(r,1,(t=>e[t])),n=i[t].rows;for(let e=0,o=i[t].count;e<o;++e){let t=new Matrix(r,1,((t,r)=>n[e][t]-s.entry(t,0)));l=l.add(t.dot(t.transpose()))}}let{eigenvectors:_}=simultaneous_poweriteration(l.inverse().dot(h),this._d);
// return embedding
return _=Matrix.from(_).transpose(),this.Y=t.dot(_),this.projection}}
/**
 * @class
 * @alias LLE
 * @extends DR
 */class LLE extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LLE
     * @param {Matrix} X - the high-dimensional data.
     * @param {Number} neighbors - the label / class of each data point.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     */
constructor(t,e,r=2,s=euclidean,i=1212){return super(t,r,s,i),super.parameter_list=["k"],this.parameter("k",Math.min(e??Math.max(Math.floor(this._N/10),2),this._N-1)),this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,e=this._d,r=this._N,s=this._D,i=this.parameter("k"),n=k_nearest_neighbors(t,i,null,this._metric),o=new Matrix(i,1,1),a=new Matrix(r,r);for(let e=0;e<r;++e){const r=n[e],h=new Matrix(i,s,((s,i)=>t.entry(r[s].j,i)-t.entry(e,i))),l=h.dot(h.T);if(i>s){const t=neumair_sum(l.diag)/1e3;for(let e=0;e<i;++e)l.set_entry(e,e,l.entry(e,e)+t)}
// reconstruct;
let _=Matrix.solve_CG(l,o,this._randomizer);_=_.divide(_.sum);for(let t=0;t<i;++t)a.set_entry(e,r[t].j,_.entry(t,0))}
// comp embedding
const h=new Matrix(r,r,"identity").sub(a),l=h.T.dot(h),{eigenvectors:_}=simultaneous_poweriteration(l.T.inverse(),e+1);
// return embedding
return this.Y=Matrix.from(_.slice(1,1+e)).T,this.projection}}
/**
 * @class
 * @alias LTSA
 * @extends DR
 */class LTSA extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LTSA
     * @param {Matrix} X - the high-dimensional data.
     * @param {Number} neighbors - the label / class of each data point.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @see {@link https://epubs.siam.org/doi/abs/10.1137/S1064827502419154}
     */
constructor(t,e,r=2,s=euclidean,i=1212){if(super(t,r,s,i),super.parameter_list=["k"],this.parameter("k",Math.min(e??Math.max(Math.floor(this._N/10),2),this._N-1)),this._D<=r)throw`Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${r})!`;return this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,e=this._d,[r,s]=t.shape,i=this.parameter("k"),n=k_nearest_neighbors(t,i,null,this._metric),o=new Matrix(s,s,"center"),a=new Matrix(r,r,0);for(let s=0;s<r;++s){
// 1.2 compute the d largest eigenvectors of the correlation matrix
const r=[s,...n[s].map((t=>t.j))];let h=Matrix.from(r.map((e=>t.row(e))));
// center X_i
h=h.dot(o);
// correlation matrix
const l=h.dot(h.transpose()),{eigenvectors:_}=simultaneous_poweriteration(l,e),c=Matrix.from(_),u=c.transpose().dot(c).add(1/Math.sqrt(i+1));for(let t=0;t<i+1;++t)for(let e=0;e<i+1;++e)a.set_entry(r[t],r[e],a.entry(r[t],r[e])-(t===e?1:0)+u.entry(t,e))}
// 3. Aligning global coordinates
const{eigenvectors:h}=simultaneous_poweriteration(a,e+1);
// return embedding
return this.Y=Matrix.from(h.slice(1)).transpose(),this.projection}}
/**
 * @class
 * @alias TSNE
 * @extends DR
 */class TSNE extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TSNE
     * @param {Matrix} X - the high-dimensional data. 
     * @param {Number} [perplexity = 50] - perplexity.
     * @param {Number} [epsilon = 10] - learning parameter.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @returns {TSNE}
     */
constructor(t,e=50,r=10,s=2,i=euclidean,n=1212){return super(t,s,i,n),super.parameter_list=["perplexity","epsilon"],[this._N,this._D]=this.X.shape,this.parameter("perplexity",Math.min(e,this._N-1)),this.parameter("epsilon",r),this._iter=0,this.Y=new Matrix(this._N,this._d,(()=>this._randomizer.random)),this}
/**
     * 
     * @param {Matrix} distance_matrix - accepts a precomputed distance matrix
     * @returns {TSNE}
     */init(t=null){
// init
const e=Math.log(this._perplexity),r=this._N,s=this._D,i=this._metric,n=this.X;let o;if(t)o=t;else{o=new Matrix(r,r);for(let t=0;t<r;++t){const e=n.row(t);for(let s=t+1;s<r;++s){const r=i(e,n.row(s));o.set_entry(t,s,r),o.set_entry(s,t,r)}}}const a=new Matrix(r,r,"zeros");this._ystep=new Matrix(r,s,"zeros"),this._gains=new Matrix(r,s,1);
// search for fitting sigma
let h=new Array(r).fill(0);for(let t=0;t<r;++t){let s=-1/0,i=1/0,n=1,l=!1,_=0;for(;!l;){let a=0;for(let e=0;e<r;++e){let r=Math.exp(-o.entry(t,e)*n);t===e&&(r=0),h[e]=r,a+=r}let c=0;for(let t=0;t<r;++t){let e=0===a?0:h[t]/a;h[t]=e,e>1e-7&&(c-=e*Math.log(e))}c>e?(s=n,n=i===1/0?2*n:(n+i)/2):(i=n,n=s===-1/0?n/2:(n+s)/2),++_,Math.abs(c-e)<1e-4&&(l=!0),_>=50&&(l=!0)}for(let e=0;e<r;++e)a.set_entry(t,e,h[e])}
//compute probabilities
const l=new Matrix(r,r,"zeros"),_=2*r;for(let t=0;t<r;++t)for(let e=t;e<r;++e){const r=Math.max((a.entry(t,e)+a.entry(e,t))/_,1e-100);l.set_entry(t,e,r),l.set_entry(e,t,r)}return this._P=l,this}
/**
     * 
     * @param {Number} [iterations=500] - number of iterations.
     * @yields {Matrix|Array<Array>} - the projection.
     */transform(t=500){this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}
/**
     * 
     * @param {Number} [iterations=500] - number of iterations.
     * @yields {Matrix|Array<Array>} - the projection.
     */*generator(t=500){this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}
/**
     * performs a optimization step
     * @private
     * @returns {Matrix}
     */next(){const t=++this._iter,e=this._P,r=this._ystep,s=this._gains,i=this._N,n=this._epsilon,o=this._d;let a=this.Y;
//calc cost gradient;
const h=t<100?4:1,l=new Matrix(i,i,"zeros");
// compute Q dist (unnormalized)
let _=0;for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){let r=0;for(let s=0;s<o;++s){const i=a.entry(t,s)-a.entry(e,s);r+=i*i}const s=1/(1+r);l.set_entry(t,e,s),l.set_entry(e,t,s),_+=2*s}
// normalize Q dist
const c=new Matrix(i,i,0);for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){const r=Math.max(l.entry(t,e)/_,1e-100);c.set_entry(t,e,r),c.set_entry(e,t,r)}const u=new Matrix(i,o,"zeros");for(let t=0;t<i;++t)for(let r=0;r<i;++r){const s=4*(h*e.entry(t,r)-c.entry(t,r))*l.entry(t,r);for(let e=0;e<o;++e)u.set_entry(t,e,u.entry(t,e)+s*(a.entry(t,e)-a.entry(r,e)))}
// perform gradient step
let f=new Float64Array(o);for(let e=0;e<i;++e)for(let i=0;i<o;++i){const o=u.entry(e,i),h=r.entry(e,i),l=s.entry(e,i);let _=Math.sign(o)===Math.sign(h)?.8*l:l+.2;_<.01&&(_=.01),s.set_entry(e,i,_);const c=(t<250?.5:.8)*h-n*_*o;r.set_entry(e,i,c),a.set_entry(e,i,a.entry(e,i)+c),f[i]+=a.entry(e,i)}for(let t=0;t<i;++t)for(let e=0;e<2;++e)a.set_entry(t,e,a.entry(t,e)-f[e]/i);return this.Y}}
/**
 *
 * @memberof module:optimization
 * @alias powell
 * @param {Function} f
 * @param {Array} x0
 * @param {Number} [max_iter = 300]
 * @returns {Array}
 * @see http://optimization-js.github.io/optimization-js/optimization.js.html#line438
 */function powell(t,e,r=300){const s=e.length;let i=.001,n=1e4,o=e.slice(),a=t(o),h=!1;for(;r-- >=0&&!h;){h=!0;for(let e=0;e<s;++e){o[e]+=1e-6;let r=t(o);o[e]-=1e-6;let s=(r-a)/1e-6;Math.abs(s)>.01&&(h=!1),o[e]-=i*s,a=t(o)}i*=n>=a?1.05:.4,n=a}return o}
/**
 * @class
 * @alias UMAP
 * @extends DR
 */class UMAP extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias UMAP
     * @param {Matrix} X - the high-dimensional data. 
     * @param {Number} [n_neighbors = 15] - size of the local neighborhood.
     * @param {Number} [local_connectivity = 1] - number of nearest neighbors connected in the local neighborhood.
     * @param {Number} [min_dist = 1] - controls how tightly points get packed together.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points in the high-dimensional space.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @returns {UMAP}
     */
constructor(t,e=15,r=1,s=1,i=2,n=euclidean,o=1212){return super(t,i,n,o),super.parameter_list=["n_neighbors","local_connectivity","min_dist"],[this._N,this._D]=this.X.shape,e=Math.min(this._N-1,e),this.parameter("n_neighbors",e),this.parameter("local_connectivity",Math.min(r,e-1)),this.parameter("min_dist",s),this._iter=0,this._spread=1,this._set_op_mix_ratio=1,this._repulsion_strength=1,this._negative_sample_rate=5,this._n_epochs=350,this._initial_alpha=1,this.Y=new Matrix(this._N,this._d,(()=>this._randomizer.random)),this}
/**
     * @private
     * @param {Number} spread 
     * @param {Number} min_dist 
     * @returns {Array}
     */_find_ab_params(t,e){const r=linspace(0,3*t,300),s=linspace(0,3*t,300);for(let i=0,n=r.length;i<n;++i){const n=r[i];s[i]=n<e?1:Math.exp(-(n-e)/t)}return powell((t=>{const e=linspace(1,300).map(((e,i)=>{return s[i]-(n=r[i],o=t[0],a=t[1],1/(1+o*Math.pow(n,2*a)));var n,o,a}));return Math.sqrt(neumair_sum(e.map((t=>t*t))))}),[1,1])}
/**
     * @private
     * @param {Array<Array>} distances 
     * @param {Array<Number>} sigmas 
     * @param {Array<Number>} rhos 
     * @returns {Array}
     */_compute_membership_strengths(t,e,r){for(let s=0,i=t.length;s<i;++s)for(let i=0,n=t[s].length;i<n;++i){const n=t[s][i].value-r[s];t[s][i].value=n>0?Math.exp(-n/e[s]):1}return t}
/**
     * @private
     * @param {KNN|BallTree} knn 
     * @param {Number} k 
     * @returns {Object}
     */_smooth_knn_dist(t,e){const r=1e-5,s=.001,i=this._local_connectivity,n=Math.log2(e),o=[],a=[],h=this.X,l=h.shape[0],_=[];if("precomputed"===this._metric)for(let r=0;r<l;++r)_.push(t.search(r,e).reverse());else for(const r of h)_.push(t.search(r,e).raw_data().reverse());for(let t=0;t<l;++t){let h=0,l=1/0,c=1;const u=_[t],f=u.filter((t=>t.value>0)),d=f.length;if(d>=i){const e=Math.floor(i),s=i-e;e>0?(o.push(f[e-1]),s>r&&(o[t].value+=s*(f[e].value-f[e-1]))):o[t].value=s*f[0].value}else d>0&&(o[t]=f[d-1].value);for(let s=0;s<64;++s){let s=0;for(let r=0;r<e;++r){const e=u[r].value-o[t];s+=e>0?Math.exp(-e/c):1}if(Math.abs(s-n)<r)break;s>n?[l,c]=[c,(h+l)/2]:[h,c]=l===1/0?[c,2*c]:[c,(h+l)/2]}a[t]=c;const p=u.reduce(((t,e)=>t+e.value),0)/u.length;
//let mean_d = null;
if(o[t]>0)a[t]<s*p&&(a[t]=s*p);else{const e=_.reduce(((t,e)=>t+e.reduce(((t,e)=>t+e.value),0)/e.length));a[t]>s*e&&(a[t]=s*e)}}return{distances:_,sigmas:a,rhos:o}}
/**
     * @private
     * @param {Matrix} X 
     * @param {Number} n_neighbors 
     * @returns {Matrix}
     */_fuzzy_simplicial_set(t,e){const r=t.shape[0],s=this._metric,i="precomputed"===s?new KNN(t,"precomputed"):new BallTree(t.to2dArray,s);let{distances:n,sigmas:o,rhos:a}=this._smooth_knn_dist(i,e);n=this._compute_membership_strengths(n,o,a);const h=new Matrix(r,r,"zeros");for(let t=0;t<r;++t){const e=n[t];for(let r=0;r<e.length;++r)h.set_entry(t,e[r].element.index,e[r].value)}const l=h.T,_=h.mult(l);return h.add(l).sub(_).mult(this._set_op_mix_ratio).add(_.mult(1-this._set_op_mix_ratio))}
/**
     * @private
     * @param {Number} n_epochs 
     * @returns {Array}
     */_make_epochs_per_sample(t){const e=this._weights,r=new Float32Array(e.length).fill(-1),s=max(e),i=e.map((e=>t*(e/s)));for(let e=0;e<r.length;++e)i[e]>0&&(r[e]=Math.round(t/i[e]));return r}
/**
     * @private
     * @param {Matrix} graph 
     * @returns {Object}
     */_tocoo(t){const e=[],r=[],s=[],[i,n]=t.shape;for(let o=0;o<i;++o)for(let i=0;i<n;++i){const n=t.entry(o,i);0!==n&&(e.push(o),r.push(i),s.push(n))}return{rows:e,cols:r,data:s}}
/**
     * Computes all necessary 
     * @returns {UMAP}
     */init(){const[t,e]=this._find_ab_params(this._spread,this._min_dist);this._a=t,this._b=e,this._graph=this._fuzzy_simplicial_set(this.X,this._n_neighbors);const{rows:r,cols:s,data:i}=this._tocoo(this._graph);return this._head=r,this._tail=s,this._weights=i,this._epochs_per_sample=this._make_epochs_per_sample(this._n_epochs),this._epochs_per_negative_sample=this._epochs_per_sample.map((t=>t*this._negative_sample_rate)),this._epoch_of_next_sample=this._epochs_per_sample.slice(),this._epoch_of_next_negative_sample=this._epochs_per_negative_sample.slice(),this}set local_connectivity(t){this._local_connectivity=t}get local_connectivity(){return this._local_connectivity}set min_dist(t){this._min_dist=t}get min_dist(){return this._min_dist}graph(){return this.check_init(),{cols:this._head,rows:this._tail,weights:this._weights}}
/**
     * 
     * @param {Number} [iterations=350] - number of iterations.
     * @returns {Matrix|Array}
     */transform(t=350){this._n_epochs!=t&&(this._n_epochs=t,this.init()),this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}
/**
     * 
     * @param {Number} [iterations=350] - number of iterations.
     * @returns {Matrix|Array}
     */*generator(t=350){this._n_epochs!=t&&(this._n_epochs=t,this.init()),this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}
/**
     * @private
     * @param {Number} x 
     * @returns {Number}
     */_clip(t){return t>4?4:t<-4?-4:t}
/**
     * performs the optimization step.
     * @private
     * @param {Matrix} head_embedding 
     * @param {Matrix} tail_embedding 
     * @param {Matrix} head 
     * @param {Matrix} tail 
     * @returns {Matrix}
     */_optimize_layout(t,e,r,s){const{_d:i,_alpha:n,_repulsion_strength:o,_a:a,_b:h,_epochs_per_sample:l,_epochs_per_negative_sample:_,_epoch_of_next_negative_sample:c,_epoch_of_next_sample:u,_clip:f}=this,d=s.length;for(let p=0,m=l.length;p<m;++p)if(u[p]<=this._iter){const m=r[p],y=s[p],w=t.row(m),g=e.row(y),x=euclidean_squared(w,g);let M=0;x>0&&(M=-2*a*h*Math.pow(x,h-1)/(a*Math.pow(x,h)+1));for(let r=0;r<i;++r){const s=f(M*(w[r]-g[r]))*n,i=w[r]+s,o=g[r]-s;w[r]=i,g[r]=o,t.set_entry(m,r,i),e.set_entry(y,r,o)}u[p]+=l[p];const A=(this._iter-c[p])/_[p];for(let r=0;r<A;++r){const r=Math.floor(this._randomizer.random*d),l=e.row(s[r]),_=euclidean_squared(w,l);let c=0;if(_>0)c=2*o*h/((.01+_)*(a*Math.pow(_,h)+1));else if(m===r)continue;for(let o=0;o<i;++o){const i=f(c*(w[o]-l[o]))*n,a=w[o]+i,h=l[o]-i;w[o]=a,l[o]=h,t.set_entry(m,o,a),e.set_entry(s[r],o,h)}}c[p]+=A*_[p]}return t}
/**
     * @private
     * @returns {Matrix}
     */next(){let t=++this._iter,e=this.Y;return this._alpha=this._initial_alpha*(1-t/this._n_epochs),this.Y=this._optimize_layout(e,e,this._head,this._tail),this.Y}}
/**
 * @class
 * @alias TriMap
 * @extends DR
 */class TriMap extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TriMap
     * @param {Matrix} X - the high-dimensional data. 
     * @param {Number} [weight_adj = 500] - scaling factor.
     * @param {Number} [c = 5] - number of triplets multiplier.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @returns {TriMap}
     * @see {@link https://arxiv.org/pdf/1910.00204v1.pdf}
     * @see {@link https://github.com/eamid/trimap}
     */
constructor(t,e=500,r=5,s=2,i=euclidean,n=1212){return super(t,s,i,n),super.parameter_list=["weight_adj","c"],this.parameter("weight_adj",e),this.parameter("c",r),this}
/**
     * 
     * @param {Matrix} [pca = null] - Initial Embedding (if null then PCA gets used). 
     * @param {KNN} [knn = null] - KNN Object (if null then BallTree gets used). 
     */init(t=null,e=null){const r=this.X,s=r.shape[0],i=this._d,n=this._metric,o=this._c;this.n_inliers=2*o,this.n_outliers=1*o,this.n_random=1*o,this.Y=t||new PCA(r,i).transform(),//.mult(.01);
this.knn=e||new BallTree(r.to2dArray,n);const{triplets:a,weights:h}=this._generate_triplets(this.n_inliers,this.n_outliers,this.n_random);return this.triplets=a,this.weights=h,this.lr=1e3*s/a.shape[0],this.C=1/0,this.tol=1e-7,this.vel=new Matrix(s,i,0),this.gain=new Matrix(s,i,1),this}
/**
     * Generates {@link n_inliers} x {@link n_outliers} x {@link n_random} triplets.
     * @param {Number} n_inliers 
     * @param {Number} n_outliers 
     * @param {Number} n_random 
     */_generate_triplets(t,e,r){const s=this._metric,i=this._weight_adj,n=this.X,o=n.shape[0],a=this.knn,h=Math.min(t+20,o),l=new Matrix(o,h),_=new Matrix(o,h);for(let t=0;t<o;++t)a.search(n.row(t),h+1).raw_data().filter((t=>0!=t.value)).sort(((t,e)=>t.value-e.value)).forEach(((e,r)=>{l.set_entry(t,r,e.element.index),_.set_entry(t,r,e.value)}));
// scale parameter
const c=new Float64Array(o);for(let t=0;t<o;++t)c[t]=Math.max((_.entry(t,3)+_.entry(t,4)+_.entry(t,5)+_.entry(t,6))/4,1e-10);const u=this._find_p(_,c,l);let f=this._sample_knn_triplets(u,l,t,e),d=f.shape[0];const p=new Float64Array(d);for(let t=0;t<d;++t){const e=f.entry(t,0),r=f.entry(t,2);p[t]=s(n.row(e),n.row(r))}let m=this._find_weights(f,u,l,p,c);if(r>0){const{random_triplets:t,random_weights:e}=this._sample_random_triplets(n,r,c);f=f.concat(t,"vertical"),m=Float64Array.from([...m,...e])}d=f.shape[0];let y=-1/0;for(let t=0;t<d;++t)isNaN(m[t])&&(m[t]=0),y<m[t]&&(y=m[t]);let w=-1/0;for(let t=0;t<d;++t)m[t]/=y,m[t]+=1e-4,m[t]=Math.log(1+i*m[t]),w<m[t]&&(w=m[t]);for(let t=0;t<d;++t)m[t]/=w;return{triplets:f,weights:m}}
/**
     * Calculates the similarity matrix P
     * @private
     * @param {Matrix} knn_distances - matrix of pairwise knn distances
     * @param {Float64Array} sig - scaling factor for the distances
     * @param {Matrix} nbrs - nearest neighbors
     * @returns {Matrix} pairwise similarity matrix
     */_find_p(t,e,r){const[s,i]=t.shape;return new Matrix(s,i,((s,i)=>Math.exp(-(t.entry(s,i)**2)/e[s]/e[r.entry(s,i)])))}
/**
     * Sample nearest neighbors triplets based on the similarity values given in P.
     * @private
     * @param {Matrix} P - Matrix of pairwise similarities between each point and its neighbors given in matrix nbrs.
     * @param {Matrix} nbrs - Nearest neighbors indices for each point. The similarity values are given in matrix {@link P}. Row i corresponds to the i-th point.
     * @param {Number} n_inliers - Number of inlier points.
     * @param {Number} n_outliers - Number of outlier points.
     * 
     */_sample_knn_triplets(t,e,r,s){const i=e.shape[0],n=new Matrix(i*r*s,3);for(let o=0;o<i;++o){let a=o*r*s;const h=this.__argsort(t.row(o).map((t=>-t)));for(let t=0;t<r;++t){let r=t*s;const l=e.entry(o,h[t]),_=this._rejection_sample(s,i,h.slice(0,t+1));for(let t=0;t<s;++t){const e=a+r+t,s=_[t];n.set_entry(e,0,o),n.set_entry(e,1,l),n.set_entry(e,2,s)}}}return n}
/**
     * Should do the same as np.argsort()
     * @private
     * @param {Array} A 
     */__argsort(t){return t.map(((t,e)=>({d:t,i:e}))).sort(((t,e)=>t.d-e.d)).map((t=>t.i))}
/**
     * Samples {@link n_samples} integers from a given interval [0, {@link max_int}] while rejection the values that are in the {@link rejects}.
     * @private
     * @param {*} n_samples 
     * @param {*} max_int 
     * @param {*} rejects 
     */_rejection_sample(t,e,r){const s=this._randomizer,i=linspace(0,e-1).filter((t=>r.indexOf(t)<0));return s.choice(i,Math.min(t,i.length-2))}
/**
     * Calculates the weights for the sampled nearest neighbors triplets
     * @private
     * @param {Matrix} triplets - Sampled Triplets.
     * @param {Matrix} P - Pairwise similarity matrix.
     * @param {Matrix} nbrs - nearest Neighbors
     * @param {Float64Array} outlier_distances - Matrix of pairwise outlier distances
     * @param {Float64Array} sig - scaling factor for the distances.
     */_find_weights(t,e,r,s,i){const n=t.shape[0],o=new Float64Array(n);for(let a=0;a<n;++a){const n=t.entry(a,0),h=r.row(n).indexOf(t.entry(a,1)),l=e.entry(n,h);let _=Math.exp(-(s[a]**2)/(i[n]*i[t.entry(a,2)]));_<1e-20&&(_=1e-20),o[a]=l/_}return o}
/**
     * Sample uniformly ranom triplets
     * @private
     * @param {Matrix} X - Data matrix.
     * @param {Number} n_random - Number of random triplets per point
     * @param {Float64Array} sig - Scaling factor for the distances
     */_sample_random_triplets(t,e,r){const s=this._metric,i=this._randomizer,n=t.shape[0],o=new Matrix(n*e,3),a=new Float64Array(n*e);for(let h=0;h<n;++h){const l=h*e,_=[...linspace(0,h-1),...linspace(h+1,n-1)];for(let n=0;n<e;++n){let[e,c]=i.choice(_,2),u=Math.exp(-(s(t.row(h),t.row(e))**2)/(r[h]*r[e]));u<1e-20&&(u=1e-20);let f=Math.exp(-(s(t.row(h),t.row(c))**2)/(r[h]*r[c]));f<1e-20&&(f=1e-20),u<f&&([e,c]=[c,e],[u,f]=[f,u]);const d=l+n;o.set_entry(d,0,h),o.set_entry(d,1,e),o.set_entry(d,2,c),a[d]=u/f}}return{random_triplets:o,random_weights:a}}
/**
     * Computes the gradient for updating the embedding.
     * @param {Matrix} Y - The embedding
     */_grad(t){const e=this.n_inliers,r=this.n_outliers,s=this.triplets,i=this.weights,[n,o]=t.shape,a=s.shape[0],h=new Matrix(n,o,0);let l=new Array(o).fill(0),_=new Array(o).fill(0),c=1,u=1,f=0,d=0;const p=n*e*r;for(let e=0;e<a;++e){const[n,a,m]=s.row(e);
// update y_ij, y_ik, d_ij, d_ik
if(e%r==0||e>=p){c=1,u=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(a,e),i=t.entry(m,e);l[e]=r-s,_[e]=r-i,c+=l[e]**2,u+=_[e]**2}
// update y_ik and d_ik only
}else{u=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(m,e);_[e]=r-s,u+=_[e]**2}}c>u&&++f,d+=i[e]/(1+u/c);const y=(i[e]/(c+u))**2;for(let t=0;t<o;++t){const e=l[t]*u*y,r=_[t]*c*y;h.set_entry(n,t,h.entry(n,t)+e-r),h.set_entry(a,t,h.entry(a,t)-e),h.set_entry(m,t,h.entry(m,t)+r)}}return{grad:h,loss:d,n_viol:f}}
/**
     * 
     * @param {Number} max_iteration 
     */transform(t=400){this.check_init();for(let e=0;e<t;++e)this._next(e);return this.projection}
/**
     * @yields {Matrix}
     * @returns {Matrix}
     */*generator(){this.check_init();for(let t=0;t<800;++t)this._next(t),yield this.projection;return this.projection}
/**
     * Does the iteration step.
     * @private
     * @param {Number} iter 
     */_next(t){const e=t>150?.5:.3,r=this.C,s=this.vel,i=this.Y.add(s.mult(e)),{grad:n,loss:o,n_viol:a}=this._grad(i);return this.C=o,this.Y=this._update_embedding(i,t,n),this.lr*=r>o+this.tol?1.01:.9,this.Y}
/**
     * Updates the embedding.
     * @private
     * @param {Matrix} Y 
     * @param {Number} iter 
     * @param {Matrix} grad 
     */_update_embedding(t,e,r){const[s,i]=t.shape,n=e>150?.9:.5,o=this.gain,a=this.vel,h=this.lr;for(let e=0;e<s;++e)for(let s=0;s<i;++s){const i=Math.sign(a.entry(e,s))!=Math.sign(r.entry(e,s))?o.entry(e,s)+.2:Math.max(.8*o.entry(e,s),.01);o.set_entry(e,s,i),a.set_entry(e,s,n*a.entry(e,s)-h*o.entry(e,s)*r.entry(e,s)),t.set_entry(e,s,t.entry(e,s)+a.entry(e,s))}return t}}
/**
 * @class
 * @alias Hierarchical_Clustering
 */class Hierarchical_Clustering{
/**
     * @constructor
     * @memberof module:clustering
     * @alias Hierarchical_Clustering
     * @todo needs restructuring.
     * @param {Matrix} - Data or distance matrix if metric is 'precomputed'
     * @param {("single"|"complete"|"average")} [linkage = "complete"]
     * @param {Function|"precomputed"} [metric = euclidean]
     * @returns {Hierarchical_Clustering}
     */
constructor(t,e="complete",r=euclidean){if(this._id=0,this._matrix=t instanceof Matrix?t:Matrix.from(t),this._metric=r,this._linkage=e,"precomputed"===r&&this._matrix.shape[0]!==this._matrix.shape[1])throw new Error("If metric is 'precomputed', then matrix has to be square!");return this.init(),this.root=this.do(),this}
/**
     *
     * @param {Number} value - value where to cut the tree.
     * @param {("distance"|"depth")} [type = "distance"] - type of value.
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}.
     */get_clusters(t,e="distance"){let r,s=[];switch(e){case"distance":r=t=>t.dist;break;case"depth":r=t=>t.depth;break;default:throw new Error("invalid type")}return this._traverse(this.root,r,t,s),s}
/**
     * @private
     * @param {} node
     * @param {*} f
     * @param {*} value
     * @param {*} result
     */_traverse(t,e,r,s){e(t)<=r?s.push(t.leaves()):(this._traverse(t.left,e,r,s),this._traverse(t.right,e,r,s))}
/**
     * computes the tree.
     */init(){const t=this._metric,e=this._matrix,r=this._n=e.shape[0],s=this._d_min=new Float64Array(r);let i;if("precomputed"!==t){i=new Matrix(r,r,0);//new Array(n);
for(let n=0;n<r;++n){s[n]=0;
//distance_matrix[i] = new Float64Array(n);
for(let o=0;o<r;++o)i.set_entry(n,o,n===o?1/0:t(e.row(n),e.row(o))),i.entry(n,s[n])>i.entry(n,o)&&(s[n]=o)}}else{i=this._matrix.clone();for(let t=0;t<r;++t)for(let e=0;e<r;++e)t===e?i.set_entry(t,e,1/0):i.entry(t,s[t])>i.entry(t,e)&&(s[t]=e)}this._distance_matrix=i;const n=this._clusters=new Array(r),o=this._c_size=new Uint16Array(r);for(let t=0;t<r;++t)n[t]=[],n[t][0]=new Cluster(this._id++,null,null,0,e.row(t),t,1,0),o[t]=1;return this}
/**
     * computes the tree.
     */do(){const t=this._n,e=this._d_min,r=this._distance_matrix,s=this._clusters,i=this._c_size,n=this._linkage;let o=null;for(let a=0,h=t-1;a<h;++a){let a=0;for(let s=0;s<t;++s){let i=r.entry(s,e[s]);for(let n=s+1;n<t;++n)i>r.entry(s,n)&&(e[s]=n,i=r.entry(s,e[s]))}for(let s=0;s<t;++s)r.entry(s,e[s])<r.entry(a,e[a])&&(a=s);let h=e[a],l=s[a][0],_=s[h][0],c=l.isLeaf?[l.index]:l.index,u=_.isLeaf?[_.index]:_.index,f=c.concat(u),d=new Cluster(this._id++,l,_,r.entry(a,h),null,f);l.parent=d,_.parent=d,s[a].unshift(d),i[a]+=i[h];for(let e=0;e<t;++e){const t=r.entry(a,e),s=r.entry(h,e);let o;switch(n){case"single":o=Math.min(t,s);break;case"complete":o=Math.max(t,s);break;case"average":o=(i[a]*t+i[h]*s)/(i[a]+i[e])}r.set_entry(e,a,o),r.set_entry(a,e,o)}r.set_entry(a,a,1/0);for(let e=0;e<t;++e)r.set_entry(e,h,1/0),r.set_entry(h,e,1/0);
/* for (let j = 0; j < n; ++j) {
                if (d_min[j] === c2) {
                    d_min[j] = c1;
                }
                if (D.entry(c1, j) < D.entry(c1, d_min[c1])) {
                    d_min[c1] = j;
                }
            } */o=d}return o}}class Cluster{constructor(t,e,r,s,i,n,o,a){return this.id=t,this.left=e,this.right=r,this.dist=s,this.index=n,this.size=o??e.size+r.size,this.depth=a??1+Math.max(e.depth,r.depth),this.centroid=i??this._calculate_centroid(e,r),this.parent=null,this}_calculate_centroid(t,e){const r=t.size,s=e.size,i=t.centroid,n=e.centroid,o=this.size,a=t.centroid.length,h=new Float64Array(a);for(let t=0;t<a;++t)h[t]=(r*i[t]+s*n[t])/o;return h}get isLeaf(){return 0===this.depth}leaves(){if(this.isLeaf)return[this];const t=this.left,e=this.right;return(t.isLeaf?[t]:t.leaves()).concat(e.isLeaf?[e]:e.leaves())}descendants(){if(this.isLeaf)return[this];const t=this.left.descendants(),e=this.right.descendants();return t.concat(e).concat([this])}}
/**
 * @class
 * @alias KMeans
 */class KMeans{
/**
     * @constructor
     * @memberof module:clustering
     * @alias KMeans
     * @todo needs restructuring. 
     * @param {Matrix} matrix 
     * @param {Numbers} K 
     * @param {Function} [metric = euclidean] 
     * @param {Number} [seed = 1987]
     * @param {Boolean} [init = true]
     * @returns {KMeans}
     */
constructor(t,e,r=euclidean,s=1987,i=!0){this._metric=r,this._matrix=t,this._K=e;const[n,o]=t.shape;return this._N=n,this._D=o,e>n&&(e=n),this._randomizer=new Randomizer(s),this._clusters=new Array(n).fill(void 0),this._cluster_centroids=this._get_random_centroids(e),i&&this.init(e,this._cluster_centroids),this}
/**
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. 
     */get_clusters(){const t=this._K,e=this._clusters,r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>r[t].push(e))),r}
/**
     * @private
     * @param {Array} points 
     * @param {Array} candidates 
     */_furthest_point(t,e){const r=this._matrix,s=this._metric;let i=t.length;return Heap.heapify(e,(e=>{const n=r.row(e);let o=0;for(let e=0;e<i;++e)o+=s(n,t[e]);return o}),"max").pop().element}_get_random_centroids(t){const e=this._N,r=this._randomizer,s=this._matrix,i=new Array(t).fill(),n=linspace(0,e-1),o=r.random_int%(e-1);i[0]=s.row(o);const a=[o],h=Math.floor((e-t)/t);// / K
for(let e=1;e<t;++e){
// sampling + kmeans++ improvement?
const t=r.choice(n.filter((t=>-1==a.indexOf(t))),h),o=this._furthest_point(i.slice(0,e),t);a.push(o),i[e]=s.row(o)}return i}_iteration(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._metric,o=this._clusters;let a=!1;
// find nearest cluster centroid.
for(let s=0;s<r;++s){const r=i.row(s);let h=1/0,l=null;for(let s=0;s<e;++s){let e=n(t[s],r);e<h&&(h=e,l=s)}o[s]!==l&&(a=!0),o[s]=l}
// update cluster centroid
// reset cluster centroids to 0
for(let r=0;r<e;++r){const e=t[r];for(let t=0;t<s;++t)e[t]=0}
// compute centroid
return this._compute_centroid(t),{clusters_changed:a,cluster_centroids:t}}_compute_centroid(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._clusters,o=new Array(e).fill(0);for(let e=0;e<r;++e){const r=i.row(e),a=n[e];o[a]++;const h=t[a];for(let t=0;t<s;++t)h[t]+=r[t]}for(let r=0;r<e;++r){const e=o[r];t[r]=t[r].map((t=>t/e))}}
/**
     * Computes {@link K} clusters out of the {@link matrix}.
     * @param {Number} K - number of clusters.
     */init(t,e){t||(t=this._K),e||(e=this._get_random_centroids(t));let r=!1;do{const t=this._iteration(e);e=t.cluster_centroids,r=t.clusters_changed}while(r)}}
/**
 * @class
 * @alias KMedoids
 */class KMedoids{
/**
     * @constructor
     * @memberof module:clustering
     * @alias KMedoids
     * @todo needs restructuring. 
     * @param {Matrix} matrix - data matrix
     * @param {Numbers} K - number of clusters
     * @param {number} [max_iter=null] - maximum number of iterations. Default is 10 * Math.log10(N)
     * @param {Function} [metric = euclidean] - metric defining the dissimilarity 
     * @param {Number} [seed = 1212] - seed value for random number generator
     * @returns {KMedoids}
     * @see {@link https://link.springer.com/chapter/10.1007/978-3-030-32047-8_16} Faster k-Medoids Clustering: Improving the PAM, CLARA, and CLARANS Algorithms
     */
constructor(t,e,r=null,s=euclidean,i=1212){this._metric=s,this._matrix=t,this._A=this._matrix.to2dArray,this._K=e;const[n,o]=t.shape;return this._N=n,this._D=o,this._max_iter=r||10*Math.log10(n),this._distance_matrix=new Matrix(n,n,"zeros"),
/* for (let i = 1; i < N; ++i) {
            for (let j = i + 1; j < N; ++j) {
                let dist = metric(this._A[i], this._A[j]);
                this._distance_matrix.set_entry(i, j, dist);
                this._distance_matrix.set_entry(j, i, dist)
            }
        } */
e>n&&(e=n),this._randomizer=new Randomizer(i),this._clusters=new Array(n).fill(void 0),this._cluster_medoids=this._get_random_medoids(e),
//if (init) this.init(K, this._cluster_medoids);
this._is_initialized=!1,this}
/**
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. 
     */get_clusters(){const t=this._K,e=this._A;this._is_initialized||this.init(t,this._cluster_medoids);const r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>{r[this._nearest_medoid(t,e).index_nearest].push(e)})),r.medoids=this._cluster_medoids,r}async*generator(){const t=this._max_iter;yield this.get_clusters();let e=!1,r=0;do{e=this._iteration(),yield this.get_clusters()}while(!e&&++r<t)}
/**
     * Algorithm 1. FastPAM1: Improved SWAP algorithm
     */
/* _iteration_1() {
        const A = this._A;
        const N = this._N;
        const K = this._K;
        const medoids = this._cluster_medoids;
        let DeltaTD = 0;
        let m0 = null;
        let x0 = null;
        A.forEach((x_j, j) => {
            if (medoids.findIndex(m => m === j) < 0) {
                const nearest_medoid = this._nearest_medoid(x_j, j);
                const d_j = nearest_medoid.distance_nearest; // distance to current medoid
                const deltaTD = new Array(K).fill(-d_j); // change if making j a medoid
                A.forEach((x_o, o) => {
                    // disance to new medoid
                    const d_oj = this._get_distance(o, j, x_o, x_j);
                    const {
                        "index_nearest": n,
                        "distance_nearest": d_n,
                        "distance_second": d_s,
                    } = this._nearest_medoid(x_o, o); 
                    this._clusters[o] = n; // cached values
                    deltaTD[n] += Math.min(d_oj, d_s) - d_n; // loss change
                    if (d_oj < d_n) { // reassignment check
                        deltaTD.forEach((d_i, i) => {
                            if (n !== i) {
                                deltaTD[i] = d_i + d_oj - d_n; // update loss change
                            }
                        });
                    }
                });
                // choose best medoid i;
                const i = deltaTD
                    .map((d, i) => [d, i])
                    .sort((d1, d2) => d1[0] - d2[0])[0][1];
                const deltaTD_i = deltaTD[i];
                // store
                if (deltaTD_i < DeltaTD) {
                    DeltaTD = deltaTD_i;
                    m0 = i;
                    x0 = j;
                }
            }
        });

        if (DeltaTD >= 0) {
            return true // break loop if DeltaTD >= 0
        }
        // swap roles of medoid m and non-medoid x;
        medoids[m0] = x0;
        this._cluster_medoids = medoids;
        return false
    } */
/** Algorithm 2. FastPAM2: SWAP with multiple candidates
     * 
     */_iteration(){const t=this._A,e=this._K,r=this._cluster_medoids,s=t.map(((t,e)=>this._nearest_medoid(t,e))),i=new Array(e).fill(0),n=new Array(e).fill(null);
// stop if no improvements were found
if(t.forEach(((o,a)=>{if(r.findIndex((t=>t===a))<0){const r=s[a].distance_nearest,h=new Array(e).fill(-r);// distance to current medoid
// change if making j a medoid
t.forEach(((t,r)=>{if(a===r)return;const i=this._get_distance(r,a,t,o),{index_nearest:n,distance_nearest:l,distance_second:_}=s[r];// distance to new medoid
// loss change for x_o
// Reassignment check
if(// cached
h[n]+=Math.min(i,_)-l,i<l)
// update loss change
for(let t=0;t<e;++t)t!==n&&(h[t]+=i-l)})),
// remember best swap for i;
h.map(((t,e)=>[t,e])).filter((([t,e])=>t<i[e])).forEach((([t,e])=>{t<i[e]&&(i[e]=t,n[e]=a)}))}})),min(i)>=0)return!0;
// execute all improvements
for(;min(i)<0;){
// swap roles of medoid m_i and non_medoid xs_i
const e=i.map(((t,e)=>[t,e])).sort((([t],[e])=>t-e))[0][1];0==r.filter((t=>t==n[e])).length&&(r[e]=n[e]),
// disable the swap just performed
i[e]=0,
// recompute TD for remaining swap candidates
i.map(((t,e)=>[t,e])).filter((([t])=>t<0)).forEach((([n,o])=>{const a=t[o];let h=0;t.forEach(((t,i)=>{r.findIndex((t=>t!=o&&t==i))>=0||e!=o&&(s[i].index_nearest===r[o]?h+=Math.min(this._get_distance(i,o,t,a),s[i].distance_second)-s[i].distance_nearest:h+=Math.min(this._get_distance(i,o,t,a)-s[i].distance_nearest,0))})),i[o]=h}))}return this._cluster_medoids=r,!1}_get_distance(t,e,r=null,s=null){if(t===e)return 0;const i=this._distance_matrix,n=this._A,o=this._metric;let a=i.entry(t,e);return 0===a&&(a=o(r||n[t],s||n[e]),i.set_entry(t,e,a),i.set_entry(e,t,a)),a}_nearest_medoid(t,e){const r=this._cluster_medoids,s=this._A,[i,n]=r.map(((r,i)=>{const n=s[r];return[this._get_distance(e,r,t,n),i]})).sort(((t,e)=>t[0]-e[0]));return{distance_nearest:i[0],index_nearest:i[1],distance_second:n[0],index_second:n[1]}}
/**
     * Computes {@link K} clusters out of the {@link matrix}.
     * @param {Number} K - number of clusters.
     */init(t,e){t||(t=this._K),e||(e=this._get_random_medoids(t));const r=this._max_iter;let s=!1,i=0;do{s=this._iteration()}while(!s&&++i<r);return this}
/**
     * Algorithm 3. FastPAM LAB: Linear Approximate BUILD initialization.
     * @param {number} K - number of clusters
     * 
     */_get_random_medoids(t){const e=this._N,r=this._A,s=linspace(0,e-1),i=this._randomizer,n=Math.min(e,10+Math.ceil(Math.sqrt(e))),o=new Array(n).fill(1/0),a=[];
// first medoid
let h=1/0,l=i.choice(s,n);for(let t=0;t<n;++t){const e=l[t],s=r[e];for(let e=0;e<n;++e){if(e===t)continue;const i=r[l[e]];o[t]+=this._get_distance(t,e,s,i)}o[t]<h&&(h=o[t],// smallest distance sum
a.push(e))}
// other medoids
for(let e=1;e<t;++e){let t=1/0;l=i.choice(s.filter((t=>a.findIndex((e=>e===t))<0)),n);for(let e=0;e<n;++e){let s=0;const i=l[e],o=r[i];for(let t=0;t<n;++t){if(t===e)continue;const n=l[t],h=r[n];let _=this._get_distance(i,n,o,h)-min(a.map((t=>this._get_distance(n,t,h))));_<0&&(s+=_)}
// best reduction
s<t&&(t=s,a.push(i))}h+=t}return a.slice(0,t)}}
/**
 * @class
 * @alias OPTICS
 */class OPTICS{
/**
     * **O**rdering **P**oints **T**o **I**dentify the **C**lustering **S**tructure.
     * @constructor
     * @memberof module:clustering
     * @alias OPTICS
     * @todo needs restructuring. 
     * @param {Matrix} matrix - the data.
     * @param {Number} epsilon - the minimum distance which defines whether a point is a neighbor or not.
     * @param {Number} min_points - the minimum number of points which a point needs to create a cluster. (Should be higher than 1, else each point creates a cluster.)
     * @param {Function} [metric = euclidean] - the distance metric which defines the distance between two points of the {@link matrix}.
     * @returns {OPTICS}
     * @see {@link https://www.dbs.ifi.lmu.de/Publikationen/Papers/OPTICS.pdf}
     * @see {@link https://en.wikipedia.org/wiki/OPTICS_algorithm}
     */
constructor(t,e,r,s=euclidean){return this._matrix=t,this._epsilon=e,this._min_points=r,this._metric=s,this._ordered_list=[],this._clusters=[],this._DB=new Array(t.shape[0]).fill(),this.init(),this}
/**
     * Computes the clustering.
     */init(){const t=this._ordered_list,e=this._matrix,r=e.shape[0],s=this._DB,i=this._clusters;let n=this._cluster_index=0;for(let t=0;t<r;++t)s[t]={element:e.row(t),index:t,reachability_distance:void 0,processed:!1};for(const e of s)if(!e.processed&&(e.neighbors=this._get_neighbors(e),e.processed=!0,i.push([e.index]),n=i.length-1,t.push(e),null!=this._core_distance(e))){const t=new Heap(null,(t=>t.reachability_distance),"min");this._update(e,t),this._expand_cluster(t,i[n])}return this}
/**
     * 
     * @private
     * @param {Object} p - a point of {@link matrix}.
     * @returns {Array} An array consisting of the {@link epsilon}-neighborhood of {@link p}.
     */_get_neighbors(t){if("neighbors"in t)return t.neighbors;const e=this._DB,r=this._metric,s=this._epsilon,i=[];for(const n of e)n.index!=t.index&&r(t.element,n.element)<s&&i.push(n);return i}
/**
     * 
     * @private
     * @param {Object} p - a point of {@link matrix}.
     * @returns {Number} The distance to the {@link min_points}-th nearest point of {@link p}, or undefined if the {@link epsilon}-neighborhood has fewer elements than {@link min_points}.
     */_core_distance(t){const e=this._min_points,r=this._metric;if(!(t.neighbors&&t.neighbors.length<=e))return r(t.element,t.neighbors[e].element)}
/**
     * Updates the reachability distance of the points.
     * @private
     * @param {Object} p 
     * @param {Heap} seeds 
     */_update(t,e){const r=this._metric,s=this._core_distance(t),i=this._get_neighbors(t);//p.neighbors;
for(const n of i){if(n.processed)continue;const i=Math.max(s,r(t.element,n.element));
//if (q.reachability_distance == undefined) { // q is not in seeds
e.raw_data().findIndex((t=>t.element==n))<0?(n.reachability_distance=i,e.push(n)):// q is in seeds
i<n.reachability_distance&&(n.reachability_distance=i,e=Heap.heapify(e.data(),(t=>t.reachability_distance),"min"))}}
/**
     * Expands the {@link cluster} with points in {@link seeds}.
     * @private
     * @param {Heap} seeds 
     * @param {Array} cluster 
     */_expand_cluster(t,e){const r=this._ordered_list;for(;!t.empty;){const s=t.pop().element;s.neighbors=this._get_neighbors(s),s.processed=!0,e.push(s.index),r.push(s),null!=this._core_distance(s)&&(this._update(s,t),this._expand_cluster(t,e))}}
/**
     * Returns an array of clusters.
     * @returns {Array<Array>} Array of clusters with the indices of the rows in given {@link matrix}.
     */get_clusters(){const t=[],e=[],r=this._min_points;for(const s of this._clusters)s.length<r?e.push(...s):t.push(s);return t.push(e),t}
/**
     * @returns {Array} Returns an array, where the ith entry defines the cluster affirmation of the ith point of {@link matrix}. (-1 stands for outlier)
     */get_cluster_affirmation(){const t=this._matrix.shape[0],e=new Array(t).fill(),r=this.get_clusters();for(let t=0,s=r.length;t<s;++t){const i=r[t];for(const r of i)e[r]=t<s-1?t:-1}return e}}
/**
 * @class
 * @alias LSP
 * @extends DR
 */class LSP extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LSP
     * @param {Matrix} X - the high-dimensional data. 
     * @param {number} [k = Math.max(Math.floor(N / 10), 2)] - number of neighbors to consider.
     * @param {number} [control_points = Math.ceil(Math.sqrt(N))] - number of controlpoints
     * @param {number} [d = 2] - the dimensionality of the projection.
     * @param {function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @returns {LSP}
     * @see {@link https://ieeexplore.ieee.org/document/4378370}
     */
constructor(t,e,r,s=2,i=euclidean,n=1212){return super(t,s,i,n),super.parameter_list=["k","control_points"],this.parameter("k",Math.min(e??Math.max(Math.floor(this._N/10),2),this._N-1)),this.parameter("control_points",Math.min(r??Math.ceil(Math.sqrt(this._N)),this._N-1)),this._is_initialized=!1,this}
/**
     * 
     * @param {DR} DR - method used for position control points.
     * @param {DR_parameters} DR_parameters - array containing parameters for the DR method which projects the control points
     * @returns {LSP} 
     */init(t=MDS,e=[],r=BallTree){if(this._is_initialized)return this;const s=this.X,i=this._N,n=this.parameter("k"),o=this._d,a=this._metric,h=this.parameter("control_points"),l=new KMedoids(s,h,null,a).get_clusters().medoids,_=new Matrix(h,i,"zeros");l.forEach(((t,e)=>{_.set_entry(e,t,1)}));const c=new t(Matrix.from(l.map((t=>s.row(t)))),...e,o).transform(),u=s.to2dArray,f=new r(u,a),d=new Matrix(i,i,"I"),p=-1/n;u.forEach(((t,e)=>{for(const{index:r}of f.search(t,n).iterate())e!==r&&d.set_entry(e,r,p)}));const m=d.concat(_,"vertical"),y=new Matrix(i,o,"zeros").concat(c,"vertical");return this._A=m,this._b=y,this._is_initialized=!0,this}
/**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */transform(){this.check_init();const t=this._A,e=t.T,r=this._b,s=e.dot(t),i=e.dot(r);return this.Y=Matrix.solve_CG(s,i,this._randomizer),this.projection}}
/**
 * @class
 * @alias TopoMap
 * @memberof module:dimensionality_reduction
 * @extends DR
 */class TopoMap extends DR{
/**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TopoMap
     * @param {Matrix} X - the high-dimensional data.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @returns {TopoMap}
     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}
     */
constructor(t,e=2,r=euclidean,s=1212){return super(t,e,r,s),super.parameter_list=[],[this._N,this._D]=this.X.shape,this._distance_matrix=new Matrix(this._N,this._N,0),this}
/**
     * @private
     */__lazy_distance_matrix(t,e,r){const s=this._distance_matrix,i=this.X,n=s.entry(t,e);if(0===n){let n=r(i.row(t),i.row(e));return s.set_entry(t,e,n),s.set_entry(e,t,n),n}return n}
/**
     * Computes the minimum spanning tree, using a given metric
     * @private
     * @param {Function} metric
     * @see {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}
     */_make_minimum_spanning_tree(t=euclidean){const e=this._N,r=[...this.X];let s=new DisjointSet(r);const i=[];let n=[];for(let r=0;r<e;++r)for(let s=r+1;s<e;++s)n.push([r,s,this.__lazy_distance_matrix(r,s,t)]);n=n.sort(((t,e)=>t[2]-e[2]));for(const[t,e,o]of n){const n=s.find(r[t]),a=s.find(r[e]);n!==a&&(i.push([t,e,o]),s.union(n,a))}return i.sort(((t,e)=>t[2]-e[2]))}
/**
     * initializes TopoMap. Sets all projcted points to zero, and computes a minimum spanning tree.
     */init(){return this.Y=new Matrix(this._N,this._d,0),this._Emst=this._make_minimum_spanning_tree(this._metric),this._is_initialized=!0,this}
/**
     * Returns true if Point C is left of line AB.
     * @private
     * @param {Array} PointA - Point A of line AB
     * @param {Array} PointB - Point B of line AB
     * @param {Array} PointC - Point C
     * @returns {Boolean}
     */__hull_cross([t,e],[r,s],[i,n]){return(r-t)*(n-e)-(s-e)*(i-t)<=0}
/**
     * Computes the convex hull of the set of Points S
     * @private
     * @param {Array} S - Set of Points.
     * @see {@link https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript}
     * @returns {Array} convex hull of S. Starts at the bottom-most point and continues counter-clockwise.
     */__hull(t){const e=t.sort((([t,e],[r,s])=>e-s||t-r)),r=e.length;if(r<=2)return e;const s=[];for(let t=0;t<r;++t){for(;s.length>=2&&this.__hull_cross(s[s.length-2],s[s.length-1],e[t]);)s.pop();s.push(e[t])}const i=[];for(let t=r-1;t>=0;--t){for(;i.length>=2&&this.__hull_cross(i[i.length-2],i[i.length-1],e[t]);)i.pop();i.push(e[t])}return i.pop(),s.pop(),s.concat(i)}
/**
     * Finds the angle to rotate Point A and B to lie on a line parallel to the x-axis.
     * @private
     * @param {Array} PointA
     * @param {Array} PointB
     * @return {Object} Object containing the sinus- and cosinus-values for a rotation.
     */__findAngle([t,e],[r,s]){const i=euclidean([t,e],[r,s]);if(0===i)return{sin:0,cos:1};const n=[(r-t)/i,(s-e)/i],o=n[0];let a=Math.sqrt(1-o*o);return a=n[1]>=0?-a:a,{sin:a,cos:o}}
/**
     * @private
     * @param {Array} hull
     * @param {Array} p
     * @param {Bool} topEdge
     */__align_hull(t,e,r){let s,i,n,o=-1;for(let r=0;r<t.length;++r){const i=euclidean(t[r],e);(-1===o||s>i)&&(s=i,o=r)}r?(i=t[o],n=t[(o+1)%t.length]):(0==o&&(o=t.length-1),i=t[o],n=t[(o-1)%t.length]);const a={tx:-t[o][0],ty:-t[o][1]};if(t.length>=2){const{sin:t,cos:e}=this.__findAngle(i,n);a.sin=t,a.cos=e}else a.sin=0,a.cos=1;return a}
/**
     * @private
     * @param {Array} Point - The point which should get transformed.
     * @param {Object} Transformation - contains the values for translation and rotation.
     */__transform([t,e],{tx:r,ty:s,sin:i,cos:n}){let o=t+r,a=e+s;return[o*n-a*i,o*i+a*n]}
/**
     * Calls {@link __transform} for each point in Set C
     * @private
     * @param {Array} C - Set of points.
     * @param {Object} t - Transform object.
     * @param {Number} yOffset - value to offset set C.
     */__transform_component(t,e,r){const s=t.length;for(let i=0;i<s;++i){const s=t[i],[n,o]=this.__transform(s,e);s[0]=n,s[1]=o+r}}
/**
     * @private
     * @param {Array} u - point u
     * @param {Array} v - point v
     * @param {Number} w - edge weight w
     */__align_components(t,e,r){const s=[...t.__disjoint_set.children],i=[...e.__disjoint_set.children],n=this.__hull(s),o=this.__hull(i),a=this.__align_hull(n,t,!1),h=this.__align_hull(o,e,!0);this.__transform_component(s,a,0),this.__transform_component(i,h,r)}
/**
     * Transforms the inputdata {@link X} to dimensionality 2.
     */transform(){this._is_initialized||this.init();const t=this._Emst,e=[...this.Y],r=new DisjointSet(e.map(((t,e)=>(t.i=e,t))));for(const[s,i,n]of t){const t=r.find(e[s]),o=r.find(e[i]);t!==o&&(this.__align_components(t,o,n),r.union(t,o))}return this.projection}*generator(){this._is_initialized||this.init();const t=this._Emst,e=[...this.Y],r=new DisjointSet(e.map(((t,e)=>(t.i=e,t))));for(const[s,i,n]of t){const t=r.find(e[s]),o=r.find(e[i]);t!==o&&(this.__align_components(t,o,n),r.union(t,o),yield this.projection)}return this.projection}}
/**
 * @class
 * @alias SAMMON
 * @extends DR
 */class SAMMON extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias SAMMON
     * @param {Matrix} X - the high-dimensional data. 
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @returns {SAMMON}
     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}
     */
constructor(t,e=.1,r=2,s=euclidean,i=1212){return super(t,r,s,i),super.parameter_list=["magic"],this.parameter("magic",e),[this._N,this._D]=this.X.shape,this}
/**
     * initializes SAMMON. Sets all projcted points to zero, and computes a minimum spanning tree.
     */init(t="random",e=null){const r=this._N,s=this._d;if("random"===t){const t=this._randomizer;this.Y=new Matrix(r,s,(()=>t.random))}else t instanceof DR&&(this.Y=t.transform(this.X));return this.distance_matrix=e||this.__distance_matrix(this.X),this}
/**
     * @private
     * @param {Matrix} A
     * @returns {Matrix} 
     */__distance_matrix(t){const e=this._metric,r=t.shape[0],s=new Matrix(r,r);for(let i=0;i<r;++i){const n=t.row(i);for(let o=i;o<r;++o){let r=i===o?0:e(n,t.row(o));s.set_entry(i,o,r),s.set_entry(o,i,r)}}return s}
/**
     * Transforms the inputdata {@link X} to dimenionality 2.
     */transform(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step();return this.projection}*generator(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step(),yield this.projection;return this.projection}_step(){const t=this.parameter("magic"),e=this.distance_matrix,r=this._N,s=this._d,i=this._metric;let n=this.Y,o=new Matrix(r,s,0),a=new Float64Array(s);for(let h=0;h<r;++h){let l=new Float64Array(s),_=new Float64Array(s);const c=n.row(h);for(let t=0;t<r;++t){if(h===t)continue;const r=n.row(t),o=new Float64Array(s);for(let t=0;t<s;++t)o[t]=c[t]-r[t];const a=i(c,r),u=e.entry(h,t),f=u-a,d=Math.max(u*a,.01);for(let t=0;t<s;++t)l[t]+=o[t]*f/d,_[t]+=(f-Math.pow(o[t],2)*(1+f/a)/a)/d}for(let e=0;e<s;++e){const r=n.entry(h,e)+(t*l[e]/Math.abs(_[e])||0);o.set_entry(h,e,r),a[e]+=r}}for(let t=0;t<s;++t)a[t]/=r;for(let t=0;t<r;++t)for(let e=0;e<s;++e)n.set_entry(t,e,o.entry(t,e)-a[e]);return n}}var t="0.4.4";export{BallTree,DisjointSet,FASTMAP,Heap,Hierarchical_Clustering,ISOMAP,KMeans,KMedoids,KNN,LDA,LLE,LSP,LTSA,MDS,Matrix,OPTICS,PCA,Randomizer,SAMMON,TSNE,TopoMap,TriMap,UMAP,canberra,chebyshev,cosine,distance_matrix,euclidean,euclidean_squared,hamming,inner_product,jaccard,k_nearest_neighbors,kahan_sum,linspace,manhattan,max,min,neumair_sum,norm,normalize,powell,qr_gramschmidt as qr,qr_householder,simultaneous_poweriteration,sokal_michener,t as version,yule};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJ1aWQuZXNtLmpzIiwic291cmNlcyI6WyIuLi9tZXRyaWNzL2V1Y2xpZGVhbi5qcyIsIi4uL251bWVyaWNhbC9rYWhhbl9zdW0uanMiLCIuLi9udW1lcmljYWwvbmV1bWFpcl9zdW0uanMiLCIuLi9tZXRyaWNzL2V1Y2xpZGVhbl9zcXVhcmVkLmpzIiwiLi4vbWV0cmljcy9jb3NpbmUuanMiLCIuLi9tZXRyaWNzL21hbmhhdHRhbi5qcyIsIi4uL21ldHJpY3MvY2hlYnlzaGV2LmpzIiwiLi4vbWV0cmljcy9jYW5iZXJyYS5qcyIsIi4uL21ldHJpY3MvamFjY2FyZC5qcyIsIi4uL21ldHJpY3MvaGFtbWluZy5qcyIsIi4uL21ldHJpY3Mvc29rYWxfbWljaGVuZXIuanMiLCIuLi9tZXRyaWNzL3l1bGUuanMiLCIuLi9tYXRyaXgva19uZWFyZXN0X25laWdoYm9ycy5qcyIsIi4uL21hdHJpeC9kaXN0YW5jZV9tYXRyaXguanMiLCIuLi9tYXRyaXgvbGluc3BhY2UuanMiLCIuLi9tYXRyaXgvbm9ybS5qcyIsIi4uL21hdHJpeC9ub3JtYWxpemUuanMiLCIuLi9saW5lYXJfYWxnZWJyYS9xci5qcyIsIi4uL2xpbmVhcl9hbGdlYnJhL3FyX2hvdXNlaG9sZGVyLmpzIiwiLi4vbGluZWFyX2FsZ2VicmEvc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uLmpzIiwiLi4vbGluZWFyX2FsZ2VicmEvaW5uZXJfcHJvZHVjdC5qcyIsIi4uL21hdHJpeC9NYXRyaXguanMiLCIuLi91dGlsL3JhbmRvbWl6ZXIuanMiLCIuLi91dGlsL21heC5qcyIsIi4uL3V0aWwvbWluLmpzIiwiLi4vZGF0YXN0cnVjdHVyZS9IZWFwLmpzIiwiLi4vZGF0YXN0cnVjdHVyZS9EaXNqb2ludFNldC5qcyIsIi4uL2tubi9CYWxsVHJlZS5qcyIsIi4uL2tubi9LTk4uanMiLCIuLi9kaW1yZWQvRFIuanMiLCIuLi9kaW1yZWQvUENBLmpzIiwiLi4vZGltcmVkL01EUy5qcyIsIi4uL2RpbXJlZC9JU09NQVAuanMiLCIuLi9kaW1yZWQvRkFTVE1BUC5qcyIsIi4uL2RpbXJlZC9MREEuanMiLCIuLi9kaW1yZWQvTExFLmpzIiwiLi4vZGltcmVkL0xUU0EuanMiLCIuLi9kaW1yZWQvVFNORS5qcyIsIi4uL29wdGltaXphdGlvbi9wb3dlbGwuanMiLCIuLi9kaW1yZWQvVU1BUC5qcyIsIi4uL2RpbXJlZC9UcmlNYXAuanMiLCIuLi9jbHVzdGVyaW5nL0hpZXJhcmNoaWNhbF9DbHVzdGVyaW5nLmpzIiwiLi4vY2x1c3RlcmluZy9LTWVhbnMuanMiLCIuLi9jbHVzdGVyaW5nL0tNZWRvaWRzLmpzIiwiLi4vY2x1c3RlcmluZy9PUFRJQ1MuanMiLCIuLi9kaW1yZWQvTFNQLmpzIiwiLi4vZGltcmVkL1RvcG9NYXAuanMiLCIuLi9kaW1yZWQvU0FNTU9OLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV1Y2xpZGVhbl9zcXVhcmVkIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIGV1Y2xpZGVhbiBkaXN0YW5jZSAobDxzdWI+Mjwvc3ViPikgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGV1Y2xpZGVhblxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGV1Y2xpZGVhbl9zcXVhcmVkKGEsIGIpKTtcbn1cbiIsIi8qKlxuICogTnVtZXJpY2FsIHN0YWJsZSBzdW1tYXRpb24gd2l0aCB0aGUgS2FoYW4gc3VtbWF0aW9uIGFsZ29yaXRobS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bnVtZXJpY2FsXG4gKiBAYWxpYXMga2FoYW5fc3VtXG4gKiBAcGFyYW0ge0FycmF5fSBzdW1tYW5kcyAtIEFycmF5IG9mIHZhbHVlcyB0byBzdW0gdXAuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3VtLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2FoYW5fc3VtbWF0aW9uX2FsZ29yaXRobX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN1bW1hbmRzKSB7XG4gICAgbGV0IG4gPSBzdW1tYW5kcy5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IGNvbXBlbnNhdGlvbiA9IDA7XG4gICAgbGV0IHksIHQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICB5ID0gc3VtbWFuZHNbaV0gLSBjb21wZW5zYXRpb247XG4gICAgICAgIHQgPSBzdW0gKyB5O1xuICAgICAgICBjb21wZW5zYXRpb24gPSB0IC0gc3VtIC0geTtcbiAgICAgICAgc3VtID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cbiIsIi8qKlxuICogTnVtZXJpY2FsIHN0YWJsZSBzdW1tYXRpb24gd2l0aCB0aGUgTmV1bWFpciBzdW1tYXRpb24gYWxnb3JpdGhtLlxuICogQG1lbWJlcm9mIG1vZHVsZTpudW1lcmljYWxcbiAqIEBhbGlhcyBuZXVtYWlyX3N1bVxuICogQHBhcmFtIHtBcnJheX0gc3VtbWFuZHMgLSBBcnJheSBvZiB2YWx1ZXMgdG8gc3VtIHVwLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIHN1bS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0thaGFuX3N1bW1hdGlvbl9hbGdvcml0aG0jRnVydGhlcl9lbmhhbmNlbWVudHN9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzdW1tYW5kcykge1xuICAgIGxldCBuID0gc3VtbWFuZHMubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGxldCBjb21wZW5zYXRpb24gPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbGV0IHN1bW1hbmQgPSBzdW1tYW5kc1tpXTtcbiAgICAgICAgbGV0IHQgPSBzdW0gKyBzdW1tYW5kO1xuICAgICAgICBpZiAoTWF0aC5hYnMoc3VtKSA+PSBNYXRoLmFicyhzdW1tYW5kKSkge1xuICAgICAgICAgICAgY29tcGVuc2F0aW9uICs9IHN1bSAtIHQgKyBzdW1tYW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcGVuc2F0aW9uICs9IHN1bW1hbmQgLSB0ICsgc3VtO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHQ7XG4gICAgfVxuICAgIHJldHVybiBzdW0gKyBjb21wZW5zYXRpb247XG59XG4iLCJpbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkZWFuIGRpc3RhbmNlIChsPHN1Yj4yPC9zdWI+PHN1cD4yPC9zdXA+KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgZXVjbGlkZWFuX3NxdWFyZWRcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgc3F1YXJlZCBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgcyA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBsZXQgeCA9IGFbaV07XG4gICAgICAgIGxldCB5ID0gYltpXTtcbiAgICAgICAgc1tpXSA9ICh4IC0geSkgKiAoeCAtIHkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV1bWFpcl9zdW0ocyk7XG59XG4iLCIvKipcbiAqIENvbXB1dGVzIHRoZSBjb3NpbmUgZGlzdGFuY2UgKG5vdCBzaW1pbGFyaXR5KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgY29zaW5lXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYlxuICogQGV4YW1wbGVcbiAqIGRydWlkLmNvc2luZShbMSwwXSxbMSwxXSkgPT0gMC43ODUzOTgxNjMzOTc0NDg0ID09IM+ALzRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBjb3NpbmUgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IHN1bV9hID0gMDtcbiAgICBsZXQgc3VtX2IgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHN1bSArPSBhW2ldICogYltpXTtcbiAgICAgICAgc3VtX2EgKz0gYVtpXSAqIGFbaV07XG4gICAgICAgIHN1bV9iICs9IGJbaV0gKiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5hY29zKHN1bSAvIChNYXRoLnNxcnQoc3VtX2EpICogTWF0aC5zcXJ0KHN1bV9iKSkpO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgbWFuaGF0dGFuIGRpc3RhbmNlIChsPHN1Yj4xPC9zdWI+KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgbWFuaGF0dGFuXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYlxuICogQHJldHVybnMge051bWJlcn0gdGhlIG1hbmhhdHRhbiBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovIFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBzdW0gKz0gTWF0aC5hYnMoYVtpXSAtIGJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgY2hlYnlzaGV2IGRpc3RhbmNlIChMPHN1Yj7iiJ48L3N1Yj4pIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1ldHJpY3NcbiAqIEBhbGlhcyBjaGVieXNoZXZcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY2hlYnlzaGV2IGRpc3RhbmNlIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKE1hdGguYWJzKGFbaV0gLSBiW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCguLi5yZXMpO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgY2FuYmVycmEgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGNhbmJlcnJhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGEgXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGIgXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgY2FuYmVycmEgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbmJlcnJhX2Rpc3RhbmNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgbiA9IGEubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHN1bSArPSAoTWF0aC5hYnMoYVtpXSAtIGJbaV0pIC8gKE1hdGguYWJzKGFbaV0pICsgTWF0aC5hYnMoYltpXSkpKVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufSIsIi8qKlxuICogQ29tcHV0ZXMgdGhlIGphY2NhcmQgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGphY2NhcmRcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgamFjY2FyZCBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IG51bV9ub25femVybyA9IDA7XG4gICAgbGV0IG51bV9lcXVhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY29uc3QgeCA9IGFbaV0gIT0gMDtcbiAgICAgICAgY29uc3QgeSA9IGJbaV0gIT0gMDtcbiAgICAgICAgbnVtX25vbl96ZXJvICs9IHggfHwgeTtcbiAgICAgICAgbnVtX2VxdWFsICs9IHggJiYgeTtcbiAgICB9XG4gICAgcmV0dXJuIChudW1fbm9uX3plcm8gLSBudW1fZXF1YWwpIC8gbnVtX25vbl96ZXJvO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgaGFtbWluZyBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgaGFtbWluZ1xuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBoYW1taW5nIGRpc3RhbmNlIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgZGlzYWdyZWUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IHggPSBhW2ldO1xuICAgICAgICBjb25zdCB5ID0gYltpXTtcbiAgICAgICAgZGlzYWdyZWUgKz0geCAhPSB5O1xuICAgIH1cbiAgICByZXR1cm4gZGlzYWdyZWUgLyBuO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgU29rYWwtTWljaGVuZXIgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIHNva2FsX21pY2hlbmVyXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGEgXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGIgXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgU29rYWwtTWljaGVuZXIgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS4gIFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgY29uc3QgbiA9IGEubGVuZ3RoO1xuICAgIGxldCBudW1fbm90X2VxdWFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCB4ID0gYVtpXSAhPSAwO1xuICAgICAgICBjb25zdCB5ID0gYltpXSAhPSAwO1xuICAgICAgICBudW1fbm90X2VxdWFsICs9IHggIT0geTtcbiAgICB9XG4gICAgcmV0dXJuICgyICogbnVtX25vdF9lcXVhbCkgLyAobiArIG51bV9ub3RfZXF1YWwpO1xufSIsIi8qKlxuICogQ29tcHV0ZXMgdGhlIHl1bGUgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIHl1bGVcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgeXVsZSBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IG51bV90cnVlX3RydWUgPSAwO1xuICAgIGxldCBudW1fdHJ1ZV9mYWxzZSA9IDA7XG4gICAgbGV0IG51bV9mYWxzZV90cnVlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCB4ID0gYVtpXSAhPSAwO1xuICAgICAgICBjb25zdCB5ID0gYltpXSAhPSAwO1xuICAgICAgICBudW1fdHJ1ZV90cnVlICs9IHggJiYgeTtcbiAgICAgICAgbnVtX3RydWVfZmFsc2UgKz0geCAmJiAheTtcbiAgICAgICAgbnVtX2ZhbHNlX3RydWUgKz0gIXggJiYgeDtcbiAgICB9XG4gICAgY29uc3QgbnVtX2ZhbHNlX2ZhbHNlID0gbiAtIG51bV90cnVlX3RydWUgLSBudW1fdHJ1ZV9mYWxzZSAtIG51bV9mYWxzZV90cnVlO1xuICAgIHJldHVybiBudW1fdHJ1ZV9mYWxzZSA9PSAwIHx8IG51bV9mYWxzZV90cnVlID09IDAgPyAwIDogKDIgKiBudW1fdHJ1ZV9mYWxzZSAqIG51bV9mYWxzZV90cnVlKSAvIChudW1fdHJ1ZV90cnVlICogbnVtX2ZhbHNlX2ZhbHNlICsgbnVtX3RydWVfZmFsc2UgKiBudW1fZmFsc2VfdHJ1ZSk7XG59XG4iLCJpbXBvcnQgeyBkaXN0YW5jZV9tYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBrLW5lYXJlc3QgbmVpZ2hib3JzIG9mIGVhY2ggcm93IG9mIHtAbGluayBBfS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWF0cml4XG4gKiBAYWxpYXMga19uZWFyZXN0X25laWdiaG9yc1xuICogQHBhcmFtIHtNYXRyaXh9IEEgLSBFaXRoZXIgdGhlIGRhdGEgbWF0cml4LCBvciBhIGRpc3RhbmNlIG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBrIC0gVGhlIG51bWJlciBvZiBuZWlnaGJvcnMgdG8gY29tcHV0ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBtZXRyaWNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKEEsIGssIG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgIGNvbnN0IHJvd3MgPSBBLnNoYXBlWzBdO1xuICAgIGxldCBEID0gbWV0cmljID09IFwicHJlY29tcHV0ZWRcIiA/IEEuY2xvbmUoKSA6IGRpc3RhbmNlX21hdHJpeChBLCBtZXRyaWMpO1xuICAgIGxldCBuTiA9IG5ldyBBcnJheShyb3dzKTtcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICBuTltyb3ddID0gQXJyYXkuZnJvbShELnJvdyhyb3cpKVxuICAgICAgICAgICAgLm1hcCgoZGlzdGFuY2UsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGk6IHJvdyxcbiAgICAgICAgICAgICAgICAgICAgajogY29sLFxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2UpXG4gICAgICAgICAgICAuc2xpY2UoMSwgayArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbk47XG59XG4iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgbWF0cml4IG9mIGRhdGFtYXRyaXgge0BsaW5rIEF9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptYXRyaXhcbiAqIEBhbGlhcyBkaXN0YW5jZV9tYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4fSBBIC0gTWF0cml4LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYz1ldWNsaWRlYW5dIC0gVGhlIGRpaXN0YW5jZSBtZXRyaWMuXG4gKiBAcmV0dXJucyB7TWF0cml4fSBEIC0gVGhlIGRpc3RhbmNlIG1hdHJpeCBvZiB7QGxpbmsgQX0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChBLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICBsZXQgbiA9IEEuc2hhcGVbMF07XG4gICAgY29uc3QgRCA9IG5ldyBNYXRyaXgobiwgbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY29uc3QgQV9pID0gQS5yb3coaSk7XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgY29uc3QgZGlzdCA9IG1ldHJpYyhBX2ksIEEucm93KGopKTtcbiAgICAgICAgICAgIEQuc2V0X2VudHJ5KGksIGosIGRpc3QpO1xuICAgICAgICAgICAgRC5zZXRfZW50cnkoaiwgaSwgZGlzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEQ7XG59XG4iLCIvKipcbiAqIENyZWF0ZXMgYW4gQXJyYXkgY29udGFpbmluZyB7QGxpbmsgbnVtYmVyfSBudW1iZXJzIGZyb20ge0BsaW5rIHN0YXJ0fSB0byB7QGxpbmsgZW5kfS5cbiAqIElmIDxjb2RlPntAbGluayBudW1iZXJ9ID0gbnVsbDwvbnVsbD4uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1hdHJpeFxuICogQGFsaWFzIGxpbnNwYWNlXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgLSBTdGFydCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgLSBFbmQgdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW251bWJlciA9IG51bGxdIC0gTnVtYmVyIG9mIG51bWJlciBiZXR3ZWVuIHtAbGluayBzdGFydH0gYW5kIHtAbGluayBlbmR9LlxuICogQHJldHVybnMge0FycmF5fSAtIEFuIGFycmF5IHdpdGgge0BsaW5rIG51bWJlcn0gZW50cmllcywgYmVnaW5uaW5nIGF0IHtAbGluayBzdGFydH0gZW5kaW5nIGF0IHtAbGluayBlbmR9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgbnVtYmVyID0gbnVsbCkge1xuICAgIGlmICghbnVtYmVyKSB7XG4gICAgICAgIG51bWJlciA9IE1hdGgubWF4KE1hdGgucm91bmQoZW5kIC0gc3RhcnQpICsgMSwgMSk7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAyKSB7XG4gICAgICAgIHJldHVybiBudW1iZXIgPT09IDEgPyBbc3RhcnRdIDogW107XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBuZXcgQXJyYXkobnVtYmVyKTtcbiAgICBudW1iZXIgLT0gMTtcbiAgICBmb3IgKGxldCBpID0gbnVtYmVyOyBpID49IDA7IC0taSkge1xuICAgICAgICByZXN1bHRbaV0gPSAoaSAqIGVuZCArIChudW1iZXIgLSBpKSAqIHN0YXJ0KSAvIG51bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG4vL2ltcG9ydCB7IG5ldW1haXJfc3VtIH0gZnJvbSBcIi4uL251bWVyaWNhbC9pbmRleFwiO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBub3JtIG9mIGEgdmVjdG9yLCBieSBjb21wdXRpbmcgaXRzIGRpc3RhbmNlIHRvICoqMCoqLlxuICogQG1lbWJlcm9mIG1vZHVsZTptYXRyaXhcbiAqIEBhbGlhcyBub3JtXG4gKiBAcGFyYW0ge01hdHJpeHxBcnJheTxOdW1iZXI+fEZsb2F0NjRBcnJheX0gdiAtIFZlY3Rvci4gXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIFdoaWNoIG1ldHJpYyBzaG91bGQgYmUgdXNlZCB0byBjb21wdXRlIHRoZSBub3JtLlxuICogQHJldHVybnMge051bWJlcn0gLSBUaGUgbm9ybSBvZiB7QGxpbmsgdn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICh2LCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICBsZXQgdmVjdG9yID0gbnVsbDtcbiAgICBpZiAodiBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICBsZXQgW3Jvd3MsIGNvbHNdID0gdi5zaGFwZTtcbiAgICAgICAgaWYgKHJvd3MgPT09IDEpIHZlY3RvciA9IHYucm93KDApO1xuICAgICAgICBlbHNlIGlmIChjb2xzID09PSAxKSB2ZWN0b3IgPSB2LmNvbCgwKTtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJNYXRyaXggbXVzdCBiZSAxZCFcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmVjdG9yID0gdjtcbiAgICB9XG4gICAgY29uc3QgbiA9IHZlY3Rvci5sZW5ndGg7XG4gICAgY29uc3QgemVyb3MgPSBGbG9hdDY0QXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9LCAoKSA9PiAwKTtcbiAgICByZXR1cm4gbWV0cmljKHZlY3RvciwgemVyb3MpO1xufVxuIiwiaW1wb3J0IHsgbm9ybSB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgVmVjdG9yIHtAbGluayB2fS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWF0cml4XG4gKiBAYWxpYXMgbm9ybWFsaXplXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj58RmxvYXQ2NEFycmF5fSB2IC0gVmVjdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRyaWMgXG4gKiBAcmV0dXJucyB7QXJyYXk8TnVtYmVyPnxGbG9hdDY0QXJyYXl9IC0gVGhlIG5vcm1hbGl6ZWQgdmVjdG9yIHdpdGggbGVuZ3RoIDEuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHYsIG1ldHJpYyA9IGV1Y2xpZGVhbikgIHtcbiAgICBjb25zdCB2X25vcm0gPSBub3JtKHYsIG1ldHJpYyk7XG4gICAgcmV0dXJuIHYubWFwKHZhbHVlID0+IHZhbHVlIC8gdl9ub3JtKTtcbn0iLCJpbXBvcnQgeyBNYXRyaXgsIG5vcm0gfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4LmpzXCI7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFFSIERlY29tcG9zaXRpb24gb2YgdGhlIE1hdHJpeCB7QGxpbmsgQX0gdXNpbmcgR3JhbS1TY2htaWR0IHByb2Nlc3MuXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmxpbmVhcl9hbGdlYnJhXG4gKiBAYWxpYXMgcXJcbiAqIEBwYXJhbSB7TWF0cml4fSBBXG4gKiBAcmV0dXJucyB7e1I6IE1hdHJpeCwgUTogTWF0cml4fX1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1FSX2RlY29tcG9zaXRpb24jVXNpbmdfdGhlX0dyYW0lRTIlODAlOTNTY2htaWR0X3Byb2Nlc3N9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChBKSB7XG4gICAgY29uc3QgW3Jvd3MsIGNvbHNdID0gQS5zaGFwZTtcbiAgICBjb25zdCBRID0gbmV3IE1hdHJpeChyb3dzLCBjb2xzLCBcImlkZW50aXR5XCIpO1xuICAgIGNvbnN0IFIgPSBuZXcgTWF0cml4KGNvbHMsIGNvbHMsIDApO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcbiAgICAgICAgbGV0IHYgPSBBLmNvbChqKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHEgPSBRLmNvbChpKTtcbiAgICAgICAgICAgIGNvbnN0IHFfZG90X3YgPSBuZXVtYWlyX3N1bShxLm1hcCgocV8sIGspID0+IHFfICogdltrXSkpO1xuICAgICAgICAgICAgUi5zZXRfZW50cnkoaSwgaiwgcV9kb3Rfdik7XG4gICAgICAgICAgICB2ID0gdi5tYXAoKHZfLCBrKSA9PiB2XyAtIHFfZG90X3YgKiBxW2tdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2X25vcm0gPSBub3JtKHYsIGV1Y2xpZGVhbik7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcm93czsgKytrKSB7XG4gICAgICAgICAgICBRLnNldF9lbnRyeShrLCBqLCB2W2tdIC8gdl9ub3JtKTtcbiAgICAgICAgfVxuICAgICAgICBSLnNldF9lbnRyeShqLCBqLCB2X25vcm0pO1xuICAgIH1cbiAgICByZXR1cm4geyBSLCBRIH07XG59XG4iLCJpbXBvcnQgeyBNYXRyaXgsIG5vcm0gfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFFSIERlY29tcG9zaXRpb24gb2YgdGhlIE1hdHJpeCB7QGxpbmsgQX0gd2l0aCBob3VzZWhvbGRlciB0cmFuc2Zvcm1hdGlvbnMuXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmxpbmVhcl9hbGdlYnJhXG4gKiBAYWxpYXMgcXJfaG91c2Vob2xkZXJcbiAqIEBwYXJhbSB7TWF0cml4fSBBXG4gKiBAcmV0dXJucyB7e1I6IE1hdHJpeCwgUTogTWF0cml4fX1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1FSX2RlY29tcG9zaXRpb24jVXNpbmdfSG91c2Vob2xkZXJfcmVmbGVjdGlvbnN9XG4gKiBAc2VlIHtAbGluayBodHRwOi8vbWx3aWtpLm9yZy9pbmRleC5waHAvSG91c2Vob2xkZXJfVHJhbnNmb3JtYXRpb259XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChBKSB7XG4gICAgY29uc3QgW3Jvd3MsIGNvbHNdID0gQS5zaGFwZTtcbiAgICBjb25zdCBRID0gbmV3IE1hdHJpeChyb3dzLCByb3dzLCBcIklcIik7XG4gICAgY29uc3QgUiA9IEEuY2xvbmUoKTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgKytqKSB7XG4gICAgICAgIGNvbnN0IHggPSBNYXRyaXguZnJvbShSLmNvbChqKS5zbGljZShqKSk7XG4gICAgICAgIGNvbnN0IHhfbm9ybSA9IG5vcm0oeCk7XG4gICAgICAgIGNvbnN0IHgwID0geC5lbnRyeSgwLCAwKTtcbiAgICAgICAgY29uc3QgcmhvID0gLU1hdGguc2lnbih4MCk7XG4gICAgICAgIGNvbnN0IHUxID0geDAgLSByaG8gKiB4X25vcm07XG4gICAgICAgIGNvbnN0IHUgPSB4LmRpdmlkZSh1MSkuc2V0X2VudHJ5KDAsIDAsIDEpO1xuICAgICAgICBjb25zdCBiZXRhID0gKC1yaG8gKiB1MSkgLyB4X25vcm07XG5cbiAgICAgICAgY29uc3QgdV9vdXRlcl91ID0gdS5vdXRlcih1KTtcbiAgICAgICAgY29uc3QgUl9ibG9jayA9IFIuZ2V0X2Jsb2NrKGosIDApO1xuICAgICAgICBjb25zdCBuZXdfUiA9IFJfYmxvY2suc3ViKHVfb3V0ZXJfdS5kb3QoUl9ibG9jaykubXVsdChiZXRhKSk7XG4gICAgICAgIGNvbnN0IFFfYmxvY2sgPSBRLmdldF9ibG9jaygwLCBqKTtcbiAgICAgICAgY29uc3QgbmV3X1EgPSBRX2Jsb2NrLnN1YihRX2Jsb2NrLmRvdCh1X291dGVyX3UpLm11bHQoYmV0YSkpO1xuICAgICAgICBSLnNldF9ibG9jayhqLCAwLCBuZXdfUik7XG4gICAgICAgIFEuc2V0X2Jsb2NrKDAsIGosIG5ld19RKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgUiwgUSB9O1xufVxuIiwiaW1wb3J0IHsgcXIgYXMgcXJfZ3JhbXNjaG1pZHQgfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUmFuZG9taXplciB9IGZyb20gXCIuLi91dGlsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW5fc3F1YXJlZCB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHtAbGluayBrfSBiaWdnZXN0IEVpZ2VudmVjdG9ycyBhbmQgRWlnZW52YWx1ZXMgZnJvbSBNYXRyaXgge0BsaW5rIEF9IHdpdGggdGhlIFFSLUFsZ29yaXRobS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bGluZWFyX2FsZ2VicmFcbiAqIEBhbGlhcyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb25cbiAqIEBwYXJhbSB7TWF0cml4fSBBIC0gVGhlIE1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IGsgLSBUaGUgbnVtYmVyIG9mIGVpZ2VudmVjdG9ycyBhbmQgZWlnZW52YWx1ZXMgdG8gY29tcHV0ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4X2l0ZXJhdGlvbnM9MTAwXSAtIFRoZSBudW1iZXIgb2YgbWF4aXVtdW0gaXRlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHNob3VsZCBydW4uXG4gKiBAcGFyYW0ge051bWJlcnxSYW5kb21pemVyfSBbc2VlZD0xMjEyXSAtIFRoZSBzZWVkIHZhbHVlIG9yIGEgcmFuZG9taXplciB1c2VkIGluIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0ge051bWJlcn0gW3RvbD0xZS04XSAtIEFsbG93ZWQgZXJyb3IgZm9yIHN0b3BwaW5nIGNyaXRlcmlhXG4gKiBAcmV0dXJucyB7e2VpZ2VudmFsdWVzOiBBcnJheSwgZWlnZW52ZWN0b3JzOiBBcnJheX19IC0gVGhlIHtAbGluayBrfSBiaWdnZXN0IGVpZ2VudmVjdG9ycyBhbmQgZWlnZW52YWx1ZXMgb2YgTWF0cml4IHtAbGluayBBfS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKEEsIGsgPSAyLCBtYXhfaXRlcmF0aW9ucyA9IDEwMCwgc2VlZCA9IDEyMTIsIHFyID0gcXJfZ3JhbXNjaG1pZHQsIHRvbCA9IDFlLTgpIHtcbiAgICBjb25zdCByYW5kb21pemVyID0gc2VlZCBpbnN0YW5jZW9mIFJhbmRvbWl6ZXIgPyBzZWVkIDogbmV3IFJhbmRvbWl6ZXIoc2VlZCk7XG4gICAgaWYgKCEoQSBpbnN0YW5jZW9mIE1hdHJpeCkpIEEgPSBNYXRyaXguZnJvbShBKTtcbiAgICBjb25zdCBuID0gQS5zaGFwZVswXTtcbiAgICBsZXQgeyBROiBRLCBSOiBSIH0gPSBxcihuZXcgTWF0cml4KG4sIGssICgpID0+IHJhbmRvbWl6ZXIucmFuZG9tKSk7XG4gICAgd2hpbGUgKG1heF9pdGVyYXRpb25zLS0pIHtcbiAgICAgICAgY29uc3Qgb2xkUSA9IFEuY2xvbmUoKTtcbiAgICAgICAgY29uc3QgWiA9IEEuZG90KFEpO1xuICAgICAgICBjb25zdCBRUiA9IHFyKFopO1xuICAgICAgICBRID0gUVIuUTtcbiAgICAgICAgUiA9IFFSLlI7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZXVjbGlkZWFuX3NxdWFyZWQoUS52YWx1ZXMsIG9sZFEudmFsdWVzKTtcbiAgICAgICAgaWYgKGVycm9yIDwgdG9sKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGVpZ2VudmFsdWVzID0gUi5kaWFnO1xuICAgIGNvbnN0IGVpZ2VudmVjdG9ycyA9IFEudHJhbnNwb3NlKCkudG8yZEFycmF5O1xuICAgIHJldHVybiB7IGVpZ2VudmFsdWVzLCBlaWdlbnZlY3RvcnMgfTtcbn1cbiIsImltcG9ydCB7IG5ldW1haXJfc3VtIH0gZnJvbSBcIi4uL251bWVyaWNhbC9pbmRleC5qc1wiO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBpbm5lciBwcm9kdWN0IGJldHdlZW4gdHdvIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGguXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmxpbmVhcl9hbGdlYnJhXG4gKiBAYWxpYXMgaW5uZXJfcHJvZHVjdFxuICogQHBhcmFtIHtBcnJheXxGbG9hdDY0QXJyYXl9IGEgLSBBcnJheSBhXG4gKiBAcGFyYW0ge0FycmF5fEZsb2F0NjRBcnJheX0gYiAtIEFycmF5IGJcbiAqIEByZXR1cm5zIFRoZSBpbm5lciBwcm9kdWN0IGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBjb25zdCBOID0gYS5sZW5ndGg7XG4gICAgaWYgKE4gIT0gYi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXkgYSBhbmQgYiBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoIVwiKVxuICAgIH1cbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICBzdW0gKz0gYSAqIGI7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4iLCJpbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcbmltcG9ydCB7IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbiB9IGZyb20gXCIuLi9saW5lYXJfYWxnZWJyYS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUmFuZG9taXplciB9IGZyb20gXCIuLi91dGlsL2luZGV4LmpzXCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIE1hdHJpeFxuICogQHJlcXVpcmVzIG1vZHVsZTpudW1lcmljYWwvbmV1bWFpcl9zdW1cbiAqL1xuZXhwb3J0IGNsYXNzIE1hdHJpeCB7XG4gICAgLyoqXG4gICAgICogY3JlYXRlcyBhIG5ldyBNYXRyaXguIEVudHJpZXMgYXJlIHN0b3JlZCBpbiBhIEZsb2F0NjRBcnJheS5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1hdHJpeFxuICAgICAqIEBhbGlhcyBNYXRyaXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93cyAtIFRoZSBhbW91bnQgb2Ygcm93cyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xzIC0gVGhlIGFtb3VudCBvZiBjb2x1bW5zIG9mIHRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb258c3RyaW5nfG51bWJlcil9IHZhbHVlPTAgLSBDYW4gYmUgYSBmdW5jdGlvbiB3aXRoIHJvdyBhbmQgY29sIGFzIHBhcmFtZXRlcnMsIGEgbnVtYmVyLCBvciBcInplcm9zXCIsIFwiaWRlbnRpdHlcIiBvciBcIklcIiwgb3IgXCJjZW50ZXJcIi5cbiAgICAgKiAgLSAqKmZ1bmN0aW9uKio6IGZvciBlYWNoIGVudHJ5IHRoZSBmdW5jdGlvbiBnZXRzIGNhbGxlZCB3aXRoIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgYWN0dWFsIHJvdyBhbmQgY29sdW1uLlxuICAgICAqICAtICoqc3RyaW5nKio6IGFsbG93ZWQgYXJlXG4gICAgICogICAgICAtIFwiemVyb1wiLCBjcmVhdGVzIGEgemVybyBtYXRyaXguXG4gICAgICogICAgICAtIFwiaWRlbnRpdHlcIiBvciBcIklcIiwgY3JlYXRlcyBhbiBpZGVudGl0eSBtYXRyaXguXG4gICAgICogICAgICAtIFwiY2VudGVyXCIsIGNyZWF0ZXMgYW4gY2VudGVyIG1hdHJpeC5cbiAgICAgKiAgLSAqKm51bWJlcioqOiBjcmVhdGUgYSBtYXRyaXggZmlsbGVkIHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBsZXQgQSA9IG5ldyBNYXRyaXgoMTAsIDEwLCAoKSA9PiBNYXRoLnJhbmRvbSgpKTsgLy9jcmVhdGVzIGEgMTAgdGltZXMgMTAgcmFuZG9tIG1hdHJpeC5cbiAgICAgKiBsZXQgQiA9IG5ldyBNYXRyaXgoMywgMywgXCJJXCIpOyAvLyBjcmVhdGVzIGEgMyB0aW1lcyAzIGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSByZXR1cm5zIGEge0BsaW5rIHJvd3N9IHRpbWVzIHtAbGluayBjb2xzfSBNYXRyaXggZmlsbGVkIHdpdGgge0BsaW5rIHZhbHVlfS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihyb3dzID0gbnVsbCwgY29scyA9IG51bGwsIHZhbHVlID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yb3dzID0gcm93cztcbiAgICAgICAgdGhpcy5fY29scyA9IGNvbHM7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgICAgICBpZiAocm93cyAmJiBjb2xzKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkocm93cyAqIGNvbHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkocm93cyAqIGNvbHMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gdmFsdWUocm93LCBjb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJ6ZXJvc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4KHJvd3MsIGNvbHMsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiaWRlbnRpdHlcIiB8fCB2YWx1ZSA9PT0gXCJJXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkocm93cyAqIGNvbHMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiBjb2xzICsgcm93XSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJjZW50ZXJcIiAmJiByb3dzID09IGNvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkocm93cyAqIGNvbHMpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IChpLCBqKSA9PiAoaSA9PT0gaiA/IDEgOiAwKSAtIDEgLyByb3dzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gdmFsdWUocm93LCBjb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0NjRBcnJheShyb3dzICogY29scyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbcm93ICogY29scyArIGNvbF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWF0cml4IG91dCBvZiB7QGxpbmsgQX0uXG4gICAgICogQHBhcmFtIHsoTWF0cml4fEFycmF5fEZsb2F0NjRBcnJheXxudW1iZXIpfSBBIC0gVGhlIG1hdHJpeCwgYXJyYXksIG9yIG51bWJlciwgd2hpY2ggc2hvdWxkIGNvbnZlcnRlZCB0byBhIE1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge1wicm93XCJ8XCJjb2xcInxcImRpYWdcIn0gW3R5cGUgPSBcInJvd1wiXSAtIElmIHtAbGluayBBfSBpcyBhIEFycmF5IG9yIEZsb2F0NjRBcnJheSwgdGhlbiB0eXBlIGRlZmluZXMgaWYgaXQgaXMgYSByb3ctIG9yIGEgY29sdW1uIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBsZXQgQSA9IE1hdHJpeC5mcm9tKFtbMSwgMF0sIFswLCAxXV0pOyAvL2NyZWF0ZXMgYSB0d28gYnkgdHdvIGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKiBsZXQgUyA9IE1hdHJpeC5mcm9tKFsxLCAyLCAzXSwgXCJkaWFnXCIpOyAvLyBjcmVhdGVzIGEgMyBieSAzIG1hdHJpeCB3aXRoIDEsIDIsIDMgb24gaXRzIGRpYWdvbmFsLiBbWzEsIDAsIDBdLCBbMCwgMiwgMF0sIFswLCAwLCAzXV1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShBLCB0eXBlID0gXCJyb3dcIikge1xuICAgICAgICBpZiAoQSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgcmV0dXJuIEEuY2xvbmUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEEpIHx8IEEgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgIGxldCBtID0gQS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobSA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXkgaXMgZW1wdHlcIik7XG4gICAgICAgICAgICAvLyAxZFxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KEFbMF0pICYmICEoQVswXSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCgxLCBtLCAoXywgaikgPT4gQVtqXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4KG0sIDEsIChpKSA9PiBBW2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZGlhZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4KG0sIG0sIChpLCBqKSA9PiAoaSA9PSBqID8gQVtpXSA6IDApKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIxZCBhcnJheSBoYXMgTmFOIGVudHJpZXNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDJkXG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoQVswXSkgfHwgQVswXSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkge1xuICAgICAgICAgICAgICAgIGxldCBuID0gQVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgbTsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFbcm93XS5sZW5ndGggIT09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZhcmlvdXMgYXJyYXkgbGVuZ3Roc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtLCBuLCAoaSwgaikgPT4gQVtpXVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEEgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4KDEsIDEsIEEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXJyb3JcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgcm93fTxzdXA+dGg8L3N1cD4gcm93IGZyb20gdGhlIE1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAgICogQHJldHVybnMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICByb3cocm93KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgIHJldHVybiBkYXRhLnN1YmFycmF5KHJvdyAqIGNvbHMsIChyb3cgKyAxKSAqIGNvbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZ2VuZXJhdG9yIHlpZWxkaW5nIGVhY2ggcm93IG9mIHRoZSBNYXRyaXguXG4gICAgICogQHlpZWxkcyB7RmxvYXQ2NEFycmF5fVxuICAgICAqL1xuICAgICppdGVyYXRlX3Jvd3MoKSB7XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMudmFsdWVzO1xuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgeWllbGQgZGF0YS5zdWJhcnJheShyb3cgKiBjb2xzLCAocm93ICsgMSkgKiBjb2xzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGEge0BsaW5rIE1hdHJpeH0gb2JqZWN0IGFuIGl0ZXJhYmxlIG9iamVjdC5cbiAgICAgKiBAeWllbGRzIHtGbG9hdDY0QXJyYXl9XG4gICAgICovXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLml0ZXJhdGVfcm93cygpKSB7XG4gICAgICAgICAgICB5aWVsZCByb3c7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlbnRyaWVzIG9mIHtAbGluayByb3d9PHN1cD50aDwvc3VwPiByb3cgZnJvbSB0aGUgTWF0cml4IHRvIHRoZSBlbnRyaWVzIGZyb20ge0BsaW5rIHZhbHVlc30uXG4gICAgICogQHBhcmFtIHtpbnR9IHJvd1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc2V0X3Jvdyhyb3csIHZhbHVlcykge1xuICAgICAgICBsZXQgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykgJiYgdmFsdWVzLmxlbmd0aCA9PT0gY29scykge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJvdyAqIGNvbHM7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzW29mZnNldCArIGNvbF0gPSB2YWx1ZXNbY29sXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBNYXRyaXggJiYgdmFsdWVzLnNoYXBlWzFdID09PSBjb2xzICYmIHZhbHVlcy5zaGFwZVswXSA9PT0gMSkge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJvdyAqIGNvbHM7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzW29mZnNldCArIGNvbF0gPSB2YWx1ZXMuX2RhdGFbY29sXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgY29sfTxzdXA+dGg8L3N1cD4gY29sdW1uIGZyb20gdGhlIE1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge2ludH0gY29sXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGNvbChjb2wpIHtcbiAgICAgICAgbGV0IHJlc3VsdF9jb2wgPSBuZXcgRmxvYXQ2NEFycmF5KHRoaXMuX3Jvd3MpO1xuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLl9yb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgcmVzdWx0X2NvbFtyb3ddID0gdGhpcy52YWx1ZXNbcm93ICogdGhpcy5fY29scyArIGNvbF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdF9jb2w7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIGNvbH08c3VwPnRoPC9zdXA+IGVudHJ5IGZyb20gdGhlIHtAbGluayByb3d9PHN1cD50aDwvc3VwPiByb3cgb2YgdGhlIE1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge2ludH0gcm93XG4gICAgICogQHBhcmFtIHtpbnR9IGNvbFxuICAgICAqIEByZXR1cm5zIHtmbG9hdDY0fVxuICAgICAqL1xuICAgIGVudHJ5KHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tyb3cgKiB0aGlzLl9jb2xzICsgY29sXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB7QGxpbmsgY29sfTxzdXA+dGg8L3N1cD4gZW50cnkgZnJvbSB0aGUge0BsaW5rIHJvd308c3VwPnRoPC9zdXA+IHJvdyBvZiB0aGUgTWF0cml4IHRvIHRoZSBnaXZlbiB7QGxpbmsgdmFsdWV9LlxuICAgICAqIEBwYXJhbSB7aW50fSByb3dcbiAgICAgKiBAcGFyYW0ge2ludH0gY29sXG4gICAgICogQHBhcmFtIHtmbG9hdDY0fSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc2V0X2VudHJ5KHJvdywgY29sLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlc1tyb3cgKiB0aGlzLl9jb2xzICsgY29sXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHRyYW5zcG9zZWQgTWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgdHJhbnNwb3NlKCkge1xuICAgICAgICBsZXQgQiA9IG5ldyBNYXRyaXgodGhpcy5fY29scywgdGhpcy5fcm93cywgKHJvdywgY29sKSA9PiB0aGlzLmVudHJ5KGNvbCwgcm93KSk7XG4gICAgICAgIHJldHVybiBCO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgdHJhbnNwb3NlZCBNYXRyaXguIFNob3J0LWZvcm0gb2Yge0BmdW5jdGlvbiB0cmFuc3Bvc2V9LlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgZ2V0IFQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9zZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIGludmVyc2UoKSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0aGlzLl9yb3dzO1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgbGV0IEIgPSBuZXcgTWF0cml4KHJvd3MsIDIgKiBjb2xzLCAoaSwgaikgPT4ge1xuICAgICAgICAgICAgaWYgKGogPj0gY29scykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpID09PSBqIC0gY29scyA/IDEgOiAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbnRyeShpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBoID0gMDtcbiAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICB3aGlsZSAoaCA8IHJvd3MgJiYgayA8IGNvbHMpIHtcbiAgICAgICAgICAgIHZhciBpX21heCA9IDA7XG4gICAgICAgICAgICBsZXQgbWF4X3ZhbCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBoOyBpIDwgcm93czsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IE1hdGguYWJzKEIuZW50cnkoaSwgaykpO1xuICAgICAgICAgICAgICAgIGlmIChtYXhfdmFsIDwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlfbWF4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgbWF4X3ZhbCA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQi5lbnRyeShpX21heCwgaykgPT0gMCkge1xuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcCByb3dzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAyICogY29sczsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoX3ZhbCA9IEIuZW50cnkoaCwgaik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpX3ZhbCA9IEIuZW50cnkoaV9tYXgsIGopO1xuICAgICAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShoLCBqLCBoX3ZhbCk7XG4gICAgICAgICAgICAgICAgICAgIEIuc2V0X2VudHJ5KGlfbWF4LCBqLCBpX3ZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBoICsgMTsgaSA8IHJvd3M7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZiA9IEIuZW50cnkoaSwgaykgLyBCLmVudHJ5KGgsIGspO1xuICAgICAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShpLCBrLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGsgKyAxOyBqIDwgMiAqIGNvbHM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgQi5zZXRfZW50cnkoaSwgaiwgQi5lbnRyeShpLCBqKSAtIEIuZW50cnkoaCwgaikgKiBmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoKys7XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGxldCBmID0gQi5lbnRyeShyb3csIHJvdyk7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSByb3c7IGNvbCA8IDIgKiBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIEIuc2V0X2VudHJ5KHJvdywgY29sLCBCLmVudHJ5KHJvdywgY29sKSAvIGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcm93ID0gcm93cyAtIDE7IHJvdyA+PSAwOyAtLXJvdykge1xuICAgICAgICAgICAgbGV0IEJfcm93X3JvdyA9IEIuZW50cnkocm93LCByb3cpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3c7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBCX2lfcm93ID0gQi5lbnRyeShpLCByb3cpO1xuICAgICAgICAgICAgICAgIGxldCBmID0gQl9pX3JvdyAvIEJfcm93X3JvdztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IDIgKiBjb2xzOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IEJfaV9qID0gQi5lbnRyeShpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IEJfcm93X2ogPSBCLmVudHJ5KHJvdywgaik7XG4gICAgICAgICAgICAgICAgICAgIEJfaV9qID0gQl9pX2ogLSBCX3Jvd19qICogZjtcbiAgICAgICAgICAgICAgICAgICAgQi5zZXRfZW50cnkoaSwgaiwgQl9pX2opO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KHJvd3MsIGNvbHMsIChpLCBqKSA9PiBCLmVudHJ5KGksIGogKyBjb2xzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZG90IHByb2R1Y3QuIElmIHtAbGluayBCfSBpcyBhbiBBcnJheSBvciBGbG9hdDY0QXJyYXkgdGhlbiBhbiBBcnJheSBnZXRzIHJldHVybmVkLiBJZiB7QGxpbmsgQn0gaXMgYSBNYXRyaXggdGhlbiBhIE1hdHJpeCBnZXRzIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSB7KE1hdHJpeHxBcnJheXxGbG9hdDY0QXJyYXkpfSBCIHRoZSByaWdodCBzaWRlXG4gICAgICogQHJldHVybnMgeyhNYXRyaXh8QXJyYXkpfVxuICAgICAqL1xuICAgIGRvdChCKSB7XG4gICAgICAgIGlmIChCIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgQSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoQS5zaGFwZVsxXSAhPT0gQi5zaGFwZVswXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQS5kb3QoQik6IEEgaXMgYSAke0Euc2hhcGUuam9pbihcIiDiqK8gXCIpfS1NYXRyaXgsIEIgaXMgYSAke0Iuc2hhcGUuam9pbihcIiDiqK8gXCIpfS1NYXRyaXg6IFxuICAgICAgICAgICAgICAgIEEgaGFzICR7QS5zaGFwZVsxXX0gY29scyBhbmQgQiAke0Iuc2hhcGVbMF19IHJvd3MuIFxuICAgICAgICAgICAgICAgIE11c3QgYmUgZXF1YWwhYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgSSA9IEEuc2hhcGVbMV07XG4gICAgICAgICAgICBsZXQgQyA9IG5ldyBNYXRyaXgoQS5zaGFwZVswXSwgQi5zaGFwZVsxXSwgKHJvdywgY29sKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgQV9pID0gQS5yb3cocm93KTtcbiAgICAgICAgICAgICAgICBjb25zdCBCX2kgPSBCLmNvbChjb2wpO1xuICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBBX2lbaV0gKiBCX2lbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBDO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoQikgfHwgQiBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkge1xuICAgICAgICAgICAgbGV0IHJvd3MgPSB0aGlzLl9yb3dzO1xuICAgICAgICAgICAgaWYgKEIubGVuZ3RoICE9PSByb3dzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBLmRvdChCKTogQSBoYXMgJHtyb3dzfSBjb2xzIGFuZCBCIGhhcyAke0IubGVuZ3RofSByb3dzLiBNdXN0IGJlIGVxdWFsIWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IEMgPSBuZXcgQXJyYXkocm93cyk7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgIENbcm93XSA9IG5ldW1haXJfc3VtKHRoaXMucm93KHJvdykubWFwKChlKSA9PiBlICogQltyb3ddKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQiBtdXN0IGJlIE1hdHJpeCBvciBBcnJheWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG91dGVyIHByb2R1Y3QgZnJvbSB7QGxpbmsgdGhpc30gYW5kIHtAbGluayBCfS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgb3V0ZXIoQikge1xuICAgICAgICBsZXQgQSA9IHRoaXM7XG4gICAgICAgIGxldCBsID0gQS5fZGF0YS5sZW5ndGg7XG4gICAgICAgIGxldCByID0gQi5fZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsICE9IHIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBDID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBDLnNoYXBlID0gW1xuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAoaSwgaikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpIDw9IGopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEEuX2RhdGFbaV0gKiBCLl9kYXRhW2pdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDLmVudHJ5KGosIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBDO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgbWF0cml4IHtAbGluayBCfSB0byB0aGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBCIC0gbWF0cml4IHRvIGFwcGVuZC5cbiAgICAgKiBAcGFyYW0ge1wiaG9yaXpvbnRhbFwifFwidmVydGljYWxcInxcImRpYWdcIn0gW3R5cGUgPSBcImhvcml6b250YWxcIl0gLSB0eXBlIG9mIGNvbmNhdGVuYXRpb24uXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDFdLCBbMSwgMV1dKTsgLy8gMiBieSAyIG1hdHJpeCBmaWxsZWQgd2l0aCBvbmVzLlxuICAgICAqIGxldCBCID0gTWF0cml4LmZyb20oW1syLCAyXSwgWzIsIDJdXSk7IC8vIDIgYnkgMiBtYXRyaXggZmlsbGVkIHdpdGggdHdvcy5cbiAgICAgKlxuICAgICAqIEEuY29uY2F0KEIsIFwiaG9yaXpvbnRhbFwiKTsgLy8gMiBieSA0IG1hdHJpeC4gW1sxLCAxLCAyLCAyXSwgWzEsIDEsIDIsIDJdXVxuICAgICAqIEEuY29uY2F0KEIsIFwidmVydGljYWxcIik7IC8vIDQgYnkgMiBtYXRyaXguIFtbMSwgMV0sIFsxLCAxXSwgWzIsIDJdLCBbMiwgMl1dXG4gICAgICogQS5jb25jYXQoQiwgXCJkaWFnXCIpOyAvLyA0IGJ5IDQgbWF0cml4LiBbWzEsIDEsIDAsIDBdLCBbMSwgMSwgMCwgMF0sIFswLCAwLCAyLCAyXSwgWzAsIDAsIDIsIDJdXVxuICAgICAqL1xuICAgIGNvbmNhdChCLCB0eXBlID0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgY29uc3QgQSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IFtyb3dzX0EsIGNvbHNfQV0gPSBBLnNoYXBlO1xuICAgICAgICBjb25zdCBbcm93c19CLCBjb2xzX0JdID0gQi5zaGFwZTtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgIGlmIChyb3dzX0EgIT0gcm93c19CKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBLmNvbmNhdChCLCBcImhvcml6b250YWxcIik6IEEgYW5kIEIgbmVlZCBzYW1lIG51bWJlciBvZiByb3dzLCBBIGhhcyAke3Jvd3NfQX0gcm93cywgQiBoYXMgJHtyb3dzX0J9IHJvd3MuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBYID0gbmV3IE1hdHJpeChyb3dzX0EsIGNvbHNfQSArIGNvbHNfQiwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgICAgIFguc2V0X2Jsb2NrKDAsIDAsIEEpO1xuICAgICAgICAgICAgWC5zZXRfYmxvY2soMCwgY29sc19BLCBCKTtcbiAgICAgICAgICAgIHJldHVybiBYO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgICBpZiAoY29sc19BICE9IGNvbHNfQikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQS5jb25jYXQoQiwgXCJ2ZXJ0aWNhbFwiKTogQSBhbmQgQiBuZWVkIHNhbWUgbnVtYmVyIG9mIGNvbHVtbnMsIEEgaGFzICR7Y29sc19BfSBjb2x1bW5zLCBCIGhhcyAke2NvbHNfQn0gY29sdW1ucy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFggPSBuZXcgTWF0cml4KHJvd3NfQSArIHJvd3NfQiwgY29sc19BLCBcInplcm9zXCIpO1xuICAgICAgICAgICAgWC5zZXRfYmxvY2soMCwgMCwgQSk7XG4gICAgICAgICAgICBYLnNldF9ibG9jayhyb3dzX0EsIDAsIEIpO1xuICAgICAgICAgICAgcmV0dXJuIFg7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImRpYWdcIikge1xuICAgICAgICAgICAgY29uc3QgWCA9IG5ldyBNYXRyaXgocm93c19BICsgcm93c19CLCBjb2xzX0EgKyBjb2xzX0IsIFwiemVyb3NcIik7XG4gICAgICAgICAgICBYLnNldF9ibG9jaygwLCAwLCBBKTtcbiAgICAgICAgICAgIFguc2V0X2Jsb2NrKHJvd3NfQSwgY29sc19BLCBCKTtcbiAgICAgICAgICAgIHJldHVybiBYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eXBlIG11c3QgYmUgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLCBidXQgdHlwZSBpcyAke3R5cGV9IWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JpdGVzIHRoZSBlbnRyaWVzIG9mIEIgaW4gQSBhdCBhbiBvZmZzZXQgcG9zaXRpb24gZ2l2ZW4gYnkge0BsaW5rIG9mZnNldF9yb3d9IGFuZCB7QGxpbmsgb2Zmc2V0X2NvbH0uXG4gICAgICogQHBhcmFtIHtpbnR9IG9mZnNldF9yb3dcbiAgICAgKiBAcGFyYW0ge2ludH0gb2Zmc2V0X2NvbFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBCXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzZXRfYmxvY2sob2Zmc2V0X3Jvdywgb2Zmc2V0X2NvbCwgQikge1xuICAgICAgICBsZXQgW3Jvd3MsIGNvbHNdID0gQi5zaGFwZTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGlmIChyb3cgPiB0aGlzLl9yb3dzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2wgPiB0aGlzLl9jb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldF9lbnRyeShyb3cgKyBvZmZzZXRfcm93LCBjb2wgKyBvZmZzZXRfY29sLCBCLmVudHJ5KHJvdywgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIGVudHJpZXMgZnJvbSB0aGUge0BsaW5rIHN0YXJ0X3Jvd308c3VwPnRoPC9zdXA+IHJvdyB0byB0aGUge0BsaW5rIGVuZF9yb3d9PHN1cD50aDwvc3VwPiByb3csIHRoZSB7QGxpbmsgc3RhcnRfY29sfTxzdXA+dGg8L3N1cD4gY29sdW1uIHRvIHRoZSB7QGxpbmsgZW5kX2NvbH08c3VwPnRoPC9zdXA+IGNvbHVtbiBvZiB0aGUgbWF0cml4LlxuICAgICAqIElmIHtAbGluayBlbmRfcm93fSBvciB7QGxpbmsgZW5kX2NvbH0gaXMgZW1wdHksIHRoZSByZXNwZWN0aXZlIHZhbHVlIGlzIHNldCB0byB7QGxpbmsgdGhpcy5yb3dzfSBvciB7QGxpbmsgdGhpcy5jb2xzfS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRfcm93XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0X2NvbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kX3JvdyA9IG51bGxdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRfY29sID0gbnVsbF1cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSBSZXR1cm5zIGEgZW5kX3JvdyAtIHN0YXJ0X3JvdyB0aW1lcyBlbmRfY29sIC0gc3RhcnRfY29sIG1hdHJpeCwgd2l0aCByZXNwZWN0aXZlIGVudHJpZXMgZnJvbSB0aGUgbWF0cml4LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBsZXQgQSA9IE1hdHJpeC5mcm9tKFtbMSwgMiwgM10sIFs0LCA1LCA2XSwgWzcsIDgsIDldXSk7IC8vIGEgMyBieSAzIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIEEuZ2V0X2Jsb2NrKDEsIDEpOyAvLyBbWzUsIDZdLCBbOCwgOV1dXG4gICAgICogQS5nZXRfYmxvY2soMCwgMCwgMSwgMSk7IC8vIFtbMV1dXG4gICAgICogQS5nZXRfYmxvY2soMSwgMSwgMiwgMik7IC8vIFtbNV1dXG4gICAgICogQS5nZXRfYmxvY2soMCwgMCwgMiwgMik7IC8vIFtbMSwgMl0sIFs0LCA1XV1cbiAgICAgKi9cbiAgICBnZXRfYmxvY2soc3RhcnRfcm93LCBzdGFydF9jb2wsIGVuZF9yb3cgPSBudWxsLCBlbmRfY29sID0gbnVsbCkge1xuICAgICAgICBjb25zdCBbcm93cywgY29sc10gPSB0aGlzLnNoYXBlO1xuICAgICAgICBlbmRfcm93ID0gZW5kX3JvdyA/PyByb3dzO1xuICAgICAgICBlbmRfY29sID0gZW5kX2NvbCA/PyBjb2xzO1xuICAgICAgICBpZiAoZW5kX3JvdyA8PSBzdGFydF9yb3cgfHwgZW5kX2NvbCA8PSBzdGFydF9jb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgICAgICAgICAgZW5kX3JvdyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdGFydF9yb3csIGFuZCBcbiAgICAgICAgICAgICAgICBlbmRfY29sIG11c3QgYmUgZ3JlYXRlciB0aGFuIHN0YXJ0X2NvbCwgYnV0XG4gICAgICAgICAgICAgICAgZW5kX3JvdyA9ICR7ZW5kX3Jvd30sIHN0YXJ0X3JvdyA9ICR7c3RhcnRfcm93fSwgZW5kX2NvbCA9ICR7ZW5kX2NvbH0sIGFuZCBzdGFydF9jb2wgPSAke3N0YXJ0X2NvbH0hYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWCA9IG5ldyBNYXRyaXgoZW5kX3JvdyAtIHN0YXJ0X3JvdywgZW5kX2NvbCAtIHN0YXJ0X2NvbCwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gc3RhcnRfcm93LCBuZXdfcm93ID0gMDsgcm93IDwgZW5kX3JvdzsgKytyb3csICsrbmV3X3Jvdykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gc3RhcnRfY29sLCBuZXdfY29sID0gMDsgY29sIDwgZW5kX2NvbDsgKytjb2wsICsrbmV3X2NvbCkge1xuICAgICAgICAgICAgICAgIFguc2V0X2VudHJ5KG5ld19yb3csIG5ld19jb2wsIHRoaXMuZW50cnkocm93LCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWDtcbiAgICAgICAgLy9yZXR1cm4gbmV3IE1hdHJpeChlbmRfcm93IC0gc3RhcnRfcm93LCBlbmRfY29sIC0gc3RhcnRfY29sLCAoaSwgaikgPT4gdGhpcy5lbnRyeShpICsgc3RhcnRfcm93LCBqICsgc3RhcnRfY29sKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBhcnJheSBnYXRoZXJpbmcgZW50cmllcyBkZWZpbmVkIGJ5IHRoZSBpbmRpY2VzIGdpdmVuIGJ5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gcm93X2luZGljZXMgLSBBcnJheSBjb25zaXN0cyBvZiBpbmRpY2VzIG9mIHJvd3MgZm9yIGdhdGhlcmluZyBlbnRyaWVzIG9mIHRoaXMgbWF0cml4XG4gICAgICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBjb2xfaW5kaWNlcyAgLSBBcnJheSBjb25zaXN0cyBvZiBpbmRpY2VzIG9mIGNvbHMgZm9yIGdhdGhlcmluZyBlbnRyaWVzIG9mIHRoaXMgbWF0cml4XG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBnYXRoZXIocm93X2luZGljZXMsIGNvbF9pbmRpY2VzKSB7XG4gICAgICAgIGNvbnN0IE4gPSByb3dfaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IEQgPSBjb2xfaW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgUiA9IG5ldyBNYXRyaXgoTiwgRCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByb3dfaW5kZXggPSByb3dfaW5kaWNlc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sX2luZGV4ID0gY29sX2luZGljZXNbal07XG4gICAgICAgICAgICAgICAgUi5zZXRfZW50cnkoaSwgaiwgdGhpcy5lbnRyeShyb3dfaW5kZXgsIGNvbF9pbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGYgZnVuY3Rpb24gdGFrZXMgMiBwYXJhbWV0ZXJzLCB0aGUgdmFsdWUgb2YgdGhlIGFjdHVhbCBlbnRyeSBhbmQgYSB2YWx1ZSBnaXZlbiBieSB0aGUgZnVuY3Rpb24ge0BsaW5rIHZ9LiBUaGUgcmVzdWx0IG9mIHtAbGluayBmfSBnZXRzIHdyaXRlbiB0byB0aGUgTWF0cml4LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHYgZnVuY3Rpb24gdGFrZXMgMiBwYXJhbWV0ZXJzIGZvciByb3cgYW5kIGNvbCwgYW5kIHJldHVybnMgYSB2YWx1ZSB3aXRjaCBzaG91bGQgYmUgYXBwbGllZCB0byB0aGUgY29sdGggZW50cnkgb2YgdGhlIHJvd3RoIHJvdyBvZiB0aGUgbWF0cml4LlxuICAgICAqL1xuICAgIF9hcHBseV9hcnJheShmLCB2KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgY29uc3QgW3Jvd3MsIGNvbHNdID0gdGhpcy5zaGFwZTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHJvdyAqIGNvbHM7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBvZmZzZXQgKyBjb2w7XG4gICAgICAgICAgICAgICAgZGF0YVtpXSA9IGYoZGF0YVtpXSwgdihyb3csIGNvbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9hcHBseV9yb3d3aXNlX2FycmF5KHZhbHVlcywgZikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlfYXJyYXkoZiwgKF8sIGopID0+IHZhbHVlc1tqXSk7XG4gICAgfVxuXG4gICAgX2FwcGx5X2NvbHdpc2VfYXJyYXkodmFsdWVzLCBmKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgY29uc3QgW3Jvd3MsIGNvbHNdID0gdGhpcy5zaGFwZTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHJvdyAqIGNvbHM7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBvZmZzZXQgKyBjb2w7XG4gICAgICAgICAgICAgICAgZGF0YVtpXSA9IGYoZGF0YVtpXSwgdmFsdWVzW3Jvd10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9hcHBseSh2YWx1ZSwgZikge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMudmFsdWVzO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCBbdmFsdWVfcm93cywgdmFsdWVfY29sc10gPSB2YWx1ZS5zaGFwZTtcbiAgICAgICAgICAgIGxldCBbcm93cywgY29sc10gPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgaWYgKHZhbHVlX3Jvd3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29scyAhPT0gdmFsdWVfY29scykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbHMgIT09IHZhbHVlX2NvbHNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbcm93ICogY29scyArIGNvbF0gPSBmKGRhdGFbcm93ICogY29scyArIGNvbF0sIHZhbHVlLmVudHJ5KDAsIGNvbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZV9jb2xzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd3MgIT09IHZhbHVlX3Jvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByb3dzICE9PSB2YWx1ZV9yb3dzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gZihkYXRhW3JvdyAqIGNvbHMgKyBjb2xdLCB2YWx1ZS5lbnRyeShyb3csIDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocm93cyA9PSB2YWx1ZV9yb3dzICYmIGNvbHMgPT0gdmFsdWVfY29scykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gZihkYXRhW3JvdyAqIGNvbHMgKyBjb2xdLCB2YWx1ZS5lbnRyeShyb3csIGNvbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVycm9yYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgICAgIGxldCBjb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IHJvd3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWVbcm93XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PT0gY29scykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gZihkYXRhW3JvdyAqIGNvbHMgKyBjb2xdLCB2YWx1ZVtjb2xdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9yb3dzICogdGhpcy5fY29sczsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBmKGRhdGFbaV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgdGhlIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBsZXQgQiA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgQi5fcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgIEIuX2NvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICBCLl9kYXRhID0gdGhpcy52YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgIHJldHVybiBCO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudHJ5d2lzZSBtdWx0aXBsaWNhdGlvbiB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAyXSwgWzMsIDRdXSk7IC8vIGEgMiBieSAyIG1hdHJpeC5cbiAgICAgKiBsZXQgQiA9IEEuY2xvbmUoKTsgLy8gQiA9PSBBO1xuICAgICAqXG4gICAgICogQS5tdWx0KDIpOyAvLyBbWzIsIDRdLCBbNiwgOF1dO1xuICAgICAqIEEubXVsdChCKTsgLy8gW1sxLCA0XSwgWzksIDE2XV07XG4gICAgICovXG4gICAgbXVsdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9hcHBseSh2YWx1ZSwgKGEsIGIpID0+IGEgKiBiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnRyeXdpc2UgZGl2aXNpb24gd2l0aCB7QGxpbmsgdmFsdWV9LlxuICAgICAqIEBwYXJhbSB7TWF0cml4fEFycmF5fE51bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBsZXQgQSA9IE1hdHJpeC5mcm9tKFtbMSwgMl0sIFszLCA0XV0pOyAvLyBhIDIgYnkgMiBtYXRyaXguXG4gICAgICogbGV0IEIgPSBBLmNsb25lKCk7IC8vIEIgPT0gQTtcbiAgICAgKlxuICAgICAqIEEuZGl2aWRlKDIpOyAvLyBbWzAuNSwgMV0sIFsxLjUsIDJdXTtcbiAgICAgKiBBLmRpdmlkZShCKTsgLy8gW1sxLCAxXSwgWzEsIDFdXTtcbiAgICAgKi9cbiAgICBkaXZpZGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYXBwbHkodmFsdWUsIChhLCBiKSA9PiBhIC8gYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW50cnl3aXNlIGFkZGl0aW9uIHdpdGgge0BsaW5rIHZhbHVlfS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeHxBcnJheXxOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDJdLCBbMywgNF1dKTsgLy8gYSAyIGJ5IDIgbWF0cml4LlxuICAgICAqIGxldCBCID0gQS5jbG9uZSgpOyAvLyBCID09IEE7XG4gICAgICpcbiAgICAgKiBBLmFkZCgyKTsgLy8gW1szLCA0XSwgWzUsIDZdXTtcbiAgICAgKiBBLmFkZChCKTsgLy8gW1syLCA0XSwgWzYsIDhdXTtcbiAgICAgKi9cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYXBwbHkodmFsdWUsIChhLCBiKSA9PiBhICsgYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW50cnl3aXNlIHN1YnRyYWN0aW9uIHdpdGgge0BsaW5rIHZhbHVlfS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeHxBcnJheXxOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDJdLCBbMywgNF1dKTsgLy8gYSAyIGJ5IDIgbWF0cml4LlxuICAgICAqIGxldCBCID0gQS5jbG9uZSgpOyAvLyBCID09IEE7XG4gICAgICpcbiAgICAgKiBBLnN1YigyKTsgLy8gW1stMSwgMF0sIFsxLCAyXV07XG4gICAgICogQS5zdWIoQik7IC8vIFtbMCwgMF0sIFswLCAwXV07XG4gICAgICovXG4gICAgc3ViKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2FwcGx5KHZhbHVlLCAoYSwgYikgPT4gYSAtIGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBBcnJheSBpbiB0aGUgZm9ybSBbcm93cywgY29sdW1uc10uXG4gICAgICovXG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuX3Jvd3MsIHRoaXMuX2NvbHNdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdHJpeCBpbiB0aGUgZ2l2ZW4gc2hhcGUgd2l0aCB0aGUgZ2l2ZW4gZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB2YWx1ZXMgZm9yIHRoZSBlbnRyaWVzIG9mIHRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1ldGVyIC0gdGFrZXMgYW4gQXJyYXkgaW4gdGhlIGZvcm0gW3Jvd3MsIGNvbHMsIHZhbHVlXSwgd2hlcmUgcm93cyBhbmQgY29scyBhcmUgdGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIG9mIHRoZSBtYXRyaXgsIGFuZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBwYXJhbWV0ZXJzIChyb3cgYW5kIGNvbCkgd2hpY2ggaGFzIHRvIHJldHVybiBhIHZhbHVlIGZvciB0aGUgY29sdGggZW50cnkgb2YgdGhlIHJvd3RoIHJvdy5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHNldCBzaGFwZShbcm93cywgY29scywgdmFsdWUgPSAoKSA9PiAwXSkge1xuICAgICAgICB0aGlzLl9yb3dzID0gcm93cztcbiAgICAgICAgdGhpcy5fY29scyA9IGNvbHM7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IHZhbHVlKHJvdywgY29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBNYXRyaXggYXMgYSBBcnJheSBvZiBGbG9hdDY0QXJyYXlzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxGbG9hdDY0QXJyYXk+fVxuICAgICAqL1xuICAgIGdldCB0bzJkQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLml0ZXJhdGVfcm93cygpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTWF0cml4IGFzIGEgQXJyYXkgb2YgQXJyYXlzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59XG4gICAgICovXG4gICAgZ2V0IGFzQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLml0ZXJhdGVfcm93cygpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChBcnJheS5mcm9tKHJvdykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlhZ29uYWwgb2YgdGhlIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7RmxvYXQ2NEFycmF5fVxuICAgICAqL1xuICAgIGdldCBkaWFnKCkge1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgIGNvbnN0IG1pbl9yb3dfY29sID0gTWF0aC5taW4ocm93cywgY29scyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgRmxvYXQ2NEFycmF5KG1pbl9yb3dfY29sKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaW5fcm93X2NvbDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLmVudHJ5KGksIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWVhbiBvZiBhbGwgZW50cmllcyBvZiB0aGUgTWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IG1lYW4oKSB7XG4gICAgICAgIGNvbnN0IHN1bSA9IHRoaXMuc3VtO1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fcm93cyAqIHRoaXMuX2NvbHM7XG4gICAgICAgIHJldHVybiBzdW0gLyBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN1bSBvb2YgYWxsIGVudHJpZXMgb2YgdGhlIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzdW0oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgcmV0dXJuIG5ldW1haXJfc3VtKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN1bSBvb2YgYWxsIGVudHJpZXMgb2YgdGhlIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7RmxvYXQ2NEFycmF5fVxuICAgICAqL1xuICAgIGdldCB2YWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZWFuIG9mIGVhY2ggcm93IG9mIHRoZSBtYXRyaXguXG4gICAgICogQHJldHVybnMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgbWVhblJvd3MoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBGbG9hdDY0QXJyYXkuZnJvbSh7IGxlbmd0aDogcm93cyB9KTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyb3ddID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jvd10gKz0gZGF0YVtyb3cgKiBjb2xzICsgY29sXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtyb3ddIC89IGNvbHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0aGUgbWVhbiBvZiBlYWNoIGNvbHVtbiBvZiB0aGUgbWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtGbG9hdDY0QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IG1lYW5Db2xzKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0aGlzLl9yb3dzO1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRmxvYXQ2NEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHMgfSk7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICByZXN1bHRbY29sXSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtjb2xdICs9IGRhdGFbcm93ICogY29scyArIGNvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbY29sXSAvPSByb3dzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU29sdmVzIHRoZSBlcXVhdGlvbiB7QGxpbmsgQX14ID0ge0BsaW5rIGJ9IHVzaW5nIHRoZSBjb25qdWdhdGUgZ3JhZGllbnQgbWV0aG9kLiBSZXR1cm5zIHRoZSByZXN1bHQgeC5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQSAtIE1hdHJpeFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBiIC0gTWF0cml4XG4gICAgICogQHBhcmFtIHtSYW5kb21pemVyfSBbcmFuZG9taXplcj1udWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdG9sPTFlLTNdXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzdGF0aWMgc29sdmVfQ0coQSwgYiwgcmFuZG9taXplciwgdG9sID0gMWUtMykge1xuICAgICAgICBpZiAocmFuZG9taXplciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmFuZG9taXplciA9IG5ldyBSYW5kb21pemVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm93cyA9IEEuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IGNvbHMgPSBiLnNoYXBlWzFdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IE1hdHJpeChyb3dzLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGJfaSA9IE1hdHJpeC5mcm9tKGIuY29sKGkpKS5UO1xuICAgICAgICAgICAgbGV0IHggPSBuZXcgTWF0cml4KHJvd3MsIDEsICgpID0+IHJhbmRvbWl6ZXIucmFuZG9tKTtcbiAgICAgICAgICAgIGxldCByID0gYl9pLnN1YihBLmRvdCh4KSk7XG4gICAgICAgICAgICBsZXQgZCA9IHIuY2xvbmUoKTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCB6ID0gQS5kb3QoZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxwaGEgPSByLlQuZG90KHIpLmVudHJ5KDAsIDApIC8gZC5ULmRvdCh6KS5lbnRyeSgwLCAwKTtcbiAgICAgICAgICAgICAgICB4ID0geC5hZGQoZC5tdWx0KGFscGhhKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcl9uZXh0ID0gci5zdWIoei5tdWx0KGFscGhhKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmV0YSA9IHJfbmV4dC5ULmRvdChyX25leHQpLmVudHJ5KDAsIDApIC8gci5ULmRvdChyKS5lbnRyeSgwLCAwKTtcbiAgICAgICAgICAgICAgICBkID0gcl9uZXh0LmFkZChkLm11bHQoYmV0YSkpO1xuICAgICAgICAgICAgICAgIHIgPSByX25leHQ7XG4gICAgICAgICAgICB9IHdoaWxlIChNYXRoLmFicyhyLm1lYW4pID4gdG9sKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoeCwgXCJob3Jpem9udGFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU29sdmVzIHRoZSBlcXVhdGlvbiB7QGxpbmsgQX14ID0ge0BsaW5rIGJ9LiBSZXR1cm5zIHRoZSByZXN1bHQgeC5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQSAtIE1hdHJpeCBvciBMVSBEZWNvbXBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGIgLSBNYXRyaXhcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHN0YXRpYyBzb2x2ZShBLCBiKSB7XG4gICAgICAgIGxldCB7IEw6IEwsIFU6IFUgfSA9IFwiTFwiIGluIEEgJiYgXCJVXCIgaW4gQSA/IEEgOiBNYXRyaXguTFUoQSk7XG4gICAgICAgIGxldCByb3dzID0gTC5zaGFwZVswXTtcbiAgICAgICAgbGV0IHggPSBiLmNsb25lKCk7XG5cbiAgICAgICAgLy8gZm9yd2FyZFxuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgcm93IC0gMTsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICB4LnNldF9lbnRyeSgwLCByb3csIHguZW50cnkoMCwgcm93KSAtIEwuZW50cnkocm93LCBjb2wpICogeC5lbnRyeSgxLCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHguc2V0X2VudHJ5KDAsIHJvdywgeC5lbnRyeSgwLCByb3cpIC8gTC5lbnRyeShyb3csIHJvdykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmFja3dhcmRcbiAgICAgICAgZm9yIChsZXQgcm93ID0gcm93cyAtIDE7IHJvdyA+PSAwOyAtLXJvdykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gcm93cyAtIDE7IGNvbCA+IHJvdzsgLS1jb2wpIHtcbiAgICAgICAgICAgICAgICB4LnNldF9lbnRyeSgwLCByb3csIHguZW50cnkoMCwgcm93KSAtIFUuZW50cnkocm93LCBjb2wpICogeC5lbnRyeSgwLCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHguc2V0X2VudHJ5KDAsIHJvdywgeC5lbnRyeSgwLCByb3cpIC8gVS5lbnRyeShyb3csIHJvdykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICoge0BsaW5rIEx9e0BsaW5rIFV9IGRlY29tcG9zaXRpb24gb2YgdGhlIE1hdHJpeCB7QGxpbmsgQX0uIENyZWF0ZXMgdHdvIG1hdHJpY2VzLCBzbyB0aGF0IHRoZSBkb3QgcHJvZHVjdCBMVSBlcXVhbHMgQS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQVxuICAgICAqIEByZXR1cm5zIHt7TDogTWF0cml4LCBVOiBNYXRyaXh9fSByZXN1bHQgLSBSZXR1cm5zIHRoZSBsZWZ0IHRyaWFuZ2xlIG1hdHJpeCB7QGxpbmsgTH0gYW5kIHRoZSB1cHBlciB0cmlhbmdsZSBtYXRyaXgge0BsaW5rIFV9LlxuICAgICAqL1xuICAgIHN0YXRpYyBMVShBKSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBBLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBMID0gbmV3IE1hdHJpeChyb3dzLCByb3dzLCBcInplcm9zXCIpO1xuICAgICAgICBjb25zdCBVID0gbmV3IE1hdHJpeChyb3dzLCByb3dzLCBcImlkZW50aXR5XCIpO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93czsgKytqKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gajsgaSA8IHJvd3M7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgajsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBMLmVudHJ5KGksIGspICogVS5lbnRyeShrLCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgTC5zZXRfZW50cnkoaSwgaiwgQS5lbnRyeShpLCBqKSAtIHN1bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gajsgaSA8IHJvd3M7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChMLmVudHJ5KGosIGopID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgajsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBMLmVudHJ5KGosIGspICogVS5lbnRyeShrLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgVS5zZXRfZW50cnkoaiwgaSwgKEEuZW50cnkoaiwgaSkgLSBzdW0pIC8gTC5lbnRyeShqLCBqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBMOiBMLCBVOiBVIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRldGVybWluYW50ZSBvZiB7QGxpbmsgQX0sIGJ5IHVzaW5nIHRoZSBMVSBkZWNvbXBvc2l0aW9uIG9mIHtAbGluayBBfS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldCAtIFJldHVybnMgdGhlIGRldGVybWluYXRlIG9mIHRoZSBNYXRyaXgge0BsaW5rIEF9LlxuICAgICAqL1xuICAgIHN0YXRpYyBkZXQoQSkge1xuICAgICAgICBjb25zdCByb3dzID0gQS5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgeyBMLCBVIH0gPSBNYXRyaXguTFUoQSk7XG4gICAgICAgIGNvbnN0IExfZGlhZyA9IEwuZGlhZztcbiAgICAgICAgY29uc3QgVV9kaWFnID0gVS5kaWFnO1xuICAgICAgICBsZXQgZGV0ID0gTF9kaWFnWzBdICogVV9kaWFnWzBdO1xuICAgICAgICBmb3IgKGxldCByb3cgPSAxOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgZGV0ICo9IExfZGlhZ1tyb3ddICogVV9kaWFnW3Jvd107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUge0BsaW5rIGt9IGNvbXBvbmVudHMgb2YgdGhlIFNWRCBkZWNvbXBvc2l0aW9uIG9mIHRoZSBtYXRyaXgge0BsaW5rIE19XG4gICAgICogQHBhcmFtIHtNYXRyaXh9IE1cbiAgICAgKiBAcGFyYW0ge2ludH0gW2s9Ml1cbiAgICAgKiBAcmV0dXJucyB7e1U6IE1hdHJpeCwgU2lnbWE6IE1hdHJpeCwgVjogTWF0cml4fX1cbiAgICAgKi9cbiAgICBzdGF0aWMgU1ZEKE0sIGsgPSAyKSB7XG4gICAgICAgIGNvbnN0IE1UID0gTS5UO1xuICAgICAgICBsZXQgTXRNID0gTVQuZG90KE0pO1xuICAgICAgICBsZXQgTU10ID0gTS5kb3QoTVQpO1xuICAgICAgICBsZXQgeyBlaWdlbnZlY3RvcnM6IFYsIGVpZ2VudmFsdWVzOiBTaWdtYSB9ID0gc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uKE10TSwgayk7XG4gICAgICAgIGxldCB7IGVpZ2VudmVjdG9yczogVSB9ID0gc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uKE1NdCwgayk7XG4gICAgICAgIHJldHVybiB7IFU6IFUsIFNpZ21hOiBTaWdtYS5tYXAoKHNpZ21hKSA9PiBNYXRoLnNxcnQoc2lnbWEpKSwgVjogViB9O1xuXG4gICAgICAgIC8vQWxnb3JpdGhtIDFhOiBIb3VzZWhvbGRlciByZWR1Y3Rpb24gdG8gYmlkaWFnb25hbCBmb3JtOlxuICAgICAgICAvKiBjb25zdCBbbSwgbl0gPSBBLnNoYXBlO1xuICAgICAgICBsZXQgVSA9IG5ldyBNYXRyaXgobSwgbiwgKGksIGopID0+IGkgPT0gaiA/IDEgOiAwKTtcbiAgICAgICAgY29uc29sZS5sb2coVS50bzJkQXJyYXkpXG4gICAgICAgIGxldCBWID0gbmV3IE1hdHJpeChuLCBtLCAoaSwgaikgPT4gaSA9PSBqID8gMSA6IDApO1xuICAgICAgICBjb25zb2xlLmxvZyhWLnRvMmRBcnJheSlcbiAgICAgICAgbGV0IEIgPSBNYXRyaXguYmlkaWFnb25hbChBLmNsb25lKCksIFUsIFYpO1xuICAgICAgICBjb25zb2xlLmxvZyhVLFYsQilcbiAgICAgICAgcmV0dXJuIHsgVTogVSwgXCJTaWdtYVwiOiBCLCBWOiBWIH07ICovXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgbGluc3BhY2UsIE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBtb2R1bGU6dXRpbHNcbiAqIEBhbGlhcyBSYW5kb21pemVyXG4gKi9cbmV4cG9ydCBjbGFzcyBSYW5kb21pemVyIHtcbiAgICAvKipcbiAgICAgKiBNZXJzZW5uZSBUd2lzdGVyIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbX3NlZWQ9bmV3IERhdGUoKS5nZXRUaW1lKCldIC0gVGhlIHNlZWQgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci4gSWYgPGNvZGU+X3NlZWQgPT0gbnVsbDwvY29kZT4gdGhlbiB0aGUgYWN0dWFsIHRpbWUgZ2V0cyB1c2VkIGFzIHNlZWQuXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYm11cnJheTcvbWVyc2VubmUtdHdpc3Rlci1leGFtcGxlcy9ibG9iL21hc3Rlci9qYXZhc2NyaXB0LW1lcnNlbm5lLXR3aXN0ZXIuanNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihfc2VlZCkge1xuICAgICAgICB0aGlzLl9OID0gNjI0O1xuICAgICAgICB0aGlzLl9NID0gMzk3O1xuICAgICAgICB0aGlzLl9NQVRSSVhfQSA9IDB4OTkwOGIwZGY7XG4gICAgICAgIHRoaXMuX1VQUEVSX01BU0sgPSAweDgwMDAwMDAwO1xuICAgICAgICB0aGlzLl9MT1dFUl9NQVNLID0gMHg3ZmZmZmZmZjtcbiAgICAgICAgdGhpcy5fbXQgPSBuZXcgQXJyYXkodGhpcy5fTik7XG4gICAgICAgIHRoaXMuX210aSA9IHRoaXMuTiArIDE7XG5cbiAgICAgICAgdGhpcy5zZWVkID0gX3NlZWQgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldCBzZWVkKF9zZWVkKSB7XG4gICAgICAgIHRoaXMuX3NlZWQgPSBfc2VlZDtcbiAgICAgICAgbGV0IG10ID0gdGhpcy5fbXQ7XG5cbiAgICAgICAgbXRbMF0gPSBfc2VlZCA+Pj4gMDtcbiAgICAgICAgZm9yICh0aGlzLl9tdGkgPSAxOyB0aGlzLl9tdGkgPCB0aGlzLl9OOyB0aGlzLl9tdGkgKz0gMSkge1xuICAgICAgICAgICAgbGV0IG10aSA9IHRoaXMuX210aTtcbiAgICAgICAgICAgIGxldCBzID0gbXRbbXRpIC0gMV0gXiAobXRbbXRpIC0gMV0gPj4+IDMwKTtcbiAgICAgICAgICAgIG10W210aV0gPSAoKCgocyAmIDB4ZmZmZjAwMDApID4+PiAxNikgKiAxODEyNDMzMjUzKSA8PCAxNikgKyAocyAmIDB4MDAwMGZmZmYpICogMTgxMjQzMzI1MyArIG10aTtcbiAgICAgICAgICAgIG10W210aV0gPj4+PSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2VlZCBvZiB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge051bWJlcn0gLSBUaGUgc2VlZC5cbiAgICAgKi9cbiAgICBnZXQgc2VlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSAtIEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIFswLCAxXVxuICAgICAqL1xuICAgIGdldCByYW5kb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmRvbV9pbnQgKiAoMS4wIC8gNDI5NDk2NzI5Ni4wKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCBNQVhfSU5URUdFUi5cbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn0gLSBBIHJhbmRvbSBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGdldCByYW5kb21faW50KCkge1xuICAgICAgICBsZXQgeSxcbiAgICAgICAgICAgIG1hZzAxID0gbmV3IEFycmF5KDB4MCwgdGhpcy5fTUFUUklYX0EpO1xuICAgICAgICBpZiAodGhpcy5fbXRpID49IHRoaXMuX04pIHtcbiAgICAgICAgICAgIGxldCBraztcblxuICAgICAgICAgICAgLyogaWYgKHRoaXMuX210aSA9PSB0aGlzLl9OICsgMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VlZCA9IDU0ODk7XG4gICAgICAgICAgICB9ICovXG5cbiAgICAgICAgICAgIGxldCBOX00gPSB0aGlzLl9OIC0gdGhpcy5fTTtcbiAgICAgICAgICAgIGxldCBNX04gPSB0aGlzLl9NIC0gdGhpcy5fTjtcblxuICAgICAgICAgICAgZm9yIChrayA9IDA7IGtrIDwgTl9NOyArK2trKSB7XG4gICAgICAgICAgICAgICAgeSA9ICh0aGlzLl9tdFtra10gJiB0aGlzLl9VUFBFUl9NQVNLKSB8ICh0aGlzLl9tdFtrayArIDFdICYgdGhpcy5fTE9XRVJfTUFTSyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbXRba2tdID0gdGhpcy5fbXRba2sgKyB0aGlzLl9NXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IGtrIDwgdGhpcy5fTiAtIDE7ICsra2spIHtcbiAgICAgICAgICAgICAgICB5ID0gKHRoaXMuX210W2trXSAmIHRoaXMuX1VQUEVSX01BU0spIHwgKHRoaXMuX210W2trICsgMV0gJiB0aGlzLl9MT1dFUl9NQVNLKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tdFtra10gPSB0aGlzLl9tdFtrayArIE1fTl0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeSA9ICh0aGlzLl9tdFt0aGlzLl9OIC0gMV0gJiB0aGlzLl9VUFBFUl9NQVNLKSB8ICh0aGlzLl9tdFswXSAmIHRoaXMuX0xPV0VSX01BU0spO1xuICAgICAgICAgICAgdGhpcy5fbXRbdGhpcy5fTiAtIDFdID0gdGhpcy5fbXRbdGhpcy5fTSAtIDFdIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV07XG5cbiAgICAgICAgICAgIHRoaXMuX210aSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB5ID0gdGhpcy5fbXRbKHRoaXMuX210aSArPSAxKV07XG4gICAgICAgIHkgXj0geSA+Pj4gMTE7XG4gICAgICAgIHkgXj0gKHkgPDwgNykgJiAweDlkMmM1NjgwO1xuICAgICAgICB5IF49ICh5IDw8IDE1KSAmIDB4ZWZjNjAwMDA7XG4gICAgICAgIHkgXj0geSA+Pj4gMTg7XG5cbiAgICAgICAgcmV0dXJuIHkgPj4+IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzYW1wbGVzIGZyb20gYW4gaW5wdXQgTWF0cml4IG9yIEFycmF5LlxuICAgICAqIEBwYXJhbSB7TWF0cml4fEFycmF5fEZsb2F0NjRBcnJheX0gQSAtIFRoZSBpbnB1dCBNYXRyaXggb3IgQXJyYXkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gLSBUaGUgbnVtYmVyIG9mIHNhbXBsZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIEEgcmFuZG9tIHNlbGVjdGlvbiBmb3JtIHtAbGluayBBfSBvZiB7QGxpbmsgbn0gc2FtcGxlcy5cbiAgICAgKi9cbiAgICBjaG9pY2UoQSwgbikge1xuICAgICAgICBpZiAoQSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IHJvd3MgPSBBLnNoYXBlWzBdO1xuICAgICAgICAgICAgaWYgKG4gPiByb3dzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibiBiaWdnZXIgdGhhbiBBIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzYW1wbGUgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICBsZXQgaW5kZXhfbGlzdCA9IGxpbnNwYWNlKDAsIHJvd3MgLSAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gaW5kZXhfbGlzdC5sZW5ndGg7IGkgPCBuOyArK2ksIC0tbCkge1xuICAgICAgICAgICAgICAgIGxldCByYW5kb21faW5kZXggPSB0aGlzLnJhbmRvbV9pbnQgJSBsO1xuICAgICAgICAgICAgICAgIHNhbXBsZVtpXSA9IGluZGV4X2xpc3Quc3BsaWNlKHJhbmRvbV9pbmRleCwgMSlbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlLm1hcCgoZCkgPT4gQS5yb3coZCkpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoQSkgfHwgQSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkge1xuICAgICAgICAgICAgbGV0IHJvd3MgPSBBLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuID4gcm93cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm4gYmlnZ2VyIHRoYW4gQSFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2FtcGxlID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgbGV0IGluZGV4X2xpc3QgPSBsaW5zcGFjZSgwLCByb3dzIC0gMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGluZGV4X2xpc3QubGVuZ3RoOyBpIDwgbjsgKytpLCAtLWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZG9tX2luZGV4ID0gdGhpcy5yYW5kb21faW50ICUgbDtcbiAgICAgICAgICAgICAgICBzYW1wbGVbaV0gPSBpbmRleF9saXN0LnNwbGljZShyYW5kb21faW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZS5tYXAoKGQpID0+IEFbZF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIFJldHVybnMgc2FtcGxlcyBmcm9tIGFuIGlucHV0IE1hdHJpeCBvciBBcnJheS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeHxBcnJheXxGbG9hdDY0QXJyYXl9IEEgLSBUaGUgaW5wdXQgTWF0cml4IG9yIEFycmF5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWVkIC0gVGhlIHNlZWQgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gQSByYW5kb20gc2VsZWN0aW9uIGZvcm0ge0BsaW5rIEF9IG9mIHtAbGluayBufSBzYW1wbGVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjaG9pY2UoQSwgbiwgc2VlZCA9IDEyMTIpIHtcbiAgICAgICAgY29uc3QgUiA9IG5ldyBSYW5kb21pemVyKHNlZWQpO1xuICAgICAgICByZXR1cm4gUi5jaG9pY2UoQSwgbik7XG4gICAgICAgIC8qIGxldCByb3dzID0gQS5zaGFwZVswXTtcbiAgICAgICAgaWYgKG4gPiByb3dzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuIGJpZ2dlciB0aGFuIEEhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5kID0gbmV3IFJhbmRvbWl6ZXIoc2VlZCk7XG4gICAgICAgIGxldCBzYW1wbGUgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIGxldCBpbmRleF9saXN0ID0gbGluc3BhY2UoMCwgcm93cyAtIDEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGluZGV4X2xpc3QubGVuZ3RoOyBpIDwgbjsgKytpLCAtLWwpIHtcbiAgICAgICAgICAgIGxldCByYW5kb21faW5kZXggPSByYW5kLnJhbmRvbV9pbnQgJSBsO1xuICAgICAgICAgICAgc2FtcGxlW2ldID0gaW5kZXhfbGlzdC5zcGxpY2UocmFuZG9tX2luZGV4LCAxKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvL3JldHVybiByZXN1bHQ7XG4gICAgICAgIC8vcmV0dXJuIG5ldyBNYXRyaXgobiwgY29scywgKHJvdywgY29sKSA9PiBBLmVudHJ5KHNhbXBsZVtyb3ddLCBjb2wpKVxuICAgICAgICByZXR1cm4gc2FtcGxlLm1hcCgoZCkgPT4gQS5yb3coZCkpOyAqL1xuICAgIH1cbn1cbiIsIi8qKlxuICogUmV0dXJucyBtYXhpbXVtIGluIEFycmF5IHtAbGluayB2YWx1ZXN9LlxuICogQG1lbWJlcm9mIG1vZHVsZTp1dGlsc1xuICogQGFsaWFzIG1heFxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIGxldCBtYXg7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKG1heCA8IHZhbHVlIHx8IChtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xufSIsIi8qKlxuICogUmV0dXJucyBtYXhpbXVtIGluIEFycmF5IHtAbGluayB2YWx1ZXN9LlxuICogQG1lbWJlcm9mIG1vZHVsZTp1dGlsc1xuICogQGFsaWFzIG1pblxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgbGV0IG1pbjtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlIDw9IHZhbHVlKSkpIHtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW47XG59IiwiLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBIZWFwXG4gKi9cbmV4cG9ydCBjbGFzcyBIZWFwIHtcbiAgICAvKipcbiAgICAgKiBBIGhlYXAgaXMgYSBkYXRhc3RydWN0dXJlIGhvbGRpbmcgaXRzIGVsZW1lbnRzIGluIGEgc3BlY2lmaWMgd2F5LCBzbyB0aGF0IHRoZSB0b3AgZWxlbWVudCB3b3VsZCBiZSB0aGUgZmlyc3QgZW50cnkgb2YgYW4gb3JkZXJlZCBsaXN0LlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGF0YXN0cnVjdHVyZVxuICAgICAqIEBhbGlhcyBIZWFwXG4gICAgICogQHBhcmFtIHtBcnJheT19IGVsZW1lbnRzIC0gQ29udGFpbnMgdGhlIGVsZW1lbnRzIGZvciB0aGUgSGVhcC4ge0BsaW5rIGVsZW1lbnRzfSBjYW4gYmUgbnVsbC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbYWNjZXNzb3IgPSAoZCkgPT4gZF0gLSBGdW5jdGlvbiByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0geyhcIm1pblwifFwibWF4XCJ8RnVuY3Rpb24pfSBbY29tcGFyYXRvciA9IFwibWluXCJdIC0gRnVuY3Rpb24gcmV0dXJuaW5nIHRydWUgb3IgZmFsc2UgZGVmaW5pbmcgdGhlIHdpc2hlZCBvcmRlciBvZiB0aGUgSGVhcCwgb3IgU3RyaW5nIGZvciBwcmVkZWZpbmVkIGZ1bmN0aW9uLiAoXCJtaW5cIiBmb3IgYSBNaW4tSGVhcCwgXCJtYXhcIiBmb3IgYSBNYXhfaGVhcClcbiAgICAgKiBAcmV0dXJucyB7SGVhcH1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CaW5hcnlfaGVhcH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cyA9IG51bGwsIGFjY2Vzc29yID0gZCA9PiBkLCBjb21wYXJhdG9yID0gXCJtaW5cIikge1xuICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBIZWFwLmhlYXBpZnkoZWxlbWVudHMsIGFjY2Vzc29yLCBjb21wYXJhdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FjY2Vzc29yID0gYWNjZXNzb3I7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIgPSBbXTtcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yID09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wYXJhdG9yID0gKGEsIGIpID0+IGEgPCBiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wYXJhdG9yID09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wYXJhdG9yID0gKGEsIGIpID0+IGEgPiBiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgSGVhcCBmcm9tIGFuIEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheXxTZXR9IGVsZW1lbnRzIC0gQ29udGFpbnMgdGhlIGVsZW1lbnRzIGZvciB0aGUgSGVhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gW2FjY2Vzc29yID0gKGQpID0+IGRdIC0gRnVuY3Rpb24gcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHsoU3RyaW5nPXxGdW5jdGlvbil9IFtjb21wYXJhdG9yID0gXCJtaW5cIl0gLSBGdW5jdGlvbiByZXR1cm5pbmcgdHJ1ZSBvciBmYWxzZSBkZWZpbmluZyB0aGUgd2lzaGVkIG9yZGVyIG9mIHRoZSBIZWFwLCBvciBTdHJpbmcgZm9yIHByZWRlZmluZWQgZnVuY3Rpb24uIChcIm1pblwiIGZvciBhIE1pbi1IZWFwLCBcIm1heFwiIGZvciBhIE1heF9oZWFwKVxuICAgICAqIEByZXR1cm5zIHtIZWFwfVxuICAgICAqL1xuICAgIHN0YXRpYyBoZWFwaWZ5KGVsZW1lbnRzLCBhY2Nlc3NvciA9IGQgPT4gZCwgY29tcGFyYXRvciA9IFwibWluXCIpIHtcbiAgICAgICAgY29uc3QgaGVhcCA9IG5ldyBIZWFwKG51bGwsIGFjY2Vzc29yLCBjb21wYXJhdG9yKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gaGVhcC5fY29udGFpbmVyO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5wdXNoKHtcbiAgICAgICAgICAgICAgICBcImVsZW1lbnRcIjogZSxcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IGFjY2Vzc29yKGUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGguZmxvb3IoKGVsZW1lbnRzLmxlbmd0aCAvIDIpIC0gMSk7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBoZWFwLl9oZWFwaWZ5X2Rvd24oaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgZWxlbWVudHMgb2YgY29udGFpbmVyIGFycmF5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4X2EgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4X2IgXG4gICAgICovXG4gICAgX3N3YXAoaW5kZXhfYSwgaW5kZXhfYikge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG4gICAgICAgIFtjb250YWluZXJbaW5kZXhfYl0sIGNvbnRhaW5lcltpbmRleF9hXV0gPSBbY29udGFpbmVyW2luZGV4X2FdLCBjb250YWluZXJbaW5kZXhfYl1dO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGVhcGlmeV91cCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBjb250YWluZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgbGV0IHBhcmVudEluZGV4ID0gTWF0aC5mbG9vcigoaW5kZXggLSAxKSAvIDIpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb21wYXJhdG9yKGNvbnRhaW5lcltpbmRleF0udmFsdWUsIGNvbnRhaW5lcltwYXJlbnRJbmRleF0udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3dhcChwYXJlbnRJbmRleCwgaW5kZXgpXG4gICAgICAgICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVzaGVzIHRoZSBlbGVtZW50IHRvIHRoZSBoZWFwLlxuICAgICAqIEBwYXJhbSB7fSBlbGVtZW50XG4gICAgICogQHJldHVybnMge0hlYXB9XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fYWNjZXNzb3IoZWxlbWVudCk7XG4gICAgICAgIC8vY29uc3Qgbm9kZSA9IG5ldyBOb2RlKGVsZW1lbnQsIHZhbHVlKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHtcImVsZW1lbnRcIjogZWxlbWVudCwgXCJ2YWx1ZVwiOiB2YWx1ZX07XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLl9oZWFwaWZ5X3VwKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF9pbmRleCA9IDBdIFxuICAgICAqL1xuICAgIF9oZWFwaWZ5X2Rvd24oc3RhcnRfaW5kZXg9MCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG4gICAgICAgIGNvbnN0IGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjb250YWluZXIubGVuZ3RoO1xuICAgICAgICBsZXQgbGVmdCA9IDIgKiBzdGFydF9pbmRleCArIDE7XG4gICAgICAgIGxldCByaWdodCA9IDIgKiBzdGFydF9pbmRleCArIDI7XG4gICAgICAgIGxldCBpbmRleCA9IHN0YXJ0X2luZGV4O1xuICAgICAgICBpZiAoaW5kZXggPiBsZW5ndGgpIHRocm93IFwiaW5kZXggaGlnaGVyIHRoYW4gbGVuZ3RoXCJcbiAgICAgICAgaWYgKGxlZnQgPCBsZW5ndGggJiYgY29tcGFyYXRvcihjb250YWluZXJbbGVmdF0udmFsdWUsIGNvbnRhaW5lcltpbmRleF0udmFsdWUpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0IDwgbGVuZ3RoICYmIGNvbXBhcmF0b3IoY29udGFpbmVyW3JpZ2h0XS52YWx1ZSwgY29udGFpbmVyW2luZGV4XS52YWx1ZSkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ICE9PSBzdGFydF9pbmRleCkge1xuICAgICAgICAgICAgdGhpcy5fc3dhcChzdGFydF9pbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5faGVhcGlmeV9kb3duKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW5kIHJldHVybnMgdGhlIHRvcCBlbnRyeSBvZiB0aGUgaGVhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3QgY29uc2lzdHMgb2YgdGhlIGVsZW1lbnQgYW5kIGl0cyB2YWx1ZSAoY29tcHV0ZWQgYnkge0BsaW5rIGFjY2Vzc29yfSkuXG4gICAgICovXG4gICAgcG9wKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG4gICAgICAgIGlmIChjb250YWluZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChjb250YWluZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N3YXAoMCwgY29udGFpbmVyLmxlbmd0aCAtIDEpO1xuICAgICAgICBjb25zdCBpdGVtID0gY29udGFpbmVyLnBvcCgpO1xuICAgICAgICB0aGlzLl9oZWFwaWZ5X2Rvd24oKTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG9wIGVudHJ5IG9mIHRoZSBoZWFwIHdpdGhvdXQgcmVtb3ZpbmcgaXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IGNvbnNpc3RzIG9mIHRoZSBlbGVtZW50IGFuZCBpdHMgdmFsdWUgKGNvbXB1dGVkIGJ5IHtAbGluayBhY2Nlc3Nvcn0pLlxuICAgICAqL1xuICAgIGdldCBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lci5sZW5ndGggPiAwID8gdGhpcy5fY29udGFpbmVyWzBdIDogbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFlpZWxkcyB0aGUgcmF3IGRhdGFcbiAgICAgKiBAeWllbGRzIHtPYmplY3R9IE9iamVjdCBjb25zaXN0cyBvZiB0aGUgZWxlbWVudCBhbmQgaXRzIHZhbHVlIChjb21wdXRlZCBieSB7QGxpbmsgYWNjZXNzb3J9KS5cbiAgICAgKi9cbiAgICAqIGl0ZXJhdGUoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY29udGFpbmVyLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5fY29udGFpbmVyW2ldLmVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWFwIGFzIG9yZGVyZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBjb25zaXN0aW5nIHRoZSBlbGVtZW50cyBvcmRlcmVkIGJ5IHtAbGluayBjb21wYXJhdG9yfS5cbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKClcbiAgICAgICAgICAgIC5zb3J0KChhLGIpID0+IHRoaXMuX2NvbXBhcmF0b3IoYSwgYikgPyAtMSA6IDApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBlbGVtZW50cyBvZiBjb250YWluZXIgYXJyYXkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBjb25zaXN0aW5nIHRoZSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyXG4gICAgICAgICAgICAubWFwKGQgPT4gZC5lbGVtZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRhaW5lciBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBjb250YWluZXIgYXJyYXkuXG4gICAgICovXG4gICAgcmF3X2RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHNpemUgb2YgdGhlIGhlYXAuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZhbHNlIGlmIHRoZSB0aGUgaGVhcCBoYXMgZW50cmllcywgdHJ1ZSBpZiB0aGUgaGVhcCBoYXMgbm8gZW50cmllcy5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG59IiwiLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBEaXNqb2ludFNldFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzam9pbnQtc2V0X2RhdGFfc3RydWN0dXJlfVxuICovXG5leHBvcnQgY2xhc3MgRGlzam9pbnRTZXQge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBEaXNqb2ludFNldFxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGF0YXN0cnVjdHVyZVxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBlbGVtZW50cyBcbiAgICAgKiBAcmV0dXJucyB7RGlzam9pbnRTZXR9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2xpc3QgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlX3NldChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBtYWtlX3NldCh4KSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLl9saXN0O1xuICAgICAgICBpZiAoIWxpc3QuaGFzKHgpKSB7XG4gICAgICAgICAgICBsaXN0LmFkZCh4KTtcbiAgICAgICAgICAgIHguX19kaXNqb2ludF9zZXQgPSB7fTtcbiAgICAgICAgICAgIHguX19kaXNqb2ludF9zZXQucGFyZW50ID0geDtcbiAgICAgICAgICAgIHguX19kaXNqb2ludF9zZXQuY2hpbGRyZW4gPSBuZXcgU2V0KFt4XSk7XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0LnNpemUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZpbmQoeCkge1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgaWYgKGxpc3QuaGFzKHgpKSB7XG4gICAgICAgICAgICBpZiAoeC5fX2Rpc2pvaW50X3NldC5wYXJlbnQgIT09IHgpIHtcbiAgICAgICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuLmFkZCguLi54KTtcbiAgICAgICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0LnBhcmVudCA9IHRoaXMuZmluZCh4Ll9fZGlzam9pbnRfc2V0LnBhcmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguX19kaXNqb2ludF9zZXQucGFyZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdW5pb24oeCwgeSkge1xuICAgICAgICBsZXQgbm9kZV94ID0gdGhpcy5maW5kKHgpO1xuICAgICAgICBsZXQgbm9kZV95ID0gdGhpcy5maW5kKHkpO1xuXG4gICAgICAgIGlmIChub2RlX3ggPT09IG5vZGVfeSkgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChub2RlX3guX19kaXNqb2ludF9zZXQuc2l6ZSA8IG5vZGVfeS5fX2Rpc2pvaW50X3NldC5zaXplKSBbbm9kZV94LCBub2RlX3ldID0gW25vZGVfeSwgbm9kZV94XTtcblxuICAgICAgICBub2RlX3kuX19kaXNqb2ludF9zZXQucGFyZW50ID0gbm9kZV94O1xuICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuP1xuICAgICAgICBub2RlX3kuX19kaXNqb2ludF9zZXQuY2hpbGRyZW4uZm9yRWFjaChub2RlX3guX19kaXNqb2ludF9zZXQuY2hpbGRyZW4uYWRkLCBub2RlX3guX19kaXNqb2ludF9zZXQuY2hpbGRyZW4pO1xuICAgICAgICBub2RlX3guX19kaXNqb2ludF9zZXQuc2l6ZSArPSBub2RlX3kuX19kaXNqb2ludF9zZXQuc2l6ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59IiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IEhlYXAgfSBmcm9tIFwiLi4vZGF0YXN0cnVjdHVyZS9pbmRleC5qc1wiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBCYWxsVHJlZVxuICovXG5leHBvcnQgY2xhc3MgQmFsbFRyZWUge1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIEJhbGxUcmVlIHdpdGggZ2l2ZW4ge0BsaW5rIGVsZW1lbnRzfS5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmtublxuICAgICAqIEBhbGlhcyBCYWxsVHJlZVxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBlbGVtZW50cyAtIEVsZW1lbnRzIHdoaWNoIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgQmFsbFRyZWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSBtZXRyaWMgdG8gdXNlOiAoYSwgYikgPT4gZGlzdGFuY2VcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYWxsX3RyZWV9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2ludmlzYWwvbm9vYmpzL2Jsb2IvbWFzdGVyL3NyYy90cmVlL0JhbGxUcmVlLmpzfVxuICAgICAqIEByZXR1cm5zIHtCYWxsVHJlZX1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cyA9IG51bGwsIG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgICAgICB0aGlzLl9Ob2RlID0gY2xhc3Mge1xuICAgICAgICAgICAgY29uc3RydWN0b3IocGl2b3QsIGNoaWxkMT1udWxsLCBjaGlsZDI9bnVsbCwgcmFkaXVzPW51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpdm90ID0gcGl2b3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZDEgPSBjaGlsZDE7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZDIgPSBjaGlsZDI7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fTGVhZiA9IGNsYXNzIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBvaW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcbiAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gZWxlbWVudHMgLSBuZXcgZWxlbWVudHMuXG4gICAgICogQHJldHVybnMge0JhbGxUcmVlfVxuICAgICAqL1xuICAgIGFkZChlbGVtZW50cykge1xuICAgICAgICBlbGVtZW50cyA9IGVsZW1lbnRzLm1hcCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGluZGV4LCBlbGVtZW50OiBlbGVtZW50fVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5fY29uc3RydWN0KGVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5PCo+fSBlbGVtZW50cyBcbiAgICAgKiBAcmV0dXJucyB7Tm9kZX0gcm9vdCBvZiBiYWxsdHJlZS5cbiAgICAgKi9cbiAgICBfY29uc3RydWN0KGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5fTGVhZihlbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgYyA9IHRoaXMuX2dyZWF0ZXN0X3NwcmVhZChlbGVtZW50cyk7XG4gICAgICAgICAgICBsZXQgc29ydGVkX2VsZW1lbnRzID0gZWxlbWVudHMuc29ydCgoYSwgYikgPT4gYS5lbGVtZW50W2NdIC0gYi5lbGVtZW50W2NdKTtcbiAgICAgICAgICAgIGxldCBuID0gc29ydGVkX2VsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBwX2luZGV4ID0gTWF0aC5mbG9vcihuIC8gMik7XG4gICAgICAgICAgICBsZXQgcCA9IGVsZW1lbnRzW3BfaW5kZXhdO1xuICAgICAgICAgICAgbGV0IEwgPSBzb3J0ZWRfZWxlbWVudHMuc2xpY2UoMCwgcF9pbmRleCk7XG4gICAgICAgICAgICBsZXQgUiA9IHNvcnRlZF9lbGVtZW50cy5zbGljZShwX2luZGV4LCBuKTtcbiAgICAgICAgICAgIGxldCByYWRpdXMgPSBNYXRoLm1heCguLi5lbGVtZW50cy5tYXAoZCA9PiB0aGlzLl9tZXRyaWMocC5lbGVtZW50LCBkLmVsZW1lbnQpKSk7XG4gICAgICAgICAgICBsZXQgQlxuICAgICAgICAgICAgaWYgKEwubGVuZ3RoID4gMCAmJiBSLmxlbmd0aCA+IDApIHsgICAgICAgICBcbiAgICAgICAgICAgICAgICBCID0gbmV3IHRoaXMuX05vZGUocCwgdGhpcy5fY29uc3RydWN0KEwpLCB0aGlzLl9jb25zdHJ1Y3QoUiksIHJhZGl1cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEIgPSBuZXcgdGhpcy5fTGVhZihlbGVtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOb2RlfSBCIFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgX2dyZWF0ZXN0X3NwcmVhZChCKSB7XG4gICAgICAgIGxldCBkID0gQlswXS5lbGVtZW50Lmxlbmd0aDtcbiAgICAgICAgbGV0IHN0YXJ0ID0gbmV3IEFycmF5KGQpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZDsgKytpKSB7XG4gICAgICAgICAgICBzdGFydFtpXSA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzcHJlYWQgPSBCLnJlZHVjZSgoYWNjLCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGFjY1tpXVswXSA9IE1hdGgubWluKGFjY1tpXVswXSwgY3VycmVudC5lbGVtZW50W2ldKTtcbiAgICAgICAgICAgICAgICBhY2NbaV1bMV0gPSBNYXRoLm1heChhY2NbaV1bMV0sIGN1cnJlbnQuZWxlbWVudFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBzdGFydCk7XG4gICAgICAgIHNwcmVhZCA9IHNwcmVhZC5tYXAoZCA9PiBkWzFdIC0gZFswXSk7XG4gICAgICAgIFxuICAgICAgICBsZXQgYyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZDsgKytpKSB7XG4gICAgICAgICAgICBjID0gc3ByZWFkW2ldID4gc3ByZWFkW2NdID8gaSA6IGM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHsqfSB0IC0gcXVlcnkgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2sgPSA1XSAtIG51bWJlciBvZiBuZWFyZXN0IG5laWdoYm9ycyB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0hlYXB9IC0gSGVhcCBjb25zaXN0cyBvZiB0aGUge0BsaW5rIGt9IG5lYXJlc3QgbmVpZ2hib3JzLlxuICAgICAqL1xuICAgIHNlYXJjaCh0LCBrID0gNSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VhcmNoKHQsIGssIG5ldyBIZWFwKG51bGwsIGQgPT4gdGhpcy5fbWV0cmljKGQuZWxlbWVudCwgdCksIFwibWF4XCIpLCB0aGlzLl9yb290KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdCAtIHF1ZXJ5IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtrID0gNV0gLSBudW1iZXIgb2YgbmVhcmVzdCBuZWlnaGJvcnMgdG8gcmV0dXJuLlxuICAgICAqIEBwYXJhbSB7SGVhcH0gUSAtIEhlYXAgY29uc2lzdHMgb2YgdGhlIGN1cnJlbnRseSBmb3VuZCB7QGxpbmsga30gbmVhcmVzdCBuZWlnaGJvcnMuXG4gICAgICogQHBhcmFtIHtOb2RlfExlYWZ9IEIgXG4gICAgICovXG4gICAgX3NlYXJjaCh0LCBrLCBRLCBCKSB7XG4gICAgICAgIC8vIEIgaXMgTm9kZVxuICAgICAgICBpZiAoUS5sZW5ndGggPj0gayAmJiBCLnBpdm90ICYmIEIucmFkaXVzICYmIHRoaXMuX21ldHJpYyh0LCBCLnBpdm90LmVsZW1lbnQpIC0gQi5yYWRpdXMgPj0gUS5maXJzdC52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH0gXG4gICAgICAgIGlmIChCLmNoaWxkMSkgdGhpcy5fc2VhcmNoKHQsIGssIFEsIEIuY2hpbGQxKTtcbiAgICAgICAgaWYgKEIuY2hpbGQyKSB0aGlzLl9zZWFyY2godCwgaywgUSwgQi5jaGlsZDIpO1xuICAgICAgICBcbiAgICAgICAgLy8gQiBpcyBsZWFmXG4gICAgICAgIGlmIChCLnBvaW50cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBCLnBvaW50cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgcCA9IEIucG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChrID4gUS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgUS5wdXNoKHApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFEucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgUS5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFE7XG4gICAgfVxufSIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBIZWFwIH0gZnJvbSBcIi4uL2RhdGFzdHJ1Y3R1cmUvaW5kZXguanNcIjtcbmltcG9ydCB7IGRpc3RhbmNlX21hdHJpeCwgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEtOTlxuICovXG5leHBvcnQgY2xhc3MgS05OIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBLTk4gbGlzdCB3aXRoIGdpdmVuIHtAbGluayBlbGVtZW50c30uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTprbm5cbiAgICAgKiBAYWxpYXMgS05OXG4gICAgICogQHBhcmFtIHtBcnJheT19IGVsZW1lbnRzIC0gRWxlbWVudHMgd2hpY2ggc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBLTk4gbGlzdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbbWV0cmljID0gZXVjbGlkZWFuXSBtZXRyaWMgaXMgZWl0aGVyIHByZWNvbXB1dGVkIG9yIGEgZnVuY3Rpb24gdG8gdXNlOiAoYSwgYikgPT4gZGlzdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7S05OfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzPW51bGwsIG1ldHJpYz1ldWNsaWRlYW4pIHtcbiAgICAgICAgdGhpcy5fbWV0cmljID0gbWV0cmljO1xuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IGVsZW1lbnRzIGluc3RhbmNlb2YgTWF0cml4ID8gZWxlbWVudHMgOiBNYXRyaXguZnJvbShlbGVtZW50cyk7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9lbGVtZW50cy5zaGFwZVswXTtcbiAgICAgICAgaWYgKG1ldHJpYyA9PT0gXCJwcmVjb21wdXRlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9EID0gdGhpcy5fZWxlbWVudHMuY2xvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX0QgPSBkaXN0YW5jZV9tYXRyaXgodGhpcy5fZWxlbWVudHMsIG1ldHJpYyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5LTk4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgTjsgKytyb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IHRoaXMuX0Qucm93KHJvdyk7XG4gICAgICAgICAgICBjb25zdCBIID0gbmV3IEhlYXAobnVsbCwgZCA9PiBkLnZhbHVlLCBcIm1pblwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgSC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRpc3RhbmNlc1tqXSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGosXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLktOTi5wdXNoKEgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtBcnJheXxOdW1iZXJ9IHQgLSBxdWVyeSBlbGVtZW50IG9yIGluZGV4LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbayA9IDVdIC0gbnVtYmVyIG9mIG5lYXJlc3QgbmVpZ2hib3JzIHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7SGVhcH0gLSBIZWFwIGNvbnNpc3RzIG9mIHRoZSB7QGxpbmsga30gbmVhcmVzdCBuZWlnaGJvcnMuXG4gICAgICovXG4gICAgc2VhcmNoKHQsIGsgPSA1KSB7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgY29uc3QgS05OID0gdGhpcy5LTk47XG4gICAgICAgIGxldCBIO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21ldHJpYyA9PSBcInByZWNvbXB1dGVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlNlYXJjaCBieSBxdWVyeSBlbGVtZW50IGlzIG9ubHkgcG9zc2libGUgd2hlbiBub3QgdXNpbmcgYSBwcmVjb21wdXRlZCBkaXN0YW5jZSBtYXRyaXghXCJcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzO1xuICAgICAgICAgICAgY29uc3QgTiA9IEtOTi5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbmVhcmVzdF9lbGVtZW50X2luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0X2Rpc3QgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzLnJvdyhpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gbWV0cmljKHQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgbmVhcmVzdF9kaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RfZWxlbWVudF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RfZGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSCA9IEtOTltuZWFyZXN0X2VsZW1lbnRfaW5kZXhdO1xuICAgICAgICB9IGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIodCkpIHtcbiAgICAgICAgICAgIEggPSBLTk5bdF1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQgPSBbXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGs7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goSC5wb3AoKSlcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuZm9yRWFjaChyZXMgPT4gSC5wdXNoKHJlcy5lbGVtZW50KSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gICAgXG59XG4iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUmFuZG9taXplciB9IGZyb20gXCIuLi91dGlsL2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgRFJcbiAqIEBib3Jyb3dzIERSI3BhcmFtZXRlciBhcyBEUiNwYXJhXG4gKiBAYm9ycm93cyBEUiNwYXJhbWV0ZXIgYXMgRFIjcFxuICovXG5leHBvcnQgY2xhc3MgRFIge1xuICAgIC8vc3RhdGljIHBhcmFtZXRlcl9saXN0ID0gW107XG4gICAgZ2V0IHBhcmFtZXRlcl9saXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyX2xpc3Q7XG4gICAgfVxuXG4gICAgc2V0IHBhcmFtZXRlcl9saXN0KGxpc3QpIHtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyX2xpc3QgPSBsaXN0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBEUlxuICAgICAqIEBwYXJhbSB7TWF0cml4fEFycmF5PEFycmF5PE51bWJlcj4+fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2QgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7c2VlZH0gW3NlZWQgPSAxMjEyXSAtIHRoZSBzZWVkIHZhbHVlIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge0RSfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIGQgPSAyLCBtZXRyaWMgPSBldWNsaWRlYW4sIHNlZWQgPSAxMjEyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KFgpKSB7XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gXCJhcnJheVwiO1xuICAgICAgICAgICAgdGhpcy5YID0gTWF0cml4LmZyb20oWCk7XG4gICAgICAgIH0gZWxzZSBpZiAoWCBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IFwibWF0cml4XCI7XG4gICAgICAgICAgICB0aGlzLlggPSBYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gdmFsaWQgdHlwZSBmb3IgWFwiKTtcbiAgICAgICAgfVxuICAgICAgICBbdGhpcy5fTiwgdGhpcy5fRF0gPSB0aGlzLlguc2hhcGU7XG4gICAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgICB0aGlzLl9tZXRyaWMgPSBtZXRyaWM7XG4gICAgICAgIHRoaXMuX3NlZWQgPSBzZWVkO1xuICAgICAgICB0aGlzLl9yYW5kb21pemVyID0gbmV3IFJhbmRvbWl6ZXIoc2VlZCk7XG4gICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhbmQgZ2V0IHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ZhbHVlID0gbnVsbF0gLSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyIHRvIHNldCwgaWYgPGNvZGU+dmFsdWUgPT0gbnVsbDwvY29kZT4gdGhlbiByZXR1cm4gYWN0dWFsIHBhcmFtZXRlciB2YWx1ZS5cbiAgICAgKiBAbWVtYmVyb2YgRFJcbiAgICAgKi9cbiAgICBwYXJhbWV0ZXIobmFtZSwgdmFsdWUgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJhbWV0ZXJfbGlzdC5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlciFgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbYF8ke25hbWV9YF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2BfJHtuYW1lfWBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFyYShuYW1lLCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVyKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBwKG5hbWUsIHZhbHVlID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXIobmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IFJldHVybnMgdGhlIHByb2plY3Rpb24uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICAqZ2VuZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICBjaGVja19pbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzX2luaXRpYWxpemVkICYmIHR5cGVvZiB0aGlzLmluaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLl9pc19pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBwcm9qZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZSA9PT0gXCJtYXRyaXhcIiA/IHRoaXMuWSA6IHRoaXMuWS50bzJkQXJyYXk7XG4gICAgfVxuXG4gICAgYXN5bmMgdHJhbnNmb3JtX2FzeW5jKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIHN0YXRpYyB0cmFuc2Zvcm0oLi4uYXJncykge1xuICAgICAgICBsZXQgZHIgPSBuZXcgdGhpcyguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIGRyLnRyYW5zZm9ybSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyB0cmFuc2Zvcm1fYXN5bmMoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oLi4uYXJncyk7XG4gICAgfVxuXG4gICAgc3RhdGljICpnZW5lcmF0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBkciA9IG5ldyB0aGlzKC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCBnZW4gPSBkci5nZW5lcmF0b3IoKTtcbiAgICAgICAgZm9yIChjb25zdCByZXMgb2YgZ2VuKSB7XG4gICAgICAgICAgICB5aWVsZCByZXM7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBQQ0FcbiAqIEBhdWdtZW50cyBEUlxuICovXG5leHBvcnQgY2xhc3MgUENBIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIFBDQVxuICAgICAqIEBwYXJhbSB7TWF0cml4fEFycmF5PEFycmF5PE51bWJlcj4+fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2QgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7UENBfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIGQgPSAyKSB7XG4gICAgICAgIHN1cGVyKFgsIGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuc2lvbmFsaXR5IHtAbGluayBkfS4gSWYgcGFyYW1ldGVyIHtAbGluayBBfSBpcyBnaXZlbiwgdGhlbiBwcm9qZWN0IHtAbGluayBBfSB3aXRoIHRoZSBwcmluY2lwYWwgY29tcG9uZW50cyBvZiB7QGxpbmsgWH0uXG4gICAgICogQHBhcmFtIHtudWxsfE1hdHJpeHxBcnJheX0gW0EgPSBudWxsXSAtIElmIGdpdmVuLCB0aGUgZGF0YSB0byBwcm9qZWN0LlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh8QXJyYXl9IC0gVGhlIHByb2plY3RlZCBkYXRhLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybShBID0gbnVsbCkge1xuICAgICAgICBjb25zdCBWID0gdGhpcy5wcmluY2lwYWxfY29tcG9uZW50cygpO1xuICAgICAgICBpZiAoQSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICAgICAgdGhpcy5ZID0gWC5kb3QoVik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoQSkpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRyaXguZnJvbShBKS5kb3QoVikuYXNBcnJheTtcbiAgICAgICAgfSBlbHNlIGlmIChBIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICByZXR1cm4gQS5kb3QoVik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCB0eXBlIGZvciBBIVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSB7QGxpbmsgZH0gcHJpbmNpcGFsIGNvbXBvbmVudHMgb2YgTWF0cml4IHtAbGluayBYfS5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHByaW5jaXBhbF9jb21wb25lbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5WKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5WO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IG1lYW5zID0gTWF0cml4LmZyb20oWC5tZWFuQ29scyk7XG4gICAgICAgIGNvbnN0IFhfY2VudCA9IFguc3ViKG1lYW5zKTtcbiAgICAgICAgY29uc3QgQyA9IFhfY2VudC50cmFuc3Bvc2UoKS5kb3QoWF9jZW50KTtcbiAgICAgICAgY29uc3QgeyBlaWdlbnZlY3RvcnM6IFYgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihDLCB0aGlzLl9kKTtcbiAgICAgICAgdGhpcy5WID0gTWF0cml4LmZyb20oVikudHJhbnNwb3NlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLlY7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9ufSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IGRpc3RhbmNlX21hdHJpeCwgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBNRFNcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBNRFMgZXh0ZW5kcyBEUntcbiAgICAvKipcbiAgICAgKiBDbGFzc2ljYWwgTURTLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIE1EU1xuICAgICAqIEBwYXJhbSB7TWF0cml4fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2QgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFwicHJlY29tcHV0ZWRcIn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy4gIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VlZCA9IDEyMTJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIGQ9MiwgbWV0cmljPWV1Y2xpZGVhbiwgc2VlZD0xMjEyKSB7XG4gICAgICAgIHN1cGVyKFgsIGQsIG1ldHJpYywgc2VlZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0ZGF0YSB7QGxpbmsgWH0gdG8gZGltZW5zaW9uYWxpdHkge0BsaW5rIGR9LlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh8QXJyYXl9XG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCByb3dzID0gWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBBID0gbWV0cmljID09PSBcInByZWNvbXB1dGVkXCIgPyBYIDogZGlzdGFuY2VfbWF0cml4KFgsIG1ldHJpYyk7IFxuICAgICAgICBjb25zdCBhaV8gPSBBLm1lYW5Db2xzO1xuICAgICAgICBjb25zdCBhX2ogPSBBLm1lYW5Sb3dzO1xuICAgICAgICBjb25zdCBhX18gPSBBLm1lYW47XG5cbiAgICAgICAgdGhpcy5fZF9YID0gQTtcbiAgICAgICAgY29uc3QgQiA9IG5ldyBNYXRyaXgocm93cywgcm93cywgKGksIGopID0+IChBLmVudHJ5KGksIGopIC0gYWlfW2ldIC0gYV9qW2pdICsgYV9fKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBWIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oQiwgdGhpcy5fZCk7XG4gICAgICAgIHRoaXMuWSA9IE1hdHJpeC5mcm9tKFYpLnRyYW5zcG9zZSgpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gdGhlIHN0cmVzcyBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICBzdHJlc3MoKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLlguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IFkgPSB0aGlzLlk7XG4gICAgICAgIGNvbnN0IGRfWCA9IHRoaXMuX2RfWDsgLypuZXcgTWF0cml4KCk7XG4gICAgICAgIGRfWC5zaGFwZSA9IFtOLCBOLCAoaSwgaikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGkgPCBqID8gbWV0cmljKFgucm93KGkpLCBYLnJvdyhqKSkgOiBkX1guZW50cnkoaiwgaSk7XG4gICAgICAgIH1dKi9cbiAgICAgICAgY29uc3QgZF9ZID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBkX1kuc2hhcGUgPSBbTiwgTiwgKGksIGopID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpIDwgaiA/IGV1Y2xpZGVhbihZLnJvdyhpKSwgWS5yb3coaikpIDogZF9ZLmVudHJ5KGosIGkpO1xuICAgICAgICB9XVxuICAgICAgICBsZXQgdG9wX3N1bSA9IDA7XG4gICAgICAgIGxldCBib3R0b21fc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIHRvcF9zdW0gKz0gTWF0aC5wb3coZF9YLmVudHJ5KGksIGopIC0gZF9ZLmVudHJ5KGksIGopLCAyKTtcbiAgICAgICAgICAgICAgICBib3R0b21fc3VtICs9IE1hdGgucG93KGRfWC5lbnRyeShpLCBqKSwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0b3Bfc3VtIC8gYm90dG9tX3N1bSk7XG4gICAgfVxufSIsImltcG9ydCB7IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbn0gZnJvbSBcIi4uL2xpbmVhcl9hbGdlYnJhL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSGVhcCB9IGZyb20gXCIuLi9kYXRhc3RydWN0dXJlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSVNPTUFQXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgSVNPTUFQIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIElTT01BUFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS4gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5laWdoYm9ycyAtIHRoZSBudW1iZXIgb2YgbmVpZ2hib3JzIHtAbGluayBJU09NQVB9IHNob3VsZCB1c2UgdG8gcHJvamVjdCB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2QgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi4gXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy4gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWVkID0gMTIxMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgbmVpZ2hib3JzLCBkID0gMiwgbWV0cmljID0gZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgc3VwZXIoWCwgZCwgbWV0cmljLCBzZWVkKTtcbiAgICAgICAgc3VwZXIucGFyYW1ldGVyX2xpc3QgPSBbXCJrXCJdO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcImtcIiwgTWF0aC5taW4obmVpZ2hib3JzID8/IE1hdGgubWF4KE1hdGguZmxvb3IodGhpcy5YLnNoYXBlWzBdIC8gMTApLCAyKSwgdGhpcy5fTiAtMSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIC8vIFRPRE86IG1ha2Uga25uIGV4dGVybiBhbmQgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RvciBvciB0cmFuc2Zvcm0/XG4gICAgICAgIGNvbnN0IEQgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIEQuc2hhcGUgPSBbcm93cywgcm93cywgKGksaikgPT4gaSA8PSBqID8gbWV0cmljKFgucm93KGkpLCBYLnJvdyhqKSkgOiBELmVudHJ5KGosaSldXG4gICAgICAgIGNvbnN0IGtOZWFyZXN0TmVpZ2hib3JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93czsgKytqKSB7XG4gICAgICAgICAgICAgICAgcm93LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBcImluZGV4XCI6IGosXG4gICAgICAgICAgICAgICAgICAgIFwiZGlzdGFuY2VcIjogRC5lbnRyeShpLCBqKSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgSCA9IG5ldyBIZWFwKHJvdywgZCA9PiBkLmRpc3RhbmNlLCBcIm1pblwiKTtcbiAgICAgICAgICAgIGtOZWFyZXN0TmVpZ2hib3JzLnB1c2goSC50b0FycmF5KCkuc2xpY2UoMSwgdGhpcy5fayArIDEpKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvKkQgPSBkaWprc3RyYShrTmVhcmVzdE5laWdoYm9ycyk7Ki9cbiAgICAgICAgLy8gY29tcHV0ZSBzaG9ydGVzdCBwYXRoc1xuICAgICAgICAvLyBUT0RPOiBtYWtlIGV4dGVyblxuICAgICAgICAvKiogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmxveWQlRTIlODAlOTNXYXJzaGFsbF9hbGdvcml0aG19ICovXG4gICAgICAgIGNvbnN0IEcgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIChpLGopID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0ga05lYXJlc3ROZWlnaGJvcnNbaV0uZmluZChuID0+IG4uaW5kZXggPT09IGopO1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyID8gb3RoZXIuZGlzdGFuY2UgOiBJbmZpbml0eVxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dzOyArK2opIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJvd3M7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBHLnNldF9lbnRyeShpLCBqLCBNYXRoLm1pbihHLmVudHJ5KGksIGopLCBHLmVudHJ5KGksIGspICsgRy5lbnRyeShrLCBqKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGV0IGFpXyA9IG5ldyBGbG9hdDY0QXJyYXkocm93cyk7XG4gICAgICAgIGxldCBhX2ogPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MpO1xuICAgICAgICBsZXQgYV9fID0gMDtcbiAgICAgICAgbGV0IEEgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIChpLGopID0+IHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBHLmVudHJ5KGksIGopO1xuICAgICAgICAgICAgdmFsID0gdmFsID09PSBJbmZpbml0eSA/IDAgOiB2YWw7XG4gICAgICAgICAgICBhaV9baV0gKz0gdmFsO1xuICAgICAgICAgICAgYV9qW2pdICs9IHZhbDtcbiAgICAgICAgICAgIGFfXyArPSB2YWw7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGFpXyA9IGFpXy5tYXAodiA9PiB2IC8gcm93cyk7XG4gICAgICAgIGFfaiA9IGFfai5tYXAodiA9PiB2IC8gcm93cyk7XG4gICAgICAgIGFfXyAvPSAocm93cyAqKiAyKTtcbiAgICAgICAgY29uc3QgQiA9IG5ldyBNYXRyaXgocm93cywgcm93cywgKGksaikgPT4gKEEuZW50cnkoaSxqKSAtIGFpX1tpXSAtIGFfaltqXSArIGFfXykpO1xuICAgICAgICAgICAgIFxuICAgICAgICAvLyBjb21wdXRlIGQgZWlnZW52ZWN0b3JzXG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBWIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oQiwgdGhpcy5fZCk7XG4gICAgICAgIHRoaXMuWSA9IE1hdHJpeC5mcm9tKFYpLnRyYW5zcG9zZSgpO1xuICAgICAgICAvLyByZXR1cm4gZW1iZWRkaW5nXG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG5cbn0iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBGQVNUTUFQXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgRkFTVE1BUCBleHRlbmRzIERSe1xuICAgIC8qKlxuICAgICAqIEZhc3RNYXA6IGEgZmFzdCBhbGdvcml0aG0gZm9yIGluZGV4aW5nLCBkYXRhLW1pbmluZyBhbmQgdmlzdWFsaXphdGlvbiBvZiB0cmFkaXRpb25hbCBhbmQgbXVsdGltZWRpYSBkYXRhc2V0c1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIEZBU1RNQVBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuICBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RkFTVE1BUH1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvaS5vcmcvMTAuMTE0NS8yMjM3ODQuMjIzODEyfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIGQ9MiwgbWV0cmljPWV1Y2xpZGVhbiwgc2VlZD0xMjEyKSB7XG4gICAgICAgIHN1cGVyKFgsIGQsIG1ldHJpYywgc2VlZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENob29zZXMgdHdvIHBvaW50cyB3aGljaCBhcmUgdGhlIG1vc3QgZGlzdGFudCBpbiB0aGUgYWN0dWFsIHByb2plY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaXN0IFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgY29uc2lzdGluZyBvZiBmaXJzdCBpbmRleCwgc2Vjb25kIGluZGV4LCBhbmQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIHBvaW50cy5cbiAgICAgKi9cbiAgICBfY2hvb3NlX2Rpc3RhbnRfb2JqZWN0cyhkaXN0KSB7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IE4gPSBYLnNoYXBlWzBdO1xuICAgICAgICBsZXQgYV9pbmRleCA9IHRoaXMuX3JhbmRvbWl6ZXIucmFuZG9tX2ludCAlIE4gLSAxO1xuICAgICAgICBsZXQgYl9pbmRleCA9IG51bGw7XG4gICAgICAgIGxldCBtYXhfZGlzdCA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGRfYWkgPSBkaXN0KGFfaW5kZXgsIGkpXG4gICAgICAgICAgICBpZiAoZF9haSA+IG1heF9kaXN0KSB7XG4gICAgICAgICAgICAgICAgbWF4X2Rpc3QgPSBkX2FpO1xuICAgICAgICAgICAgICAgIGJfaW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1heF9kaXN0ID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZF9iaSA9IGRpc3QoYl9pbmRleCwgaSlcbiAgICAgICAgICAgIGlmIChkX2JpID4gbWF4X2Rpc3QpIHtcbiAgICAgICAgICAgICAgICBtYXhfZGlzdCA9IGRfYmk7XG4gICAgICAgICAgICAgICAgYV9pbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthX2luZGV4LCBiX2luZGV4LCBtYXhfZGlzdF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHJldHVybnMge01hdHJpeH0gVGhlIHtAbGluayBkfS1kaW1lbnNpb25hbCBwcm9qZWN0aW9uIG9mIHRoZSBkYXRhIG1hdHJpeCB7QGxpbmsgWH0uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuX2Q7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgY29uc3QgWSA9IG5ldyBNYXRyaXgoTiwgZCwgMCk7XG4gICAgICAgIGxldCBkaXN0ID0gKGEsIGIpID0+IG1ldHJpYyhYLnJvdyhhKSwgWC5yb3coYikpO1xuXG4gICAgICAgIGZvciAobGV0IF9jb2wgPSAwOyBfY29sIDwgZDsgKytfY29sKSB7XG4gICAgICAgICAgICBsZXQgb2xkX2Rpc3QgPSBkaXN0O1xuICAgICAgICAgICAgLy8gY2hvb3NlIHBpdm90IG9iamVjdHNcbiAgICAgICAgICAgIGNvbnN0IFthX2luZGV4LCBiX2luZGV4LCBkX2FiXSA9IHRoaXMuX2Nob29zZV9kaXN0YW50X29iamVjdHMoZGlzdCk7XG4gICAgICAgICAgICAvLyByZWNvcmQgaWQgb2YgcGl2b3Qgb2JqZWN0c1xuICAgICAgICAgICAgLy9QQVswXS5wdXNoKGFfaW5kZXgpO1xuICAgICAgICAgICAgLy9QQVsxXS5wdXNoKGJfaW5kZXgpO1xuICAgICAgICAgICAgLyogaWYgKGRfYWIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGFsbCBpbnRlci1vYmplY3QgZGlzdGFuY2VzIGFyZSB6ZXJvc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIFkuc2V0X2VudHJ5KGksIF9jb2wsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7ICovXG4gICAgICAgICAgICBpZiAoZF9hYiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHByb2plY3QgdGhlIG9iamVjdHMgb24gdGhlIGxpbmUgKE9fYSwgT19iKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRfYWkgPSBkaXN0KGFfaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkX2JpID0gZGlzdChiX2luZGV4LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeV9pID0gKGRfYWkgKiogMiArIGRfYWIgKiogMiAtIGRfYmkgKiogMikgLyAoMiAqIGRfYWIpO1xuICAgICAgICAgICAgICAgICAgICBZLnNldF9lbnRyeShpLCBfY29sLCB5X2kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgcHJvamVjdGlvbnMgb2YgdGhlIG9iamVjdHMgb24gYVxuICAgICAgICAgICAgICAgIC8vIGh5cGVycGxhbmUgcGVycGVuZGljbHVhciB0byB0aGUgbGluZSAoYSwgYik7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGRpc3RhbmNlIGZ1bmN0aW9uIEQnKCkgYmV0d2VlbiB0d28gXG4gICAgICAgICAgICAgICAgLy8gcHJvamVjdGlvbnMgaXMgZ2l2ZW4gYnkgRXEuNFxuICAgICAgICAgICAgICAgIGRpc3QgPSAoYSwgYikgPT4gTWF0aC5zcXJ0KG9sZF9kaXN0KGEsIGIpICoqIDIgLSAoWS5lbnRyeShhLCBfY29sKSAtIFkuZW50cnkoYiwgX2NvbCkpICoqIDIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZ1xuICAgICAgICB0aGlzLlkgPSBZO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9ufSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBMREFcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBMREEgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgTERBXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxhYmVscyAtIHRoZSBsYWJlbCAvIGNsYXNzIG9mIGVhY2ggZGF0YSBwb2ludC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2QgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLiAgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWVkID0gMTIxMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgbGFiZWxzLCBkID0gMiwgbWV0cmljID0gZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgc3VwZXIoWCwgZCwgbWV0cmljLCBzZWVkKTtcbiAgICAgICAgc3VwZXIucGFyYW1ldGVyX2xpc3QgPSBbXCJsYWJlbHNcIl07XG4gICAgICAgIHRoaXMucGFyYW1ldGVyKFwibGFiZWxzXCIsIGxhYmVscyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0ZGF0YSB7QGxpbmsgWH0gdG8gZGltZW5pb25hbGl0eSB7QGxpbmsgZH0uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICBsZXQgWCA9IHRoaXMuWDtcbiAgICAgICAgbGV0IFsgcm93cywgY29scyBdID0gWC5zaGFwZTtcbiAgICAgICAgbGV0IGxhYmVscyA9IHRoaXMuX2xhYmVscztcbiAgICAgICAgbGV0IHVuaXF1ZV9sYWJlbHMgPSB7fTtcbiAgICAgICAgbGV0IGxhYmVsX2lkID0gMDtcbiAgICAgICAgbGFiZWxzLmZvckVhY2goKGwsIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChsIGluIHVuaXF1ZV9sYWJlbHMpIHtcbiAgICAgICAgICAgICAgICB1bmlxdWVfbGFiZWxzW2xdLmNvdW50Kys7XG4gICAgICAgICAgICAgICAgdW5pcXVlX2xhYmVsc1tsXS5yb3dzLnB1c2goWC5yb3coaSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bmlxdWVfbGFiZWxzW2xdID0ge1xuICAgICAgICAgICAgICAgICAgICBcImlkXCI6IGxhYmVsX2lkKyssXG4gICAgICAgICAgICAgICAgICAgIFwiY291bnRcIjogMSxcbiAgICAgICAgICAgICAgICAgICAgXCJyb3dzXCI6IFtYLnJvdyhpKV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgLy8gY3JlYXRlIFhfbWVhbiBhbmQgdmVjdG9yIG1lYW5zO1xuICAgICAgICBsZXQgWF9tZWFuID0gWC5tZWFuO1xuICAgICAgICBsZXQgVl9tZWFuID0gbmV3IE1hdHJpeChsYWJlbF9pZCwgY29scylcbiAgICAgICAgZm9yIChsZXQgbGFiZWwgaW4gdW5pcXVlX2xhYmVscykge1xuICAgICAgICAgICAgbGV0IFYgPSBNYXRyaXguZnJvbSh1bmlxdWVfbGFiZWxzW2xhYmVsXS5yb3dzKTtcbiAgICAgICAgICAgIGxldCB2X21lYW4gPSBWLm1lYW5Db2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcbiAgICAgICAgICAgICAgICBWX21lYW4uc2V0X2VudHJ5KHVuaXF1ZV9sYWJlbHNbbGFiZWxdLmlkLCBqLCB2X21lYW5bal0pO1xuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgLy8gc2NhdHRlcl9iZXR3ZWVuXG4gICAgICAgIGxldCBTX2IgPSBuZXcgTWF0cml4KGNvbHMsIGNvbHMpO1xuICAgICAgICBmb3IgKGxldCBsYWJlbCBpbiB1bmlxdWVfbGFiZWxzKSB7XG4gICAgICAgICAgICBsZXQgdiA9IFZfbWVhbi5yb3codW5pcXVlX2xhYmVsc1tsYWJlbF0uaWQpO1xuICAgICAgICAgICAgbGV0IG0gPSBuZXcgTWF0cml4KGNvbHMsIDEsIChqKSA9PiB2W2pdIC0gWF9tZWFuKTtcbiAgICAgICAgICAgIGxldCBOID0gdW5pcXVlX2xhYmVsc1tsYWJlbF0uY291bnQ7XG4gICAgICAgICAgICBTX2IgPSBTX2IuYWRkKG0uZG90KG0udHJhbnNwb3NlKCkpLm11bHQoTikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2NhdHRlcl93aXRoaW5cbiAgICAgICAgbGV0IFNfdyA9IG5ldyBNYXRyaXgoY29scywgY29scyk7XG4gICAgICAgIGZvciAobGV0IGxhYmVsIGluIHVuaXF1ZV9sYWJlbHMpIHtcbiAgICAgICAgICAgIGxldCB2ID0gVl9tZWFuLnJvdyh1bmlxdWVfbGFiZWxzW2xhYmVsXS5pZCk7XG4gICAgICAgICAgICBsZXQgbSA9IG5ldyBNYXRyaXgoY29scywgMSwgKGopID0+IHZbal0pXG4gICAgICAgICAgICBsZXQgUiA9IHVuaXF1ZV9sYWJlbHNbbGFiZWxdLnJvd3M7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHVuaXF1ZV9sYWJlbHNbbGFiZWxdLmNvdW50OyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvd192ID0gbmV3IE1hdHJpeChjb2xzLCAxLCAoaixfKSA9PiBSW2ldW2pdIC0gbS5lbnRyeShqLCAwKSk7XG4gICAgICAgICAgICAgICAgU193ID0gU193LmFkZChyb3dfdi5kb3Qocm93X3YudHJhbnNwb3NlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB7IGVpZ2VudmVjdG9yczogViB9ID0gc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uKFNfdy5pbnZlcnNlKCkuZG90KFNfYiksIHRoaXMuX2QpXG4gICAgICAgIFYgPSBNYXRyaXguZnJvbShWKS50cmFuc3Bvc2UoKVxuICAgICAgICB0aGlzLlkgPSBYLmRvdChWKVxuXG4gICAgICAgIC8vIHJldHVybiBlbWJlZGRpbmdcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG59IiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbn0gZnJvbSBcIi4uL2xpbmVhcl9hbGdlYnJhL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBrX25lYXJlc3RfbmVpZ2hib3JzIH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgTExFXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgTExFIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIExMRVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbmVpZ2hib3JzIC0gdGhlIGxhYmVsIC8gY2xhc3Mgb2YgZWFjaCBkYXRhIHBvaW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuICBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBuZWlnaGJvcnMsIGQ9MiwgbWV0cmljPWV1Y2xpZGVhbiwgc2VlZD0xMjEyKSB7XG4gICAgICAgIHN1cGVyKFgsIGQsIG1ldHJpYywgc2VlZCk7XG4gICAgICAgIHN1cGVyLnBhcmFtZXRlcl9saXN0ID0gW1wia1wiXTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJrXCIsIE1hdGgubWluKG5laWdoYm9ycyA/PyBNYXRoLm1heChNYXRoLmZsb29yKHRoaXMuX04gLyAxMCksIDIpLCB0aGlzLl9OIC0gMSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuaW9uYWxpdHkge0BsaW5rIGR9LlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuX2Q7XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5fRDtcbiAgICAgICAgY29uc3QgayA9IHRoaXMucGFyYW1ldGVyKFwia1wiKTtcbiAgICAgICAgY29uc3Qgbk4gPSBrX25lYXJlc3RfbmVpZ2hib3JzKFgsIGssIG51bGwsIHRoaXMuX21ldHJpYyk7XG4gICAgICAgIGNvbnN0IE8gPSBuZXcgTWF0cml4KGssIDEsIDEpO1xuICAgICAgICBjb25zdCBXID0gbmV3IE1hdHJpeChyb3dzLCByb3dzKTtcblxuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgY29uc3Qgbk5fcm93ID0gbk5bcm93XTtcbiAgICAgICAgICAgIGNvbnN0IFogPSBuZXcgTWF0cml4KGssIGNvbHMsIChpLCBqKSA9PiBYLmVudHJ5KG5OX3Jvd1tpXS5qLCBqKSAtIFguZW50cnkocm93LCBqKSk7XG4gICAgICAgICAgICBjb25zdCBDID0gWi5kb3QoWi5UKTtcbiAgICAgICAgICAgIGlmICggayA+IGNvbHMgKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgQ190cmFjZSA9IG5ldW1haXJfc3VtKEMuZGlhZykgLyAxMDAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgazsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIEMuc2V0X2VudHJ5KGosIGosIEMuZW50cnkoaiwgaikgKyBDX3RyYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWNvbnN0cnVjdDtcbiAgICAgICAgICAgIGxldCB3ID0gTWF0cml4LnNvbHZlX0NHKEMsIE8sIHRoaXMuX3JhbmRvbWl6ZXIpO1xuICAgICAgICAgICAgdyA9IHcuZGl2aWRlKHcuc3VtKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgazsgKytqKSB7XG4gICAgICAgICAgICAgICAgVy5zZXRfZW50cnkocm93LCBuTl9yb3dbal0uaiwgdy5lbnRyeShqLCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcCBlbWJlZGRpbmdcbiAgICAgICAgY29uc3QgSSA9IG5ldyBNYXRyaXgocm93cywgcm93cywgXCJpZGVudGl0eVwiKTtcbiAgICAgICAgY29uc3QgSVcgPSBJLnN1YihXKTtcbiAgICAgICAgY29uc3QgTSA9IElXLlQuZG90KElXKTtcbiAgICAgICAgY29uc3QgeyBlaWdlbnZlY3RvcnM6IFYgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihNLlQuaW52ZXJzZSgpLCBkICsgMSk7XG4gICAgICAgIHRoaXMuWSA9IE1hdHJpeC5mcm9tKFYuc2xpY2UoMSwgMSArIGQpKS5UO1xuXG4gICAgICAgIC8vIHJldHVybiBlbWJlZGRpbmdcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG59IiwiaW1wb3J0IHsgTWF0cml4LCBrX25lYXJlc3RfbmVpZ2hib3JzIH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbn0gZnJvbSBcIi4uL2xpbmVhcl9hbGdlYnJhL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgTFRTQVxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIExUU0EgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgTFRTQVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbmVpZ2hib3JzIC0gdGhlIGxhYmVsIC8gY2xhc3Mgb2YgZWFjaCBkYXRhIHBvaW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuICBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2VwdWJzLnNpYW0ub3JnL2RvaS9hYnMvMTAuMTEzNy9TMTA2NDgyNzUwMjQxOTE1NH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBuZWlnaGJvcnMsIGQ9MiwgbWV0cmljPWV1Y2xpZGVhbiwgc2VlZD0xMjEyKSB7XG4gICAgICAgIHN1cGVyKFgsIGQsIG1ldHJpYywgc2VlZCk7XG4gICAgICAgIHN1cGVyLnBhcmFtZXRlcl9saXN0ID0gW1wia1wiXTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJrXCIsIE1hdGgubWluKG5laWdoYm9ycyA/PyBNYXRoLm1heChNYXRoLmZsb29yKHRoaXMuX04gLyAxMCksIDIpLCB0aGlzLl9OIC0gMSkpO1xuICAgICAgICBpZiAodGhpcy5fRCA8PSBkKSB0aHJvdyBgRGltZW5zaW9uYWxpdHkgb2YgWCAoRCA9ICR7dGhpcy5fRH0pIG11c3QgYmUgZ3JlYXRlciB0aGFuIHRoZSByZXF1aXJlZCBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcmVzdWx0IChkID0gJHtkfSkhYDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXRkYXRhIHtAbGluayBYfSB0byBkaW1lbmlvbmFsaXR5IHtAbGluayBkfS5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLl9kO1xuICAgICAgICBjb25zdCBbIHJvd3MsIEQgXSA9IFguc2hhcGU7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLnBhcmFtZXRlcihcImtcIik7XG4gICAgICAgIC8vIDEuMSBkZXRlcm1pbmUgayBuZWFyZXN0IG5laWdoYm9yc1xuICAgICAgICBjb25zdCBuTiA9IGtfbmVhcmVzdF9uZWlnaGJvcnMoWCwgaywgbnVsbCwgdGhpcy5fbWV0cmljKTtcbiAgICAgICAgLy8gY2VudGVyIG1hdHJpeFxuICAgICAgICBjb25zdCBPID0gbmV3IE1hdHJpeChELCBELCBcImNlbnRlclwiKTtcbiAgICAgICAgY29uc3QgQiA9IG5ldyBNYXRyaXgocm93cywgcm93cywgMCk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgLy8gMS4yIGNvbXB1dGUgdGhlIGQgbGFyZ2VzdCBlaWdlbnZlY3RvcnMgb2YgdGhlIGNvcnJlbGF0aW9uIG1hdHJpeFxuICAgICAgICAgICAgY29uc3QgSV9pID0gW3JvdywgLi4ubk5bcm93XS5tYXAobiA9PiBuLmopXVxuICAgICAgICAgICAgbGV0IFhfaSA9IE1hdHJpeC5mcm9tKElfaS5tYXAobiA9PiBYLnJvdyhuKSkpO1xuICAgICAgICAgICAgLy8gY2VudGVyIFhfaVxuICAgICAgICAgICAgWF9pID0gWF9pLmRvdChPKVxuICAgICAgICAgICAgLy8gY29ycmVsYXRpb24gbWF0cml4XG4gICAgICAgICAgICBjb25zdCBDID0gWF9pLmRvdChYX2kudHJhbnNwb3NlKCkpO1xuICAgICAgICAgICAgY29uc3QgeyBlaWdlbnZlY3RvcnM6IGcgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihDLCBkKTtcbiAgICAgICAgICAgIC8vZy5wdXNoKGxpbnNwYWNlKDAsIGspLm1hcChfID0+IDEgLyBNYXRoLnNxcnQoayArIDEpKSk7XG4gICAgICAgICAgICBjb25zdCBHX2lfdCA9IE1hdHJpeC5mcm9tKGcpO1xuICAgICAgICAgICAgLy8gMi4gQ29uc3RydWN0aW5nIGFsaWdubWVudCBtYXRyaXhcbiAgICAgICAgICAgIGNvbnN0IFdfaSA9IEdfaV90LnRyYW5zcG9zZSgpLmRvdChHX2lfdCkuYWRkKDEgLyBNYXRoLnNxcnQoayArIDEpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgayArIDE7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgayArIDE7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShJX2lbaV0sIElfaVtqXSwgQi5lbnRyeShJX2lbaV0sIElfaVtqXSkgLSAoaSA9PT0gaiA/IDEgOiAwICkgKyBXX2kuZW50cnkoaSwgaikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIEFsaWduaW5nIGdsb2JhbCBjb29yZGluYXRlc1xuICAgICAgICBjb25zdCB7IGVpZ2VudmVjdG9yczogWSB9ID0gc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uKEIsIGQgKyAxKTtcbiAgICAgICAgdGhpcy5ZID0gTWF0cml4LmZyb20oWS5zbGljZSgxKSkudHJhbnNwb3NlKCk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZ1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIFRTTkVcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBUU05FIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIFRTTkVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGVycGxleGl0eSA9IDUwXSAtIHBlcnBsZXhpdHkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlcHNpbG9uID0gMTBdIC0gbGVhcm5pbmcgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuICBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7VFNORX1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBwZXJwbGV4aXR5PTUwLCBlcHNpbG9uPTEwLCBkPTIsIG1ldHJpYz1ldWNsaWRlYW4sIHNlZWQ9MTIxMikge1xuICAgICAgICBzdXBlcihYLCBkLCBtZXRyaWMsIHNlZWQpO1xuICAgICAgICBzdXBlci5wYXJhbWV0ZXJfbGlzdCA9IFtcInBlcnBsZXhpdHlcIiwgXCJlcHNpbG9uXCJdO1xuICAgICAgICBbIHRoaXMuX04sIHRoaXMuX0QgXSA9IHRoaXMuWC5zaGFwZTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJwZXJwbGV4aXR5XCIsIE1hdGgubWluKHBlcnBsZXhpdHksIHRoaXMuX04gLSAxKSk7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyKFwiZXBzaWxvblwiLCBlcHNpbG9uKTtcbiAgICAgICAgdGhpcy5faXRlciA9IDA7XG4gICAgICAgIHRoaXMuWSA9IG5ldyBNYXRyaXgodGhpcy5fTiwgdGhpcy5fZCwgKCkgPT4gdGhpcy5fcmFuZG9taXplci5yYW5kb20pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gZGlzdGFuY2VfbWF0cml4IC0gYWNjZXB0cyBhIHByZWNvbXB1dGVkIGRpc3RhbmNlIG1hdHJpeFxuICAgICAqIEByZXR1cm5zIHtUU05FfVxuICAgICAqL1xuICAgIGluaXQoZGlzdGFuY2VfbWF0cml4PW51bGwpIHtcbiAgICAgICAgLy8gaW5pdFxuICAgICAgICBjb25zdCBIdGFyZ2V0ID0gTWF0aC5sb2codGhpcy5fcGVycGxleGl0eSk7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBEID0gdGhpcy5fRDtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBsZXQgRGVsdGE7XG4gICAgICAgIGlmIChkaXN0YW5jZV9tYXRyaXgpIHtcbiAgICAgICAgICAgIERlbHRhID0gZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRGVsdGEgPSBuZXcgTWF0cml4KE4sIE4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBYX2kgPSBYLnJvdyhpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBtZXRyaWMoWF9pLCBYLnJvdyhqKSlcbiAgICAgICAgICAgICAgICAgICAgRGVsdGEuc2V0X2VudHJ5KGksIGosIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgRGVsdGEuc2V0X2VudHJ5KGosIGksIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBcbiAgICAgICAgICAgIFxuICAgICAgICBjb25zdCBQID0gbmV3IE1hdHJpeChOLCBOLCBcInplcm9zXCIpO1xuXG4gICAgICAgIHRoaXMuX3lzdGVwID0gbmV3IE1hdHJpeChOLCBELCBcInplcm9zXCIpO1xuICAgICAgICB0aGlzLl9nYWlucyA9IG5ldyBNYXRyaXgoTiwgRCwgMSk7XG5cbiAgICAgICAgLy8gc2VhcmNoIGZvciBmaXR0aW5nIHNpZ21hXG4gICAgICAgIGxldCBwcm93ID0gbmV3IEFycmF5KE4pLmZpbGwoMCk7XG4gICAgICAgIGNvbnN0IHRvbCA9IDFlLTQ7XG4gICAgICAgIGNvbnN0IG1heHRyaWVzID0gNTA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBsZXQgYmV0YW1pbiA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBiZXRhbWF4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBsZXQgYmV0YSA9IDE7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBsZXQgbnVtID0gMDtcbiAgICAgICAgICAgIHdoaWxlKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaiA9IE1hdGguZXhwKC1EZWx0YS5lbnRyeShpLCBqKSAqIGJldGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaikgcGogPSAwO1xuICAgICAgICAgICAgICAgICAgICBwcm93W2pdID0gcGo7XG4gICAgICAgICAgICAgICAgICAgIHBzdW0gKz0gcGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBIaGVyZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBqID0gKHBzdW0gPT09IDApID8gMCA6IHByb3dbal0gLyBwc3VtO1xuICAgICAgICAgICAgICAgICAgICBwcm93W2pdID0gcGo7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaiA+IDFlLTcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhoZXJlIC09IHBqICogTWF0aC5sb2cocGopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChIaGVyZSA+IEh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYmV0YW1pbiA9IGJldGE7XG4gICAgICAgICAgICAgICAgICAgIGJldGEgPSAoYmV0YW1heCA9PT0gSW5maW5pdHkpID8gKGJldGEgKiAyKSA6ICgoYmV0YSArIGJldGFtYXgpIC8gMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmV0YW1heCA9IGJldGE7XG4gICAgICAgICAgICAgICAgICAgIGJldGEgPSAoYmV0YW1pbiA9PT0gLUluZmluaXR5KSA/IChiZXRhIC8gMikgOiAoKGJldGEgKyBiZXRhbWluKSAvIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK251bTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoSGhlcmUgLSBIdGFyZ2V0KSA8IHRvbCkgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG51bSA+PSBtYXh0cmllcykgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgUC5zZXRfZW50cnkoaSwgaiwgcHJvd1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbXB1dGUgcHJvYmFiaWxpdGllc1xuICAgICAgICBjb25zdCBQb3V0ID0gbmV3IE1hdHJpeChOLCBOLCBcInplcm9zXCIpXG4gICAgICAgIGNvbnN0IE4yID0gTiAqIDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBNYXRoLm1heCgoUC5lbnRyeShpLCBqKSArIFAuZW50cnkoaiwgaSkpIC8gTjIsIDFlLTEwMCk7XG4gICAgICAgICAgICAgICAgUG91dC5zZXRfZW50cnkoaSwgaiwgcCk7XG4gICAgICAgICAgICAgICAgUG91dC5zZXRfZW50cnkoaiwgaSwgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fUCA9IFBvdXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaXRlcmF0aW9ucz01MDBdIC0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gICAgICogQHlpZWxkcyB7TWF0cml4fEFycmF5PEFycmF5Pn0gLSB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oaXRlcmF0aW9ucz01MDApIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaXRlcmF0aW9ucz01MDBdIC0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gICAgICogQHlpZWxkcyB7TWF0cml4fEFycmF5PEFycmF5Pn0gLSB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICAqIGdlbmVyYXRvcihpdGVyYXRpb25zPTUwMCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGVyZm9ybXMgYSBvcHRpbWl6YXRpb24gc3RlcFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyID0gKyt0aGlzLl9pdGVyO1xuICAgICAgICBjb25zdCBQID0gdGhpcy5fUDtcbiAgICAgICAgY29uc3QgeXN0ZXAgPSB0aGlzLl95c3RlcDtcbiAgICAgICAgY29uc3QgZ2FpbnMgPSB0aGlzLl9nYWlucztcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLl9lcHNpbG9uO1xuICAgICAgICBjb25zdCBkaW0gPSB0aGlzLl9kO1xuICAgICAgICBsZXQgWSA9IHRoaXMuWTtcblxuICAgICAgICAvL2NhbGMgY29zdCBncmFkaWVudDtcbiAgICAgICAgY29uc3QgcG11bCA9IGl0ZXIgPCAxMDAgPyA0IDogMTtcbiAgICAgICAgXG4gICAgICAgIC8vIGNvbXB1dGUgUSBkaXN0ICh1bm5vcm1hbGl6ZWQpXG4gICAgICAgIGNvbnN0IFF1ID0gbmV3IE1hdHJpeChOLCBOLCBcInplcm9zXCIpXG4gICAgICAgIGxldCBxc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBkc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRoZXJlID0gWS5lbnRyeShpLCBkKSAtIFkuZW50cnkoaiwgZCk7XG4gICAgICAgICAgICAgICAgICAgIGRzdW0gKz0gZGhlcmUgKiBkaGVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcXUgPSAxIC8gKDEgKyBkc3VtKTtcbiAgICAgICAgICAgICAgICBRdS5zZXRfZW50cnkoaSwgaiwgcXUpO1xuICAgICAgICAgICAgICAgIFF1LnNldF9lbnRyeShqLCBpLCBxdSk7XG4gICAgICAgICAgICAgICAgcXN1bSArPSAyICogcXU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3JtYWxpemUgUSBkaXN0XG4gICAgICAgIGNvbnN0IFEgPSBuZXcgTWF0cml4KE4sIE4sIDApXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBNYXRoLm1heChRdS5lbnRyeShpLCBqKSAvIHFzdW0sIDFlLTEwMCk7XG4gICAgICAgICAgICAgICAgUS5zZXRfZW50cnkoaSwgaiwgdmFsKTtcbiAgICAgICAgICAgICAgICBRLnNldF9lbnRyeShqLCBpLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ3JhZCA9IG5ldyBNYXRyaXgoTiwgZGltLCBcInplcm9zXCIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVtdWx0ID0gNCAqIChwbXVsICogUC5lbnRyeShpLCBqKSAtIFEuZW50cnkoaSwgaikpICogUXUuZW50cnkoaSwgaik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICBncmFkLnNldF9lbnRyeShpLCBkLCBncmFkLmVudHJ5KGksIGQpICsgcHJlbXVsdCAqIChZLmVudHJ5KGksIGQpIC0gWS5lbnRyeShqLCBkKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBlcmZvcm0gZ3JhZGllbnQgc3RlcFxuICAgICAgICBsZXQgeW1lYW4gPSBuZXcgRmxvYXQ2NEFycmF5KGRpbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2lkID0gZ3JhZC5lbnRyeShpLCBkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWQgPSB5c3RlcC5lbnRyeShpLCBkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnYWluaWQgPSBnYWlucy5lbnRyeShpLCBkKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgbmV3Z2FpbiA9IE1hdGguc2lnbihnaWQpID09PSBNYXRoLnNpZ24oc2lkKSA/IGdhaW5pZCAqIC44IDogZ2FpbmlkICsgLjI7XG4gICAgICAgICAgICAgICAgaWYgKG5ld2dhaW4gPCAuMDEpIG5ld2dhaW4gPSAuMDE7XG4gICAgICAgICAgICAgICAgZ2FpbnMuc2V0X2VudHJ5KGksIGQsIG5ld2dhaW4pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9tdmFsID0gaXRlciA8IDI1MCA/IC41IDogLjg7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3c2lkID0gbW9tdmFsICogc2lkIC0gZXBzaWxvbiAqIG5ld2dhaW4gKiBnaWQ7XG4gICAgICAgICAgICAgICAgeXN0ZXAuc2V0X2VudHJ5KGksIGQsIG5ld3NpZCk7XG5cbiAgICAgICAgICAgICAgICBZLnNldF9lbnRyeShpLCBkLCBZLmVudHJ5KGksIGQpICsgbmV3c2lkKTtcbiAgICAgICAgICAgICAgICB5bWVhbltkXSArPSBZLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgMjsgKytkKSB7XG4gICAgICAgICAgICAgICAgWS5zZXRfZW50cnkoaSwgZCwgWS5lbnRyeShpLCBkKSAtIHltZWFuW2RdIC8gTilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLlk7XG4gICAgfVxufSAiLCIvKipcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm9wdGltaXphdGlvblxuICogQGFsaWFzIHBvd2VsbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHtBcnJheX0geDBcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4X2l0ZXIgPSAzMDBdXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAc2VlIGh0dHA6Ly9vcHRpbWl6YXRpb24tanMuZ2l0aHViLmlvL29wdGltaXphdGlvbi1qcy9vcHRpbWl6YXRpb24uanMuaHRtbCNsaW5lNDM4XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChmLCB4MCwgbWF4X2l0ZXIgPSAzMDApIHtcbiAgICBjb25zdCBlcHNpbG9uID0gMWUtMjtcbiAgICBjb25zdCBuID0geDAubGVuZ3RoO1xuICAgIGxldCBhbHBoYSA9IDFlLTM7XG4gICAgbGV0IHBmeCA9IDEwMDAwO1xuICAgIGxldCB4ID0geDAuc2xpY2UoKTtcbiAgICBsZXQgZnggPSBmKHgpO1xuICAgIGxldCBjb252ZXJnZW5jZSA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKG1heF9pdGVyLS0gPj0gMCAmJiAhY29udmVyZ2VuY2UpIHtcbiAgICAgICAgY29udmVyZ2VuY2UgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgeFtpXSArPSAxZS02O1xuICAgICAgICAgICAgbGV0IGZ4aSA9IGYoeCk7XG4gICAgICAgICAgICB4W2ldIC09IDFlLTY7XG4gICAgICAgICAgICBsZXQgZHggPSAoZnhpIC0gZngpIC8gMWUtNjtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeCkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgY29udmVyZ2VuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhbaV0gLT0gYWxwaGEgKiBkeDtcbiAgICAgICAgICAgIGZ4ID0gZih4KTtcbiAgICAgICAgfVxuICAgICAgICBhbHBoYSAqPSBwZnggPj0gZnggPyAxLjA1IDogMC40O1xuICAgICAgICBwZnggPSBmeDtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4sIGV1Y2xpZGVhbl9zcXVhcmVkIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IEJhbGxUcmVlIH0gZnJvbSBcIi4uL2tubi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBsaW5zcGFjZSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IHBvd2VsbCB9IGZyb20gXCIuLi9vcHRpbWl6YXRpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBLTk4gfSBmcm9tIFwiLi4va25uL2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgVU1BUFxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIFVNQVAgZXh0ZW5kcyBEUiB7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBVTUFQXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW25fbmVpZ2hib3JzID0gMTVdIC0gc2l6ZSBvZiB0aGUgbG9jYWwgbmVpZ2hib3Job29kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbG9jYWxfY29ubmVjdGl2aXR5ID0gMV0gLSBudW1iZXIgb2YgbmVhcmVzdCBuZWlnaGJvcnMgY29ubmVjdGVkIGluIHRoZSBsb2NhbCBuZWlnaGJvcmhvb2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5fZGlzdCA9IDFdIC0gY29udHJvbHMgaG93IHRpZ2h0bHkgcG9pbnRzIGdldCBwYWNrZWQgdG9nZXRoZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBpbiB0aGUgaGlnaC1kaW1lbnNpb25hbCBzcGFjZS4gIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VlZCA9IDEyMTJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtVTUFQfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIG5fbmVpZ2hib3JzPTE1LCBsb2NhbF9jb25uZWN0aXZpdHk9MSwgbWluX2Rpc3Q9MSwgZD0yLCBtZXRyaWM9ZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgc3VwZXIoWCwgZCwgbWV0cmljLCBzZWVkKVxuICAgICAgICBzdXBlci5wYXJhbWV0ZXJfbGlzdCA9IFtcIm5fbmVpZ2hib3JzXCIsIFwibG9jYWxfY29ubmVjdGl2aXR5XCIsIFwibWluX2Rpc3RcIl07XG4gICAgICAgIFsgdGhpcy5fTiwgdGhpcy5fRCBdID0gdGhpcy5YLnNoYXBlO1xuICAgICAgICBuX25laWdoYm9ycyA9IE1hdGgubWluKHRoaXMuX04gLSAxLCBuX25laWdoYm9ycyk7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyKFwibl9uZWlnaGJvcnNcIiwgbl9uZWlnaGJvcnMpO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcImxvY2FsX2Nvbm5lY3Rpdml0eVwiLCBNYXRoLm1pbihsb2NhbF9jb25uZWN0aXZpdHksIG5fbmVpZ2hib3JzIC0gMSkpO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcIm1pbl9kaXN0XCIsIG1pbl9kaXN0KTtcbiAgICAgICAgdGhpcy5faXRlciA9IDA7XG4gICAgICAgIHRoaXMuX3NwcmVhZCA9IDE7XG4gICAgICAgIHRoaXMuX3NldF9vcF9taXhfcmF0aW8gPSAxO1xuICAgICAgICB0aGlzLl9yZXB1bHNpb25fc3RyZW5ndGggPSAxO1xuICAgICAgICB0aGlzLl9uZWdhdGl2ZV9zYW1wbGVfcmF0ZSA9IDU7XG4gICAgICAgIHRoaXMuX25fZXBvY2hzID0gMzUwO1xuICAgICAgICB0aGlzLl9pbml0aWFsX2FscGhhID0gMTtcbiAgICAgICAgdGhpcy5ZID0gbmV3IE1hdHJpeCh0aGlzLl9OLCB0aGlzLl9kLCAoKSA9PiB0aGlzLl9yYW5kb21pemVyLnJhbmRvbSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwcmVhZCBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluX2Rpc3QgXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIF9maW5kX2FiX3BhcmFtcyhzcHJlYWQsIG1pbl9kaXN0KSB7XG4gICAgICAgIGNvbnN0IGN1cnZlID0gKHgsIGEsIGIpID0+IDEgLyAoMSArIGEgKiBNYXRoLnBvdyh4LCAyICogYikpO1xuICAgICAgICBjb25zdCB4diA9IGxpbnNwYWNlKDAsIHNwcmVhZCAqIDMsIDMwMCk7XG4gICAgICAgIGNvbnN0IHl2ID0gbGluc3BhY2UoMCwgc3ByZWFkICogMywgMzAwKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0geHYubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB4dl9pID0geHZbaV07XG4gICAgICAgICAgICB5dltpXSA9ICh4dl9pIDwgbWluX2Rpc3QgPyAxIDogTWF0aC5leHAoLSh4dl9pIC0gbWluX2Rpc3QpIC8gc3ByZWFkKSk7XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICBjb25zdCBlcnIgPSAocCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBsaW5zcGFjZSgxLCAzMDApLm1hcCgoXywgaSkgPT4geXZbaV0gLSBjdXJ2ZSh4dltpXSwgcFswXSwgcFsxXSkpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChuZXVtYWlyX3N1bShlcnJvci5tYXAoZSA9PiBlICogZSkpKTtcbiAgICAgICAgfVxuICAgICAgXG4gICAgICAgIHJldHVybiBwb3dlbGwoZXJyLCBbMSwgMV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IGRpc3RhbmNlcyBcbiAgICAgKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHNpZ21hcyBcbiAgICAgKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHJob3MgXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIF9jb21wdXRlX21lbWJlcnNoaXBfc3RyZW5ndGhzKGRpc3RhbmNlcywgc2lnbWFzLCByaG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gZGlzdGFuY2VzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIG0gPSBkaXN0YW5jZXNbaV0ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IGRpc3RhbmNlc1tpXVtqXS52YWx1ZSAtIHJob3NbaV07XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzW2ldW2pdLnZhbHVlID0gdiA+IDAgPyBNYXRoLmV4cCgtdiAvIHNpZ21hc1tpXSkgOiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXN0YW5jZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0tOTnxCYWxsVHJlZX0ga25uIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrIFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgX3Ntb290aF9rbm5fZGlzdChrbm4sIGspIHtcbiAgICAgICAgY29uc3QgU01PT1RIX0tfVE9MRVJBTkNFID0gMWUtNTtcbiAgICAgICAgY29uc3QgTUlOX0tfRElTVF9TQ0FMRSA9IDFlLTM7XG4gICAgICAgIGNvbnN0IG5faXRlciA9IDY0O1xuICAgICAgICBjb25zdCBsb2NhbF9jb25uZWN0aXZpdHkgPSB0aGlzLl9sb2NhbF9jb25uZWN0aXZpdHk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IE1hdGgubG9nMihrKTtcbiAgICAgICAgY29uc3QgcmhvcyA9IFtdO1xuICAgICAgICBjb25zdCBzaWdtYXMgPSBbXTtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgTiA9IFguc2hhcGVbMF07XG4gICAgICAgIC8vY29uc3QgZGlzdGFuY2VzID0gWy4uLlhdLm1hcCh4X2kgPT4ga25uLnNlYXJjaCh4X2ksIGspLnJhd19kYXRhKCkucmV2ZXJzZSgpKTtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX21ldHJpYyA9PT0gXCJwcmVjb21wdXRlZFwiKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlcy5wdXNoKGtubi5zZWFyY2goaSwgaykucmV2ZXJzZSgpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBmb3IgKGNvbnN0IHhfaSBvZiBYKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzLnB1c2goa25uLnNlYXJjaCh4X2ksIGspLnJhd19kYXRhKCkucmV2ZXJzZSgpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBsbyA9IDA7XG4gICAgICAgICAgICBsZXQgaGkgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBtaWQgPSAxO1xuXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hfcmVzdWx0ID0gZGlzdGFuY2VzW2ldXG4gICAgICAgICAgICBjb25zdCBub25femVyb19kaXN0ID0gc2VhcmNoX3Jlc3VsdC5maWx0ZXIoZCA9PiBkLnZhbHVlID4gMCk7XG4gICAgICAgICAgICBjb25zdCBub25femVyb19kaXN0X2xlbmd0aCA9IG5vbl96ZXJvX2Rpc3QubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG5vbl96ZXJvX2Rpc3RfbGVuZ3RoID49IGxvY2FsX2Nvbm5lY3Rpdml0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcihsb2NhbF9jb25uZWN0aXZpdHkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRpb24gPSBsb2NhbF9jb25uZWN0aXZpdHkgLSBpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJob3MucHVzaChub25femVyb19kaXN0W2luZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbiA+IFNNT09USF9LX1RPTEVSQU5DRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmhvc1tpXS52YWx1ZSArPSBpbnRlcnBvbGF0aW9uICogKG5vbl96ZXJvX2Rpc3RbaW5kZXhdLnZhbHVlIC0gbm9uX3plcm9fZGlzdFtpbmRleCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJob3NbaV0udmFsdWUgPSBpbnRlcnBvbGF0aW9uICogbm9uX3plcm9fZGlzdFswXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vbl96ZXJvX2Rpc3RfbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJob3NbaV0gPSBub25femVyb19kaXN0W25vbl96ZXJvX2Rpc3RfbGVuZ3RoIC0gMV0udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG5faXRlcjsgKyt4KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgazsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBzZWFyY2hfcmVzdWx0W2pdLnZhbHVlIC0gcmhvc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcHN1bSArPSAoZCA+IDAgPyBNYXRoLmV4cCgtKGQgLyBtaWQpKSA6IDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocHN1bSAtIHRhcmdldCkgPCBTTU9PVEhfS19UT0xFUkFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwc3VtID4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIFtoaSwgbWlkXSA9IFttaWQsIChsbyArIGhpKSAvIDJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtsbywgbWlkXSA9IFttaWQsIG1pZCAqIDJdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2xvLCBtaWRdID0gW21pZCwgKGxvICsgaGkpIC8gMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWdtYXNbaV0gPSBtaWQ7XG5cbiAgICAgICAgICAgIGNvbnN0IG1lYW5faXRoZCA9IHNlYXJjaF9yZXN1bHQucmVkdWNlKChhLCBiKSA9PiBhICsgYi52YWx1ZSwgMCkgLyBzZWFyY2hfcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIC8vbGV0IG1lYW5fZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmhvc1tpXSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbWFzW2ldIDwgTUlOX0tfRElTVF9TQ0FMRSAqIG1lYW5faXRoZCkge1xuICAgICAgICAgICAgICAgICAgICBzaWdtYXNbaV0gPSBNSU5fS19ESVNUX1NDQUxFICogbWVhbl9pdGhkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVhbl9kID0gZGlzdGFuY2VzLnJlZHVjZSgoYWNjLCByZXMpID0+IGFjYyArIHJlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLnZhbHVlLCAwKSAvIHJlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChzaWdtYXNbaV0gPiBNSU5fS19ESVNUX1NDQUxFICogbWVhbl9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ21hc1tpXSA9IE1JTl9LX0RJU1RfU0NBTEUgKiBtZWFuX2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcImRpc3RhbmNlc1wiOiBkaXN0YW5jZXMsIFxuICAgICAgICAgICAgXCJzaWdtYXNcIjogc2lnbWFzLCBcbiAgICAgICAgICAgIFwicmhvc1wiOiByaG9zXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBYIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX25laWdoYm9ycyBcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIF9mdXp6eV9zaW1wbGljaWFsX3NldChYLCBuX25laWdoYm9ycykge1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBrbm4gPSBtZXRyaWMgPT09IFwicHJlY29tcHV0ZWRcIiA/IG5ldyBLTk4oWCwgXCJwcmVjb21wdXRlZFwiKSA6IG5ldyBCYWxsVHJlZShYLnRvMmRBcnJheSwgbWV0cmljKTtcbiAgICAgICAgbGV0IHsgZGlzdGFuY2VzLCBzaWdtYXMsIHJob3MgfSA9IHRoaXMuX3Ntb290aF9rbm5fZGlzdChrbm4sIG5fbmVpZ2hib3JzKTtcbiAgICAgICAgZGlzdGFuY2VzID0gdGhpcy5fY29tcHV0ZV9tZW1iZXJzaGlwX3N0cmVuZ3RocyhkaXN0YW5jZXMsIHNpZ21hcywgcmhvcyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgoTiwgTiwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlc19pID0gZGlzdGFuY2VzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaXN0YW5jZXNfaS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRfZW50cnkoaSwgZGlzdGFuY2VzX2lbal0uZWxlbWVudC5pbmRleCwgZGlzdGFuY2VzX2lbal0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zcG9zZWRfcmVzdWx0ID0gcmVzdWx0LlQ7XG4gICAgICAgIGNvbnN0IHByb2RfbWF0cml4ID0gcmVzdWx0Lm11bHQodHJhbnNwb3NlZF9yZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICAuYWRkKHRyYW5zcG9zZWRfcmVzdWx0KVxuICAgICAgICAgICAgLnN1Yihwcm9kX21hdHJpeClcbiAgICAgICAgICAgIC5tdWx0KHRoaXMuX3NldF9vcF9taXhfcmF0aW8pXG4gICAgICAgICAgICAuYWRkKHByb2RfbWF0cml4Lm11bHQoMSAtIHRoaXMuX3NldF9vcF9taXhfcmF0aW8pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX2Vwb2NocyBcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgX21ha2VfZXBvY2hzX3Blcl9zYW1wbGUobl9lcG9jaHMpIHtcbiAgICAgICAgY29uc3Qgd2VpZ2h0cyA9IHRoaXMuX3dlaWdodHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkod2VpZ2h0cy5sZW5ndGgpLmZpbGwoLTEpO1xuICAgICAgICBjb25zdCB3ZWlnaHRzX21heCA9IG1heCh3ZWlnaHRzKTtcbiAgICAgICAgY29uc3Qgbl9zYW1wbGVzID0gd2VpZ2h0cy5tYXAodyA9PiBuX2Vwb2NocyAqICh3IC8gd2VpZ2h0c19tYXgpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIFxuICAgICAgICAgIGlmIChuX3NhbXBsZXNbaV0gPiAwKSByZXN1bHRbaV0gPSBNYXRoLnJvdW5kKG5fZXBvY2hzIC8gbl9zYW1wbGVzW2ldKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBncmFwaCBcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIF90b2NvbyhncmFwaCkge1xuICAgICAgICBjb25zdCByb3dzID0gW107XG4gICAgICAgIGNvbnN0IGNvbHMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBjb25zdCBbIHJvd3NfbiwgY29sc19uIF0gPSBncmFwaC5zaGFwZTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93c19uOyArK3Jvdykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sc19uOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZ3JhcGguZW50cnkocm93LCBjb2wpO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICAgICAgY29scy5wdXNoKGNvbCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcInJvd3NcIjogcm93cywgXG4gICAgICAgICAgICBcImNvbHNcIjogY29scywgXG4gICAgICAgICAgICBcImRhdGFcIjogZGF0YVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGFsbCBuZWNlc3NhcnkgXG4gICAgICogQHJldHVybnMge1VNQVB9XG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3QgWyBhLCBiIF0gPSB0aGlzLl9maW5kX2FiX3BhcmFtcyh0aGlzLl9zcHJlYWQsIHRoaXMuX21pbl9kaXN0KTtcbiAgICAgICAgdGhpcy5fYSA9IGE7XG4gICAgICAgIHRoaXMuX2IgPSBiO1xuICAgICAgICB0aGlzLl9ncmFwaCA9IHRoaXMuX2Z1enp5X3NpbXBsaWNpYWxfc2V0KHRoaXMuWCwgdGhpcy5fbl9uZWlnaGJvcnMpO1xuICAgICAgICBjb25zdCB7IHJvd3MsIGNvbHMsIGRhdGE6IHdlaWdodHMgfSA9IHRoaXMuX3RvY29vKHRoaXMuX2dyYXBoKTtcbiAgICAgICAgdGhpcy5faGVhZCA9IHJvd3M7XG4gICAgICAgIHRoaXMuX3RhaWwgPSBjb2xzO1xuICAgICAgICB0aGlzLl93ZWlnaHRzID0gd2VpZ2h0cztcbiAgICAgICAgdGhpcy5fZXBvY2hzX3Blcl9zYW1wbGUgPSB0aGlzLl9tYWtlX2Vwb2Noc19wZXJfc2FtcGxlKHRoaXMuX25fZXBvY2hzKTtcbiAgICAgICAgdGhpcy5fZXBvY2hzX3Blcl9uZWdhdGl2ZV9zYW1wbGUgPSB0aGlzLl9lcG9jaHNfcGVyX3NhbXBsZS5tYXAoZCA9PiBkICogdGhpcy5fbmVnYXRpdmVfc2FtcGxlX3JhdGUpO1xuICAgICAgICB0aGlzLl9lcG9jaF9vZl9uZXh0X3NhbXBsZSA9IHRoaXMuX2Vwb2Noc19wZXJfc2FtcGxlLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuX2Vwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlID0gdGhpcy5fZXBvY2hzX3Blcl9uZWdhdGl2ZV9zYW1wbGUuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0IGxvY2FsX2Nvbm5lY3Rpdml0eSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9sb2NhbF9jb25uZWN0aXZpdHkgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgbG9jYWxfY29ubmVjdGl2aXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxfY29ubmVjdGl2aXR5O1xuICAgIH1cblxuICAgIHNldCBtaW5fZGlzdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9taW5fZGlzdCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBtaW5fZGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbl9kaXN0O1xuICAgIH1cblxuICAgIGdyYXBoKCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgcmV0dXJuIHsgY29sczogdGhpcy5faGVhZCwgcm93czogdGhpcy5fdGFpbCwgd2VpZ2h0czogdGhpcy5fd2VpZ2h0cyB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaXRlcmF0aW9ucz0zNTBdIC0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gICAgICogQHJldHVybnMge01hdHJpeHxBcnJheX1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oaXRlcmF0aW9ucz0zNTApIHtcbiAgICAgICAgaWYgKHRoaXMuX25fZXBvY2hzICE9IGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX25fZXBvY2hzID0gaXRlcmF0aW9ucztcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaXRlcmF0aW9ucz0zNTBdIC0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gICAgICogQHJldHVybnMge01hdHJpeHxBcnJheX1cbiAgICAgKi9cbiAgICAqIGdlbmVyYXRvcihpdGVyYXRpb25zPTM1MCkge1xuICAgICAgICBpZiAodGhpcy5fbl9lcG9jaHMgIT0gaXRlcmF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fbl9lcG9jaHMgPSBpdGVyYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucHJvamVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBfY2xpcCh4KSB7XG4gICAgICAgIGlmICh4ID4gNCkgcmV0dXJuIDQ7XG4gICAgICAgIGlmICh4IDwgLTQpIHJldHVybiAtNDtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGVyZm9ybXMgdGhlIG9wdGltaXphdGlvbiBzdGVwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGhlYWRfZW1iZWRkaW5nIFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSB0YWlsX2VtYmVkZGluZyBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gaGVhZCBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gdGFpbCBcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIF9vcHRpbWl6ZV9sYXlvdXQoaGVhZF9lbWJlZGRpbmcsIHRhaWxfZW1iZWRkaW5nLCBoZWFkLCB0YWlsKSB7XG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgICAgICBfZDogZGltLCBcbiAgICAgICAgICAgIF9hbHBoYTogYWxwaGEsIFxuICAgICAgICAgICAgX3JlcHVsc2lvbl9zdHJlbmd0aDogcmVwdWxzaW9uX3N0cmVuZ3RoLCBcbiAgICAgICAgICAgIF9hOiBhLCBcbiAgICAgICAgICAgIF9iOiBiLFxuICAgICAgICAgICAgX2Vwb2Noc19wZXJfc2FtcGxlOiBlcG9jaHNfcGVyX3NhbXBsZSxcbiAgICAgICAgICAgIF9lcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZTogZXBvY2hzX3Blcl9uZWdhdGl2ZV9zYW1wbGUsXG4gICAgICAgICAgICBfZXBvY2hfb2ZfbmV4dF9uZWdhdGl2ZV9zYW1wbGU6IGVwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlLFxuICAgICAgICAgICAgX2Vwb2NoX29mX25leHRfc2FtcGxlOiBlcG9jaF9vZl9uZXh0X3NhbXBsZSxcbiAgICAgICAgICAgIF9jbGlwOiBjbGlwXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0YWlsX2xlbmd0aCA9IHRhaWwubGVuZ3RoO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gZXBvY2hzX3Blcl9zYW1wbGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoZXBvY2hfb2ZfbmV4dF9zYW1wbGVbaV0gPD0gdGhpcy5faXRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGogPSBoZWFkW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGsgPSB0YWlsW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBoZWFkX2VtYmVkZGluZy5yb3coaik7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSB0YWlsX2VtYmVkZGluZy5yb3coayk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IGV1Y2xpZGVhbl9zcXVhcmVkKGN1cnJlbnQsIG90aGVyKTtcbiAgICAgICAgICAgICAgICBsZXQgZ3JhZF9jb2VmZiA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRfY29lZmYgPSAoLTIgKiBhICogYiAqIE1hdGgucG93KGRpc3QsIGIgLSAxKSkgLyAoYSAqIE1hdGgucG93KGRpc3QsIGIpICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3JhZF9kID0gY2xpcChncmFkX2NvZWZmICogKGN1cnJlbnRbZF0gLSBvdGhlcltkXSkpICogYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBjdXJyZW50W2RdICsgZ3JhZF9kO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvID0gb3RoZXJbZF0gLSBncmFkX2Q7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRbZF0gPSBjO1xuICAgICAgICAgICAgICAgICAgICBvdGhlcltkXSA9IG87XG4gICAgICAgICAgICAgICAgICAgIGhlYWRfZW1iZWRkaW5nLnNldF9lbnRyeShqLCBkLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgdGFpbF9lbWJlZGRpbmcuc2V0X2VudHJ5KGssIGQsIG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcG9jaF9vZl9uZXh0X3NhbXBsZVtpXSArPSBlcG9jaHNfcGVyX3NhbXBsZVtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuX25lZ19zYW1wbGVzID0gKHRoaXMuX2l0ZXIgLSBlcG9jaF9vZl9uZXh0X25lZ2F0aXZlX3NhbXBsZVtpXSkgLyBlcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZVtpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG5fbmVnX3NhbXBsZXM7ICsrcCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrID0gTWF0aC5mbG9vcih0aGlzLl9yYW5kb21pemVyLnJhbmRvbSAqIHRhaWxfbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSB0YWlsX2VtYmVkZGluZy5yb3codGFpbFtrXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBldWNsaWRlYW5fc3F1YXJlZChjdXJyZW50LCBvdGhlcik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBncmFkX2NvZWZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkX2NvZWZmID0gKDIgKiByZXB1bHNpb25fc3RyZW5ndGggKiBiKSAvICgoLjAxICsgZGlzdCkgKiAoYSAqIE1hdGgucG93KGRpc3QsIGIpICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGogPT09IGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyYWRfZCA9IGNsaXAoZ3JhZF9jb2VmZiAqIChjdXJyZW50W2RdIC0gb3RoZXJbZF0pKSAqIGFscGhhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGN1cnJlbnRbZF0gKyBncmFkX2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvID0gb3RoZXJbZF0gLSBncmFkX2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50W2RdID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyW2RdID0gbztcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRfZW1iZWRkaW5nLnNldF9lbnRyeShqLCBkLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhaWxfZW1iZWRkaW5nLnNldF9lbnRyeSh0YWlsW2tdLCBkLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcG9jaF9vZl9uZXh0X25lZ2F0aXZlX3NhbXBsZVtpXSArPSAobl9uZWdfc2FtcGxlcyAqIGVwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZF9lbWJlZGRpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCBpdGVyID0gKyt0aGlzLl9pdGVyO1xuICAgICAgICBsZXQgWSA9IHRoaXMuWTtcblxuICAgICAgICB0aGlzLl9hbHBoYSA9ICh0aGlzLl9pbml0aWFsX2FscGhhICogKDEgLSBpdGVyIC8gdGhpcy5fbl9lcG9jaHMpKTtcbiAgICAgICAgdGhpcy5ZID0gdGhpcy5fb3B0aW1pemVfbGF5b3V0KFksIFksIHRoaXMuX2hlYWQsIHRoaXMuX3RhaWwpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLlk7XG4gICAgfVxufSAiLCJpbXBvcnQgeyBNYXRyaXgsIGxpbnNwYWNlIH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFBDQSB9IGZyb20gXCIuL1BDQS5qc1wiO1xuaW1wb3J0IHsgQmFsbFRyZWUgfSBmcm9tIFwiLi4va25uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgVHJpTWFwXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgVHJpTWFwIGV4dGVuZHMgRFJ7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgVHJpTWFwXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3dlaWdodF9hZGogPSA1MDBdIC0gc2NhbGluZyBmYWN0b3IuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjID0gNV0gLSBudW1iZXIgb2YgdHJpcGxldHMgbXVsdGlwbGllci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2QgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLiAgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWVkID0gMTIxMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHJldHVybnMge1RyaU1hcH1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2FyeGl2Lm9yZy9wZGYvMTkxMC4wMDIwNHYxLnBkZn1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZWFtaWQvdHJpbWFwfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHdlaWdodF9hZGogPSA1MDAsIGMgPSA1LCBkID0gMiwgbWV0cmljID0gZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgc3VwZXIoWCwgZCwgbWV0cmljLCBzZWVkKTtcbiAgICAgICAgc3VwZXIucGFyYW1ldGVyX2xpc3QgPSBbXCJ3ZWlnaHRfYWRqXCIsIFwiY1wiXTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJ3ZWlnaHRfYWRqXCIsIHdlaWdodF9hZGopO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcImNcIiwgYylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFtwY2EgPSBudWxsXSAtIEluaXRpYWwgRW1iZWRkaW5nIChpZiBudWxsIHRoZW4gUENBIGdldHMgdXNlZCkuIFxuICAgICAqIEBwYXJhbSB7S05OfSBba25uID0gbnVsbF0gLSBLTk4gT2JqZWN0IChpZiBudWxsIHRoZW4gQmFsbFRyZWUgZ2V0cyB1c2VkKS4gXG4gICAgICovXG4gICAgaW5pdChwY2EgPSBudWxsLCBrbm4gPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IE4gPSBYLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBkID0gdGhpcy5fZDtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBjID0gdGhpcy5fYztcbiAgICAgICAgdGhpcy5uX2lubGllcnMgPSAyICogYztcbiAgICAgICAgdGhpcy5uX291dGxpZXJzID0gMSAqIGM7XG4gICAgICAgIHRoaXMubl9yYW5kb20gPSAxICogYztcbiAgICAgICAgdGhpcy5ZID0gcGNhIHx8IG5ldyBQQ0EoWCwgZCkudHJhbnNmb3JtKCkvLy5tdWx0KC4wMSk7XG4gICAgICAgIHRoaXMua25uID0ga25uIHx8IG5ldyBCYWxsVHJlZShYLnRvMmRBcnJheSwgbWV0cmljKTtcbiAgICAgICAgY29uc3Qge3RyaXBsZXRzLCB3ZWlnaHRzfSA9IHRoaXMuX2dlbmVyYXRlX3RyaXBsZXRzKHRoaXMubl9pbmxpZXJzLCB0aGlzLm5fb3V0bGllcnMsIHRoaXMubl9yYW5kb20pO1xuICAgICAgICB0aGlzLnRyaXBsZXRzID0gdHJpcGxldHM7XG4gICAgICAgIHRoaXMud2VpZ2h0cyA9IHdlaWdodHM7XG4gICAgICAgIHRoaXMubHIgPSAxMDAwICogTiAvIHRyaXBsZXRzLnNoYXBlWzBdO1xuICAgICAgICB0aGlzLkMgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy50b2wgPSAxZS03O1xuICAgICAgICB0aGlzLnZlbCA9IG5ldyBNYXRyaXgoTiwgZCwgMCk7XG4gICAgICAgIHRoaXMuZ2FpbiA9IG5ldyBNYXRyaXgoTiwgZCwgMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB7QGxpbmsgbl9pbmxpZXJzfSB4IHtAbGluayBuX291dGxpZXJzfSB4IHtAbGluayBuX3JhbmRvbX0gdHJpcGxldHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5faW5saWVycyBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbl9vdXRsaWVycyBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbl9yYW5kb20gXG4gICAgICovXG4gICAgX2dlbmVyYXRlX3RyaXBsZXRzKG5faW5saWVycywgbl9vdXRsaWVycywgbl9yYW5kb20pIHtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCB3ZWlnaHRfYWRqID0gdGhpcy5fd2VpZ2h0X2FkajtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgTiA9IFguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IGtubiA9IHRoaXMua25uO1xuICAgICAgICBjb25zdCBuX2V4dHJhID0gTWF0aC5taW4obl9pbmxpZXJzICsgMjAsIE4pO1xuICAgICAgICBjb25zdCBuYnJzID0gbmV3IE1hdHJpeChOLCBuX2V4dHJhKTtcbiAgICAgICAgY29uc3Qga25uX2Rpc3RhbmNlcyA9IG5ldyBNYXRyaXgoTiwgbl9leHRyYSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBrbm4uc2VhcmNoKFgucm93KGkpLCBuX2V4dHJhICsgMSlcbiAgICAgICAgICAgICAgICAucmF3X2RhdGEoKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZCA9PiBkLnZhbHVlICE9IDApXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEudmFsdWUgLSBiLnZhbHVlKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChkLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG5icnMuc2V0X2VudHJ5KGksIGosIGQuZWxlbWVudC5pbmRleClcbiAgICAgICAgICAgICAgICAgICAga25uX2Rpc3RhbmNlcy5zZXRfZW50cnkoaSwgaiwgZC52YWx1ZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzY2FsZSBwYXJhbWV0ZXJcbiAgICAgICAgY29uc3Qgc2lnID0gbmV3IEZsb2F0NjRBcnJheShOKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIHNpZ1tpXSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgIChrbm5fZGlzdGFuY2VzLmVudHJ5KGksIDMpICtcbiAgICAgICAgICAgICAgICAgICAga25uX2Rpc3RhbmNlcy5lbnRyeShpLCA0KSArXG4gICAgICAgICAgICAgICAgICAgIGtubl9kaXN0YW5jZXMuZW50cnkoaSwgNSkgK1xuICAgICAgICAgICAgICAgICAgICBrbm5fZGlzdGFuY2VzLmVudHJ5KGksIDYpKSAvIDQsXG4gICAgICAgICAgICAgICAgICAgIDFlLTEwKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgUCA9IHRoaXMuX2ZpbmRfcChrbm5fZGlzdGFuY2VzLCBzaWcsIG5icnMpO1xuICAgICAgICBcbiAgICAgICAgbGV0IHRyaXBsZXRzID0gdGhpcy5fc2FtcGxlX2tubl90cmlwbGV0cyhQLCBuYnJzLCBuX2lubGllcnMsIG5fb3V0bGllcnMpO1xuICAgICAgICBsZXQgbl90cmlwbGV0cyA9IHRyaXBsZXRzLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBvdXRsaWVyX2Rpc3RhbmNlcyA9IG5ldyBGbG9hdDY0QXJyYXkobl90cmlwbGV0cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbl90cmlwbGV0czsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBqID0gdHJpcGxldHMuZW50cnkoaSwgMCk7XG4gICAgICAgICAgICBjb25zdCBrID0gdHJpcGxldHMuZW50cnkoaSwgMik7XG4gICAgICAgICAgICBvdXRsaWVyX2Rpc3RhbmNlc1tpXSA9IG1ldHJpYyhYLnJvdyhqKSwgWC5yb3coaykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3ZWlnaHRzID0gdGhpcy5fZmluZF93ZWlnaHRzKHRyaXBsZXRzLCBQLCBuYnJzLCBvdXRsaWVyX2Rpc3RhbmNlcywgc2lnKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChuX3JhbmRvbSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHtyYW5kb21fdHJpcGxldHMsIHJhbmRvbV93ZWlnaHRzfSA9IHRoaXMuX3NhbXBsZV9yYW5kb21fdHJpcGxldHMoWCwgbl9yYW5kb20sIHNpZyk7XG4gICAgICAgICAgICB0cmlwbGV0cyA9IHRyaXBsZXRzLmNvbmNhdChyYW5kb21fdHJpcGxldHMsIFwidmVydGljYWxcIik7XG4gICAgICAgICAgICB3ZWlnaHRzID0gRmxvYXQ2NEFycmF5LmZyb20oWy4uLndlaWdodHMsIC4uLnJhbmRvbV93ZWlnaHRzXSlcbiAgICAgICAgfVxuICAgICAgICBuX3RyaXBsZXRzID0gdHJpcGxldHMuc2hhcGVbMF07XG4gICAgICAgIGxldCBtYXhfd2VpZ2h0ID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5fdHJpcGxldHM7ICsraSkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHdlaWdodHNbaV0pKSB7d2VpZ2h0c1tpXSA9IDA7fVxuICAgICAgICAgICAgaWYgKG1heF93ZWlnaHQgPCB3ZWlnaHRzW2ldKSBtYXhfd2VpZ2h0ID0gd2VpZ2h0c1tpXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF4X3dlaWdodF8yID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5fdHJpcGxldHM7ICsraSkge1xuICAgICAgICAgICAgd2VpZ2h0c1tpXSAvPSBtYXhfd2VpZ2h0O1xuICAgICAgICAgICAgd2VpZ2h0c1tpXSArPSAuMDAwMTtcbiAgICAgICAgICAgIHdlaWdodHNbaV0gPSBNYXRoLmxvZygxICsgd2VpZ2h0X2FkaiAqIHdlaWdodHNbaV0pO1xuICAgICAgICAgICAgaWYgKG1heF93ZWlnaHRfMiA8IHdlaWdodHNbaV0pIG1heF93ZWlnaHRfMiA9IHdlaWdodHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuX3RyaXBsZXRzOyArK2kpIHtcbiAgICAgICAgICAgIHdlaWdodHNbaV0gLz0gbWF4X3dlaWdodF8yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcInRyaXBsZXRzXCI6IHRyaXBsZXRzLFxuICAgICAgICAgICAgXCJ3ZWlnaHRzXCI6IHdlaWdodHMsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBzaW1pbGFyaXR5IG1hdHJpeCBQXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0ga25uX2Rpc3RhbmNlcyAtIG1hdHJpeCBvZiBwYWlyd2lzZSBrbm4gZGlzdGFuY2VzXG4gICAgICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IHNpZyAtIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgZGlzdGFuY2VzXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IG5icnMgLSBuZWFyZXN0IG5laWdoYm9yc1xuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IHBhaXJ3aXNlIHNpbWlsYXJpdHkgbWF0cml4XG4gICAgICovXG4gICAgX2ZpbmRfcChrbm5fZGlzdGFuY2VzLCBzaWcsIG5icnMpIHtcbiAgICAgICAgY29uc3QgW04sIG5fbmVpZ2hib3JzXSA9IGtubl9kaXN0YW5jZXMuc2hhcGU7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KE4sIG5fbmVpZ2hib3JzLCAoaSwgaikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZXhwKC0oKGtubl9kaXN0YW5jZXMuZW50cnkoaSwgaikgKiogMikgLyBzaWdbaV0gLyBzaWdbbmJycy5lbnRyeShpLCBqKV0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2FtcGxlIG5lYXJlc3QgbmVpZ2hib3JzIHRyaXBsZXRzIGJhc2VkIG9uIHRoZSBzaW1pbGFyaXR5IHZhbHVlcyBnaXZlbiBpbiBQLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFAgLSBNYXRyaXggb2YgcGFpcndpc2Ugc2ltaWxhcml0aWVzIGJldHdlZW4gZWFjaCBwb2ludCBhbmQgaXRzIG5laWdoYm9ycyBnaXZlbiBpbiBtYXRyaXggbmJycy5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbmJycyAtIE5lYXJlc3QgbmVpZ2hib3JzIGluZGljZXMgZm9yIGVhY2ggcG9pbnQuIFRoZSBzaW1pbGFyaXR5IHZhbHVlcyBhcmUgZ2l2ZW4gaW4gbWF0cml4IHtAbGluayBQfS4gUm93IGkgY29ycmVzcG9uZHMgdG8gdGhlIGktdGggcG9pbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5faW5saWVycyAtIE51bWJlciBvZiBpbmxpZXIgcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX291dGxpZXJzIC0gTnVtYmVyIG9mIG91dGxpZXIgcG9pbnRzLlxuICAgICAqIFxuICAgICAqL1xuICAgIF9zYW1wbGVfa25uX3RyaXBsZXRzKFAsIG5icnMsIG5faW5saWVycywgbl9vdXRsaWVycykge1xuICAgICAgICBjb25zdCBOID0gbmJycy5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgdHJpcGxldHMgPSBuZXcgTWF0cml4KE4gKiBuX2lubGllcnMgKiBuX291dGxpZXJzLCAzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBuX2kgPSBpICogbl9pbmxpZXJzICogbl9vdXRsaWVycztcbiAgICAgICAgICAgIGNvbnN0IHNvcnRfaW5kaWNlcyA9IHRoaXMuX19hcmdzb3J0KFAucm93KGkpLm1hcChkID0+IC1kKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5faW5saWVyczsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5faiA9IGogKiBuX291dGxpZXJzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpbSA9IG5icnMuZW50cnkoaSwgc29ydF9pbmRpY2VzW2pdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1wbGVzID0gdGhpcy5fcmVqZWN0aW9uX3NhbXBsZShuX291dGxpZXJzLCBOLCBzb3J0X2luZGljZXMuc2xpY2UoMCwgaiArIDEpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5fb3V0bGllcnM7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG5faSArIG5faiArIGs7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dCA9IHNhbXBsZXNba107XG4gICAgICAgICAgICAgICAgICAgIHRyaXBsZXRzLnNldF9lbnRyeShpbmRleCwgMCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIHRyaXBsZXRzLnNldF9lbnRyeShpbmRleCwgMSwgc2ltKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpcGxldHMuc2V0X2VudHJ5KGluZGV4LCAyLCBvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJpcGxldHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIGRvIHRoZSBzYW1lIGFzIG5wLmFyZ3NvcnQoKVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gQSBcbiAgICAgKi9cbiAgICBfX2FyZ3NvcnQoQSkge1xuICAgICAgICByZXR1cm4gQVxuICAgICAgICAgICAgLm1hcCgoZCwgaSkgPT4ge3JldHVybiB7ZDogZCwgaTogaX07fSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmQgLSBiLmQpXG4gICAgICAgICAgICAubWFwKChkKSA9PiBkLmkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhbXBsZXMge0BsaW5rIG5fc2FtcGxlc30gaW50ZWdlcnMgZnJvbSBhIGdpdmVuIGludGVydmFsIFswLCB7QGxpbmsgbWF4X2ludH1dIHdoaWxlIHJlamVjdGlvbiB0aGUgdmFsdWVzIHRoYXQgYXJlIGluIHRoZSB7QGxpbmsgcmVqZWN0c30uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG5fc2FtcGxlcyBcbiAgICAgKiBAcGFyYW0geyp9IG1heF9pbnQgXG4gICAgICogQHBhcmFtIHsqfSByZWplY3RzIFxuICAgICAqL1xuICAgIF9yZWplY3Rpb25fc2FtcGxlKG5fc2FtcGxlcywgbWF4X2ludCwgcmVqZWN0cykge1xuICAgICAgICBjb25zdCByYW5kb21pemVyID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBsaW5zcGFjZSgwLCBtYXhfaW50IC0gMSkuZmlsdGVyKGQgPT4gcmVqZWN0cy5pbmRleE9mKGQpIDwgMCk7XG4gICAgICAgIHJldHVybiByYW5kb21pemVyLmNob2ljZShpbnRlcnZhbCwgTWF0aC5taW4obl9zYW1wbGVzLCBpbnRlcnZhbC5sZW5ndGggLSAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgd2VpZ2h0cyBmb3IgdGhlIHNhbXBsZWQgbmVhcmVzdCBuZWlnaGJvcnMgdHJpcGxldHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSB0cmlwbGV0cyAtIFNhbXBsZWQgVHJpcGxldHMuXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFAgLSBQYWlyd2lzZSBzaW1pbGFyaXR5IG1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbmJycyAtIG5lYXJlc3QgTmVpZ2hib3JzXG4gICAgICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IG91dGxpZXJfZGlzdGFuY2VzIC0gTWF0cml4IG9mIHBhaXJ3aXNlIG91dGxpZXIgZGlzdGFuY2VzXG4gICAgICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IHNpZyAtIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgZGlzdGFuY2VzLlxuICAgICAqL1xuICAgIF9maW5kX3dlaWdodHModHJpcGxldHMsIFAsIG5icnMsIG91dGxpZXJfZGlzdGFuY2VzLCBzaWcpIHtcbiAgICAgICAgY29uc3Qgbl90cmlwbGV0cyA9IHRyaXBsZXRzLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCB3ZWlnaHRzID0gbmV3IEZsb2F0NjRBcnJheShuX3RyaXBsZXRzKTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBuX3RyaXBsZXRzOyArK3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0cmlwbGV0cy5lbnRyeSh0LCAwKTtcbiAgICAgICAgICAgIGNvbnN0IHNpbSA9IG5icnMucm93KGkpLmluZGV4T2YodHJpcGxldHMuZW50cnkodCwgMSkpO1xuICAgICAgICAgICAgY29uc3QgcF9zaW0gPSBQLmVudHJ5KGksIHNpbSk7XG4gICAgICAgICAgICBsZXQgcF9vdXQgPSBNYXRoLmV4cCgtKG91dGxpZXJfZGlzdGFuY2VzW3RdICoqIDIgLyAoc2lnW2ldICogc2lnW3RyaXBsZXRzLmVudHJ5KHQsIDIpXSkpKTtcbiAgICAgICAgICAgIGlmIChwX291dCA8IDFlLTIwKSBwX291dCA9IDFlLTIwO1xuICAgICAgICAgICAgd2VpZ2h0c1t0XSA9IHBfc2ltIC8gcF9vdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlaWdodHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2FtcGxlIHVuaWZvcm1seSByYW5vbSB0cmlwbGV0c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSBEYXRhIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbl9yYW5kb20gLSBOdW1iZXIgb2YgcmFuZG9tIHRyaXBsZXRzIHBlciBwb2ludFxuICAgICAqIEBwYXJhbSB7RmxvYXQ2NEFycmF5fSBzaWcgLSBTY2FsaW5nIGZhY3RvciBmb3IgdGhlIGRpc3RhbmNlc1xuICAgICAqL1xuICAgIF9zYW1wbGVfcmFuZG9tX3RyaXBsZXRzKFgsIG5fcmFuZG9tLCBzaWcpIHtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCByYW5kb21pemVyID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgY29uc3QgTiA9IFguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHJhbmRvbV90cmlwbGV0cyA9IG5ldyBNYXRyaXgoTiAqIG5fcmFuZG9tLCAzKTtcbiAgICAgICAgY29uc3QgcmFuZG9tX3dlaWdodHMgPSBuZXcgRmxvYXQ2NEFycmF5KE4gKiBuX3JhbmRvbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBuX2kgPSBpICogbl9yYW5kb207XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gWy4uLmxpbnNwYWNlKDAsIGkgLSAxKSwgLi4ubGluc3BhY2UoaSArIDEsIE4gLSAxKV1cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbl9yYW5kb207ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBbc2ltLCBvdXRdID0gcmFuZG9taXplci5jaG9pY2UoaW5kaWNlcywgMik7XG4gICAgICAgICAgICAgICAgbGV0IHBfc2ltID0gTWF0aC5leHAoLSgobWV0cmljKFgucm93KGkpLCBYLnJvdyhzaW0pKSAqKiAyKSAvIChzaWdbaV0gKiBzaWdbc2ltXSkpKTtcbiAgICAgICAgICAgICAgICBpZiAocF9zaW0gPCAxZS0yMCkgcF9zaW0gPSAxZS0yMDtcbiAgICAgICAgICAgICAgICBsZXQgcF9vdXQgPSBNYXRoLmV4cCgtKChtZXRyaWMoWC5yb3coaSksIFgucm93KG91dCkpICoqIDIpIC8gKHNpZ1tpXSAqIHNpZ1tvdXRdKSkpOyBcbiAgICAgICAgICAgICAgICBpZiAocF9vdXQgPCAxZS0yMCkgcF9vdXQgPSAxZS0yMDtcblxuICAgICAgICAgICAgICAgIGlmIChwX3NpbSA8IHBfb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIFtzaW0sIG91dF0gPSBbb3V0LCBzaW1dO1xuICAgICAgICAgICAgICAgICAgICBbcF9zaW0sIHBfb3V0XSA9IFtwX291dCwgcF9zaW1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG5faSArIGo7XG4gICAgICAgICAgICAgICAgcmFuZG9tX3RyaXBsZXRzLnNldF9lbnRyeShpbmRleCwgMCwgaSk7XG4gICAgICAgICAgICAgICAgcmFuZG9tX3RyaXBsZXRzLnNldF9lbnRyeShpbmRleCwgMSwgc2ltKTtcbiAgICAgICAgICAgICAgICByYW5kb21fdHJpcGxldHMuc2V0X2VudHJ5KGluZGV4LCAyLCBvdXQpO1xuICAgICAgICAgICAgICAgIHJhbmRvbV93ZWlnaHRzW2luZGV4XSA9IHBfc2ltIC8gcF9vdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwicmFuZG9tX3RyaXBsZXRzXCI6IHJhbmRvbV90cmlwbGV0cyxcbiAgICAgICAgICAgIFwicmFuZG9tX3dlaWdodHNcIjogcmFuZG9tX3dlaWdodHMsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgZ3JhZGllbnQgZm9yIHVwZGF0aW5nIHRoZSBlbWJlZGRpbmcuXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFkgLSBUaGUgZW1iZWRkaW5nXG4gICAgICovXG4gICAgX2dyYWQoWSkge1xuICAgICAgICBjb25zdCBuX2lubGllcnMgPSB0aGlzLm5faW5saWVycztcbiAgICAgICAgY29uc3Qgbl9vdXRsaWVycyA9IHRoaXMubl9vdXRsaWVycztcbiAgICAgICAgY29uc3QgdHJpcGxldHMgPSB0aGlzLnRyaXBsZXRzO1xuICAgICAgICBjb25zdCB3ZWlnaHRzID0gdGhpcy53ZWlnaHRzO1xuICAgICAgICBjb25zdCBbTiwgZGltXSA9IFkuc2hhcGU7XG4gICAgICAgIGNvbnN0IG5fdHJpcGxldHMgPSB0cmlwbGV0cy5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgZ3JhZCA9IG5ldyBNYXRyaXgoTiwgZGltLCAwKTtcbiAgICAgICAgbGV0IHlfaWogPSBuZXcgQXJyYXkoZGltKS5maWxsKDApO1xuICAgICAgICBsZXQgeV9payA9IG5ldyBBcnJheShkaW0pLmZpbGwoMCk7XG4gICAgICAgIGxldCBkX2lqID0gMTtcbiAgICAgICAgbGV0IGRfaWsgPSAxO1xuICAgICAgICBsZXQgbl92aW9sID0gMDtcbiAgICAgICAgbGV0IGxvc3MgPSAwO1xuICAgICAgICBjb25zdCBuX2tubl90cmlwbGV0cyA9IE4gKiBuX2lubGllcnMgKiBuX291dGxpZXJzO1xuXG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgbl90cmlwbGV0czsgKyt0KSB7XG4gICAgICAgICAgICBjb25zdCBbaSwgaiwga10gPSB0cmlwbGV0cy5yb3codCk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgeV9paiwgeV9paywgZF9paiwgZF9pa1xuICAgICAgICAgICAgaWYgKHQgJSBuX291dGxpZXJzID09IDAgfHwgdCA+PSBuX2tubl90cmlwbGV0cykge1xuICAgICAgICAgICAgICAgIGRfaWogPSAxXG4gICAgICAgICAgICAgICAgZF9payA9IDFcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFlfaWQgPSBZLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBZX2pkID0gWS5lbnRyeShqLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWV9rZCA9IFkuZW50cnkoaywgZCk7XG4gICAgICAgICAgICAgICAgICAgIHlfaWpbZF0gPSBZX2lkIC0gWV9qZDtcbiAgICAgICAgICAgICAgICAgICAgeV9pa1tkXSA9IFlfaWQgLSBZX2tkO1xuICAgICAgICAgICAgICAgICAgICBkX2lqICs9ICh5X2lqW2RdICoqIDIpO1xuICAgICAgICAgICAgICAgICAgICBkX2lrICs9ICh5X2lrW2RdICoqIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB5X2lrIGFuZCBkX2lrIG9ubHlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZF9payA9IDE7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBZX2lkID0gWS5lbnRyeShpLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWV9rZCA9IFkuZW50cnkoaywgZCk7XG4gICAgICAgICAgICAgICAgICAgIHlfaWtbZF0gPSBZX2lkIC0gWV9rZDtcbiAgICAgICAgICAgICAgICAgICAgZF9payArPSAoeV9pa1tkXSAqKiAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkX2lqID4gZF9paykgKytuX3Zpb2w7XG4gICAgICAgICAgICBsb3NzICs9IHdlaWdodHNbdF0gLyAoMSArIGRfaWsgLyBkX2lqKTtcbiAgICAgICAgICAgIGNvbnN0IHcgPSAod2VpZ2h0c1t0XSAvIChkX2lqICsgZF9paykpICoqIDI7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3MgPSB5X2lqW2RdICogZF9payAqIHc7XG4gICAgICAgICAgICAgICAgY29uc3QgZ28gPSB5X2lrW2RdICogZF9paiAqIHc7XG4gICAgICAgICAgICAgICAgZ3JhZC5zZXRfZW50cnkoaSwgZCwgZ3JhZC5lbnRyeShpLCBkKSArIGdzIC0gZ28pO1xuICAgICAgICAgICAgICAgIGdyYWQuc2V0X2VudHJ5KGosIGQsIGdyYWQuZW50cnkoaiwgZCkgLSBncyk7XG4gICAgICAgICAgICAgICAgZ3JhZC5zZXRfZW50cnkoaywgZCwgZ3JhZC5lbnRyeShrLCBkKSArIGdvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJncmFkXCI6IGdyYWQsXG4gICAgICAgICAgICBcImxvc3NcIjogbG9zcyxcbiAgICAgICAgICAgIFwibl92aW9sXCI6IG5fdmlvbCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4X2l0ZXJhdGlvbiBcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0obWF4X2l0ZXJhdGlvbiA9IDQwMCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaXRlciA9IDA7IGl0ZXIgPCBtYXhfaXRlcmF0aW9uOyArK2l0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQoaXRlcilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB5aWVsZHMge01hdHJpeH1cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgICogZ2VuZXJhdG9yKCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaXRlciA9IDA7IGl0ZXIgPCA4MDA7ICsraXRlcikge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChpdGVyKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucHJvamVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIGl0ZXJhdGlvbiBzdGVwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZXIgXG4gICAgICovXG4gICAgX25leHQoaXRlcikge1xuICAgICAgICBjb25zdCBnYW1tYSA9IGl0ZXIgPiAxNTAgPyAuNSA6IC4zO1xuICAgICAgICBjb25zdCBvbGRfQyA9IHRoaXMuQztcbiAgICAgICAgY29uc3QgdmVsID0gdGhpcy52ZWw7XG4gICAgICAgIGNvbnN0IFkgPSB0aGlzLlkuYWRkKHZlbC5tdWx0KGdhbW1hKSk7XG4gICAgICAgIGNvbnN0IHtncmFkLCBsb3NzLCBuX3Zpb2x9ID0gdGhpcy5fZ3JhZChZKTtcbiAgICAgICAgdGhpcy5DID0gbG9zcztcbiAgICAgICAgdGhpcy5ZID0gdGhpcy5fdXBkYXRlX2VtYmVkZGluZyhZLCBpdGVyLCBncmFkKTtcbiAgICAgICAgdGhpcy5sciAqPSAob2xkX0MgPiBsb3NzICsgdGhpcy50b2wpICA/IDEuMDEgOiAuOTtcbiAgICAgICAgcmV0dXJuIHRoaXMuWTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBlbWJlZGRpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaXRlciBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gZ3JhZCBcbiAgICAgKi9cbiAgICBfdXBkYXRlX2VtYmVkZGluZyhZLCBpdGVyLCBncmFkKSB7XG4gICAgICAgIGNvbnN0IFtOLCBkaW1dID0gWS5zaGFwZTtcbiAgICAgICAgY29uc3QgZ2FtbWEgPSBpdGVyID4gMTUwID8gLjkgOiAuNTsgLy8gbW9tZW50IHBhcmFtZXRlclxuICAgICAgICBjb25zdCBtaW5fZ2FpbiA9IC4wMTtcbiAgICAgICAgY29uc3QgZ2FpbiA9IHRoaXMuZ2FpbjtcbiAgICAgICAgY29uc3QgdmVsID0gdGhpcy52ZWw7XG4gICAgICAgIGNvbnN0IGxyID0gdGhpcy5scjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdfZ2FpbiA9IChNYXRoLnNpZ24odmVsLmVudHJ5KGksIGQpKSAhPSBNYXRoLnNpZ24oZ3JhZC5lbnRyeShpLCBkKSkpID8gZ2Fpbi5lbnRyeShpLCBkKSArIC4yIDogTWF0aC5tYXgoZ2Fpbi5lbnRyeShpLCBkKSAqIC44LCBtaW5fZ2Fpbik7XG4gICAgICAgICAgICAgICAgZ2Fpbi5zZXRfZW50cnkoaSwgZCwgbmV3X2dhaW4pO1xuICAgICAgICAgICAgICAgIHZlbC5zZXRfZW50cnkoaSwgZCwgZ2FtbWEgKiB2ZWwuZW50cnkoaSwgZCkgLSBsciAqIGdhaW4uZW50cnkoaSwgZCkgKiBncmFkLmVudHJ5KGksIGQpKTtcbiAgICAgICAgICAgICAgICBZLnNldF9lbnRyeShpLCBkLCBZLmVudHJ5KGksIGQpICsgdmVsLmVudHJ5KGksIGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWTtcbiAgICB9XG59IiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSGllcmFyY2hpY2FsX0NsdXN0ZXJpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIEhpZXJhcmNoaWNhbF9DbHVzdGVyaW5nIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNsdXN0ZXJpbmdcbiAgICAgKiBAYWxpYXMgSGllcmFyY2hpY2FsX0NsdXN0ZXJpbmdcbiAgICAgKiBAdG9kbyBuZWVkcyByZXN0cnVjdHVyaW5nLlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSAtIERhdGEgb3IgZGlzdGFuY2UgbWF0cml4IGlmIG1ldHJpYyBpcyAncHJlY29tcHV0ZWQnXG4gICAgICogQHBhcmFtIHsoXCJzaW5nbGVcInxcImNvbXBsZXRlXCJ8XCJhdmVyYWdlXCIpfSBbbGlua2FnZSA9IFwiY29tcGxldGVcIl1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFwicHJlY29tcHV0ZWRcIn0gW21ldHJpYyA9IGV1Y2xpZGVhbl1cbiAgICAgKiBAcmV0dXJucyB7SGllcmFyY2hpY2FsX0NsdXN0ZXJpbmd9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF0cml4LCBsaW5rYWdlID0gXCJjb21wbGV0ZVwiLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICAgICAgdGhpcy5faWQgPSAwO1xuICAgICAgICB0aGlzLl9tYXRyaXggPSBtYXRyaXggaW5zdGFuY2VvZiBNYXRyaXggPyBtYXRyaXggOiBNYXRyaXguZnJvbShtYXRyaXgpO1xuICAgICAgICB0aGlzLl9tZXRyaWMgPSBtZXRyaWM7XG4gICAgICAgIHRoaXMuX2xpbmthZ2UgPSBsaW5rYWdlO1xuICAgICAgICBpZiAobWV0cmljID09PSBcInByZWNvbXB1dGVkXCIgJiYgdGhpcy5fbWF0cml4LnNoYXBlWzBdICE9PSB0aGlzLl9tYXRyaXguc2hhcGVbMV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklmIG1ldHJpYyBpcyAncHJlY29tcHV0ZWQnLCB0aGVuIG1hdHJpeCBoYXMgdG8gYmUgc3F1YXJlIVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5kbygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHdoZXJlIHRvIGN1dCB0aGUgdHJlZS5cbiAgICAgKiBAcGFyYW0geyhcImRpc3RhbmNlXCJ8XCJkZXB0aFwiKX0gW3R5cGUgPSBcImRpc3RhbmNlXCJdIC0gdHlwZSBvZiB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fSAtIEFycmF5IG9mIGNsdXN0ZXJzIHdpdGggdGhlIGluZGljZXMgb2YgdGhlIHJvd3MgaW4gZ2l2ZW4ge0BsaW5rIG1hdHJpeH0uXG4gICAgICovXG4gICAgZ2V0X2NsdXN0ZXJzKHZhbHVlLCB0eXBlID0gXCJkaXN0YW5jZVwiKSB7XG4gICAgICAgIGxldCBjbHVzdGVycyA9IFtdO1xuICAgICAgICBsZXQgYWNjZXNzb3I7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRpc3RhbmNlXCI6XG4gICAgICAgICAgICAgICAgYWNjZXNzb3IgPSAoZCkgPT4gZC5kaXN0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlcHRoXCI6XG4gICAgICAgICAgICAgICAgYWNjZXNzb3IgPSAoZCkgPT4gZC5kZXB0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYXZlcnNlKHRoaXMucm9vdCwgYWNjZXNzb3IsIHZhbHVlLCBjbHVzdGVycyk7XG4gICAgICAgIHJldHVybiBjbHVzdGVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSBub2RlXG4gICAgICogQHBhcmFtIHsqfSBmXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gcmVzdWx0XG4gICAgICovXG4gICAgX3RyYXZlcnNlKG5vZGUsIGYsIHZhbHVlLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKGYobm9kZSkgPD0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUubGVhdmVzKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJhdmVyc2Uobm9kZS5sZWZ0LCBmLCB2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuX3RyYXZlcnNlKG5vZGUucmlnaHQsIGYsIHZhbHVlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZXMgdGhlIHRyZWUuXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fbWF0cml4O1xuICAgICAgICBjb25zdCBuID0gKHRoaXMuX24gPSBBLnNoYXBlWzBdKTtcbiAgICAgICAgY29uc3QgZF9taW4gPSAodGhpcy5fZF9taW4gPSBuZXcgRmxvYXQ2NEFycmF5KG4pKTtcbiAgICAgICAgbGV0IGRpc3RhbmNlX21hdHJpeDtcbiAgICAgICAgaWYgKG1ldHJpYyAhPT0gXCJwcmVjb21wdXRlZFwiKSB7XG4gICAgICAgICAgICBkaXN0YW5jZV9tYXRyaXggPSBuZXcgTWF0cml4KG4sIG4sIDApOyAvL25ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZF9taW5baV0gPSAwO1xuICAgICAgICAgICAgICAgIC8vZGlzdGFuY2VfbWF0cml4W2ldID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZV9tYXRyaXguc2V0X2VudHJ5KGksIGosIGkgPT09IGogPyBJbmZpbml0eSA6IG1ldHJpYyhBLnJvdyhpKSwgQS5yb3coaikpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlX21hdHJpeC5lbnRyeShpLCBkX21pbltpXSkgPiBkaXN0YW5jZV9tYXRyaXguZW50cnkoaSwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRfbWluW2ldID0gajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3RhbmNlX21hdHJpeCA9IHRoaXMuX21hdHJpeC5jbG9uZSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VfbWF0cml4LnNldF9lbnRyeShpLCBqLCBJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2VfbWF0cml4LmVudHJ5KGksIGRfbWluW2ldKSA+IGRpc3RhbmNlX21hdHJpeC5lbnRyeShpLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZF9taW5baV0gPSBqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlX21hdHJpeCA9IGRpc3RhbmNlX21hdHJpeDtcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSAodGhpcy5fY2x1c3RlcnMgPSBuZXcgQXJyYXkobikpO1xuICAgICAgICBjb25zdCBjX3NpemUgPSAodGhpcy5fY19zaXplID0gbmV3IFVpbnQxNkFycmF5KG4pKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzW2ldID0gW107XG4gICAgICAgICAgICBjbHVzdGVyc1tpXVswXSA9IG5ldyBDbHVzdGVyKHRoaXMuX2lkKyssIG51bGwsIG51bGwsIDAsIEEucm93KGkpLCBpLCAxLCAwKTtcbiAgICAgICAgICAgIGNfc2l6ZVtpXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZXMgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZG8oKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9uO1xuICAgICAgICBjb25zdCBkX21pbiA9IHRoaXMuX2RfbWluO1xuICAgICAgICBjb25zdCBEID0gdGhpcy5fZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9IHRoaXMuX2NsdXN0ZXJzO1xuICAgICAgICBjb25zdCBjX3NpemUgPSB0aGlzLl9jX3NpemU7XG4gICAgICAgIGNvbnN0IGxpbmthZ2UgPSB0aGlzLl9saW5rYWdlO1xuICAgICAgICBsZXQgcm9vdCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IHAgPSAwLCBwX21heCA9IG4gLSAxOyBwIDwgcF9tYXg7ICsrcCkge1xuICAgICAgICAgICAgbGV0IGMxID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IERfaV9taW4gPSBELmVudHJ5KGksIGRfbWluW2ldKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKERfaV9taW4gPiBELmVudHJ5KGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkX21pbltpXSA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICBEX2lfbWluID0gRC5lbnRyeShpLCBkX21pbltpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChELmVudHJ5KGksIGRfbWluW2ldKSA8IEQuZW50cnkoYzEsIGRfbWluW2MxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYzEgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjMiA9IGRfbWluW2MxXTtcbiAgICAgICAgICAgIGxldCBjMV9jbHVzdGVyID0gY2x1c3RlcnNbYzFdWzBdO1xuICAgICAgICAgICAgbGV0IGMyX2NsdXN0ZXIgPSBjbHVzdGVyc1tjMl1bMF07XG4gICAgICAgICAgICBsZXQgYzFfY2x1c3Rlcl9pbmRpY2VzID0gYzFfY2x1c3Rlci5pc0xlYWYgPyBbYzFfY2x1c3Rlci5pbmRleF0gOiBjMV9jbHVzdGVyLmluZGV4O1xuICAgICAgICAgICAgbGV0IGMyX2NsdXN0ZXJfaW5kaWNlcyA9IGMyX2NsdXN0ZXIuaXNMZWFmID8gW2MyX2NsdXN0ZXIuaW5kZXhdIDogYzJfY2x1c3Rlci5pbmRleDtcbiAgICAgICAgICAgIGxldCBpbmRpY2VzID0gYzFfY2x1c3Rlcl9pbmRpY2VzLmNvbmNhdChjMl9jbHVzdGVyX2luZGljZXMpO1xuICAgICAgICAgICAgbGV0IG5ld19jbHVzdGVyID0gbmV3IENsdXN0ZXIodGhpcy5faWQrKywgYzFfY2x1c3RlciwgYzJfY2x1c3RlciwgRC5lbnRyeShjMSwgYzIpLCBudWxsLCBpbmRpY2VzKTtcbiAgICAgICAgICAgIGMxX2NsdXN0ZXIucGFyZW50ID0gbmV3X2NsdXN0ZXI7XG4gICAgICAgICAgICBjMl9jbHVzdGVyLnBhcmVudCA9IG5ld19jbHVzdGVyO1xuICAgICAgICAgICAgY2x1c3RlcnNbYzFdLnVuc2hpZnQobmV3X2NsdXN0ZXIpO1xuICAgICAgICAgICAgY19zaXplW2MxXSArPSBjX3NpemVbYzJdO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCBEX2MxX2ogPSBELmVudHJ5KGMxLCBqKTtcbiAgICAgICAgICAgICAgICBjb25zdCBEX2MyX2ogPSBELmVudHJ5KGMyLCBqKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChsaW5rYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzaW5nbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5taW4oRF9jMV9qLCBEX2MyX2opO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb21wbGV0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heChEX2MxX2osIERfYzJfaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImF2ZXJhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gKGNfc2l6ZVtjMV0gKiBEX2MxX2ogKyBjX3NpemVbYzJdICogRF9jMl9qKSAvIChjX3NpemVbYzFdICsgY19zaXplW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBELnNldF9lbnRyeShqLCBjMSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIEQuc2V0X2VudHJ5KGMxLCBqLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEQuc2V0X2VudHJ5KGMxLCBjMSwgSW5maW5pdHkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBELnNldF9lbnRyeShpLCBjMiwgSW5maW5pdHkpO1xuICAgICAgICAgICAgICAgIEQuc2V0X2VudHJ5KGMyLCBpLCBJbmZpbml0eSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRfbWluW2pdID09PSBjMikge1xuICAgICAgICAgICAgICAgICAgICBkX21pbltqXSA9IGMxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoRC5lbnRyeShjMSwgaikgPCBELmVudHJ5KGMxLCBkX21pbltjMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRfbWluW2MxXSA9IGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAqL1xuICAgICAgICAgICAgcm9vdCA9IG5ld19jbHVzdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbn1cblxuY2xhc3MgQ2x1c3RlciB7XG4gICAgY29uc3RydWN0b3IoaWQsIGxlZnQsIHJpZ2h0LCBkaXN0LCBjZW50cm9pZCwgaW5kZXgsIHNpemUsIGRlcHRoKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLmRpc3QgPSBkaXN0O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemUgPz8gbGVmdC5zaXplICsgcmlnaHQuc2l6ZTtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoID8/IDEgKyBNYXRoLm1heChsZWZ0LmRlcHRoLCByaWdodC5kZXB0aCk7XG4gICAgICAgIHRoaXMuY2VudHJvaWQgPSBjZW50cm9pZCA/PyB0aGlzLl9jYWxjdWxhdGVfY2VudHJvaWQobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9jYWxjdWxhdGVfY2VudHJvaWQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgY29uc3QgbF9zaXplID0gbGVmdC5zaXplO1xuICAgICAgICBjb25zdCByX3NpemUgPSByaWdodC5zaXplO1xuICAgICAgICBjb25zdCBsX2NlbnRyb2lkID0gbGVmdC5jZW50cm9pZDtcbiAgICAgICAgY29uc3Qgcl9jZW50cm9pZCA9IHJpZ2h0LmNlbnRyb2lkO1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICBjb25zdCBuID0gbGVmdC5jZW50cm9pZC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld19jZW50cm9pZCA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBuZXdfY2VudHJvaWRbaV0gPSAobF9zaXplICogbF9jZW50cm9pZFtpXSArIHJfc2l6ZSAqIHJfY2VudHJvaWRbaV0pIC8gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3X2NlbnRyb2lkO1xuICAgIH1cblxuICAgIGdldCBpc0xlYWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHRoID09PSAwO1xuICAgIH1cblxuICAgIGxlYXZlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMZWFmKSByZXR1cm4gW3RoaXNdO1xuICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIHJldHVybiAobGVmdC5pc0xlYWYgPyBbbGVmdF0gOiBsZWZ0LmxlYXZlcygpKS5jb25jYXQocmlnaHQuaXNMZWFmID8gW3JpZ2h0XSA6IHJpZ2h0LmxlYXZlcygpKTtcbiAgICB9XG5cbiAgICBkZXNjZW5kYW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMZWFmKSByZXR1cm4gW3RoaXNdO1xuICAgICAgICBjb25zdCBsZWZ0X2Rlc2NlbmRhbnRzID0gdGhpcy5sZWZ0LmRlc2NlbmRhbnRzKCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0X2Rlc2NlbmRhbnRzID0gdGhpcy5yaWdodC5kZXNjZW5kYW50cygpO1xuICAgICAgICByZXR1cm4gbGVmdF9kZXNjZW5kYW50cy5jb25jYXQocmlnaHRfZGVzY2VuZGFudHMpLmNvbmNhdChbdGhpc10pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBSYW5kb21pemVyIH0gZnJvbSBcIi4uL3V0aWwvaW5kZXguanNcIjtcbmltcG9ydCB7IEhlYXAgfSBmcm9tIFwiLi4vZGF0YXN0cnVjdHVyZS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbGluc3BhY2UgfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgS01lYW5zXG4gKi9cbmV4cG9ydCBjbGFzcyBLTWVhbnMge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y2x1c3RlcmluZ1xuICAgICAqIEBhbGlhcyBLTWVhbnNcbiAgICAgKiBAdG9kbyBuZWVkcyByZXN0cnVjdHVyaW5nLiBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4IFxuICAgICAqIEBwYXJhbSB7TnVtYmVyc30gSyBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxOTg3XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2luaXQgPSB0cnVlXVxuICAgICAqIEByZXR1cm5zIHtLTWVhbnN9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF0cml4LCBLLCBtZXRyaWMgPSBldWNsaWRlYW4sIHNlZWQ9MTk4NywgaW5pdCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5fbWV0cmljID0gbWV0cmljO1xuICAgICAgICB0aGlzLl9tYXRyaXggPSBtYXRyaXg7XG4gICAgICAgIHRoaXMuX0sgPSBLO1xuICAgICAgICBjb25zdCBbTiwgRF0gPSBtYXRyaXguc2hhcGU7XG4gICAgICAgIHRoaXMuX04gPSBOO1xuICAgICAgICB0aGlzLl9EID0gRDtcbiAgICAgICAgaWYgKEsgPiBOKSBLID0gTjtcbiAgICAgICAgdGhpcy5fcmFuZG9taXplciA9IG5ldyBSYW5kb21pemVyKHNlZWQpO1xuICAgICAgICB0aGlzLl9jbHVzdGVycyA9IG5ldyBBcnJheShOKS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJfY2VudHJvaWRzID0gdGhpcy5fZ2V0X3JhbmRvbV9jZW50cm9pZHMoSyk7XG4gICAgICAgIGlmIChpbml0KSB0aGlzLmluaXQoSywgdGhpcy5fY2x1c3Rlcl9jZW50cm9pZHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fSAtIEFycmF5IG9mIGNsdXN0ZXJzIHdpdGggdGhlIGluZGljZXMgb2YgdGhlIHJvd3MgaW4gZ2l2ZW4ge0BsaW5rIG1hdHJpeH0uIFxuICAgICAqL1xuICAgIGdldF9jbHVzdGVycygpIHtcbiAgICAgICAgY29uc3QgSyA9IHRoaXMuX0s7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gdGhpcy5fY2x1c3RlcnM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShLKS5maWxsKCkubWFwKCgpID0+IG5ldyBBcnJheSgpKTtcbiAgICAgICAgY2x1c3RlcnMuZm9yRWFjaCgoYywgaSkgPT4gcmVzdWx0W2NdLnB1c2goaSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNhbmRpZGF0ZXMgXG4gICAgICovXG4gICAgX2Z1cnRoZXN0X3BvaW50KHBvaW50cywgY2FuZGlkYXRlcykge1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fbWF0cml4O1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGxldCBpID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgbGV0IEggPSBIZWFwLmhlYXBpZnkoXG4gICAgICAgICAgICBjYW5kaWRhdGVzLCBcbiAgICAgICAgICAgIChkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgQWQgPSBBLnJvdyhkKVxuICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBtZXRyaWMoQWQsIHBvaW50c1tqXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgXCJtYXhcIlxuICAgICAgICApXG4gICAgICAgIHJldHVybiBILnBvcCgpLmVsZW1lbnQ7XG4gICAgfVxuXG4gICAgX2dldF9yYW5kb21fY2VudHJvaWRzKEspIHtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IHJhbmRvbWl6ZXIgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fbWF0cml4O1xuICAgICAgICBjb25zdCBjbHVzdGVyX2NlbnRyb2lkcyA9IG5ldyBBcnJheShLKS5maWxsKClcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IGxpbnNwYWNlKDAsIE4gLSAxKTtcbiAgICAgICAgY29uc3QgcmFuZG9tX3BvaW50ID0gcmFuZG9taXplci5yYW5kb21faW50ICUgKE4gLSAxKTtcbiAgICAgICAgY2x1c3Rlcl9jZW50cm9pZHNbMF0gPSBBLnJvdyhyYW5kb21fcG9pbnQpO1xuICAgICAgICBjb25zdCBpbml0X3BvaW50cyA9IFtyYW5kb21fcG9pbnRdO1xuICAgICAgICBjb25zdCBzYW1wbGVfc2l6ZSA9IE1hdGguZmxvb3IoKE4gLSBLKSAvIEspOy8vIC8gS1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEs7ICsraSkge1xuICAgICAgICAgICAgLy8gc2FtcGxpbmcgKyBrbWVhbnMrKyBpbXByb3ZlbWVudD9cbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZSA9IHJhbmRvbWl6ZXIuY2hvaWNlKGluZGljZXMuZmlsdGVyKGQgPT4gaW5pdF9wb2ludHMuaW5kZXhPZihkKSA9PSAtMSksIHNhbXBsZV9zaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGZ1cnRoZXN0X3BvaW50ID0gdGhpcy5fZnVydGhlc3RfcG9pbnQoY2x1c3Rlcl9jZW50cm9pZHMuc2xpY2UoMCwgaSksIHNhbXBsZSk7XG4gICAgICAgICAgICBpbml0X3BvaW50cy5wdXNoKGZ1cnRoZXN0X3BvaW50KTtcbiAgICAgICAgICAgIGNsdXN0ZXJfY2VudHJvaWRzW2ldID0gQS5yb3coZnVydGhlc3RfcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbHVzdGVyX2NlbnRyb2lkcztcbiAgICB9XG5cbiAgICBfaXRlcmF0aW9uKGNsdXN0ZXJfY2VudHJvaWRzKSB7XG4gICAgICAgIGNvbnN0IEsgPSBjbHVzdGVyX2NlbnRyb2lkcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBEID0gdGhpcy5fRDtcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX21hdHJpeDtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9IHRoaXMuX2NsdXN0ZXJzO1xuICAgICAgICBsZXQgY2x1c3RlcnNfY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAvLyBmaW5kIG5lYXJlc3QgY2x1c3RlciBjZW50cm9pZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IEFpID0gQS5yb3coaSlcbiAgICAgICAgICAgIGxldCBtaW5fZGlzdCA9IEluZmluaXR5O1xuICAgICAgICAgICAgbGV0IG1pbl9jbHVzdGVyID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgSzsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IGQgPSBtZXRyaWMoY2x1c3Rlcl9jZW50cm9pZHNbal0sIEFpKTtcbiAgICAgICAgICAgICAgICBpZiAoZCA8IG1pbl9kaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbl9kaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgbWluX2NsdXN0ZXIgPSBqOyBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2x1c3RlcnNbaV0gIT09IG1pbl9jbHVzdGVyKSB7XG4gICAgICAgICAgICAgICAgY2x1c3RlcnNfY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbHVzdGVyc1tpXSA9IG1pbl9jbHVzdGVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBjbHVzdGVyIGNlbnRyb2lkXG4gICAgICAgIC8vIHJlc2V0IGNsdXN0ZXIgY2VudHJvaWRzIHRvIDBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBLOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRyb2lkID0gY2x1c3Rlcl9jZW50cm9pZHNbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IEQ7ICsraikge1xuICAgICAgICAgICAgICAgIGNlbnRyb2lkW2pdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wdXRlIGNlbnRyb2lkXG4gICAgICAgIHRoaXMuX2NvbXB1dGVfY2VudHJvaWQoY2x1c3Rlcl9jZW50cm9pZHMpO1xuXG4gICAgICAgIHJldHVybiB7ICAgXG4gICAgICAgICAgICBcImNsdXN0ZXJzX2NoYW5nZWRcIjogY2x1c3RlcnNfY2hhbmdlZCxcbiAgICAgICAgICAgIFwiY2x1c3Rlcl9jZW50cm9pZHNcIjogY2x1c3Rlcl9jZW50cm9pZHNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfY29tcHV0ZV9jZW50cm9pZChjbHVzdGVyX2NlbnRyb2lkcykge1xuICAgICAgICBjb25zdCBLID0gY2x1c3Rlcl9jZW50cm9pZHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgRCA9IHRoaXMuX0Q7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9tYXRyaXg7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gdGhpcy5fY2x1c3RlcnM7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJfY291bnRlciA9IG5ldyBBcnJheShLKS5maWxsKDApO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBBaSA9IEEucm93KGkpO1xuICAgICAgICAgICAgY29uc3QgY2kgPSBjbHVzdGVyc1tpXTtcbiAgICAgICAgICAgIGNsdXN0ZXJfY291bnRlcltjaV0rKztcbiAgICAgICAgICAgIGNvbnN0IGNlbnRyb2lkID0gY2x1c3Rlcl9jZW50cm9pZHNbY2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBEOyArK2opIHtcbiAgICAgICAgICAgICAgICBjZW50cm9pZFtqXSArPSBBaVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEs7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IGNsdXN0ZXJfY291bnRlcltpXTtcbiAgICAgICAgICAgIGNsdXN0ZXJfY2VudHJvaWRzW2ldID0gY2x1c3Rlcl9jZW50cm9pZHNbaV0ubWFwKGMgPT4gYyAvIG4pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHtAbGluayBLfSBjbHVzdGVycyBvdXQgb2YgdGhlIHtAbGluayBtYXRyaXh9LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBLIC0gbnVtYmVyIG9mIGNsdXN0ZXJzLlxuICAgICAqL1xuICAgIGluaXQoSywgY2x1c3Rlcl9jZW50cm9pZHMpIHtcbiAgICAgICAgaWYgKCFLKSBLID0gdGhpcy5fSztcbiAgICAgICAgaWYgKCFjbHVzdGVyX2NlbnRyb2lkcykgY2x1c3Rlcl9jZW50cm9pZHMgPSB0aGlzLl9nZXRfcmFuZG9tX2NlbnRyb2lkcyhLKTtcbiAgICAgICAgbGV0IGNsdXN0ZXJzX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0aW9uX3Jlc3VsdCA9IHRoaXMuX2l0ZXJhdGlvbihjbHVzdGVyX2NlbnRyb2lkcylcbiAgICAgICAgICAgIGNsdXN0ZXJfY2VudHJvaWRzID0gaXRlcmF0aW9uX3Jlc3VsdC5jbHVzdGVyX2NlbnRyb2lkcztcbiAgICAgICAgICAgIGNsdXN0ZXJzX2NoYW5nZWQgPSBpdGVyYXRpb25fcmVzdWx0LmNsdXN0ZXJzX2NoYW5nZWQ7XG4gICAgICAgIH0gd2hpbGUgKGNsdXN0ZXJzX2NoYW5nZWQpXG4gICAgfVxuICAgIFxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFJhbmRvbWl6ZXIgfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbGluc3BhY2UsIE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IG1pbiB9IGZyb20gXCIuLi91dGlsL2luZGV4LmpzXCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEtNZWRvaWRzXG4gKi9cbmV4cG9ydCBjbGFzcyBLTWVkb2lkcyB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjbHVzdGVyaW5nXG4gICAgICogQGFsaWFzIEtNZWRvaWRzXG4gICAgICogQHRvZG8gbmVlZHMgcmVzdHJ1Y3R1cmluZy4gXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeCAtIGRhdGEgbWF0cml4XG4gICAgICogQHBhcmFtIHtOdW1iZXJzfSBLIC0gbnVtYmVyIG9mIGNsdXN0ZXJzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhfaXRlcj1udWxsXSAtIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMuIERlZmF1bHQgaXMgMTAgKiBNYXRoLmxvZzEwKE4pXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSBtZXRyaWMgZGVmaW5pbmcgdGhlIGRpc3NpbWlsYXJpdHkgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWVkID0gMTIxMl0gLSBzZWVkIHZhbHVlIGZvciByYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuICAgICAqIEByZXR1cm5zIHtLTWVkb2lkc31cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2xpbmsuc3ByaW5nZXIuY29tL2NoYXB0ZXIvMTAuMTAwNy85NzgtMy0wMzAtMzIwNDctOF8xNn0gRmFzdGVyIGstTWVkb2lkcyBDbHVzdGVyaW5nOiBJbXByb3ZpbmcgdGhlIFBBTSwgQ0xBUkEsIGFuZCBDTEFSQU5TIEFsZ29yaXRobXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIEssIG1heF9pdGVyPW51bGwsIG1ldHJpYyA9IGV1Y2xpZGVhbiwgc2VlZD0xMjEyKSB7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbWF0cml4O1xuICAgICAgICB0aGlzLl9BID0gdGhpcy5fbWF0cml4LnRvMmRBcnJheTtcbiAgICAgICAgdGhpcy5fSyA9IEs7XG4gICAgICAgIGNvbnN0IFtOLCBEXSA9IG1hdHJpeC5zaGFwZTtcbiAgICAgICAgdGhpcy5fTiA9IE47XG4gICAgICAgIHRoaXMuX0QgPSBEO1xuICAgICAgICB0aGlzLl9tYXhfaXRlciA9IG1heF9pdGVyIHx8IDEwICogTWF0aC5sb2cxMChOKSBcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VfbWF0cml4ID0gbmV3IE1hdHJpeChOLCBOLCBcInplcm9zXCIpO1xuICAgICAgICAvKiBmb3IgKGxldCBpID0gMTsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3QgPSBtZXRyaWModGhpcy5fQVtpXSwgdGhpcy5fQVtqXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VfbWF0cml4LnNldF9lbnRyeShpLCBqLCBkaXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZV9tYXRyaXguc2V0X2VudHJ5KGosIGksIGRpc3QpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gKi9cbiAgICAgICAgaWYgKEsgPiBOKSBLID0gTjtcbiAgICAgICAgdGhpcy5fcmFuZG9taXplciA9IG5ldyBSYW5kb21pemVyKHNlZWQpO1xuICAgICAgICB0aGlzLl9jbHVzdGVycyA9IG5ldyBBcnJheShOKS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJfbWVkb2lkcyA9IHRoaXMuX2dldF9yYW5kb21fbWVkb2lkcyhLKTtcbiAgICAgICAgLy9pZiAoaW5pdCkgdGhpcy5pbml0KEssIHRoaXMuX2NsdXN0ZXJfbWVkb2lkcyk7XG4gICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IC0gQXJyYXkgb2YgY2x1c3RlcnMgd2l0aCB0aGUgaW5kaWNlcyBvZiB0aGUgcm93cyBpbiBnaXZlbiB7QGxpbmsgbWF0cml4fS4gXG4gICAgICovXG4gICAgZ2V0X2NsdXN0ZXJzKCkge1xuICAgICAgICBjb25zdCBLID0gdGhpcy5fSztcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX0E7XG4gICAgICAgIGlmICghdGhpcy5faXNfaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdChLLCB0aGlzLl9jbHVzdGVyX21lZG9pZHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShLKS5maWxsKCkubWFwKCgpID0+IG5ldyBBcnJheSgpKTtcbiAgICAgICAgQS5mb3JFYWNoKCh4X2osIGopID0+IHtcbiAgICAgICAgICAgIHJlc3VsdFt0aGlzLl9uZWFyZXN0X21lZG9pZCh4X2osIGopLmluZGV4X25lYXJlc3RdLnB1c2goaik7XG4gICAgICAgIH0pXG4gICAgICAgIHJlc3VsdC5tZWRvaWRzID0gdGhpcy5fY2x1c3Rlcl9tZWRvaWRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IG1heF9pdGVyID0gdGhpcy5fbWF4X2l0ZXI7XG4gICAgICAgIHlpZWxkIHRoaXMuZ2V0X2NsdXN0ZXJzKClcbiAgICAgICAgbGV0IGZpbmlzaCA9IGZhbHNlO1xuICAgICAgICBsZXQgaSA9IDBcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZmluaXNoID0gdGhpcy5faXRlcmF0aW9uKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldF9jbHVzdGVycygpO1xuICAgICAgICB9IHdoaWxlICghZmluaXNoICYmICsraSA8IG1heF9pdGVyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsZ29yaXRobSAxLiBGYXN0UEFNMTogSW1wcm92ZWQgU1dBUCBhbGdvcml0aG1cbiAgICAgKi9cbiAgICAvKiBfaXRlcmF0aW9uXzEoKSB7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9BO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgSyA9IHRoaXMuX0s7XG4gICAgICAgIGNvbnN0IG1lZG9pZHMgPSB0aGlzLl9jbHVzdGVyX21lZG9pZHM7XG4gICAgICAgIGxldCBEZWx0YVREID0gMDtcbiAgICAgICAgbGV0IG0wID0gbnVsbDtcbiAgICAgICAgbGV0IHgwID0gbnVsbDtcbiAgICAgICAgQS5mb3JFYWNoKCh4X2osIGopID0+IHtcbiAgICAgICAgICAgIGlmIChtZWRvaWRzLmZpbmRJbmRleChtID0+IG0gPT09IGopIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5lYXJlc3RfbWVkb2lkID0gdGhpcy5fbmVhcmVzdF9tZWRvaWQoeF9qLCBqKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkX2ogPSBuZWFyZXN0X21lZG9pZC5kaXN0YW5jZV9uZWFyZXN0OyAvLyBkaXN0YW5jZSB0byBjdXJyZW50IG1lZG9pZFxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhVEQgPSBuZXcgQXJyYXkoSykuZmlsbCgtZF9qKTsgLy8gY2hhbmdlIGlmIG1ha2luZyBqIGEgbWVkb2lkXG4gICAgICAgICAgICAgICAgQS5mb3JFYWNoKCh4X28sIG8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYW5jZSB0byBuZXcgbWVkb2lkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRfb2ogPSB0aGlzLl9nZXRfZGlzdGFuY2UobywgaiwgeF9vLCB4X2opO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImluZGV4X25lYXJlc3RcIjogbixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzdGFuY2VfbmVhcmVzdFwiOiBkX24sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRpc3RhbmNlX3NlY29uZFwiOiBkX3MsXG4gICAgICAgICAgICAgICAgICAgIH0gPSB0aGlzLl9uZWFyZXN0X21lZG9pZCh4X28sIG8pOyBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2x1c3RlcnNbb10gPSBuOyAvLyBjYWNoZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhVERbbl0gKz0gTWF0aC5taW4oZF9vaiwgZF9zKSAtIGRfbjsgLy8gbG9zcyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRfb2ogPCBkX24pIHsgLy8gcmVhc3NpZ25tZW50IGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVRELmZvckVhY2goKGRfaSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVERbaV0gPSBkX2kgKyBkX29qIC0gZF9uOyAvLyB1cGRhdGUgbG9zcyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGNob29zZSBiZXN0IG1lZG9pZCBpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBkZWx0YVREXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGQsIGkpID0+IFtkLCBpXSlcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGQxLCBkMikgPT4gZDFbMF0gLSBkMlswXSlbMF1bMV07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFURF9pID0gZGVsdGFURFtpXTtcbiAgICAgICAgICAgICAgICAvLyBzdG9yZVxuICAgICAgICAgICAgICAgIGlmIChkZWx0YVREX2kgPCBEZWx0YVREKSB7XG4gICAgICAgICAgICAgICAgICAgIERlbHRhVEQgPSBkZWx0YVREX2k7XG4gICAgICAgICAgICAgICAgICAgIG0wID0gaTtcbiAgICAgICAgICAgICAgICAgICAgeDAgPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKERlbHRhVEQgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWUgLy8gYnJlYWsgbG9vcCBpZiBEZWx0YVREID49IDBcbiAgICAgICAgfVxuICAgICAgICAvLyBzd2FwIHJvbGVzIG9mIG1lZG9pZCBtIGFuZCBub24tbWVkb2lkIHg7XG4gICAgICAgIG1lZG9pZHNbbTBdID0geDA7XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJfbWVkb2lkcyA9IG1lZG9pZHM7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gKi9cblxuICAgIC8qKiBBbGdvcml0aG0gMi4gRmFzdFBBTTI6IFNXQVAgd2l0aCBtdWx0aXBsZSBjYW5kaWRhdGVzXG4gICAgICogXG4gICAgICovXG4gICAgX2l0ZXJhdGlvbigpIHtcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX0E7XG4gICAgICAgIGNvbnN0IEsgPSB0aGlzLl9LO1xuICAgICAgICBjb25zdCBtZWRvaWRzID0gdGhpcy5fY2x1c3Rlcl9tZWRvaWRzO1xuICAgICAgICBjb25zdCBjYWNoZSA9IEEubWFwKCh4X28sIG8pID0+IHRoaXMuX25lYXJlc3RfbWVkb2lkKHhfbywgbykpO1xuICAgICAgICAvLyBlbXB0eSBiZXN0IGNhbmRpZGF0ZXMgYXJyYXlcbiAgICAgICAgY29uc3QgRGVsdGFURCA9IG5ldyBBcnJheShLKS5maWxsKDApO1xuICAgICAgICBjb25zdCB4cyA9IG5ldyBBcnJheShLKS5maWxsKG51bGwpO1xuICAgICAgICBBLmZvckVhY2goKHhfaiwgaikgPT4ge1xuICAgICAgICAgICAgaWYgKG1lZG9pZHMuZmluZEluZGV4KG0gPT4gbSA9PT0gaikgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZF9qID0gY2FjaGVbal0uZGlzdGFuY2VfbmVhcmVzdDsgLy8gZGlzdGFuY2UgdG8gY3VycmVudCBtZWRvaWRcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVREID0gbmV3IEFycmF5KEspLmZpbGwoLWRfaik7IC8vIGNoYW5nZSBpZiBtYWtpbmcgaiBhIG1lZG9pZFxuICAgICAgICAgICAgICAgIEEuZm9yRWFjaCgoeF9vLCBvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09PSBvKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRfb2ogPSB0aGlzLl9nZXRfZGlzdGFuY2UobywgaiwgeF9vLCB4X2opOyAvLyBkaXN0YW5jZSB0byBuZXcgbWVkb2lkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHtcImluZGV4X25lYXJlc3RcIjogbiwgXCJkaXN0YW5jZV9uZWFyZXN0XCI6IGRfbiwgXCJkaXN0YW5jZV9zZWNvbmRcIjogZF9zfSA9IGNhY2hlW29dOyAvLyBjYWNoZWRcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFURFtuXSArPSBNYXRoLm1pbihkX29qLCBkX3MpIC0gZF9uOyAvLyBsb3NzIGNoYW5nZSBmb3IgeF9vXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYXNzaWdubWVudCBjaGVja1xuICAgICAgICAgICAgICAgICAgICBpZiAoZF9vaiA8IGRfbikgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBsb3NzIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBLOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gbikgZGVsdGFURFtpXSArPSBkX29qIC0gZF9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgYmVzdCBzd2FwIGZvciBpO1xuICAgICAgICAgICAgICAgIGRlbHRhVERcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoZCwgaSkgPT4gW2QsIGldKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChbZCwgaV0pID0+IGQgPCBEZWx0YVREW2ldKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoW2QsIGldKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IERlbHRhVERbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWx0YVREW2ldID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4c1tpXSA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC8vIHN0b3AgaWYgbm8gaW1wcm92ZW1lbnRzIHdlcmUgZm91bmRcbiAgICAgICAgaWYgKG1pbihEZWx0YVREKSA+PSAwKSByZXR1cm4gdHJ1ZTsgXG5cbiAgICAgICAgLy8gZXhlY3V0ZSBhbGwgaW1wcm92ZW1lbnRzXG4gICAgICAgIHdoaWxlIChtaW4oRGVsdGFURCkgPCAwKSB7XG4gICAgICAgICAgICAvLyBzd2FwIHJvbGVzIG9mIG1lZG9pZCBtX2kgYW5kIG5vbl9tZWRvaWQgeHNfaVxuICAgICAgICAgICAgY29uc3QgaSA9IERlbHRhVERcbiAgICAgICAgICAgICAgICAubWFwKChkLCBpKSA9PiBbZCwgaV0pXG4gICAgICAgICAgICAgICAgLnNvcnQoKFthXSwgW2JdKSA9PiBhIC0gYilbMF1bMV07XG4gICAgICAgICAgICBpZiAobWVkb2lkcy5maWx0ZXIobSA9PiBtID09IHhzW2ldKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIG1lZG9pZHNbaV0gPSB4c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRpc2FibGUgdGhlIHN3YXAganVzdCBwZXJmb3JtZWRcbiAgICAgICAgICAgIERlbHRhVERbaV0gPSAwOyBcbiAgICAgICAgICAgIC8vIHJlY29tcHV0ZSBURCBmb3IgcmVtYWluaW5nIHN3YXAgY2FuZGlkYXRlc1xuICAgICAgICAgICAgRGVsdGFURFxuICAgICAgICAgICAgICAgIC5tYXAoKGRfaiwgaikgPT4gW2Rfaiwgal0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoW2Rfal0pID0+IGRfaiA8IDApXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKFtfLCBqXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4X2ogPSBBW2pdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgQS5mb3JFYWNoKCh4X28sIG8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZWRvaWRzLmZpbmRJbmRleChtID0+IG0gIT0gaiAmJiBtID09IG8pID49IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IGopIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZVtvXS5pbmRleF9uZWFyZXN0ID09PSBtZWRvaWRzW2pdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSAoTWF0aC5taW4odGhpcy5fZ2V0X2Rpc3RhbmNlKG8sIGosIHhfbywgeF9qKSwgY2FjaGVbb10uZGlzdGFuY2Vfc2Vjb25kKSAtIGNhY2hlW29dLmRpc3RhbmNlX25lYXJlc3QpOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSAoTWF0aC5taW4odGhpcy5fZ2V0X2Rpc3RhbmNlKG8sIGosIHhfbywgeF9qKSAtIGNhY2hlW29dLmRpc3RhbmNlX25lYXJlc3QsIDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIERlbHRhVERbal0gPSBzdW07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbHVzdGVyX21lZG9pZHMgPSBtZWRvaWRzO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgX2dldF9kaXN0YW5jZShpLCBqLCB4X2k9bnVsbCwgeF9qPW51bGwpIHtcbiAgICAgICAgaWYgKGkgPT09IGopIHJldHVybiAwO1xuICAgICAgICBjb25zdCBEID0gdGhpcy5fZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBsZXQgZF9paiA9IEQuZW50cnkoaSwgaik7XG4gICAgICAgIGlmIChkX2lqID09PSAwKSB7XG4gICAgICAgICAgICBkX2lqID0gbWV0cmljKHhfaSB8fCBBW2ldLCB4X2ogfHwgQVtqXSk7XG4gICAgICAgICAgICBELnNldF9lbnRyeShpLCBqLCBkX2lqKTtcbiAgICAgICAgICAgIEQuc2V0X2VudHJ5KGosIGksIGRfaWopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkX2lqO1xuICAgIH1cblxuICAgIF9uZWFyZXN0X21lZG9pZCh4X2osIGopIHtcbiAgICAgICAgY29uc3QgbWVkb2lkcyA9IHRoaXMuX2NsdXN0ZXJfbWVkb2lkcztcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX0E7XG4gICAgICAgIGNvbnN0IFtuZWFyZXN0LCBzZWNvbmRdID0gbWVkb2lkc1xuICAgICAgICAgICAgLm1hcCgobSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHhfbSA9IEFbbV07IFxuICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5fZ2V0X2Rpc3RhbmNlKGosIG0sIHhfaiwgeF9tKSwgaV07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnNvcnQoKG0xLCBtMikgPT4gbTFbMF0gLSBtMlswXSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBcbiAgICAgICAgICAgIFwiZGlzdGFuY2VfbmVhcmVzdFwiOiBuZWFyZXN0WzBdLCBcbiAgICAgICAgICAgIFwiaW5kZXhfbmVhcmVzdFwiOiBuZWFyZXN0WzFdLFxuICAgICAgICAgICAgXCJkaXN0YW5jZV9zZWNvbmRcIjogc2Vjb25kWzBdLFxuICAgICAgICAgICAgXCJpbmRleF9zZWNvbmRcIjogc2Vjb25kWzFdLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHtAbGluayBLfSBjbHVzdGVycyBvdXQgb2YgdGhlIHtAbGluayBtYXRyaXh9LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBLIC0gbnVtYmVyIG9mIGNsdXN0ZXJzLlxuICAgICAqL1xuICAgIGluaXQoSywgY2x1c3Rlcl9tZWRvaWRzKSB7XG4gICAgICAgIGlmICghSykgSyA9IHRoaXMuX0s7XG4gICAgICAgIGlmICghY2x1c3Rlcl9tZWRvaWRzKSBjbHVzdGVyX21lZG9pZHMgPSB0aGlzLl9nZXRfcmFuZG9tX21lZG9pZHMoSyk7XG4gICAgICAgIGNvbnN0IG1heF9pdGVyID0gdGhpcy5fbWF4X2l0ZXI7XG4gICAgICAgIGxldCBmaW5pc2ggPSBmYWxzZTtcbiAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGZpbmlzaCA9IHRoaXMuX2l0ZXJhdGlvbigpO1xuICAgICAgICB9IHdoaWxlICghZmluaXNoICYmICsraSA8IG1heF9pdGVyKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGdvcml0aG0gMy4gRmFzdFBBTSBMQUI6IExpbmVhciBBcHByb3hpbWF0ZSBCVUlMRCBpbml0aWFsaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gSyAtIG51bWJlciBvZiBjbHVzdGVyc1xuICAgICAqIFxuICAgICAqL1xuICAgIF9nZXRfcmFuZG9tX21lZG9pZHMoSykge1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX0E7XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBsaW5zcGFjZSgwLCBOIC0gMSk7XG4gICAgICAgIGNvbnN0IHJhbmRvbWl6ZXIgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oTiwgMTAgKyBNYXRoLmNlaWwoTWF0aC5zcXJ0KE4pKSk7XG4gICAgICAgIGNvbnN0IFREID0gbmV3IEFycmF5KG4pLmZpbGwoSW5maW5pdHkpO1xuICAgICAgICBjb25zdCBtZWRvaWRzID0gW107XG4gICAgICAgIC8vIGZpcnN0IG1lZG9pZFxuICAgICAgICBsZXQgVEQwID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBTID0gcmFuZG9taXplci5jaG9pY2UoaW5kaWNlcywgbik7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBTX2ogPSBTW2pdO1xuICAgICAgICAgICAgY29uc3QgeF9qID0gQVtTX2pdO1xuICAgICAgICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCBuOyArK28pIHtcbiAgICAgICAgICAgICAgICBpZiAobyA9PT0gaikgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeF9vID0gQVtTW29dXTtcbiAgICAgICAgICAgICAgICBURFtqXSArPSB0aGlzLl9nZXRfZGlzdGFuY2UoaiwgbywgeF9qLCB4X28pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFREW2pdIDwgVEQwKSB7XG4gICAgICAgICAgICAgICAgVEQwID0gVERbal07IC8vIHNtYWxsZXN0IGRpc3RhbmNlIHN1bVxuICAgICAgICAgICAgICAgIG1lZG9pZHMucHVzaChTX2opO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyIG1lZG9pZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBLOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBEZWx0YVREID0gSW5maW5pdHk7XG4gICAgICAgICAgICBTID0gcmFuZG9taXplci5jaG9pY2UoaW5kaWNlcy5maWx0ZXIoaW5kZXggPT4gbWVkb2lkcy5maW5kSW5kZXgoZCA9PiBkID09PSBpbmRleCkgPCAwKSwgbik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBkZWx0YVREID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBTX2ogPSBTW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhfaiA9IEFbU19qXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvID0gMDsgbyA8IG47ICsrbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobyA9PT0gaikgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFNfbyA9IFNbb107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhfbyA9IEFbU19vXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbHRhID0gdGhpcy5fZ2V0X2Rpc3RhbmNlKFNfaiwgU19vLCB4X2osIHhfbykgLSBtaW4obWVkb2lkcy5tYXAobSA9PiB0aGlzLl9nZXRfZGlzdGFuY2UoU19vLCBtLCB4X28pKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVEQgPSBkZWx0YVREICsgZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYmVzdCByZWR1Y3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFURCA8IERlbHRhVEQpIHtcbiAgICAgICAgICAgICAgICAgICAgRGVsdGFURCA9IGRlbHRhVEQ7XG4gICAgICAgICAgICAgICAgICAgIG1lZG9pZHMucHVzaChTX2opO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFREMCArPSBEZWx0YVREO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZWRvaWRzLnNsaWNlKDAsIEspO1xuICAgIH1cbiAgICBcbn1cbiIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBIZWFwIH0gZnJvbSBcIi4uL2RhdGFzdHJ1Y3R1cmUvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBPUFRJQ1NcbiAqL1xuZXhwb3J0IGNsYXNzIE9QVElDUyB7XG4gICAgLyoqXG4gICAgICogKipPKipyZGVyaW5nICoqUCoqb2ludHMgKipUKipvICoqSSoqZGVudGlmeSB0aGUgKipDKipsdXN0ZXJpbmcgKipTKip0cnVjdHVyZS5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNsdXN0ZXJpbmdcbiAgICAgKiBAYWxpYXMgT1BUSUNTXG4gICAgICogQHRvZG8gbmVlZHMgcmVzdHJ1Y3R1cmluZy4gXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeCAtIHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlcHNpbG9uIC0gdGhlIG1pbmltdW0gZGlzdGFuY2Ugd2hpY2ggZGVmaW5lcyB3aGV0aGVyIGEgcG9pbnQgaXMgYSBuZWlnaGJvciBvciBub3QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbl9wb2ludHMgLSB0aGUgbWluaW11bSBudW1iZXIgb2YgcG9pbnRzIHdoaWNoIGEgcG9pbnQgbmVlZHMgdG8gY3JlYXRlIGEgY2x1c3Rlci4gKFNob3VsZCBiZSBoaWdoZXIgdGhhbiAxLCBlbHNlIGVhY2ggcG9pbnQgY3JlYXRlcyBhIGNsdXN0ZXIuKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIGRpc3RhbmNlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMgb2YgdGhlIHtAbGluayBtYXRyaXh9LlxuICAgICAqIEByZXR1cm5zIHtPUFRJQ1N9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuZGJzLmlmaS5sbXUuZGUvUHVibGlrYXRpb25lbi9QYXBlcnMvT1BUSUNTLnBkZn1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PUFRJQ1NfYWxnb3JpdGhtfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1hdHJpeCwgZXBzaWxvbiwgbWluX3BvaW50cywgbWV0cmljID0gZXVjbGlkZWFuKSB7XG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeDtcbiAgICAgICAgdGhpcy5fZXBzaWxvbiA9IGVwc2lsb247XG4gICAgICAgIHRoaXMuX21pbl9wb2ludHMgPSBtaW5fcG9pbnRzO1xuICAgICAgICB0aGlzLl9tZXRyaWMgPSBtZXRyaWM7XG5cbiAgICAgICAgdGhpcy5fb3JkZXJlZF9saXN0ID0gW107XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJzID0gW107XG4gICAgICAgIHRoaXMuX0RCID0gbmV3IEFycmF5KG1hdHJpeC5zaGFwZVswXSkuZmlsbCgpO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGNsdXN0ZXJpbmcuXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3Qgb3JkZXJlZF9saXN0ID0gdGhpcy5fb3JkZXJlZF9saXN0O1xuICAgICAgICBjb25zdCBtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG4gICAgICAgIGNvbnN0IE4gPSBtYXRyaXguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IERCID0gdGhpcy5fREI7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gdGhpcy5fY2x1c3RlcnM7XG4gICAgICAgIGxldCBjbHVzdGVyX2luZGV4ID0gdGhpcy5fY2x1c3Rlcl9pbmRleCA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIERCW2ldID0ge1xuICAgICAgICAgICAgICAgIFwiZWxlbWVudFwiOiBtYXRyaXgucm93KGkpLFxuICAgICAgICAgICAgICAgIFwiaW5kZXhcIjogaSxcbiAgICAgICAgICAgICAgICBcInJlYWNoYWJpbGl0eV9kaXN0YW5jZVwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJwcm9jZXNzZWRcIjogZmFsc2UsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwIG9mIERCKSB7XG4gICAgICAgICAgICBpZiAocC5wcm9jZXNzZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcC5uZWlnaGJvcnMgPSB0aGlzLl9nZXRfbmVpZ2hib3JzKHApO1xuICAgICAgICAgICAgcC5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2x1c3RlcnMucHVzaChbcC5pbmRleF0pXG4gICAgICAgICAgICBjbHVzdGVyX2luZGV4ID0gY2x1c3RlcnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIG9yZGVyZWRfbGlzdC5wdXNoKHApO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvcmVfZGlzdGFuY2UocCkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VlZHMgPSBuZXcgSGVhcChudWxsLCBkID0+IGQucmVhY2hhYmlsaXR5X2Rpc3RhbmNlLCBcIm1pblwiKVxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZShwLCBzZWVkcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kX2NsdXN0ZXIoc2VlZHMsIGNsdXN0ZXJzW2NsdXN0ZXJfaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwIC0gYSBwb2ludCBvZiB7QGxpbmsgbWF0cml4fS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgdGhlIHtAbGluayBlcHNpbG9ufS1uZWlnaGJvcmhvb2Qgb2Yge0BsaW5rIHB9LlxuICAgICAqL1xuICAgIF9nZXRfbmVpZ2hib3JzKHApIHtcbiAgICAgICAgaWYgKFwibmVpZ2hib3JzXCIgaW4gcCkgcmV0dXJuIHAubmVpZ2hib3JzO1xuICAgICAgICBjb25zdCBEQiA9IHRoaXMuX0RCO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLl9lcHNpbG9uO1xuICAgICAgICBjb25zdCBuZWlnaGJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBxIG9mIERCKSB7XG4gICAgICAgICAgICBpZiAocS5pbmRleCA9PSBwLmluZGV4KSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChtZXRyaWMocC5lbGVtZW50LCBxLmVsZW1lbnQpIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKHEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWlnaGJvcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcCAtIGEgcG9pbnQgb2Yge0BsaW5rIG1hdHJpeH0uXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIGRpc3RhbmNlIHRvIHRoZSB7QGxpbmsgbWluX3BvaW50c30tdGggbmVhcmVzdCBwb2ludCBvZiB7QGxpbmsgcH0sIG9yIHVuZGVmaW5lZCBpZiB0aGUge0BsaW5rIGVwc2lsb259LW5laWdoYm9yaG9vZCBoYXMgZmV3ZXIgZWxlbWVudHMgdGhhbiB7QGxpbmsgbWluX3BvaW50c30uXG4gICAgICovXG4gICAgX2NvcmVfZGlzdGFuY2UocCkge1xuICAgICAgICBjb25zdCBtaW5fcG9pbnRzID0gdGhpcy5fbWluX3BvaW50cztcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBpZiAocC5uZWlnaGJvcnMgJiYgcC5uZWlnaGJvcnMubGVuZ3RoIDw9IG1pbl9wb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldHJpYyhwLmVsZW1lbnQsIHAubmVpZ2hib3JzW21pbl9wb2ludHNdLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlYWNoYWJpbGl0eSBkaXN0YW5jZSBvZiB0aGUgcG9pbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHAgXG4gICAgICogQHBhcmFtIHtIZWFwfSBzZWVkcyBcbiAgICAgKi9cbiAgICBfdXBkYXRlKHAsIHNlZWRzKSB7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgY29uc3QgY29yZV9kaXN0YW5jZSA9IHRoaXMuX2NvcmVfZGlzdGFuY2UocCk7XG4gICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IHRoaXMuX2dldF9uZWlnaGJvcnMocCk7Ly9wLm5laWdoYm9ycztcbiAgICAgICAgZm9yIChjb25zdCBxIG9mIG5laWdoYm9ycykge1xuICAgICAgICAgICAgaWYgKHEucHJvY2Vzc2VkKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld19yZWFjaGFiaWxpdHlfZGlzdGFuY2UgPSBNYXRoLm1heChjb3JlX2Rpc3RhbmNlLCBtZXRyaWMocC5lbGVtZW50LCBxLmVsZW1lbnQpKTtcbiAgICAgICAgICAgIC8vaWYgKHEucmVhY2hhYmlsaXR5X2Rpc3RhbmNlID09IHVuZGVmaW5lZCkgeyAvLyBxIGlzIG5vdCBpbiBzZWVkc1xuICAgICAgICAgICAgaWYgKHNlZWRzLnJhd19kYXRhKCkuZmluZEluZGV4KGQgPT4gZC5lbGVtZW50ID09IHEpIDwgMCkge1xuICAgICAgICAgICAgICAgIHEucmVhY2hhYmlsaXR5X2Rpc3RhbmNlID0gbmV3X3JlYWNoYWJpbGl0eV9kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBzZWVkcy5wdXNoKHEpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcSBpcyBpbiBzZWVkc1xuICAgICAgICAgICAgICAgIGlmIChuZXdfcmVhY2hhYmlsaXR5X2Rpc3RhbmNlIDwgcS5yZWFjaGFiaWxpdHlfZGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5yZWFjaGFiaWxpdHlfZGlzdGFuY2UgPSBuZXdfcmVhY2hhYmlsaXR5X2Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBzZWVkcyA9IEhlYXAuaGVhcGlmeShzZWVkcy5kYXRhKCksIGQgPT4gZC5yZWFjaGFiaWxpdHlfZGlzdGFuY2UsIFwibWluXCIpOyAvLyBzZWVkcyBjaGFuZ2Uga2V5ID0vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyB0aGUge0BsaW5rIGNsdXN0ZXJ9IHdpdGggcG9pbnRzIGluIHtAbGluayBzZWVkc30uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hlYXB9IHNlZWRzIFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNsdXN0ZXIgXG4gICAgICovXG4gICAgX2V4cGFuZF9jbHVzdGVyKHNlZWRzLCBjbHVzdGVyKSB7XG4gICAgICAgIGNvbnN0IG9yZGVyZWRfbGlzdCA9IHRoaXMuX29yZGVyZWRfbGlzdDtcbiAgICAgICAgd2hpbGUgKCFzZWVkcy5lbXB0eSkge1xuICAgICAgICAgICAgY29uc3QgcSA9IHNlZWRzLnBvcCgpLmVsZW1lbnQ7XG4gICAgICAgICAgICBxLm5laWdoYm9ycyA9IHRoaXMuX2dldF9uZWlnaGJvcnMocSk7XG4gICAgICAgICAgICBxLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICBjbHVzdGVyLnB1c2gocS5pbmRleCk7XG4gICAgICAgICAgICBvcmRlcmVkX2xpc3QucHVzaChxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3JlX2Rpc3RhbmNlKHEpICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZShxLCBzZWVkcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kX2NsdXN0ZXIoc2VlZHMsIGNsdXN0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjbHVzdGVycy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fSBBcnJheSBvZiBjbHVzdGVycyB3aXRoIHRoZSBpbmRpY2VzIG9mIHRoZSByb3dzIGluIGdpdmVuIHtAbGluayBtYXRyaXh9LlxuICAgICAqL1xuICAgIGdldF9jbHVzdGVycygpIHtcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgY29uc3Qgb3V0bGllcnMgPSBbXTtcbiAgICAgICAgY29uc3QgbWluX3BvaW50cyA9IHRoaXMuX21pbl9wb2ludHM7XG4gICAgICAgIGZvciAoY29uc3QgY2x1c3RlciBvZiB0aGlzLl9jbHVzdGVycykge1xuICAgICAgICAgICAgaWYgKGNsdXN0ZXIubGVuZ3RoIDwgbWluX3BvaW50cykge1xuICAgICAgICAgICAgICAgIG91dGxpZXJzLnB1c2goLi4uY2x1c3Rlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goY2x1c3Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2x1c3RlcnMucHVzaChvdXRsaWVycyk7XG4gICAgICAgIHJldHVybiBjbHVzdGVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXksIHdoZXJlIHRoZSBpdGggZW50cnkgZGVmaW5lcyB0aGUgY2x1c3RlciBhZmZpcm1hdGlvbiBvZiB0aGUgaXRoIHBvaW50IG9mIHtAbGluayBtYXRyaXh9LiAoLTEgc3RhbmRzIGZvciBvdXRsaWVyKVxuICAgICAqL1xuICAgIGdldF9jbHVzdGVyX2FmZmlybWF0aW9uKCkge1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fbWF0cml4LnNoYXBlWzBdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoTikuZmlsbCgpO1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9IHRoaXMuZ2V0X2NsdXN0ZXJzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gY2x1c3RlcnMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjbHVzdGVyID0gY2x1c3RlcnNbaV1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgY2x1c3Rlcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSAoaSA8IG4gLSAxKSA/IGkgOiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcbmltcG9ydCB7IE1EUyB9IGZyb20gXCIuL01EUy5qc1wiO1xuaW1wb3J0IHsgS01lZG9pZHMgfSBmcm9tIFwiLi4vY2x1c3RlcmluZy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IEJhbGxUcmVlIH0gZnJvbSBcIi4uL2tubi9pbmRleC5qc1wiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBMU1BcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBMU1AgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgTFNQXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2sgPSBNYXRoLm1heChNYXRoLmZsb29yKE4gLyAxMCksIDIpXSAtIG51bWJlciBvZiBuZWlnaGJvcnMgdG8gY29uc2lkZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb250cm9sX3BvaW50cyA9IE1hdGguY2VpbChNYXRoLnNxcnQoTikpXSAtIG51bWJlciBvZiBjb250cm9scG9pbnRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy4gIFxuICAgICAqIEByZXR1cm5zIHtMU1B9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL2RvY3VtZW50LzQzNzgzNzB9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgaywgY29udHJvbF9wb2ludHMsIGQ9MiwgbWV0cmljPWV1Y2xpZGVhbiwgc2VlZD0xMjEyKSB7XG4gICAgICAgIHN1cGVyKFgsIGQsIG1ldHJpYywgc2VlZCk7XG4gICAgICAgIHN1cGVyLnBhcmFtZXRlcl9saXN0ID0gW1wia1wiLCBcImNvbnRyb2xfcG9pbnRzXCJdO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcImtcIiwgTWF0aC5taW4oayA/PyBNYXRoLm1heChNYXRoLmZsb29yKHRoaXMuX04gLyAxMCksIDIpLCB0aGlzLl9OIC0gMSkpO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcImNvbnRyb2xfcG9pbnRzXCIsIE1hdGgubWluKGNvbnRyb2xfcG9pbnRzID8/IE1hdGguY2VpbChNYXRoLnNxcnQodGhpcy5fTikpLCB0aGlzLl9OIC0gMSkpO1xuICAgICAgICB0aGlzLl9pc19pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0RSfSBEUiAtIG1ldGhvZCB1c2VkIGZvciBwb3NpdGlvbiBjb250cm9sIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge0RSX3BhcmFtZXRlcnN9IERSX3BhcmFtZXRlcnMgLSBhcnJheSBjb250YWluaW5nIHBhcmFtZXRlcnMgZm9yIHRoZSBEUiBtZXRob2Qgd2hpY2ggcHJvamVjdHMgdGhlIGNvbnRyb2wgcG9pbnRzXG4gICAgICogQHJldHVybnMge0xTUH0gXG4gICAgICovXG4gICAgaW5pdChEUj1NRFMsIERSX3BhcmFtZXRlcnM9W10sIEtOTj1CYWxsVHJlZSkge1xuICAgICAgICBpZiAodGhpcy5faXNfaW5pdGlhbGl6ZWQpIHJldHVybiB0aGlzO1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgSyA9IHRoaXMucGFyYW1ldGVyKFwia1wiKTtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuX2Q7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgY29uc3QgbmMgPSB0aGlzLnBhcmFtZXRlcihcImNvbnRyb2xfcG9pbnRzXCIpO1xuICAgICAgICBjb25zdCBjb250cm9sX3BvaW50cyA9IG5ldyBLTWVkb2lkcyhYLCBuYywgbnVsbCwgbWV0cmljKS5nZXRfY2x1c3RlcnMoKS5tZWRvaWRzO1xuICAgICAgICBjb25zdCBDID0gbmV3IE1hdHJpeChuYywgTiwgXCJ6ZXJvc1wiKVxuICAgICAgICBjb250cm9sX3BvaW50cy5mb3JFYWNoKChjX2ksIGkpID0+IHtcbiAgICAgICAgICAgIEMuc2V0X2VudHJ5KGksIGNfaSwgMSk7XG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IFlfQyA9IG5ldyBEUihNYXRyaXguZnJvbShjb250cm9sX3BvaW50cy5tYXAoY19pID0+IFgucm93KGNfaSkpKSwgLi4uRFJfcGFyYW1ldGVycywgZCkudHJhbnNmb3JtKCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBYQSA9IFgudG8yZEFycmF5O1xuICAgICAgICBjb25zdCBrbm4gPSBuZXcgS05OKFhBLCBtZXRyaWMpO1xuICAgICAgICBjb25zdCBMID0gbmV3IE1hdHJpeChOLCBOLCBcIklcIik7XG4gICAgICAgIGNvbnN0IGFscGhhID0gLTEvSztcbiAgICAgICAgWEEuZm9yRWFjaCgoeF9pLCBpKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHtcImluZGV4XCI6IGp9IG9mIGtubi5zZWFyY2goeF9pLCBLKS5pdGVyYXRlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaikgY29udGludWU7XG4gICAgICAgICAgICAgICAgTC5zZXRfZW50cnkoaSwgaiwgYWxwaGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBjb25zdCBBID0gTC5jb25jYXQoQywgXCJ2ZXJ0aWNhbFwiKTtcblxuICAgICAgICBjb25zdCB6ID0gbmV3IE1hdHJpeChOLCBkLCBcInplcm9zXCIpO1xuICAgICAgICBjb25zdCBiID0gei5jb25jYXQoWV9DLCBcInZlcnRpY2FsXCIpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fQSA9IEE7XG4gICAgICAgIHRoaXMuX2IgPSBiO1xuICAgICAgICB0aGlzLl9pc19pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHJldHVybnMge01hdHJpeH0gUmV0dXJucyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgQVQgPSBBLlRcbiAgICAgICAgY29uc3QgYiA9IHRoaXMuX2I7XG4gICAgICAgIGNvbnN0IEFUQSA9IEFULmRvdChBKTtcbiAgICAgICAgY29uc3QgQVRiID0gQVQuZG90KGIpO1xuICAgICAgICB0aGlzLlkgPSBNYXRyaXguc29sdmVfQ0coQVRBLCBBVGIsIHRoaXMuX3JhbmRvbWl6ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn0gIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcbmltcG9ydCB7IERpc2pvaW50U2V0IH0gZnJvbSBcIi4uL2RhdGFzdHJ1Y3R1cmUvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBUb3BvTWFwXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIFRvcG9NYXAgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBUb3BvTWFwXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWVkID0gMTIxMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHJldHVybnMge1RvcG9NYXB9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIwMDkuMDE1MTIucGRmfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIGQgPSAyLCBtZXRyaWMgPSBldWNsaWRlYW4sIHNlZWQgPSAxMjEyKSB7XG4gICAgICAgIHN1cGVyKFgsIGQsIG1ldHJpYywgc2VlZCk7XG4gICAgICAgIHN1cGVyLnBhcmFtZXRlcl9saXN0ID0gW107XG4gICAgICAgIFt0aGlzLl9OLCB0aGlzLl9EXSA9IHRoaXMuWC5zaGFwZTtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VfbWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLl9OLCB0aGlzLl9OLCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX2xhenlfZGlzdGFuY2VfbWF0cml4KGksIGosIG1ldHJpYykge1xuICAgICAgICBjb25zdCBEID0gdGhpcy5fZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBEX2lqID0gRC5lbnRyeShpLCBqKTtcbiAgICAgICAgaWYgKERfaWogPT09IDApIHtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gbWV0cmljKFgucm93KGkpLCBYLnJvdyhqKSk7XG4gICAgICAgICAgICBELnNldF9lbnRyeShpLCBqLCBkaXN0KTtcbiAgICAgICAgICAgIEQuc2V0X2VudHJ5KGosIGksIGRpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERfaWo7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gc3Bhbm5pbmcgdHJlZSwgdXNpbmcgYSBnaXZlbiBtZXRyaWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldHJpY1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tydXNrYWwlMjdzX2FsZ29yaXRobX1cbiAgICAgKi9cbiAgICBfbWFrZV9taW5pbXVtX3NwYW5uaW5nX3RyZWUobWV0cmljID0gZXVjbGlkZWFuKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBYID0gWy4uLnRoaXMuWF07XG5cbiAgICAgICAgbGV0IGRpc2pvaW50X3NldCA9IG5ldyBEaXNqb2ludFNldChYKTtcbiAgICAgICAgY29uc3QgRiA9IFtdO1xuICAgICAgICBsZXQgRSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgRS5wdXNoKFtpLCBqLCB0aGlzLl9fbGF6eV9kaXN0YW5jZV9tYXRyaXgoaSwgaiwgbWV0cmljKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEUgPSBFLnNvcnQoKGEsIGIpID0+IGFbMl0gLSBiWzJdKTtcblxuICAgICAgICBmb3IgKGNvbnN0IFt1LCB2LCB3XSBvZiBFKSB7XG4gICAgICAgICAgICBjb25zdCBzZXRfdSA9IGRpc2pvaW50X3NldC5maW5kKFhbdV0pO1xuICAgICAgICAgICAgY29uc3Qgc2V0X3YgPSBkaXNqb2ludF9zZXQuZmluZChYW3ZdKTtcbiAgICAgICAgICAgIGlmIChzZXRfdSAhPT0gc2V0X3YpIHtcbiAgICAgICAgICAgICAgICBGLnB1c2goW3UsIHYsIHddKTtcbiAgICAgICAgICAgICAgICBkaXNqb2ludF9zZXQudW5pb24oc2V0X3UsIHNldF92KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBGLnNvcnQoKGEsIGIpID0+IGFbMl0gLSBiWzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplcyBUb3BvTWFwLiBTZXRzIGFsbCBwcm9qY3RlZCBwb2ludHMgdG8gemVybywgYW5kIGNvbXB1dGVzIGEgbWluaW11bSBzcGFubmluZyB0cmVlLlxuICAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuWSA9IG5ldyBNYXRyaXgodGhpcy5fTiwgdGhpcy5fZCwgMCk7XG4gICAgICAgIHRoaXMuX0Vtc3QgPSB0aGlzLl9tYWtlX21pbmltdW1fc3Bhbm5pbmdfdHJlZSh0aGlzLl9tZXRyaWMpO1xuICAgICAgICB0aGlzLl9pc19pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBQb2ludCBDIGlzIGxlZnQgb2YgbGluZSBBQi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFBvaW50QSAtIFBvaW50IEEgb2YgbGluZSBBQlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFBvaW50QiAtIFBvaW50IEIgb2YgbGluZSBBQlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFBvaW50QyAtIFBvaW50IENcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBfX2h1bGxfY3Jvc3MoW2F4LCBheV0sIFtieCwgYnldLCBbc3gsIHN5XSkge1xuICAgICAgICByZXR1cm4gKGJ4IC0gYXgpICogKHN5IC0gYXkpIC0gKGJ5IC0gYXkpICogKHN4IC0gYXgpIDw9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGNvbnZleCBodWxsIG9mIHRoZSBzZXQgb2YgUG9pbnRzIFNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFMgLSBTZXQgb2YgUG9pbnRzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9HZW9tZXRyeS9Db252ZXhfaHVsbC9Nb25vdG9uZV9jaGFpbiNKYXZhU2NyaXB0fVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY29udmV4IGh1bGwgb2YgUy4gU3RhcnRzIGF0IHRoZSBib3R0b20tbW9zdCBwb2ludCBhbmQgY29udGludWVzIGNvdW50ZXItY2xvY2t3aXNlLlxuICAgICAqL1xuICAgIF9faHVsbChTKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFMuc29ydCgoW3gxLCB5MV0sIFt4MiwgeTJdKSA9PiB5MSAtIHkyIHx8IHgxIC0geDIpO1xuICAgICAgICBjb25zdCBOID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKE4gPD0gMikgcmV0dXJuIHBvaW50cztcblxuICAgICAgICBjb25zdCBsb3dlciA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgd2hpbGUgKGxvd2VyLmxlbmd0aCA+PSAyICYmIHRoaXMuX19odWxsX2Nyb3NzKGxvd2VyW2xvd2VyLmxlbmd0aCAtIDJdLCBsb3dlcltsb3dlci5sZW5ndGggLSAxXSwgcG9pbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgIGxvd2VyLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG93ZXIucHVzaChwb2ludHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwcGVyID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBOIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHdoaWxlICh1cHBlci5sZW5ndGggPj0gMiAmJiB0aGlzLl9faHVsbF9jcm9zcyh1cHBlclt1cHBlci5sZW5ndGggLSAyXSwgdXBwZXJbdXBwZXIubGVuZ3RoIC0gMV0sIHBvaW50c1tpXSkpIHtcbiAgICAgICAgICAgICAgICB1cHBlci5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwcGVyLnB1c2gocG9pbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB1cHBlci5wb3AoKTtcbiAgICAgICAgbG93ZXIucG9wKCk7XG4gICAgICAgIHJldHVybiBsb3dlci5jb25jYXQodXBwZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBhbmdsZSB0byByb3RhdGUgUG9pbnQgQSBhbmQgQiB0byBsaWUgb24gYSBsaW5lIHBhcmFsbGVsIHRvIHRoZSB4LWF4aXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBQb2ludEFcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBQb2ludEJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBzaW51cy0gYW5kIGNvc2ludXMtdmFsdWVzIGZvciBhIHJvdGF0aW9uLlxuICAgICAqL1xuICAgIF9fZmluZEFuZ2xlKFtwMXgsIHAxeV0sIFtwMngsIHAyeV0pIHtcbiAgICAgICAgY29uc3QgbiA9IGV1Y2xpZGVhbihbcDF4LCBwMXldLCBbcDJ4LCBwMnldKTtcbiAgICAgICAgaWYgKG4gPT09IDApXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNpbjogMCxcbiAgICAgICAgICAgICAgICBjb3M6IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjb25zdCB2ZWMgPSBbKHAyeCAtIHAxeCkgLyBuLCAocDJ5IC0gcDF5KSAvIG5dO1xuICAgICAgICBjb25zdCBjb3MgPSB2ZWNbMF07XG4gICAgICAgIGxldCBzaW4gPSBNYXRoLnNxcnQoMSAtIGNvcyAqIGNvcyk7XG4gICAgICAgIHNpbiA9IHZlY1sxXSA+PSAwID8gLXNpbiA6IHNpbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpbjogc2luLFxuICAgICAgICAgICAgY29zOiBjb3MsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBodWxsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcFxuICAgICAqIEBwYXJhbSB7Qm9vbH0gdG9wRWRnZVxuICAgICAqL1xuICAgIF9fYWxpZ25faHVsbChodWxsLCBwLCB0b3BFZGdlKSB7XG4gICAgICAgIGxldCB2ID0gLTE7XG4gICAgICAgIGxldCBkMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBodWxsLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gZXVjbGlkZWFuKGh1bGxbaV0sIHApO1xuICAgICAgICAgICAgaWYgKHYgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZDIgPSBkO1xuICAgICAgICAgICAgICAgIHYgPSBpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZDIgPiBkKSB7XG4gICAgICAgICAgICAgICAgICAgIGQyID0gZDtcbiAgICAgICAgICAgICAgICAgICAgdiA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBsZXQgdjI7XG4gICAgICAgIGlmICh0b3BFZGdlKSB7XG4gICAgICAgICAgICB2MSA9IGh1bGxbdl07XG4gICAgICAgICAgICB2MiA9IGh1bGxbKHYgKyAxKSAlIGh1bGwubGVuZ3RoXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2ID09IDApIHYgPSBodWxsLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2MSA9IGh1bGxbdl07XG4gICAgICAgICAgICB2MiA9IGh1bGxbKHYgLSAxKSAlIGh1bGwubGVuZ3RoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uID0ge1xuICAgICAgICAgICAgdHg6IC1odWxsW3ZdWzBdLFxuICAgICAgICAgICAgdHk6IC1odWxsW3ZdWzFdLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChodWxsLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNpbiwgY29zIH0gPSB0aGlzLl9fZmluZEFuZ2xlKHYxLCB2Mik7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbi5zaW4gPSBzaW47XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbi5jb3MgPSBjb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbi5zaW4gPSAwO1xuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24uY29zID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFBvaW50IC0gVGhlIHBvaW50IHdoaWNoIHNob3VsZCBnZXQgdHJhbnNmb3JtZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFRyYW5zZm9ybWF0aW9uIC0gY29udGFpbnMgdGhlIHZhbHVlcyBmb3IgdHJhbnNsYXRpb24gYW5kIHJvdGF0aW9uLlxuICAgICAqL1xuICAgIF9fdHJhbnNmb3JtKFtweCwgcHldLCB7IHR4LCB0eSwgc2luLCBjb3MgfSkge1xuICAgICAgICBsZXQgeCA9IHB4ICsgdHg7XG4gICAgICAgIGxldCB5ID0gcHkgKyB0eTtcbiAgICAgICAgbGV0IHh4ID0geCAqIGNvcyAtIHkgKiBzaW47XG4gICAgICAgIGxldCB5eSA9IHggKiBzaW4gKyB5ICogY29zO1xuICAgICAgICByZXR1cm4gW3h4LCB5eV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMge0BsaW5rIF9fdHJhbnNmb3JtfSBmb3IgZWFjaCBwb2ludCBpbiBTZXQgQ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gQyAtIFNldCBvZiBwb2ludHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHQgLSBUcmFuc2Zvcm0gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5T2Zmc2V0IC0gdmFsdWUgdG8gb2Zmc2V0IHNldCBDLlxuICAgICAqL1xuICAgIF9fdHJhbnNmb3JtX2NvbXBvbmVudChDLCB0LCB5T2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IE4gPSBDLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBDW2ldO1xuICAgICAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLl9fdHJhbnNmb3JtKGMsIHQpO1xuICAgICAgICAgICAgY1swXSA9IGN4O1xuICAgICAgICAgICAgY1sxXSA9IGN5ICsgeU9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdSAtIHBvaW50IHVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2IC0gcG9pbnQgdlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3IC0gZWRnZSB3ZWlnaHQgd1xuICAgICAqL1xuICAgIF9fYWxpZ25fY29tcG9uZW50cyh1LCB2LCB3KSB7XG4gICAgICAgIGNvbnN0IHBvaW50c191ID0gWy4uLnUuX19kaXNqb2ludF9zZXQuY2hpbGRyZW5dO1xuICAgICAgICBjb25zdCBwb2ludHNfdiA9IFsuLi52Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuXTtcblxuICAgICAgICBjb25zdCBodWxsX3UgPSB0aGlzLl9faHVsbChwb2ludHNfdSk7XG4gICAgICAgIGNvbnN0IGh1bGxfdiA9IHRoaXMuX19odWxsKHBvaW50c192KTtcblxuICAgICAgICBjb25zdCB0X3UgPSB0aGlzLl9fYWxpZ25faHVsbChodWxsX3UsIHUsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgdF92ID0gdGhpcy5fX2FsaWduX2h1bGwoaHVsbF92LCB2LCB0cnVlKTtcblxuICAgICAgICB0aGlzLl9fdHJhbnNmb3JtX2NvbXBvbmVudChwb2ludHNfdSwgdF91LCAwKTtcbiAgICAgICAgdGhpcy5fX3RyYW5zZm9ybV9jb21wb25lbnQocG9pbnRzX3YsIHRfdiwgdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXRkYXRhIHtAbGluayBYfSB0byBkaW1lbnNpb25hbGl0eSAyLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc19pbml0aWFsaXplZCkgdGhpcy5pbml0KCk7XG4gICAgICAgIGNvbnN0IEVtc3QgPSB0aGlzLl9FbXN0O1xuICAgICAgICBjb25zdCBZID0gWy4uLnRoaXMuWV07XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBuZXcgRGlzam9pbnRTZXQoXG4gICAgICAgICAgICBZLm1hcCgoeSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHkuaSA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGZvciAoY29uc3QgW3UsIHYsIHddIG9mIEVtc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudF91ID0gY29tcG9uZW50cy5maW5kKFlbdV0pO1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50X3YgPSBjb21wb25lbnRzLmZpbmQoWVt2XSk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50X3UgPT09IGNvbXBvbmVudF92KSBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMuX19hbGlnbl9jb21wb25lbnRzKGNvbXBvbmVudF91LCBjb21wb25lbnRfdiwgdyk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnVuaW9uKGNvbXBvbmVudF91LCBjb21wb25lbnRfdik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICAqZ2VuZXJhdG9yKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzX2luaXRpYWxpemVkKSB0aGlzLmluaXQoKTtcbiAgICAgICAgY29uc3QgRW1zdCA9IHRoaXMuX0Vtc3Q7XG4gICAgICAgIGNvbnN0IFkgPSBbLi4udGhpcy5ZXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IG5ldyBEaXNqb2ludFNldChcbiAgICAgICAgICAgIFkubWFwKCh5LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgeS5pID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChjb25zdCBbdSwgdiwgd10gb2YgRW1zdCkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50X3UgPSBjb21wb25lbnRzLmZpbmQoWVt1XSk7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRfdiA9IGNvbXBvbmVudHMuZmluZChZW3ZdKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRfdSA9PT0gY29tcG9uZW50X3YpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5fX2FsaWduX2NvbXBvbmVudHMoY29tcG9uZW50X3UsIGNvbXBvbmVudF92LCB3KTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMudW5pb24oY29tcG9uZW50X3UsIGNvbXBvbmVudF92KTtcbiAgICAgICAgICAgIC8qIGxldCBvayA9IHRydWVcbiAgICAgICAgICAgIFkuZm9yRWFjaCgoW3gsIHldKSA9PiBvayA9IG9rICYmICFpc05hTih4KSAmJiAhaXNOYU4oeSkpXG4gICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coLi4uWSkgXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJlcnJvclwiIFxuICAgICAgICAgICAgfSAqL1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIGFzIERpbVJlZH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBTQU1NT05cbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBTQU1NT04gZXh0ZW5kcyBEaW1SZWQge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIFNBTU1PTlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS4gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy4gIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VlZCA9IDEyMTJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtTQU1NT059XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIwMDkuMDE1MTIucGRmfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIG1hZ2ljPTAuMSwgZD0yLCBtZXRyaWM9ZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgc3VwZXIoWCwgZCwgbWV0cmljLCBzZWVkKVxuICAgICAgICBzdXBlci5wYXJhbWV0ZXJfbGlzdCA9IFtcIm1hZ2ljXCJdO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcIm1hZ2ljXCIsIG1hZ2ljKTtcbiAgICAgICAgWyB0aGlzLl9OLCB0aGlzLl9EIF0gPSB0aGlzLlguc2hhcGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemVzIFNBTU1PTi4gU2V0cyBhbGwgcHJvamN0ZWQgcG9pbnRzIHRvIHplcm8sIGFuZCBjb21wdXRlcyBhIG1pbmltdW0gc3Bhbm5pbmcgdHJlZS5cbiAgICAgKi9cbiAgICBpbml0KERSPVwicmFuZG9tXCIsIGRpc3RhbmNlX21hdHJpeD1udWxsKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBkID0gdGhpcy5fZDtcblxuICAgICAgICBpZiAoRFIgPT09IFwicmFuZG9tXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbWl6ZXIgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICAgICAgdGhpcy5ZID0gbmV3IE1hdHJpeChOLCBkLCAoKSA9PiByYW5kb21pemVyLnJhbmRvbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoRFIgaW5zdGFuY2VvZiBEaW1SZWQpIHtcbiAgICAgICAgICAgIHRoaXMuWSA9IERSLnRyYW5zZm9ybSh0aGlzLlgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzdGFuY2VfbWF0cml4ID0gZGlzdGFuY2VfbWF0cml4IHx8IHRoaXMuX19kaXN0YW5jZV9tYXRyaXgodGhpcy5YKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IFxuICAgICAqL1xuICAgIF9fZGlzdGFuY2VfbWF0cml4KEEpIHtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBOID0gQS5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgRCA9IG5ldyBNYXRyaXgoTiwgTik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBBX2kgPSBBLnJvdyhpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gKGkgPT09IGogPyAwIDogbWV0cmljKEFfaSwgQS5yb3coaikpKTtcbiAgICAgICAgICAgICAgICBELnNldF9lbnRyeShpLCBqLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgRC5zZXRfZW50cnkoaiwgaSwgZGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEOyAgICAgICAgICAgICAgICBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuaW9uYWxpdHkgMi5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0obWF4X2l0ZXI9MjAwKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNfaW5pdGlhbGl6ZWQpIHRoaXMuaW5pdCgpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1heF9pdGVyOyArK2opIHtcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgKiBnZW5lcmF0b3IobWF4X2l0ZXI9MjAwKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNfaW5pdGlhbGl6ZWQpIHRoaXMuaW5pdCgpO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF4X2l0ZXI7ICsraikge1xuICAgICAgICAgICAgdGhpcy5fc3RlcCgpXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnByb2plY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIF9zdGVwKCkge1xuICAgICAgICBjb25zdCBNQUdJQyA9IHRoaXMucGFyYW1ldGVyKFwibWFnaWNcIik7XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLmRpc3RhbmNlX21hdHJpeDtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLl9kO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGxldCBZID0gdGhpcy5ZO1xuICAgICAgICBcbiAgICAgICAgbGV0IEcgPSBuZXcgTWF0cml4KE4sIGQsIDApO1xuXG4gICAgICAgIGxldCBzdW0gPSBuZXcgRmxvYXQ2NEFycmF5KGQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgbGV0IGUxID0gbmV3IEZsb2F0NjRBcnJheShkKTtcbiAgICAgICAgICAgIGxldCBlMiA9IG5ldyBGbG9hdDY0QXJyYXkoZCk7XG4gICAgICAgICAgICBjb25zdCBZaSA9IFkucm93KGkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaikgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgWWogPSBZLnJvdyhqKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IG5ldyBGbG9hdDY0QXJyYXkoZCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFba10gPSBZaVtrXSAtIFlqW2tdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRZID0gbWV0cmljKFlpLCBZaik7XG4gICAgICAgICAgICAgICAgY29uc3QgZFggPSBELmVudHJ5KGksIGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRxID0gZFggLSBkWTtcbiAgICAgICAgICAgICAgICBjb25zdCBkciA9IE1hdGgubWF4KGRYICogZFksIDFlLTIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIGUxW2tdICs9IGRlbHRhW2tdICogZHEgLyBkcjtcbiAgICAgICAgICAgICAgICAgICAgZTJba10gKz0gKGRxIC0gTWF0aC5wb3coZGVsdGFba10sIDIpICogKDEgKyBkcSAvIGRZKSAvIGRZKSAvIGRyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZDsgKytrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gWS5lbnRyeShpLCBrKSArIChNQUdJQyAqIGUxW2tdIC8gTWF0aC5hYnMoZTJba10pIHx8IDApO1xuICAgICAgICAgICAgICAgIEcuc2V0X2VudHJ5KGksIGssIHZhbCk7XG4gICAgICAgICAgICAgICAgc3VtW2tdICs9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGQ7ICsraykge1xuICAgICAgICAgICAgc3VtW2tdIC89IE47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkOyArK2spIHtcbiAgICAgICAgICAgICAgICBZLnNldF9lbnRyeShpLCBrLCBHLmVudHJ5KGksIGspIC0gc3VtW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWTtcbiAgICB9XG59ICJdLCJuYW1lcyI6WyJhIiwiYiIsIk1hdGgiLCJzcXJ0IiwiZXVjbGlkZWFuX3NxdWFyZWQiLCJzdW1tYW5kcyIsInkiLCJ0IiwibiIsImxlbmd0aCIsInN1bSIsImNvbXBlbnNhdGlvbiIsImkiLCJzdW1tYW5kIiwiYWJzIiwicyIsIkFycmF5IiwieCIsIm5ldW1haXJfc3VtIiwic3VtX2EiLCJzdW1fYiIsImFjb3MiLCJyZXMiLCJwdXNoIiwibWF4IiwibnVtX25vbl96ZXJvIiwibnVtX2VxdWFsIiwiZGlzYWdyZWUiLCJudW1fbm90X2VxdWFsIiwibnVtX3RydWVfdHJ1ZSIsIm51bV90cnVlX2ZhbHNlIiwibnVtX2ZhbHNlX3RydWUiLCJBIiwiayIsIm1ldHJpYyIsImV1Y2xpZGVhbiIsInJvd3MiLCJzaGFwZSIsIkQiLCJjbG9uZSIsImRpc3RhbmNlX21hdHJpeCIsIm5OIiwicm93IiwiZnJvbSIsIm1hcCIsImRpc3RhbmNlIiwiY29sIiwiaiIsInNvcnQiLCJzbGljZSIsIk1hdHJpeCIsIkFfaSIsImRpc3QiLCJzZXRfZW50cnkiLCJzdGFydCIsImVuZCIsIm51bWJlciIsInJvdW5kIiwicmVzdWx0IiwidiIsInZlY3RvciIsImNvbHMiLCJFcnJvciIsIkZsb2F0NjRBcnJheSIsInZfbm9ybSIsIm5vcm0iLCJ2YWx1ZSIsIlEiLCJSIiwicSIsInFfZG90X3YiLCJxXyIsInZfIiwieF9ub3JtIiwieDAiLCJlbnRyeSIsInJobyIsInNpZ24iLCJ1MSIsInUiLCJkaXZpZGUiLCJiZXRhIiwidV9vdXRlcl91Iiwib3V0ZXIiLCJSX2Jsb2NrIiwiZ2V0X2Jsb2NrIiwibmV3X1IiLCJzdWIiLCJkb3QiLCJtdWx0IiwiUV9ibG9jayIsIm5ld19RIiwic2V0X2Jsb2NrIiwibWF4X2l0ZXJhdGlvbnMiLCJzZWVkIiwicXIiLCJxcl9ncmFtc2NobWlkdCIsInRvbCIsInJhbmRvbWl6ZXIiLCJSYW5kb21pemVyIiwicmFuZG9tIiwib2xkUSIsIlFSIiwidmFsdWVzIiwiZWlnZW52YWx1ZXMiLCJkaWFnIiwiZWlnZW52ZWN0b3JzIiwidHJhbnNwb3NlIiwidG8yZEFycmF5IiwiTiIsImNvbnN0cnVjdG9yIiwidGhpcyIsIl9yb3dzIiwiX2NvbHMiLCJfZGF0YSIsInN0YXRpYyIsInR5cGUiLCJpc0FycmF5IiwibSIsIl8iLCJkYXRhIiwic3ViYXJyYXkiLCJpdGVyYXRlX3Jvd3MiLCJTeW1ib2wiLCJpdGVyYXRvciIsInNldF9yb3ciLCJvZmZzZXQiLCJyZXN1bHRfY29sIiwiVCIsImludmVyc2UiLCJCIiwiaCIsImlfbWF4IiwibWF4X3ZhbCIsIkluZmluaXR5IiwidmFsIiwiaF92YWwiLCJpX3ZhbCIsImYiLCJCX3Jvd19yb3ciLCJCX2lfaiIsImpvaW4iLCJJIiwiQl9pIiwiQyIsImUiLCJsIiwiY29uY2F0Iiwicm93c19BIiwiY29sc19BIiwicm93c19CIiwiY29sc19CIiwiWCIsIm9mZnNldF9yb3ciLCJvZmZzZXRfY29sIiwic3RhcnRfcm93Iiwic3RhcnRfY29sIiwiZW5kX3JvdyIsImVuZF9jb2wiLCJuZXdfcm93IiwibmV3X2NvbCIsImdhdGhlciIsInJvd19pbmRpY2VzIiwiY29sX2luZGljZXMiLCJyb3dfaW5kZXgiLCJjb2xfaW5kZXgiLCJfYXBwbHlfYXJyYXkiLCJfYXBwbHlfcm93d2lzZV9hcnJheSIsIl9hcHBseV9jb2x3aXNlX2FycmF5IiwiX2FwcGx5IiwidmFsdWVfcm93cyIsInZhbHVlX2NvbHMiLCJhZGQiLCJhc0FycmF5IiwibWluX3Jvd19jb2wiLCJtaW4iLCJtZWFuIiwibWVhblJvd3MiLCJtZWFuQ29scyIsImJfaSIsInIiLCJkIiwieiIsImFscGhhIiwicl9uZXh0IiwiTCIsIlUiLCJMVSIsIkxfZGlhZyIsIlVfZGlhZyIsImRldCIsIk0iLCJNVCIsIk10TSIsIk1NdCIsIlYiLCJTaWdtYSIsInNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbiIsInNpZ21hIiwiX3NlZWQiLCJfTiIsIl9NIiwiX01BVFJJWF9BIiwiX1VQUEVSX01BU0siLCJfTE9XRVJfTUFTSyIsIl9tdCIsIl9tdGkiLCJEYXRlIiwiZ2V0VGltZSIsIm10IiwibXRpIiwicmFuZG9tX2ludCIsIm1hZzAxIiwia2siLCJOX00iLCJNX04iLCJjaG9pY2UiLCJzYW1wbGUiLCJpbmRleF9saXN0IiwibGluc3BhY2UiLCJyYW5kb21faW5kZXgiLCJzcGxpY2UiLCJ1bmRlZmluZWQiLCJIZWFwIiwiZWxlbWVudHMiLCJhY2Nlc3NvciIsImNvbXBhcmF0b3IiLCJoZWFwaWZ5IiwiX2FjY2Vzc29yIiwiX2NvbnRhaW5lciIsIl9jb21wYXJhdG9yIiwiaGVhcCIsImNvbnRhaW5lciIsImVsZW1lbnQiLCJmbG9vciIsIl9oZWFwaWZ5X2Rvd24iLCJfc3dhcCIsImluZGV4X2EiLCJpbmRleF9iIiwiX2hlYXBpZnlfdXAiLCJpbmRleCIsInBhcmVudEluZGV4Iiwibm9kZSIsInN0YXJ0X2luZGV4IiwibGVmdCIsInJpZ2h0IiwicG9wIiwiaXRlbSIsImZpcnN0IiwiaXRlcmF0ZSIsInRvQXJyYXkiLCJyYXdfZGF0YSIsImVtcHR5IiwiRGlzam9pbnRTZXQiLCJfbGlzdCIsIlNldCIsIm1ha2Vfc2V0IiwibGlzdCIsImhhcyIsIl9fZGlzam9pbnRfc2V0IiwicGFyZW50IiwiY2hpbGRyZW4iLCJzaXplIiwiZmluZCIsInVuaW9uIiwibm9kZV94Iiwibm9kZV95IiwiZm9yRWFjaCIsIkJhbGxUcmVlIiwiX05vZGUiLCJwaXZvdCIsImNoaWxkMSIsImNoaWxkMiIsInJhZGl1cyIsIl9MZWFmIiwicG9pbnRzIiwiX21ldHJpYyIsIl9yb290IiwiX2NvbnN0cnVjdCIsImMiLCJfZ3JlYXRlc3Rfc3ByZWFkIiwic29ydGVkX2VsZW1lbnRzIiwicF9pbmRleCIsInAiLCJzcHJlYWQiLCJyZWR1Y2UiLCJhY2MiLCJjdXJyZW50Iiwic2VhcmNoIiwiX3NlYXJjaCIsIktOTiIsIl9lbGVtZW50cyIsIl9EIiwiZGlzdGFuY2VzIiwiSCIsIm5lYXJlc3RfZWxlbWVudF9pbmRleCIsIm5lYXJlc3RfZGlzdCIsIk51bWJlciIsImlzSW50ZWdlciIsIkRSIiwicGFyYW1ldGVyX2xpc3QiLCJfcGFyYW1ldGVyX2xpc3QiLCJfdHlwZSIsIl9kIiwiX3JhbmRvbWl6ZXIiLCJfaXNfaW5pdGlhbGl6ZWQiLCJwYXJhbWV0ZXIiLCJuYW1lIiwiaW5jbHVkZXMiLCJwYXJhIiwidHJhbnNmb3JtIiwiY2hlY2tfaW5pdCIsInByb2plY3Rpb24iLCJnZW5lcmF0b3IiLCJpbml0IiwiWSIsImFzeW5jIiwiYXJncyIsImdlbiIsIlBDQSIsInN1cGVyIiwicHJpbmNpcGFsX2NvbXBvbmVudHMiLCJtZWFucyIsIlhfY2VudCIsIk1EUyIsImFpXyIsImFfaiIsImFfXyIsIl9kX1giLCJzdHJlc3MiLCJkX1giLCJkX1kiLCJ0b3Bfc3VtIiwiYm90dG9tX3N1bSIsInBvdyIsIklTT01BUCIsIm5laWdoYm9ycyIsImtOZWFyZXN0TmVpZ2hib3JzIiwiX2siLCJHIiwib3RoZXIiLCJGQVNUTUFQIiwiX2Nob29zZV9kaXN0YW50X29iamVjdHMiLCJhX2luZGV4IiwiYl9pbmRleCIsIm1heF9kaXN0IiwiZF9haSIsImRfYmkiLCJfY29sIiwib2xkX2Rpc3QiLCJkX2FiIiwieV9pIiwiTERBIiwibGFiZWxzIiwiX2xhYmVscyIsInVuaXF1ZV9sYWJlbHMiLCJsYWJlbF9pZCIsImNvdW50IiwiaWQiLCJYX21lYW4iLCJWX21lYW4iLCJsYWJlbCIsInZfbWVhbiIsIlNfYiIsIlNfdyIsInJvd192IiwiTExFIiwia19uZWFyZXN0X25laWdoYm9ycyIsIk8iLCJXIiwibk5fcm93IiwiWiIsIkNfdHJhY2UiLCJ3Iiwic29sdmVfQ0ciLCJJVyIsIkxUU0EiLCJJX2kiLCJYX2kiLCJnIiwiR19pX3QiLCJXX2kiLCJUU05FIiwicGVycGxleGl0eSIsImVwc2lsb24iLCJfaXRlciIsIkh0YXJnZXQiLCJsb2ciLCJfcGVycGxleGl0eSIsIkRlbHRhIiwiUCIsIl95c3RlcCIsIl9nYWlucyIsInByb3ciLCJmaWxsIiwiYmV0YW1pbiIsImJldGFtYXgiLCJkb25lIiwibnVtIiwicHN1bSIsInBqIiwiZXhwIiwiSGhlcmUiLCJQb3V0IiwiTjIiLCJfUCIsIml0ZXJhdGlvbnMiLCJuZXh0IiwiaXRlciIsInlzdGVwIiwiZ2FpbnMiLCJfZXBzaWxvbiIsImRpbSIsInBtdWwiLCJRdSIsInFzdW0iLCJkc3VtIiwiZGhlcmUiLCJxdSIsImdyYWQiLCJwcmVtdWx0IiwieW1lYW4iLCJnaWQiLCJzaWQiLCJnYWluaWQiLCJuZXdnYWluIiwibmV3c2lkIiwibWF4X2l0ZXIiLCJwZngiLCJmeCIsImNvbnZlcmdlbmNlIiwiZnhpIiwiZHgiLCJVTUFQIiwibl9uZWlnaGJvcnMiLCJsb2NhbF9jb25uZWN0aXZpdHkiLCJtaW5fZGlzdCIsIl9zcHJlYWQiLCJfc2V0X29wX21peF9yYXRpbyIsIl9yZXB1bHNpb25fc3RyZW5ndGgiLCJfbmVnYXRpdmVfc2FtcGxlX3JhdGUiLCJfbl9lcG9jaHMiLCJfaW5pdGlhbF9hbHBoYSIsIl9maW5kX2FiX3BhcmFtcyIsInh2IiwieXYiLCJ4dl9pIiwicG93ZWxsIiwiZXJyb3IiLCJfY29tcHV0ZV9tZW1iZXJzaGlwX3N0cmVuZ3RocyIsInNpZ21hcyIsInJob3MiLCJfc21vb3RoX2tubl9kaXN0Iiwia25uIiwiU01PT1RIX0tfVE9MRVJBTkNFIiwiTUlOX0tfRElTVF9TQ0FMRSIsIl9sb2NhbF9jb25uZWN0aXZpdHkiLCJ0YXJnZXQiLCJsb2cyIiwicmV2ZXJzZSIsInhfaSIsImxvIiwiaGkiLCJtaWQiLCJzZWFyY2hfcmVzdWx0Iiwibm9uX3plcm9fZGlzdCIsImZpbHRlciIsIm5vbl96ZXJvX2Rpc3RfbGVuZ3RoIiwiaW50ZXJwb2xhdGlvbiIsIm1lYW5faXRoZCIsIm1lYW5fZCIsIl9mdXp6eV9zaW1wbGljaWFsX3NldCIsImRpc3RhbmNlc19pIiwidHJhbnNwb3NlZF9yZXN1bHQiLCJwcm9kX21hdHJpeCIsIl9tYWtlX2Vwb2Noc19wZXJfc2FtcGxlIiwibl9lcG9jaHMiLCJ3ZWlnaHRzIiwiX3dlaWdodHMiLCJGbG9hdDMyQXJyYXkiLCJ3ZWlnaHRzX21heCIsIm5fc2FtcGxlcyIsIl90b2NvbyIsImdyYXBoIiwicm93c19uIiwiY29sc19uIiwiX21pbl9kaXN0IiwiX2EiLCJfYiIsIl9ncmFwaCIsIl9uX25laWdoYm9ycyIsIl9oZWFkIiwiX3RhaWwiLCJfZXBvY2hzX3Blcl9zYW1wbGUiLCJfZXBvY2hzX3Blcl9uZWdhdGl2ZV9zYW1wbGUiLCJfZXBvY2hfb2ZfbmV4dF9zYW1wbGUiLCJfZXBvY2hfb2ZfbmV4dF9uZWdhdGl2ZV9zYW1wbGUiLCJfY2xpcCIsIl9vcHRpbWl6ZV9sYXlvdXQiLCJoZWFkX2VtYmVkZGluZyIsInRhaWxfZW1iZWRkaW5nIiwiaGVhZCIsInRhaWwiLCJfYWxwaGEiLCJyZXB1bHNpb25fc3RyZW5ndGgiLCJlcG9jaHNfcGVyX3NhbXBsZSIsImVwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlIiwiZXBvY2hfb2ZfbmV4dF9uZWdhdGl2ZV9zYW1wbGUiLCJlcG9jaF9vZl9uZXh0X3NhbXBsZSIsImNsaXAiLCJ0YWlsX2xlbmd0aCIsImdyYWRfY29lZmYiLCJncmFkX2QiLCJvIiwibl9uZWdfc2FtcGxlcyIsIlRyaU1hcCIsIndlaWdodF9hZGoiLCJwY2EiLCJfYyIsIm5faW5saWVycyIsIm5fb3V0bGllcnMiLCJuX3JhbmRvbSIsInRyaXBsZXRzIiwiX2dlbmVyYXRlX3RyaXBsZXRzIiwibHIiLCJ2ZWwiLCJnYWluIiwiX3dlaWdodF9hZGoiLCJuX2V4dHJhIiwibmJycyIsImtubl9kaXN0YW5jZXMiLCJzaWciLCJfZmluZF9wIiwiX3NhbXBsZV9rbm5fdHJpcGxldHMiLCJuX3RyaXBsZXRzIiwib3V0bGllcl9kaXN0YW5jZXMiLCJfZmluZF93ZWlnaHRzIiwicmFuZG9tX3RyaXBsZXRzIiwicmFuZG9tX3dlaWdodHMiLCJfc2FtcGxlX3JhbmRvbV90cmlwbGV0cyIsIm1heF93ZWlnaHQiLCJpc05hTiIsIm1heF93ZWlnaHRfMiIsIm5faSIsInNvcnRfaW5kaWNlcyIsIl9fYXJnc29ydCIsIm5faiIsInNpbSIsInNhbXBsZXMiLCJfcmVqZWN0aW9uX3NhbXBsZSIsIm91dCIsIm1heF9pbnQiLCJyZWplY3RzIiwiaW50ZXJ2YWwiLCJpbmRleE9mIiwicF9zaW0iLCJwX291dCIsImluZGljZXMiLCJfZ3JhZCIsInlfaWoiLCJ5X2lrIiwiZF9paiIsImRfaWsiLCJuX3Zpb2wiLCJsb3NzIiwibl9rbm5fdHJpcGxldHMiLCJZX2lkIiwiWV9qZCIsIllfa2QiLCJncyIsImdvIiwibWF4X2l0ZXJhdGlvbiIsIl9uZXh0IiwiZ2FtbWEiLCJvbGRfQyIsIl91cGRhdGVfZW1iZWRkaW5nIiwibmV3X2dhaW4iLCJIaWVyYXJjaGljYWxfQ2x1c3RlcmluZyIsIm1hdHJpeCIsImxpbmthZ2UiLCJfaWQiLCJfbWF0cml4IiwiX2xpbmthZ2UiLCJyb290IiwiZG8iLCJnZXRfY2x1c3RlcnMiLCJjbHVzdGVycyIsImRlcHRoIiwiX3RyYXZlcnNlIiwibGVhdmVzIiwiX24iLCJkX21pbiIsIl9kX21pbiIsIl9kaXN0YW5jZV9tYXRyaXgiLCJfY2x1c3RlcnMiLCJjX3NpemUiLCJfY19zaXplIiwiVWludDE2QXJyYXkiLCJDbHVzdGVyIiwicF9tYXgiLCJjMSIsIkRfaV9taW4iLCJjMiIsImMxX2NsdXN0ZXIiLCJjMl9jbHVzdGVyIiwiYzFfY2x1c3Rlcl9pbmRpY2VzIiwiaXNMZWFmIiwiYzJfY2x1c3Rlcl9pbmRpY2VzIiwibmV3X2NsdXN0ZXIiLCJ1bnNoaWZ0IiwiRF9jMV9qIiwiRF9jMl9qIiwiY2VudHJvaWQiLCJfY2FsY3VsYXRlX2NlbnRyb2lkIiwibF9zaXplIiwicl9zaXplIiwibF9jZW50cm9pZCIsInJfY2VudHJvaWQiLCJuZXdfY2VudHJvaWQiLCJkZXNjZW5kYW50cyIsImxlZnRfZGVzY2VuZGFudHMiLCJyaWdodF9kZXNjZW5kYW50cyIsIktNZWFucyIsIksiLCJfSyIsIl9jbHVzdGVyX2NlbnRyb2lkcyIsIl9nZXRfcmFuZG9tX2NlbnRyb2lkcyIsIl9mdXJ0aGVzdF9wb2ludCIsImNhbmRpZGF0ZXMiLCJBZCIsImNsdXN0ZXJfY2VudHJvaWRzIiwicmFuZG9tX3BvaW50IiwiaW5pdF9wb2ludHMiLCJzYW1wbGVfc2l6ZSIsImZ1cnRoZXN0X3BvaW50IiwiX2l0ZXJhdGlvbiIsImNsdXN0ZXJzX2NoYW5nZWQiLCJBaSIsIm1pbl9jbHVzdGVyIiwiX2NvbXB1dGVfY2VudHJvaWQiLCJjbHVzdGVyX2NvdW50ZXIiLCJjaSIsIml0ZXJhdGlvbl9yZXN1bHQiLCJLTWVkb2lkcyIsIl9BIiwiX21heF9pdGVyIiwibG9nMTAiLCJfY2x1c3Rlcl9tZWRvaWRzIiwiX2dldF9yYW5kb21fbWVkb2lkcyIsInhfaiIsIl9uZWFyZXN0X21lZG9pZCIsImluZGV4X25lYXJlc3QiLCJtZWRvaWRzIiwiZmluaXNoIiwiY2FjaGUiLCJ4X28iLCJEZWx0YVREIiwieHMiLCJmaW5kSW5kZXgiLCJkX2oiLCJkaXN0YW5jZV9uZWFyZXN0IiwiZGVsdGFURCIsImRfb2oiLCJfZ2V0X2Rpc3RhbmNlIiwiZF9uIiwiZGlzdGFuY2Vfc2Vjb25kIiwiZF9zIiwibmVhcmVzdCIsInNlY29uZCIsInhfbSIsIm0xIiwibTIiLCJpbmRleF9zZWNvbmQiLCJjbHVzdGVyX21lZG9pZHMiLCJjZWlsIiwiVEQiLCJURDAiLCJTIiwiU19qIiwiU19vIiwiZGVsdGEiLCJPUFRJQ1MiLCJtaW5fcG9pbnRzIiwiX21pbl9wb2ludHMiLCJfb3JkZXJlZF9saXN0IiwiX0RCIiwib3JkZXJlZF9saXN0IiwiREIiLCJjbHVzdGVyX2luZGV4IiwiX2NsdXN0ZXJfaW5kZXgiLCJyZWFjaGFiaWxpdHlfZGlzdGFuY2UiLCJwcm9jZXNzZWQiLCJfZ2V0X25laWdoYm9ycyIsIl9jb3JlX2Rpc3RhbmNlIiwic2VlZHMiLCJfdXBkYXRlIiwiX2V4cGFuZF9jbHVzdGVyIiwiY29yZV9kaXN0YW5jZSIsIm5ld19yZWFjaGFiaWxpdHlfZGlzdGFuY2UiLCJjbHVzdGVyIiwib3V0bGllcnMiLCJnZXRfY2x1c3Rlcl9hZmZpcm1hdGlvbiIsIkxTUCIsImNvbnRyb2xfcG9pbnRzIiwiRFJfcGFyYW1ldGVycyIsIm5jIiwiY19pIiwiWV9DIiwiWEEiLCJBVCIsIkFUQSIsIkFUYiIsIlRvcG9NYXAiLCJfX2xhenlfZGlzdGFuY2VfbWF0cml4IiwiRF9paiIsIl9tYWtlX21pbmltdW1fc3Bhbm5pbmdfdHJlZSIsImRpc2pvaW50X3NldCIsIkYiLCJFIiwic2V0X3UiLCJzZXRfdiIsIl9FbXN0IiwiX19odWxsX2Nyb3NzIiwiYXgiLCJheSIsImJ4IiwiYnkiLCJzeCIsInN5IiwiX19odWxsIiwieDEiLCJ5MSIsIngyIiwieTIiLCJsb3dlciIsInVwcGVyIiwiX19maW5kQW5nbGUiLCJwMXgiLCJwMXkiLCJwMngiLCJwMnkiLCJzaW4iLCJjb3MiLCJ2ZWMiLCJfX2FsaWduX2h1bGwiLCJodWxsIiwidG9wRWRnZSIsImQyIiwidjEiLCJ2MiIsInRyYW5zZm9ybWF0aW9uIiwidHgiLCJ0eSIsIl9fdHJhbnNmb3JtIiwicHgiLCJweSIsIl9fdHJhbnNmb3JtX2NvbXBvbmVudCIsInlPZmZzZXQiLCJjeCIsImN5IiwiX19hbGlnbl9jb21wb25lbnRzIiwicG9pbnRzX3UiLCJwb2ludHNfdiIsImh1bGxfdSIsImh1bGxfdiIsInRfdSIsInRfdiIsIkVtc3QiLCJjb21wb25lbnRzIiwiY29tcG9uZW50X3UiLCJjb21wb25lbnRfdiIsIlNBTU1PTiIsIkRpbVJlZCIsIm1hZ2ljIiwiX19kaXN0YW5jZV9tYXRyaXgiLCJfc3RlcCIsIk1BR0lDIiwiZTEiLCJlMiIsIllpIiwiWWoiLCJkWSIsImRYIiwiZHEiLCJkciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBU2UsbUJBQVVBLEVBQUdDLEdBQ3hCLE9BQU9DLEtBQUtDLEtBQUtDLGtCQUFrQkosRUFBR0M7Ozs7Ozs7O0dDRjNCLG1CQUFVSSxHQUNyQixJQUdJQyxFQUFHQyxFQUhIQyxFQUFJSCxFQUFTSSxPQUNiQyxFQUFNLEVBQ05DLEVBQWUsRUFHbkIsSUFBSyxJQUFJQyxFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQ3JCTixFQUFJRCxFQUFTTyxHQUFLRCxFQUNsQkosRUFBSUcsRUFBTUosRUFDVkssRUFBZUosRUFBSUcsRUFBTUosRUFDekJJLEVBQU1ILEVBRVYsT0FBT0c7Ozs7Ozs7O0dDWkkscUJBQVVMLEdBQ3JCLElBQUlHLEVBQUlILEVBQVNJLE9BQ2JDLEVBQU0sRUFDTkMsRUFBZSxFQUVuQixJQUFLLElBQUlDLEVBQUksRUFBR0EsRUFBSUosSUFBS0ksRUFBRyxDQUN4QixJQUFJQyxFQUFVUixFQUFTTyxHQUNuQkwsRUFBSUcsRUFBTUcsRUFDVlgsS0FBS1ksSUFBSUosSUFBUVIsS0FBS1ks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
