// https://renecutura.eu v0.4.0 Copyright 2022 Rene Cutura
/**
 * Computes the euclidean distance (l<sub>2</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias euclidean
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the euclidean distance between {@link a} and {@link b}.
 */
function euclidean(t,e){return Math.sqrt(euclidean_squared(t,e))}
/**
 * Numerical stable summation with the Kahan summation algorithm.
 * @memberof module:numerical
 * @alias kahan_sum
 * @param {Array} summands - Array of values to sum up.
 * @returns {number} The sum.
 * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm}
 */function kahan_sum(t){let e,r,s=t.length,i=0,n=0;for(let o=0;o<s;++o)e=t[o]-n,r=i+e,n=r-i-e,i=r;return i}
/**
 * Numerical stable summation with the Neumair summation algorithm.
 * @memberof module:numerical
 * @alias neumair_sum
 * @param {Array} summands - Array of values to sum up.
 * @returns {number} The sum.
 * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements}
 */function neumair_sum(t){let e=t.length,r=0,s=0;for(let i=0;i<e;++i){let e=t[i],n=r+e;Math.abs(r)>=Math.abs(e)?s+=r-n+e:s+=e-n+r,r=n}return r+s}
/**
 * Computes the squared euclidean distance (l<sub>2</sub><sup>2</sup>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias euclidean_squared
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the squared euclidean distance between {@link a} and {@link b}.
 */function euclidean_squared(t,e){if(t.length!=e.length)return;let r=t.length,s=new Array(r);for(let i=0;i<r;++i){let r=t[i],n=e[i];s[i]=(r-n)*(r-n)}return neumair_sum(s)}
/**
 * Computes the cosine distance (not similarity) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias cosine
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @example
 * druid.cosine([1,0],[1,1]) == 0.7853981633974484 == π/4
 * @returns {Number} The cosine distance between {@link a} and {@link b}.
 */function cosine(t,e){if(t.length!==e.length)return;let r=t.length,s=0,i=0,n=0;for(let o=0;o<r;++o)s+=t[o]*e[o],i+=t[o]*t[o],n+=e[o]*e[o];return Math.acos(s/(Math.sqrt(i)*Math.sqrt(n)))}
/**
 * Computes the manhattan distance (l<sub>1</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias manhattan
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the manhattan distance between {@link a} and {@link b}.
 */function manhattan(t,e){if(t.length!=e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i]);return s}
/**
 * Computes the chebyshev distance (L<sub>∞</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias chebyshev
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the chebyshev distance between {@link a} and {@link b}.
 */function chebyshev(t,e){if(t.length!=e.length)return;let r=t.length,s=[];for(let i=0;i<r;++i)s.push(Math.abs(t[i]-e[i]));return Math.max(...s)}
/**
 * Computes the canberra distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias canberra
 * @param {Array<Number>} a 
 * @param {Array<Number>} b 
 * @returns {Number} The canberra distance between {@link a} and {@link b}.
 * @see {@link https://en.wikipedia.org/wiki/Canberra_distance}
 */function canberra(t,e){if(t.length!==e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i])/(Math.abs(t[i])+Math.abs(e[i]));return s}
/**
 * Computes the jaccard distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias jaccard
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the jaccard distance between {@link a} and {@link b}.
 */function jaccard(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,i=0;for(let n=0;n<r;++n){const r=0!=t[n],o=0!=e[n];s+=r||o,i+=r&&o}return(s-i)/s}
/**
 * Computes the hamming distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias hamming
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the hamming distance between {@link a} and {@link b}.
 */function hamming(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let i=0;i<r;++i){s+=t[i]!=e[i]}return s/r}
/**
 * Computes the Sokal-Michener distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias sokal_michener
 * @param {Array<Number>} a 
 * @param {Array<Number>} b 
 * @returns {Number} the Sokal-Michener distance between {@link a} and {@link b}.  
 */function sokal_michener(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let i=0;i<r;++i){s+=0!=t[i]!=(0!=e[i])}return 2*s/(r+s)}
/**
 * Computes the yule distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias yule
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the yule distance between {@link a} and {@link b}.
 */function yule(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,i=0,n=0;for(let o=0;o<r;++o){const r=0!=t[o],a=0!=e[o];s+=r&&a,i+=r&&!a,n+=!r&&r}return 0==i||0==n?0:2*i*n/(s*(r-s-i-n)+i*n)}
/**
 *
 * @param {*} A
 * @param {*} k
 * @param {*} distance_matrix
 * @param {*} metric
 */function k_nearest_neighbors(t,e,r=null,s=euclidean){const i=t.shape[0];let n=r??distance_matrix(t,s),o=new Array(i);for(let t=0;t<i;++t)o[t]=Array.from(n.row(t)).map(((e,r)=>({i:t,j:r,distance:e}))).sort(((t,e)=>t.distance-e.distance)).slice(1,e+1);return o}
/**
 * @class
 * @alias Matrix
 * @requires module:numerical/neumair_sum
 */class Matrix{
/**
     * creates a new Matrix. Entries are stored in a Float64Array.
     * @constructor
     * @memberof module:matrix
     * @alias Matrix
     * @param {number} rows - The amount of rows of the matrix.
     * @param {number} cols - The amount of columns of the matrix.
     * @param {(function|string|number)} value=0 - Can be a function with row and col as parameters, a number, or "zeros", "identity" or "I", or "center".
     *  - **function**: for each entry the function gets called with the parameters for the actual row and column.
     *  - **string**: allowed are
     *      - "zero", creates a zero matrix.
     *      - "identity" or "I", creates an identity matrix.
     *      - "center", creates an center matrix.
     *  - **number**: create a matrix filled with the given value.
     * @example
     *
     * let A = new Matrix(10, 10, () => Math.random()); //creates a 10 times 10 random matrix.
     * let B = new Matrix(3, 3, "I"); // creates a 3 times 3 identity matrix.
     * @returns {Matrix} returns a {@link rows} times {@link cols} Matrix filled with {@link value}.
     */
constructor(t=null,e=null,r=null){if(this._rows=t,this._cols=e,this._data=null,t&&e){if(!r)return this._data=new Float64Array(t*e),this;if("function"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}if("string"==typeof r){if("zeros"===r)return new Matrix(t,e,0);if("identity"===r||"I"===r){this._data=new Float64Array(t*e);for(let r=0;r<t;++r)this._data[r*e+r]=1;return this}if("center"===r&&t==e){this._data=new Float64Array(t*e),r=(e,r)=>(e===r?1:0)-1/t;for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}}if("number"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r;return this}}return this}
/**
     * Creates a Matrix out of {@link A}.
     * @param {(Matrix|Array|Float64Array|number)} A - The matrix, array, or number, which should converted to a Matrix.
     * @param {"row"|"col"|"diag"} [type = "row"] - If {@link A} is a Array or Float64Array, then type defines if it is a row- or a column vector.
     * @returns {Matrix}
     *
     * @example
     * let A = Matrix.from([[1, 0], [0, 1]]); //creates a two by two identity matrix.
     * let S = Matrix.from([1, 2, 3], "diag"); // creates a 3 by 3 matrix with 1, 2, 3 on its diagonal. [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
     */static from(t,e="row"){if(t instanceof Matrix)return t.clone();if(!(Array.isArray(t)||t instanceof Float64Array)){if("number"==typeof t)return new Matrix(1,1,t);throw new Error("error")}{let r=t.length;if(0===r)throw new Error("Array is empty");
// 1d
if(!(Array.isArray(t[0])||t[0]instanceof Float64Array)){if("row"===e)return new Matrix(1,r,((e,r)=>t[r]));
// 2d
if("col"===e)return new Matrix(r,1,(e=>t[e]));if("diag"===e)return new Matrix(r,r,((e,r)=>e==r?t[e]:0));throw new Error("1d array has NaN entries")}if(Array.isArray(t[0])||t[0]instanceof Float64Array){let e=t[0].length;for(let s=0;s<r;++s)if(t[s].length!==e)throw new Error("various array lengths");return new Matrix(r,e,((e,r)=>t[e][r]))}}}
/**
     * Returns the {@link row}<sup>th</sup> row from the Matrix.
     * @param {Number} row
     * @returns {Float64Array}
     */row(t){const e=this.values,r=this._cols;return e.subarray(t*r,(t+1)*r)}
/**
     * Returns an generator yielding each row of the Matrix.
     * @yields {Float64Array}
     */*iterate_rows(){const t=this._cols,e=this._rows,r=this.values;for(let s=0;s<e;++s)yield r.subarray(s*t,(s+1)*t)}
/**
     * Makes a {@link Matrix} object an iterable object.
     * @yields {Float64Array}
     */*[Symbol.iterator](){for(const t of this.iterate_rows())yield t}
/**
     * Sets the entries of {@link row}<sup>th</sup> row from the Matrix to the entries from {@link values}.
     * @param {int} row
     * @param {Array} values
     * @returns {Matrix}
     */set_row(t,e){let r=this._cols;if(Array.isArray(e)&&e.length===r){let s=t*r;for(let t=0;t<r;++t)this.values[s+t]=e[t]}else if(e instanceof Matrix&&e.shape[1]===r&&1===e.shape[0]){let s=t*r;for(let t=0;t<r;++t)this.values[s+t]=e._data[t]}return this}
/**
     * Returns the {@link col}<sup>th</sup> column from the Matrix.
     * @param {int} col
     * @returns {Array}
     */col(t){let e=new Float64Array(this._rows);for(let r=0;r<this._rows;++r)e[r]=this.values[r*this._cols+t];return e}
/**
     * Returns the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix.
     * @param {int} row
     * @param {int} col
     * @returns {float64}
     */entry(t,e){return this.values[t*this._cols+e]}
/**
     * Sets the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix to the given {@link value}.
     * @param {int} row
     * @param {int} col
     * @param {float64} value
     * @returns {Matrix}
     */set_entry(t,e,r){return this.values[t*this._cols+e]=r,this}
/**
     * Returns a new transposed Matrix.
     * @returns {Matrix}
     */transpose(){return new Matrix(this._cols,this._rows,((t,e)=>this.entry(e,t)))}
/**
     * Returns a new transposed Matrix. Short-form of {@function transpose}.
     * @returns {Matrix}
     */get T(){return this.transpose()}
/**
     * Returns the inverse of the Matrix.
     * @returns {Matrix}
     */inverse(){const t=this._rows,e=this._cols;let r=new Matrix(t,2*e,((t,r)=>r>=e?t===r-e?1:0:this.entry(t,r))),s=0,i=0;for(;s<t&&i<e;){var n=0;let o=-1/0;for(let e=s;e<t;++e){let t=Math.abs(r.entry(e,i));o<t&&(n=e,o=t)}if(0==r.entry(n,i))i++;else{
// swap rows
for(let t=0;t<2*e;++t){let e=r.entry(s,t),i=r.entry(n,t);r.set_entry(s,t,e),r.set_entry(n,t,i)}for(let n=s+1;n<t;++n){let t=r.entry(n,i)/r.entry(s,i);r.set_entry(n,i,0);for(let o=i+1;o<2*e;++o)r.set_entry(n,o,r.entry(n,o)-r.entry(s,o)*t)}s++,i++}}for(let s=0;s<t;++s){let t=r.entry(s,s);for(let i=s;i<2*e;++i)r.set_entry(s,i,r.entry(s,i)/t)}for(let s=t-1;s>=0;--s){let t=r.entry(s,s);for(let i=0;i<s;i++){let n=r.entry(i,s)/t;for(let t=i;t<2*e;++t){let e=r.entry(i,t);e-=r.entry(s,t)*n,r.set_entry(i,t,e)}}}return new Matrix(t,e,((t,s)=>r.entry(t,s+e)))}
/**
     * Returns the dot product. If {@link B} is an Array or Float64Array then an Array gets returned. If {@link B} is a Matrix then a Matrix gets returned.
     * @param {(Matrix|Array|Float64Array)} B the right side
     * @returns {(Matrix|Array)}
     */dot(t){if(t instanceof Matrix){let e=this;if(e.shape[1]!==t.shape[0])throw new Error(`A.dot(B): A is a ${e.shape.join(" ⨯ ")}-Matrix, B is a ${t.shape.join(" ⨯ ")}-Matrix: \n                A has ${e.shape[1]} cols and B ${t.shape[0]} rows. \n                Must be equal!`);let r=e.shape[1];return new Matrix(e.shape[0],t.shape[1],((s,i)=>{const n=e.row(s),o=t.col(i);let a=0;for(let t=0;t<r;++t)a+=n[t]*o[t];return a}))}if(Array.isArray(t)||t instanceof Float64Array){let e=this._rows;if(t.length!==e)throw new Error(`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`);let r=new Array(e);for(let s=0;s<e;++s)r[s]=neumair_sum(this.row(s).map((e=>e*t[s])));return r}throw new Error("B must be Matrix or Array")}
/**
     * Computes the outer product from {@link this} and {@link B}.
     * @param {Matrix} B
     * @returns {Matrix}
     */outer(t){let e=this,r=e._data.length;if(r!=t._data.length)return;let s=new Matrix;return s.shape=[r,r,(r,i)=>r<=i?e._data[r]*t._data[i]:s.entry(i,r)],s}
/**
     * Appends matrix {@link B} to the matrix.
     * @param {Matrix} B - matrix to append.
     * @param {"horizontal"|"vertical"|"diag"} [type = "horizontal"] - type of concatenation.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 1], [1, 1]]); // 2 by 2 matrix filled with ones.
     * let B = Matrix.from([[2, 2], [2, 2]]); // 2 by 2 matrix filled with twos.
     *
     * A.concat(B, "horizontal"); // 2 by 4 matrix. [[1, 1, 2, 2], [1, 1, 2, 2]]
     * A.concat(B, "vertical"); // 4 by 2 matrix. [[1, 1], [1, 1], [2, 2], [2, 2]]
     * A.concat(B, "diag"); // 4 by 4 matrix. [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 2, 2], [0, 0, 2, 2]]
     */concat(t,e="horizontal"){const r=this,[s,i]=r.shape,[n,o]=t.shape;if("horizontal"==e){if(s!=n)throw new Error(`A.concat(B, "horizontal"): A and B need same number of rows, A has ${s} rows, B has ${n} rows.`);const e=new Matrix(s,i+o,"zeros");return e.set_block(0,0,r),e.set_block(0,i,t),e}if("vertical"==e){if(i!=o)throw new Error(`A.concat(B, "vertical"): A and B need same number of columns, A has ${i} columns, B has ${o} columns.`);const e=new Matrix(s+n,i,"zeros");return e.set_block(0,0,r),e.set_block(s,0,t),e}if("diag"==e){const e=new Matrix(s+n,i+o,"zeros");return e.set_block(0,0,r),e.set_block(s,i,t),e}throw new Error(`type must be "horizontal" or "vertical", but type is ${e}!`)}
/**
     * Writes the entries of B in A at an offset position given by {@link offset_row} and {@link offset_col}.
     * @param {int} offset_row
     * @param {int} offset_col
     * @param {Matrix} B
     * @returns {Matrix}
     */set_block(t,e,r){let[s,i]=r.shape;for(let n=0;n<s;++n)if(!(n>this._rows))for(let s=0;s<i;++s)s>this._cols||this.set_entry(n+t,s+e,r.entry(n,s));return this}
/**
     * Extracts the entries from the {@link start_row}<sup>th</sup> row to the {@link end_row}<sup>th</sup> row, the {@link start_col}<sup>th</sup> column to the {@link end_col}<sup>th</sup> column of the matrix.
     * If {@link end_row} or {@link end_col} is empty, the respective value is set to {@link this.rows} or {@link this.cols}.
     * @param {Number} start_row
     * @param {Number} start_col
     * @param {Number} [end_row = null]
     * @param {Number} [end_col = null]
     * @returns {Matrix} Returns a end_row - start_row times end_col - start_col matrix, with respective entries from the matrix.
     * @example
     *
     * let A = Matrix.from([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); // a 3 by 3 matrix.
     *
     * A.get_block(1, 1); // [[5, 6], [8, 9]]
     * A.get_block(0, 0, 1, 1); // [[1]]
     * A.get_block(1, 1, 2, 2); // [[5]]
     * A.get_block(0, 0, 2, 2); // [[1, 2], [4, 5]]
     */get_block(t,e,r=null,s=null){const[i,n]=this.shape;if(s=s??n,(r=r??i)<=t||s<=e)throw new Error(`\n                end_row must be greater than start_row, and \n                end_col must be greater than start_col, but\n                end_row = ${r}, start_row = ${t}, end_col = ${s}, and start_col = ${e}!`);const o=new Matrix(r-t,s-e,"zeros");for(let i=t,n=0;i<r;++i,++n)for(let t=e,r=0;t<s;++t,++r)o.set_entry(n,r,this.entry(i,t));return o;
//return new Matrix(end_row - start_row, end_col - start_col, (i, j) => this.entry(i + start_row, j + start_col));
}
/**
     * Returns a new array gathering entries defined by the indices given by argument.
     * @param {Array<Number>} row_indices - Array consists of indices of rows for gathering entries of this matrix
     * @param {Array<Number>} col_indices  - Array consists of indices of cols for gathering entries of this matrix
     * @returns {Matrix}
     */gather(t,e){const r=t.length,s=e.length,i=new Matrix(r,s);for(let s=0;s<r;++s){const n=t[s];for(let t=0;t<r;++t){const r=e[t];i.set_entry(s,t,this.entry(n,r))}}return i}
/**
     * Applies a function to each entry of the matrix.
     * @private
     * @param {function} f function takes 2 parameters, the value of the actual entry and a value given by the function {@link v}. The result of {@link f} gets writen to the Matrix.
     * @param {function} v function takes 2 parameters for row and col, and returns a value witch should be applied to the colth entry of the rowth row of the matrix.
     */_apply_array(t,e){const r=this.values,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o;r[i]=t(r[i],e(n,o))}}return this}_apply_rowwise_array(t,e){return this._apply_array(e,((e,r)=>t[r]))}_apply_colwise_array(t,e){const r=this.values,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o;r[i]=e(r[i],t[n])}}return this}_apply(t,e){let r=this.values;if(t instanceof Matrix){let[s,i]=t.shape,[n,o]=this.shape;if(1===s){if(o!==i)throw new Error("cols !== value_cols");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(0,i))}else if(1===i){if(n!==s)throw new Error("rows !== value_rows");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,0))}else{if(n!=s||o!=i)throw new Error("error");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,i))}}else if(Array.isArray(t)){let s=this._rows,i=this._cols;if(t.length===s)for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[n]);else{if(t.length!==i)throw new Error("error");for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[s])}}else for(let s=0,i=this._rows*this._cols;s<i;++s)r[s]=e(r[s],t);return this}
/**
     * Clones the Matrix.
     * @returns {Matrix}
     */clone(){let t=new Matrix;return t._rows=this._rows,t._cols=this._cols,t._data=this.values.slice(0),t}
/**
     * Entrywise multiplication with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.mult(2); // [[2, 4], [6, 8]];
     * A.mult(B); // [[1, 4], [9, 16]];
     */mult(t){return this.clone()._apply(t,((t,e)=>t*e))}
/**
     * Entrywise division with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.divide(2); // [[0.5, 1], [1.5, 2]];
     * A.divide(B); // [[1, 1], [1, 1]];
     */divide(t){return this.clone()._apply(t,((t,e)=>t/e))}
/**
     * Entrywise addition with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.add(2); // [[3, 4], [5, 6]];
     * A.add(B); // [[2, 4], [6, 8]];
     */add(t){return this.clone()._apply(t,((t,e)=>t+e))}
/**
     * Entrywise subtraction with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.sub(2); // [[-1, 0], [1, 2]];
     * A.sub(B); // [[0, 0], [0, 0]];
     */sub(t){return this.clone()._apply(t,((t,e)=>t-e))}
/**
     * Returns the number of rows and columns of the Matrix.
     * @returns {Array} An Array in the form [rows, columns].
     */get shape(){return[this._rows,this._cols]}
/**
     * Returns the matrix in the given shape with the given function which returns values for the entries of the matrix.
     * @param {Array} parameter - takes an Array in the form [rows, cols, value], where rows and cols are the number of rows and columns of the matrix, and value is a function which takes two parameters (row and col) which has to return a value for the colth entry of the rowth row.
     * @returns {Matrix}
     */set shape([t,e,r=(()=>0)]){this._rows=t,this._cols=e,this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}
/**
     * Returns the Matrix as a Array of Float64Arrays.
     * @returns {Array<Float64Array>}
     */get to2dArray(){const t=[];for(const e of this.iterate_rows())t.push(e);return t}
/**
     * Returns the Matrix as a Array of Arrays.
     * @returns {Array<Array>}
     */get asArray(){const t=[];for(const e of this.iterate_rows())t.push(Array.from(e));return t}
/**
     * Returns the diagonal of the Matrix.
     * @returns {Float64Array}
     */get diag(){const t=this._rows,e=this._cols,r=Math.min(t,e);let s=new Float64Array(r);for(let t=0;t<r;++t)s[t]=this.entry(t,t);return s}
/**
     * Returns the mean of all entries of the Matrix.
     * @returns {Number}
     */get mean(){return this.sum/(this._rows*this._cols)}
/**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Number}
     */get sum(){return neumair_sum(this.values)}
/**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Float64Array}
     */get values(){return this._data}
/**
     * Returns the mean of each row of the matrix.
     * @returns {Float64Array}
     */get meanRows(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:e});for(let i=0;i<e;++i){s[i]=0;for(let e=0;e<r;++e)s[i]+=t[i*r+e];s[i]/=r}return s}
/** Returns the mean of each column of the matrix.
     * @returns {Float64Array}
     */get meanCols(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:r});for(let i=0;i<r;++i){s[i]=0;for(let n=0;n<e;++n)s[i]+=t[n*r+i];s[i]/=e}return s}
/**
     * Solves the equation {@link A}x = {@link b} using the conjugate gradient method. Returns the result x.
     * @param {Matrix} A - Matrix
     * @param {Matrix} b - Matrix
     * @param {Randomizer} [randomizer=null]
     * @param {Number} [tol=1e-3]
     * @returns {Matrix}
     */static solve_CG(t,e,r,s=.001){null===r&&(r=new Randomizer);const i=t.shape[0],n=e.shape[1];let o=new Matrix(i,0);for(let a=0;a<n;++a){const n=Matrix.from(e.col(a)).T;let h=new Matrix(i,1,(()=>r.random)),l=n.sub(t.dot(h)),_=l.clone();do{const e=t.dot(_),r=l.T.dot(l).entry(0,0)/_.T.dot(e).entry(0,0);h=h.add(_.mult(r));const s=l.sub(e.mult(r)),i=s.T.dot(s).entry(0,0)/l.T.dot(l).entry(0,0);_=s.add(_.mult(i)),l=s}while(Math.abs(l.mean)>s);o=o.concat(h,"horizontal")}return o}
/**
     * Solves the equation {@link A}x = {@link b}. Returns the result x.
     * @param {Matrix} A - Matrix or LU Decomposition
     * @param {Matrix} b - Matrix
     * @returns {Matrix}
     */static solve(t,e){let{L:r,U:s}="L"in t&&"U"in t?t:Matrix.LU(t),i=r.shape[0],n=e.clone();
// forward
for(let t=0;t<i;++t){for(let e=0;e<t-1;++e)n.set_entry(0,t,n.entry(0,t)-r.entry(t,e)*n.entry(1,e));n.set_entry(0,t,n.entry(0,t)/r.entry(t,t))}
// backward
for(let t=i-1;t>=0;--t){for(let e=i-1;e>t;--e)n.set_entry(0,t,n.entry(0,t)-s.entry(t,e)*n.entry(0,e));n.set_entry(0,t,n.entry(0,t)/s.entry(t,t))}return n}
/**
     * {@link L}{@link U} decomposition of the Matrix {@link A}. Creates two matrices, so that the dot product LU equals A.
     * @param {Matrix} A
     * @returns {{L: Matrix, U: Matrix}} result - Returns the left triangle matrix {@link L} and the upper triangle matrix {@link U}.
     */static LU(t){const e=t.shape[0],r=new Matrix(e,e,"zeros"),s=new Matrix(e,e,"identity");for(let i=0;i<e;++i){for(let n=i;n<e;++n){let e=0;for(let t=0;t<i;++t)e+=r.entry(n,t)*s.entry(t,i);r.set_entry(n,i,t.entry(n,i)-e)}for(let n=i;n<e;++n){if(0===r.entry(i,i))return;let e=0;for(let t=0;t<i;++t)e+=r.entry(i,t)*s.entry(t,n);s.set_entry(i,n,(t.entry(i,n)-e)/r.entry(i,i))}}return{L:r,U:s}}
/**
     * Computes the determinante of {@link A}, by using the LU decomposition of {@link A}.
     * @param {Matrix} A
     * @returns {Number} det - Returns the determinate of the Matrix {@link A}.
     */static det(t){const e=t.shape[0],{L:r,U:s}=Matrix.LU(t),i=r.diag,n=s.diag;let o=i[0]*n[0];for(let t=1;t<e;++t)o*=i[t]*n[t];return o}
/**
     * Computes the {@link k} components of the SVD decomposition of the matrix {@link M}
     * @param {Matrix} M
     * @param {int} [k=2]
     * @returns {{U: Matrix, Sigma: Matrix, V: Matrix}}
     */static SVD(t,e=2){const r=t.T;let s=r.dot(t),i=t.dot(r),{eigenvectors:n,eigenvalues:o}=simultaneous_poweriteration(s,e),{eigenvectors:a}=simultaneous_poweriteration(i,e);return{U:a,Sigma:o.map((t=>Math.sqrt(t))),V:n};
//Algorithm 1a: Householder reduction to bidiagonal form:
/* const [m, n] = A.shape;
        let U = new Matrix(m, n, (i, j) => i == j ? 1 : 0);
        console.log(U.to2dArray)
        let V = new Matrix(n, m, (i, j) => i == j ? 1 : 0);
        console.log(V.to2dArray)
        let B = Matrix.bidiagonal(A.clone(), U, V);
        console.log(U,V,B)
        return { U: U, "Sigma": B, V: V }; */}}
/**
 * Computes the distance matrix of datamatrix {@link A}.
 * @param {Matrix} A - Matrix
 * @param {Function} [metric=euclidean] - The diistance metric.
 * @returns {Matrix} D - The distance matrix of {@link A}.
 */function distance_matrix(t,e=euclidean){let r=t.shape[0];const s=new Matrix(r,r);for(let i=0;i<r;++i){const n=t.row(i);for(let o=i+1;o<r;++o){const r=e(n,t.row(o));s.set_entry(i,o,r),s.set_entry(o,i,r)}}return s}
/**
 * @memberof module:matrix
 * Creates an Array containing {@link number} numbers from {@link start} to {@link end}. If <code>{@link number} = null</null>
 * @param {Number} start
 * @param {Number} end
 * @param {Number} [number = null]
 * @returns {Array}
 */function linspace(t,e,r=null){if(r||(r=Math.max(Math.round(e-t)+1,1)),r<2)return 1===r?[t]:[];let s=new Array(r);for(let i=r-=1;i>=0;--i)s[i]=(i*e+(r-i)*t)/r;return s}
//import { neumair_sum } from "../numerical/index";
function norm(t,e=euclidean){
//export default function(vector, p=2, metric = euclidean) {
let r=null;if(t instanceof Matrix){let[e,s]=t.shape;if(1===e)r=t.row(0);else{if(1!==s)throw"matrix must be 1d!";r=t.col(0)}}else r=t;let s=r.length,i=new Array(s);return i.fill(0),e(r,i);
/*let v;
    if (vector instanceof Matrix) {
        let [ rows, cols ] = v.shape;
        if (rows === 1) {
            v = vector.row(0);
        } else if (cols === 1) {
            v = vector.col(0);
        } else {
            throw "matrix must be 1d"
        }
    } else {
        v = vector;
    }
    return Math.pow(neumair_sum(v.map(e => Math.pow(e, p))), 1 / p)*/}
/**
 * @class
 * @memberof module:utils
 * @alias Randomizer
 */class Randomizer{
/**
     * Mersenne Twister random number generator.
     * @constructor
     * @param {Number} [_seed=new Date().getTime()] - The seed for the random number generator. If <code>_seed == null</code> then the actual time gets used as seed.
     * @see https://github.com/bmurray7/mersenne-twister-examples/blob/master/javascript-mersenne-twister.js
     */
constructor(t){return this._N=624,this._M=397,this._MATRIX_A=2567483615,this._UPPER_MASK=2147483648,this._LOWER_MASK=2147483647,this._mt=new Array(this._N),this._mti=this.N+1,this.seed=t||(new Date).getTime(),this}set seed(t){this._seed=t;let e=this._mt;for(e[0]=t>>>0,this._mti=1;this._mti<this._N;this._mti+=1){let t=this._mti,r=e[t-1]^e[t-1]>>>30;e[t]=(1812433253*((4294901760&r)>>>16)<<16)+1812433253*(65535&r)+t,e[t]>>>=0}}
/**
     * Returns the seed of the random number generator.
     * @returns {Number} - The seed.
     */get seed(){return this._seed}
/**
     * Returns a float between 0 and 1.
     * @returns {Number} - A random number between [0, 1]
     */get random(){return this.random_int*(1/4294967296)}
/**
     * Returns an integer between 0 and MAX_INTEGER.
     * @returns {Integer} - A random integer.
     */get random_int(){let t,e=new Array(0,this._MATRIX_A);if(this._mti>=this._N){let r,s=this._N-this._M,i=this._M-this._N;
/* if (this._mti == this._N + 1) {
                this.seed = 5489;
            } */for(r=0;r<s;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+this._M]^t>>>1^e[1&t];for(;r<this._N-1;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+i]^t>>>1^e[1&t];t=this._mt[this._N-1]&this._UPPER_MASK|this._mt[0]&this._LOWER_MASK,this._mt[this._N-1]=this._mt[this._M-1]^t>>>1^e[1&t],this._mti=0}return t=this._mt[this._mti+=1],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,t^=t>>>18,t>>>0}
/**
     * Returns samples from an input Matrix or Array.
     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.
     * @param {Number} n - The number of samples.
     * @returns {Array} - A random selection form {@link A} of {@link n} samples.
     */choice(t,e){if(t instanceof Matrix){let r=t.shape[0];if(e>r)throw new Error("n bigger than A!");let s=new Array(e),i=linspace(0,r-1);for(let t=0,r=i.length;t<e;++t,--r){let e=this.random_int%r;s[t]=i.splice(e,1)[0]}return s.map((e=>t.row(e)))}if(Array.isArray(t)||t instanceof Float64Array){let r=t.length;if(e>r)throw new Error("n bigger than A!");let s=new Array(e),i=linspace(0,r-1);for(let t=0,r=i.length;t<e;++t,--r){let e=this.random_int%r;s[t]=i.splice(e,1)[0]}return s.map((e=>t[e]))}}
/**
     * @static
     * Returns samples from an input Matrix or Array.
     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.
     * @param {Number} n - The number of samples.
     * @param {Number} seed - The seed for the random number generator.
     * @returns {Array} - A random selection form {@link A} of {@link n} samples.
     */static choice(t,e,r=1212){return new Randomizer(r).choice(t,e);
/* let rows = A.shape[0];
        if (n > rows) {
            throw new Error("n bigger than A!");
        }
        let rand = new Randomizer(seed);
        let sample = new Array(n);
        let index_list = linspace(0, rows - 1);
        for (let i = 0, l = index_list.length; i < n; ++i, --l) {
            let random_index = rand.random_int % l;
            sample[i] = index_list.splice(random_index, 1)[0];
        }
        //return result;
        //return new Matrix(n, cols, (row, col) => A.entry(sample[row], col))
        return sample.map((d) => A.row(d)); */}}
/**
 * Returns maximum in Array {@link values}.
 * @memberof module:utils
 * @alias max
 * @param {Array} values 
 * @returns {Number}
 */function max(t){let e;for(const r of t)null!=r&&(e<r||void 0===e&&r>=r)&&(e=r);return e}
/**
 * Returns maximum in Array {@link values}.
 * @memberof module:utils
 * @alias min
 * @param {Array} values
 * @returns {Number}
 */function min(t){let e;for(const r of t)null!=r&&(e>r||void 0===e&&r<=r)&&(e=r);return e}
/**
 * @class
 * @alias Heap
 */class Heap{
/**
     * A heap is a datastructure holding its elements in a specific way, so that the top element would be the first entry of an ordered list.
     * @constructor
     * @memberof module:datastructure
     * @alias Heap
     * @param {Array=} elements - Contains the elements for the Heap. {@link elements} can be null.
     * @param {Function} [accessor = (d) => d] - Function returns the value of the element.
     * @param {("min"|"max"|Function)} [comparator = "min"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. ("min" for a Min-Heap, "max" for a Max_heap)
     * @returns {Heap}
     * @see {@link https://en.wikipedia.org/wiki/Binary_heap}
     */
constructor(t=null,e=(t=>t),r="min"){return t?Heap.heapify(t,e,r):(this._accessor=e,this._container=[],this._comparator="min"==r?(t,e)=>t<e:"max"==r?(t,e)=>t>e:r,this)}
/**
     * Creates a Heap from an Array
     * @param {Array|Set} elements - Contains the elements for the Heap.
     * @param {Function=} [accessor = (d) => d] - Function returns the value of the element.
     * @param {(String=|Function)} [comparator = "min"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. ("min" for a Min-Heap, "max" for a Max_heap)
     * @returns {Heap}
     */static heapify(t,e=(t=>t),r="min"){const s=new Heap(null,e,r),i=s._container;for(const r of t)i.push({element:r,value:e(r)});for(let e=Math.floor(t.length/2-1);e>=0;--e)s._heapify_down(e);return s}
/**
     * Swaps elements of container array.
     * @private
     * @param {Number} index_a 
     * @param {Number} index_b 
     */_swap(t,e){const r=this._container;[r[e],r[t]]=[r[t],r[e]]}
/**
     * @private
     */_heapify_up(){const t=this._container;let e=t.length-1;for(;e>0;){let r=Math.floor((e-1)/2);if(!this._comparator(t[e].value,t[r].value))break;this._swap(r,e),e=r}}
/**
     * Pushes the element to the heap.
     * @param {} element
     * @returns {Heap}
     */push(t){const e={element:t,value:this._accessor(t)};
//const node = new Node(element, value);
return this._container.push(e),this._heapify_up(),this}
/**
     * @private
     * @param {Number} [start_index = 0] 
     */_heapify_down(t=0){const e=this._container,r=this._comparator,s=e.length;let i=2*t+1,n=2*t+2,o=t;if(o>s)throw"index higher than length";i<s&&r(e[i].value,e[o].value)&&(o=i),n<s&&r(e[n].value,e[o].value)&&(o=n),o!==t&&(this._swap(t,o),this._heapify_down(o))}
/**
     * Removes and returns the top entry of the heap.
     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).
     */pop(){const t=this._container;if(0===t.length)return null;if(1===t.length)return t.pop();this._swap(0,t.length-1);const e=t.pop();return this._heapify_down(),e}
/**
     * Returns the top entry of the heap without removing it.
     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).
     */get first(){return this._container.length>0?this._container[0]:null}
/**
     * Yields the raw data
     * @yields {Object} Object consists of the element and its value (computed by {@link accessor}).
     */*iterate(){for(let t=0,e=this._container.length;t<e;++t)yield this._container[t].element}
/**
     * Returns the heap as ordered array.
     * @returns {Array} Array consisting the elements ordered by {@link comparator}.
     */toArray(){return this.data().sort(((t,e)=>this._comparator(t,e)?-1:0))}
/**
     * Returns elements of container array.
     * @returns {Array} Array consisting the elements.
     */data(){return this._container.map((t=>t.element))}
/**
     * Returns the container array.
     * @returns {Array} The container array.
     */raw_data(){return this._container}
/**
     * The size of the heap.
     * @returns {Number}
     */get length(){return this._container.length}
/**
     * Returns false if the the heap has entries, true if the heap has no entries.
     * @returns {Boolean}
     */get empty(){return 0===this.length}}
/**
 * @class
 * @alias DisjointSet
 * @see {@link https://en.wikipedia.org/wiki/Disjoint-set_data_structure}
 */class DisjointSet{
/**
     * @constructor
     * @alias DisjointSet
     * @memberof module:datastructure
     * @param {Array=} elements 
     * @returns {DisjointSet}
     */
constructor(t=null){if(this._list=new Set,t)for(const e of t)this.make_set(e);return this}make_set(t){const e=this._list;return e.has(t)||(e.add(t),t.__disjoint_set={},t.__disjoint_set.parent=t,t.__disjoint_set.children=new Set([t]),t.__disjoint_set.size=1),this}find(t){return this._list.has(t)?t.__disjoint_set.parent!==t?(t.__disjoint_set.children.add(...t),t.__disjoint_set.parent=this.find(t.__disjoint_set.parent),t.__disjoint_set.parent):t:null}union(t,e){let r=this.find(t),s=this.find(e);return r===s||(r.__disjoint_set.size<s.__disjoint_set.size&&([r,s]=[s,r]),s.__disjoint_set.parent=r,
// keep track of children?
s.__disjoint_set.children.forEach(r.__disjoint_set.children.add,r.__disjoint_set.children),r.__disjoint_set.size+=s.__disjoint_set.size),this}}
/**
 * @class
 * @alias BallTree
 */class BallTree{
/**
     * Generates a BallTree with given {@link elements}.
     * @constructor
     * @memberof module:knn
     * @alias BallTree
     * @param {Array=} elements - Elements which should be added to the BallTree
     * @param {Function} [metric = euclidean] metric to use: (a, b) => distance
     * @see {@link https://en.wikipedia.org/wiki/Ball_tree}
     * @see {@link https://github.com/invisal/noobjs/blob/master/src/tree/BallTree.js}
     * @returns {BallTree}
     */
constructor(t=null,e=euclidean){return this._Node=class{constructor(t,e=null,r=null,s=null){this.pivot=t,this.child1=e,this.child2=r,this.radius=s}},this._Leaf=class{constructor(t){this.points=t}},this._metric=e,t&&this.add(t),this}
/**
     * 
     * @param {Array<*>} elements - new elements.
     * @returns {BallTree}
     */add(t){return t=t.map(((t,e)=>({index:e,element:t}))),this._root=this._construct(t),this}
/**
     * @private
     * @param {Array<*>} elements 
     * @returns {Node} root of balltree.
     */_construct(t){if(1===t.length)return new this._Leaf(t);{let e,r=this._greatest_spread(t),s=t.sort(((t,e)=>t.element[r]-e.element[r])),i=s.length,n=Math.floor(i/2),o=t[n],a=s.slice(0,n),h=s.slice(n,i),l=Math.max(...t.map((t=>this._metric(o.element,t.element))));return e=a.length>0&&h.length>0?new this._Node(o,this._construct(a),this._construct(h),l):new this._Leaf(t),e}}
/**
     * @private
     * @param {Node} B 
     * @returns {Number}
     */_greatest_spread(t){let e=t[0].element.length,r=new Array(e);for(let t=0;t<e;++t)r[t]=[1/0,-1/0];let s=t.reduce(((t,r)=>{for(let s=0;s<e;++s)t[s][0]=Math.min(t[s][0],r.element[s]),t[s][1]=Math.max(t[s][1],r.element[s]);return t}),r);s=s.map((t=>t[1]-t[0]));let i=0;for(let t=0;t<e;++t)i=s[t]>s[i]?t:i;return i}
/**
     * 
     * @param {*} t - query element.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.
     */search(t,e=5){return this._search(t,e,new Heap(null,(e=>this._metric(e.element,t)),"max"),this._root)}
/**
     * @private
     * @param {*} t - query element.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @param {Heap} Q - Heap consists of the currently found {@link k} nearest neighbors.
     * @param {Node|Leaf} B 
     */_search(t,e,r,s){
// B is Node
if(r.length>=e&&s.pivot&&s.radius&&this._metric(t,s.pivot.element)-s.radius>=r.first.value)return r;
// B is leaf
if(s.child1&&this._search(t,e,r,s.child1),s.child2&&this._search(t,e,r,s.child2),s.points)for(let t=0,i=s.points.length;t<i;++t){let i=s.points[t];e>r.length?r.push(i):(r.push(i),r.pop())}return r}}
/**
 * @class
 * @alias KNN
 */class KNN{
/**
     * Generates a KNN list with given {@link elements}.
     * @constructor
     * @memberof module:knn
     * @alias KNN
     * @param {Array=} elements - Elements which should be added to the KNN list
     * @param {Function|"precomputed"} [metric = euclidean] metric is either precomputed or a function to use: (a, b) => distance
     * @returns {KNN}
     */
constructor(t=null,e=euclidean){this._metric=e,this._elements=t instanceof Matrix?t:Matrix.from(t);const r=this._elements.shape[0];this._D="precomputed"===e?this._elements.clone():distance_matrix(this._elements,e),this.KNN=[];for(let t=0;t<r;++t){const e=this._D.row(t),s=new Heap(null,(t=>t.value),"min");for(let t=0;t<r;++t)s.push({value:e[t],index:t});this.KNN.push(s)}}
/**
     * 
     * @param {Array|Number} t - query element or index.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.
     */search(t,e=5){const r=this._metric,s=this.KNN;let i;if(Array.isArray(t)){if("precomputed"==this._metric)throw"Search by query element is only possible when not using a precomputed distance matrix!";const e=this._elements,n=s.length;let o=null,a=1/0;for(let s=0;s<n;++s){const i=r(t,e.row(s));i<a&&(o=s,a=i)}i=s[o]}else Number.isInteger(t)&&(i=s[t]);let n=[];for(let t=0;t<e;++t)n.push(i.pop());return n.forEach((t=>i.push(t.element))),n}}
/**
 * Computes the QR Decomposition of the Matrix {@link A} using Gram-Schmidt process.
 * @memberof module:linear_algebra
 * @alias qr
 * @param {Matrix} A
 * @returns {{R: Matrix, Q: Matrix}}
 * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_the_Gram%E2%80%93Schmidt_process}
 */function qr(t){const[e,r]=t.shape,s=new Matrix(e,r,"identity"),i=new Matrix(r,r,0);for(let n=0;n<r;++n){let r=t.col(n);for(let t=0;t<n;++t){const e=s.col(t),o=neumair_sum(e.map(((t,e)=>t*r[e])));i.set_entry(t,n,o),r=r.map(((t,r)=>t-o*e[r]))}const o=norm(r,euclidean);for(let t=0;t<e;++t)s.set_entry(t,n,r[t]/o);i.set_entry(n,n,o)}return{R:i,Q:s}}
/**
 * Computes the {@link k} biggest Eigenvectors and Eigenvalues from Matrix {@link A} with the QR-Algorithm.
 * @param {Matrix} A - The Matrix
 * @param {Number} k - The number of eigenvectors and eigenvalues to compute.
 * @param {Number} [max_iterations=100] - The number of maxiumum iterations the algorithm should run.
 * @param {Number|Randomizer} [seed=1212] - The seed value or a randomizer used in the algorithm.
 * @returns {{eigenvalues: Array, eigenvectors: Array}} - The {@link k} biggest eigenvectors and eigenvalues of Matrix {@link A}.
 */function simultaneous_poweriteration$1(t,e=2,r=100,s=1212){const i=s instanceof Randomizer?s:new Randomizer(s);t instanceof Matrix||(t=Matrix.from(t));const n=t.shape[0];let{Q:o,R:a}=qr(new Matrix(n,e,(()=>i.random)));for(;r--;){const e=a.clone(),s=qr(t.dot(o));o=s.Q,a=s.R,neumair_sum(a.sub(e).diag)/n<1e-12&&(r=0)}return{eigenvalues:a.diag,eigenvectors:o.transpose().to2dArray}}
/**
 * @class
 * @alias DR
 * @borrows DR#parameter as DR#para
 * @borrows DR#parameter as DR#p
 */class DR{
//static parameter_list = [];
get parameter_list(){return this._parameter_list}set parameter_list(t){return this._parameter_list=t,this}
/**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias DR
     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.
     * @param {number} [d = 2] - the dimensionality of the projection.
     * @param {function} [metric = euclidean] - the metric which defines the distance between two points.
     * @param {seed} [seed = 1212] - the seed value for the random number generator.
     * @returns {DR}
     */constructor(t,e=2,r=euclidean,s=1212){if(Array.isArray(t))this._type="array",this.X=Matrix.from(t);else{if(!(t instanceof Matrix))throw new Error("no valid type for X");this._type="matrix",this.X=t}return[this._N,this._D]=this.X.shape,this._d=e,this._metric=r,this._seed=s,this._randomizer=new Randomizer(s),this._is_initialized=!1,this}
/**
     * Set and get parameters
     * @param {String} name - name of the parameter.
     * @param {Number} [value = null] - value of the parameter to set, if <code>value == null</code> then return actual parameter value.
     * @memberof DR
     */parameter(t,e=null){if(this.parameter_list.includes(t))throw new Error(`${t} is not a valid parameter!`);return e?(this[`_${t}`]=e,this._is_initialized=!1,this):this[`_${t}`]}para(t,e=null){return this.parameter(t,e)}p(t,e=null){return this.parameter(t,e)}
/**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */transform(){return this.check_init(),this.projection}*generator(){return this.transform()}check_init(){this._is_initialized||"function"!=typeof this.init||(this.init(),this._is_initialized=!0)}
/**
     * @returns {Matrix} Returns the projection.
     */get projection(){return"matrix"===this._type?this.Y:this.Y.to2dArray}async transform_async(...t){return new this(...t).transform()}static transform(...t){return new this(...t).transform()}static async transform_async(...t){return this.transform(...t)}static*generator(...t){const e=new this(...t).generator();for(const t of e)yield t}}
/**
 * @class
 * @alias PCA
 * @augments DR
 */class PCA extends DR{
/**
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias PCA 
     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @returns {PCA}
     */
constructor(t,e=2){return super(t,e),this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,e=this.principal_components();return this.Y=t.dot(e),this.projection}
/**
     * Computes the {@link d} principal components of Matrix {@link X}.
     * @returns {Matrix} 
     */principal_components(){if(this.V)return this.V;const t=this.X,e=Matrix.from(t.meanCols),r=t.sub(e),s=r.transpose().dot(r),{eigenvectors:i}=simultaneous_poweriteration$1(s,this._d);return this.V=Matrix.from(i).transpose(),this.V}}
/**
 * @class
 * @alias MDS
 * @extends DR
 */class MDS extends DR{
/**
     * Classical MDS.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias MDS
     * @param {Matrix} X - the high-dimensional data.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     */
constructor(t,e=2,r=euclidean,s=1212){return super(t,e,r,s),this}
/**
     * Transforms the inputdata {@link X} to dimensionality {@link d}.
     * @returns {Matrix|Array}
     */transform(){const t=this.X,e=t.shape[0],r=this._metric,s="precomputed"===r?t:distance_matrix(t,r),i=s.meanCols,n=s.meanRows,o=s.mean;this._d_X=s;const a=new Matrix(e,e,((t,e)=>s.entry(t,e)-i[t]-n[e]+o)),{eigenvectors:h}=simultaneous_poweriteration$1(a,this._d);return this.Y=Matrix.from(h).transpose(),this.projection}
/**
     * @returns {Number} - the stress of the projection.
     */stress(){const t=this.X.shape[0],e=this.Y,r=this._d_X,s=new Matrix;s.shape=[t,t,(t,r)=>t<r?euclidean(e.row(t),e.row(r)):s.entry(r,t)];let i=0,n=0;for(let e=0;e<t;++e)for(let o=e+1;o<t;++o)i+=Math.pow(r.entry(e,o)-s.entry(e,o),2),n+=Math.pow(r.entry(e,o),2);return Math.sqrt(i/n)}}
/**
 * @class
 * @alias ISOMAP
 * @extends DR
 */class ISOMAP extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias ISOMAP
     * @param {Matrix} X - the high-dimensional data. 
     * @param {Number} neighbors - the number of neighbors {@link ISOMAP} should use to project the data.
     * @param {Number} [d = 2] - the dimensionality of the projection. 
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points. 
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     */
constructor(t,e,r=2,s=euclidean,i=1212){return super(t,r,s,i),super.parameter_list=["k"],this.parameter("k",Math.min(e??Math.max(Math.floor(this.X.shape[0]/10),2),this._N-1)),this}
/**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */transform(){this.check_init();const t=this.X,e=this._N,r=this._metric,s=new Matrix;s.shape=[e,e,(e,i)=>e<=i?r(t.row(e),t.row(i)):s.entry(i,e)];const i=[];for(let t=0;t<e;++t){const r=[];for(let i=0;i<e;++i)r.push({index:i,distance:s.entry(t,i)});const n=new Heap(r,(t=>t.distance),"min");i.push(n.toArray().slice(1,this._k+1))}
/*D = dijkstra(kNearestNeighbors);*/
// compute shortest paths
// TODO: make extern
/** @see {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm} */const n=new Matrix(e,e,((t,e)=>{const r=i[t].find((t=>t.index===e));return r?r.distance:1/0}));for(let t=0;t<e;++t)for(let r=0;r<e;++r)for(let s=0;s<e;++s)n.set_entry(t,r,Math.min(n.entry(t,r),n.entry(t,s)+n.entry(s,r)));let o=new Float64Array(e),a=new Float64Array(e),h=0,l=new Matrix(e,e,((t,e)=>{let r=n.entry(t,e);return r=r===1/0?0:r,o[t]+=r,a[e]+=r,h+=r,r}));o=o.map((t=>t/e)),a=a.map((t=>t/e)),h/=e**2;const _=new Matrix(e,e,((t,e)=>l.entry(t,e)-o[t]-a[e]+h)),{eigenvectors:c}=simultaneous_poweriteration$1(_,this._d);
// compute d eigenvectors
// return embedding
return this.Y=Matrix.from(c).transpose(),this.projection}}
/**
 * @class
 * @alias FASTMAP
 * @extends DR
 */class FASTMAP extends DR{
/**
     * FastMap: a fast algorithm for indexing, data-mining and visualization of traditional and multimedia datasets
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias FASTMAP
     * @param {Matrix} X - the high-dimensional data. 
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @returns {FASTMAP}
     * @see {@link https://doi.org/10.1145/223784.223812}
     */
constructor(t,e=2,r=euclidean,s=1212){return super(t,e,r,s),this}
/**
     * Chooses two points which are the most distant in the actual projection.
     * @private
     * @param {function} dist 
     * @returns {Array} An array consisting of first index, second index, and distance between the two points.
     */_choose_distant_objects(t){const e=this.X.shape[0];let r=this._randomizer.random_int%e-1,s=null,i=-1/0;for(let n=0;n<e;++n){const e=t(r,n);e>i&&(i=e,s=n)}i=-1/0;for(let n=0;n<e;++n){const e=t(s,n);e>i&&(i=e,r=n)}return[r,s,i]}
/**
     * Computes the projection.
     * @returns {Matrix} The {@link d}-dimensional projection of the data matrix {@link X}.
     */transform(){const t=this.X,e=t.shape[0],r=this._d,s=this._metric,i=new Matrix(e,r,0);let dist=(e,r)=>s(t.row(e),t.row(r));for(let t=0;t<r;++t){let r=dist;
// choose pivot objects
const[s,n,o]=this._choose_distant_objects(dist);
// record id of pivot objects
//PA[0].push(a_index);
//PA[1].push(b_index);
/* if (d_ab === 0) {
                // because all inter-object distances are zeros
                for (let i = 0; i < N; ++i) {
                    Y.set_entry(i, _col, 0);
                }
            } else { */if(0!==o){
// project the objects on the line (O_a, O_b)
for(let r=0;r<e;++r){const e=(dist(s,r)**2+o**2-dist(n,r)**2)/(2*o);i.set_entry(r,t,e)}
// consider the projections of the objects on a
// hyperplane perpendicluar to the line (a, b);
// the distance function D'() between two 
// projections is given by Eq.4
dist=(e,s)=>Math.sqrt(r(e,s)**2-(i.entry(e,t)-i.entry(s,t))**2)}}
// return embedding
return this.Y=i,this.projection}}
/**
 * @class
 * @alias LDA
 * @extends DR
 */class LDA extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LDA
     * @param {Matrix} X - the high-dimensional data.
     * @param {Array} labels - the label / class of each data point.
     * @param {number} [d = 2] - the dimensionality of the projection.
     * @param {function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     */
constructor(t,e,r=2,s=euclidean,i=1212){return super(t,r,s,i),super.parameter_list=["labels"],this.parameter("labels",e),this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){let t=this.X,[e,r]=t.shape,s=this._labels,i={},n=0;s.forEach(((e,r)=>{e in i?(i[e].count++,i[e].rows.push(t.row(r))):i[e]={id:n++,count:1,rows:[t.row(r)]}}));
// create X_mean and vector means;
let o=t.mean,a=new Matrix(n,r);for(let t in i){let e=Matrix.from(i[t].rows).meanCols;for(let s=0;s<r;++s)a.set_entry(i[t].id,s,e[s])}
// scatter_between
let h=new Matrix(r,r);for(let t in i){let e=a.row(i[t].id),s=new Matrix(r,1,(t=>e[t]-o)),n=i[t].count;h=h.add(s.dot(s.transpose()).mult(n))}
// scatter_within
let l=new Matrix(r,r);for(let t in i){let e=a.row(i[t].id),s=new Matrix(r,1,(t=>e[t])),n=i[t].rows;for(let e=0,o=i[t].count;e<o;++e){let t=new Matrix(r,1,((t,r)=>n[e][t]-s.entry(t,0)));l=l.add(t.dot(t.transpose()))}}let{eigenvectors:_}=simultaneous_poweriteration$1(l.inverse().dot(h),this._d);
// return embedding
return _=Matrix.from(_).transpose(),this.Y=t.dot(_),this.projection}}
/**
 * @class
 * @alias LLE
 * @extends DR
 */class LLE extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LLE
     * @param {Matrix} X - the high-dimensional data.
     * @param {Number} neighbors - the label / class of each data point.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     */
constructor(t,e,r=2,s=euclidean,i=1212){return super(t,r,s,i),super.parameter_list=["k"],this.parameter("k",Math.min(e??Math.max(Math.floor(this._N/10),2),this._N-1)),this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,e=this._d,r=this._N,s=this._D,i=this.parameter("k"),n=k_nearest_neighbors(t,i,null,this._metric),o=new Matrix(i,1,1),a=new Matrix(r,r);for(let e=0;e<r;++e){const r=n[e],h=new Matrix(i,s,((s,i)=>t.entry(r[s].j,i)-t.entry(e,i))),l=h.dot(h.T);if(i>s){const t=neumair_sum(l.diag)/1e3;for(let e=0;e<i;++e)l.set_entry(e,e,l.entry(e,e)+t)}
// reconstruct;
let _=Matrix.solve_CG(l,o,this._randomizer);_=_.divide(_.sum);for(let t=0;t<i;++t)a.set_entry(e,r[t].j,_.entry(t,0))}
// comp embedding
const h=new Matrix(r,r,"identity").sub(a),l=h.T.dot(h),{eigenvectors:_}=simultaneous_poweriteration$1(l.T.inverse(),e+1);
// return embedding
return this.Y=Matrix.from(_.slice(1,1+e)).T,this.projection}}
/**
 * @class
 * @alias LTSA
 * @extends DR
 */class LTSA extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LTSA
     * @param {Matrix} X - the high-dimensional data.
     * @param {Number} neighbors - the label / class of each data point.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @see {@link https://epubs.siam.org/doi/abs/10.1137/S1064827502419154}
     */
constructor(t,e,r=2,s=euclidean,i=1212){if(super(t,r,s,i),super.parameter_list=["k"],this.parameter("k",Math.min(e??Math.max(Math.floor(this._N/10),2),this._N-1)),this._D<=r)throw`Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${r})!`;return this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,e=this._d,[r,s]=t.shape,i=this.parameter("k"),n=k_nearest_neighbors(t,i,null,this._metric),o=new Matrix(s,s,"center"),a=new Matrix(r,r,0);for(let s=0;s<r;++s){
// 1.2 compute the d largest eigenvectors of the correlation matrix
const r=[s,...n[s].map((t=>t.j))];let h=Matrix.from(r.map((e=>t.row(e))));
// center X_i
h=h.dot(o);
// correlation matrix
const l=h.dot(h.transpose()),{eigenvectors:_}=simultaneous_poweriteration$1(l,e),c=Matrix.from(_),u=c.transpose().dot(c).add(1/Math.sqrt(i+1));for(let t=0;t<i+1;++t)for(let e=0;e<i+1;++e)a.set_entry(r[t],r[e],a.entry(r[t],r[e])-(t===e?1:0)+u.entry(t,e))}
// 3. Aligning global coordinates
const{eigenvectors:h}=simultaneous_poweriteration$1(a,e+1);
// return embedding
return this.Y=Matrix.from(h.slice(1)).transpose(),this.projection}}
/**
 * @class
 * @alias TSNE
 * @extends DR
 */class TSNE extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TSNE
     * @param {Matrix} X - the high-dimensional data. 
     * @param {Number} [perplexity = 50] - perplexity.
     * @param {Number} [epsilon = 10] - learning parameter.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @returns {TSNE}
     */
constructor(t,e=50,r=10,s=2,i=euclidean,n=1212){return super(t,s,i,n),super.parameter_list=["perplexity","epsilon"],[this._N,this._D]=this.X.shape,this.parameter("perplexity",Math.min(e,this._N-1)),this.parameter("epsilon",r),this._iter=0,this.Y=new Matrix(this._N,this._d,(()=>this._randomizer.random)),this}
/**
     * 
     * @param {Matrix} distance_matrix - accepts a precomputed distance matrix
     * @returns {TSNE}
     */init(t=null){
// init
const e=Math.log(this._perplexity),r=this._N,s=this._D,i=this._metric,n=this.X;let o;if(t)o=t;else{o=new Matrix(r,r);for(let t=0;t<r;++t){const e=n.row(t);for(let s=t+1;s<r;++s){const r=i(e,n.row(s));o.set_entry(t,s,r),o.set_entry(s,t,r)}}}const a=new Matrix(r,r,"zeros");this._ystep=new Matrix(r,s,"zeros"),this._gains=new Matrix(r,s,1);
// search for fitting sigma
let h=new Array(r).fill(0);for(let t=0;t<r;++t){let s=-1/0,i=1/0,n=1,l=!1,_=0;for(;!l;){let a=0;for(let e=0;e<r;++e){let r=Math.exp(-o.entry(t,e)*n);t===e&&(r=0),h[e]=r,a+=r}let c=0;for(let t=0;t<r;++t){let e=0===a?0:h[t]/a;h[t]=e,e>1e-7&&(c-=e*Math.log(e))}c>e?(s=n,n=i===1/0?2*n:(n+i)/2):(i=n,n=s===-1/0?n/2:(n+s)/2),++_,Math.abs(c-e)<1e-4&&(l=!0),_>=50&&(l=!0)}for(let e=0;e<r;++e)a.set_entry(t,e,h[e])}
//compute probabilities
const l=new Matrix(r,r,"zeros"),_=2*r;for(let t=0;t<r;++t)for(let e=t;e<r;++e){const r=Math.max((a.entry(t,e)+a.entry(e,t))/_,1e-100);l.set_entry(t,e,r),l.set_entry(e,t,r)}return this._P=l,this}
/**
     * 
     * @param {Number} [iterations=500] - number of iterations.
     * @yields {Matrix|Array<Array>} - the projection.
     */transform(t=500){this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}
/**
     * 
     * @param {Number} [iterations=500] - number of iterations.
     * @yields {Matrix|Array<Array>} - the projection.
     */*generator(t=500){this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}
/**
     * performs a optimization step
     * @private
     * @returns {Matrix}
     */next(){const t=++this._iter,e=this._P,r=this._ystep,s=this._gains,i=this._N,n=this._epsilon,o=this._d;let a=this.Y;
//calc cost gradient;
const h=t<100?4:1,l=new Matrix(i,i,"zeros");
// compute Q dist (unnormalized)
let _=0;for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){let r=0;for(let s=0;s<o;++s){const i=a.entry(t,s)-a.entry(e,s);r+=i*i}const s=1/(1+r);l.set_entry(t,e,s),l.set_entry(e,t,s),_+=2*s}
// normalize Q dist
const c=new Matrix(i,i,0);for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){const r=Math.max(l.entry(t,e)/_,1e-100);c.set_entry(t,e,r),c.set_entry(e,t,r)}const u=new Matrix(i,o,"zeros");for(let t=0;t<i;++t)for(let r=0;r<i;++r){const s=4*(h*e.entry(t,r)-c.entry(t,r))*l.entry(t,r);for(let e=0;e<o;++e)u.set_entry(t,e,u.entry(t,e)+s*(a.entry(t,e)-a.entry(r,e)))}
// perform gradient step
let f=new Float64Array(o);for(let e=0;e<i;++e)for(let i=0;i<o;++i){const o=u.entry(e,i),h=r.entry(e,i),l=s.entry(e,i);let _=Math.sign(o)===Math.sign(h)?.8*l:l+.2;_<.01&&(_=.01),s.set_entry(e,i,_);const c=(t<250?.5:.8)*h-n*_*o;r.set_entry(e,i,c),a.set_entry(e,i,a.entry(e,i)+c),f[i]+=a.entry(e,i)}for(let t=0;t<i;++t)for(let e=0;e<2;++e)a.set_entry(t,e,a.entry(t,e)-f[e]/i);return this.Y}}
/**
 *
 * @memberof module:optimization
 * @alias powell
 * @param {Function} f
 * @param {Array} x0
 * @param {Number} [max_iter = 300]
 * @returns {Array}
 * @see http://optimization-js.github.io/optimization-js/optimization.js.html#line438
 */function powell(t,e,r=300){const s=e.length;let i=.001,n=1e4,o=e.slice(),a=t(o),h=!1;for(;r-- >=0&&!h;){h=!0;for(let e=0;e<s;++e){o[e]+=1e-6;let r=t(o);o[e]-=1e-6;let s=(r-a)/1e-6;Math.abs(s)>.01&&(h=!1),o[e]-=i*s,a=t(o)}i*=n>=a?1.05:.4,n=a}return o}
/**
 * @class
 * @alias UMAP
 * @extends DR
 */class UMAP extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias UMAP
     * @param {Matrix} X - the high-dimensional data. 
     * @param {Number} [n_neighbors = 15] - size of the local neighborhood.
     * @param {Number} [local_connectivity = 1] - number of nearest neighbors connected in the local neighborhood.
     * @param {Number} [min_dist = 1] - controls how tightly points get packed together.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points in the high-dimensional space.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @returns {UMAP}
     */
constructor(t,e=15,r=1,s=1,i=2,n=euclidean,o=1212){return super(t,i,n,o),super.parameter_list=["n_neighbors","local_connectivity","min_dist"],[this._N,this._D]=this.X.shape,e=Math.min(this._N-1,e),this.parameter("n_neighbors",e),this.parameter("local_connectivity",Math.min(r,e-1)),this.parameter("min_dist",s),this._iter=0,this._spread=1,this._set_op_mix_ratio=1,this._repulsion_strength=1,this._negative_sample_rate=5,this._n_epochs=350,this._initial_alpha=1,this.Y=new Matrix(this._N,this._d,(()=>this._randomizer.random)),this}
/**
     * @private
     * @param {Number} spread 
     * @param {Number} min_dist 
     * @returns {Array}
     */_find_ab_params(t,e){const r=linspace(0,3*t,300),s=linspace(0,3*t,300);for(let i=0,n=r.length;i<n;++i){const n=r[i];s[i]=n<e?1:Math.exp(-(n-e)/t)}return powell((t=>{const e=linspace(1,300).map(((e,i)=>{return s[i]-(n=r[i],o=t[0],a=t[1],1/(1+o*Math.pow(n,2*a)));var n,o,a}));return Math.sqrt(neumair_sum(e.map((t=>t*t))))}),[1,1])}
/**
     * @private
     * @param {Array<Array>} distances 
     * @param {Array<Number>} sigmas 
     * @param {Array<Number>} rhos 
     * @returns {Array}
     */_compute_membership_strengths(t,e,r){for(let s=0,i=t.length;s<i;++s)for(let i=0,n=t[s].length;i<n;++i){const n=t[s][i].value-r[s];t[s][i].value=n>0?Math.exp(-n/e[s]):1}return t}
/**
     * @private
     * @param {KNN|BallTree} knn 
     * @param {Number} k 
     * @returns {Object}
     */_smooth_knn_dist(t,e){const r=1e-5,s=.001,i=this._local_connectivity,n=Math.log2(e),o=[],a=[],h=this.X,l=h.shape[0],_=[];if("precomputed"===this._metric)for(let r=0;r<l;++r)_.push(t.search(r,e).reverse());else for(const r of h)_.push(t.search(r,e).raw_data().reverse());for(let t=0;t<l;++t){let h=0,l=1/0,c=1;const u=_[t],f=u.filter((t=>t.value>0)),d=f.length;if(d>=i){const e=Math.floor(i),s=i-e;e>0?(o.push(f[e-1]),s>r&&(o[t].value+=s*(f[e].value-f[e-1]))):o[t].value=s*f[0].value}else d>0&&(o[t]=f[d-1].value);for(let s=0;s<64;++s){let s=0;for(let r=0;r<e;++r){const e=u[r].value-o[t];s+=e>0?Math.exp(-e/c):1}if(Math.abs(s-n)<r)break;s>n?[l,c]=[c,(h+l)/2]:[h,c]=l===1/0?[c,2*c]:[c,(h+l)/2]}a[t]=c;const p=u.reduce(((t,e)=>t+e.value),0)/u.length;
//let mean_d = null;
if(o[t]>0)a[t]<s*p&&(a[t]=s*p);else{const e=_.reduce(((t,e)=>t+e.reduce(((t,e)=>t+e.value),0)/e.length));a[t]>s*e&&(a[t]=s*e)}}return{distances:_,sigmas:a,rhos:o}}
/**
     * @private
     * @param {Matrix} X 
     * @param {Number} n_neighbors 
     * @returns {Matrix}
     */_fuzzy_simplicial_set(t,e){const r=t.shape[0],s=this._metric,i="precomputed"===s?new KNN(t,"precomputed"):new BallTree(t.to2dArray,s);let{distances:n,sigmas:o,rhos:a}=this._smooth_knn_dist(i,e);n=this._compute_membership_strengths(n,o,a);const h=new Matrix(r,r,"zeros");for(let t=0;t<r;++t){const e=n[t];for(let r=0;r<e.length;++r)h.set_entry(t,e[r].element.index,e[r].value)}const l=h.T,_=h.mult(l);return h.add(l).sub(_).mult(this._set_op_mix_ratio).add(_.mult(1-this._set_op_mix_ratio))}
/**
     * @private
     * @param {Number} n_epochs 
     * @returns {Array}
     */_make_epochs_per_sample(t){const e=this._weights,r=new Float32Array(e.length).fill(-1),s=max(e),i=e.map((e=>t*(e/s)));for(let e=0;e<r.length;++e)i[e]>0&&(r[e]=Math.round(t/i[e]));return r}
/**
     * @private
     * @param {Matrix} graph 
     * @returns {Object}
     */_tocoo(t){const e=[],r=[],s=[],[i,n]=t.shape;for(let o=0;o<i;++o)for(let i=0;i<n;++i){const n=t.entry(o,i);0!==n&&(e.push(o),r.push(i),s.push(n))}return{rows:e,cols:r,data:s}}
/**
     * Computes all necessary 
     * @returns {UMAP}
     */init(){const[t,e]=this._find_ab_params(this._spread,this._min_dist);this._a=t,this._b=e,this._graph=this._fuzzy_simplicial_set(this.X,this._n_neighbors);const{rows:r,cols:s,data:i}=this._tocoo(this._graph);return this._head=r,this._tail=s,this._weights=i,this._epochs_per_sample=this._make_epochs_per_sample(this._n_epochs),this._epochs_per_negative_sample=this._epochs_per_sample.map((t=>t*this._negative_sample_rate)),this._epoch_of_next_sample=this._epochs_per_sample.slice(),this._epoch_of_next_negative_sample=this._epochs_per_negative_sample.slice(),this}set local_connectivity(t){this._local_connectivity=t}get local_connectivity(){return this._local_connectivity}set min_dist(t){this._min_dist=t}get min_dist(){return this._min_dist}graph(){return this.check_init(),{cols:this._head,rows:this._tail,weights:this._weights}}
/**
     * 
     * @param {Number} [iterations=350] - number of iterations.
     * @returns {Matrix|Array}
     */transform(t=350){this._n_epochs!=t&&(this._n_epochs=t,this.init()),this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}
/**
     * 
     * @param {Number} [iterations=350] - number of iterations.
     * @returns {Matrix|Array}
     */*generator(t=350){this._n_epochs!=t&&(this._n_epochs=t,this.init()),this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}
/**
     * @private
     * @param {Number} x 
     * @returns {Number}
     */_clip(t){return t>4?4:t<-4?-4:t}
/**
     * performs the optimization step.
     * @private
     * @param {Matrix} head_embedding 
     * @param {Matrix} tail_embedding 
     * @param {Matrix} head 
     * @param {Matrix} tail 
     * @returns {Matrix}
     */_optimize_layout(t,e,r,s){const{_d:i,_alpha:n,_repulsion_strength:o,_a:a,_b:h,_epochs_per_sample:l,_epochs_per_negative_sample:_,_epoch_of_next_negative_sample:c,_epoch_of_next_sample:u,_clip:f}=this,d=s.length;for(let p=0,m=l.length;p<m;++p)if(u[p]<=this._iter){const m=r[p],y=s[p],w=t.row(m),g=e.row(y),x=euclidean_squared(w,g);let M=0;x>0&&(M=-2*a*h*Math.pow(x,h-1)/(a*Math.pow(x,h)+1));for(let r=0;r<i;++r){const s=f(M*(w[r]-g[r]))*n,i=w[r]+s,o=g[r]-s;w[r]=i,g[r]=o,t.set_entry(m,r,i),e.set_entry(y,r,o)}u[p]+=l[p];const A=(this._iter-c[p])/_[p];for(let r=0;r<A;++r){const r=Math.floor(this._randomizer.random*d),l=e.row(s[r]),_=euclidean_squared(w,l);let c=0;if(_>0)c=2*o*h/((.01+_)*(a*Math.pow(_,h)+1));else if(m===r)continue;for(let o=0;o<i;++o){const i=f(c*(w[o]-l[o]))*n,a=w[o]+i,h=l[o]-i;w[o]=a,l[o]=h,t.set_entry(m,o,a),e.set_entry(s[r],o,h)}}c[p]+=A*_[p]}return t}
/**
     * @private
     * @returns {Matrix}
     */next(){let t=++this._iter,e=this.Y;return this._alpha=this._initial_alpha*(1-t/this._n_epochs),this.Y=this._optimize_layout(e,e,this._head,this._tail),this.Y}}
/**
 * @class
 * @alias TriMap
 * @extends DR
 */class TriMap extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TriMap
     * @param {Matrix} X - the high-dimensional data. 
     * @param {Number} [weight_adj = 500] - scaling factor.
     * @param {Number} [c = 5] - number of triplets multiplier.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @returns {TriMap}
     * @see {@link https://arxiv.org/pdf/1910.00204v1.pdf}
     * @see {@link https://github.com/eamid/trimap}
     */
constructor(t,e=500,r=5,s=2,i=euclidean,n=1212){return super(t,s,i,n),super.parameter_list=["weight_adj","c"],this.parameter("weight_adj",e),this.parameter("c",r),this}
/**
     * 
     * @param {Matrix} [pca = null] - Initial Embedding (if null then PCA gets used). 
     * @param {KNN} [knn = null] - KNN Object (if null then BallTree gets used). 
     */init(t=null,e=null){const r=this.X,s=r.shape[0],i=this._d,n=this._metric,o=this._c;this.n_inliers=2*o,this.n_outliers=1*o,this.n_random=1*o,this.Y=t||new PCA(r,i).transform(),//.mult(.01);
this.knn=e||new BallTree(r.to2dArray,n);const{triplets:a,weights:h}=this._generate_triplets(this.n_inliers,this.n_outliers,this.n_random);return this.triplets=a,this.weights=h,this.lr=1e3*s/a.shape[0],this.C=1/0,this.tol=1e-7,this.vel=new Matrix(s,i,0),this.gain=new Matrix(s,i,1),this}
/**
     * Generates {@link n_inliers} x {@link n_outliers} x {@link n_random} triplets.
     * @param {Number} n_inliers 
     * @param {Number} n_outliers 
     * @param {Number} n_random 
     */_generate_triplets(t,e,r){const s=this._metric,i=this._weight_adj,n=this.X,o=n.shape[0],a=this.knn,h=Math.min(t+20,o),l=new Matrix(o,h),_=new Matrix(o,h);for(let t=0;t<o;++t)a.search(n.row(t),h+1).raw_data().filter((t=>0!=t.value)).sort(((t,e)=>t.value-e.value)).forEach(((e,r)=>{l.set_entry(t,r,e.element.index),_.set_entry(t,r,e.value)}));
// scale parameter
const c=new Float64Array(o);for(let t=0;t<o;++t)c[t]=Math.max((_.entry(t,3)+_.entry(t,4)+_.entry(t,5)+_.entry(t,6))/4,1e-10);const u=this._find_p(_,c,l);let f=this._sample_knn_triplets(u,l,t,e),d=f.shape[0];const p=new Float64Array(d);for(let t=0;t<d;++t){const e=f.entry(t,0),r=f.entry(t,2);p[t]=s(n.row(e),n.row(r))}let m=this._find_weights(f,u,l,p,c);if(r>0){const{random_triplets:t,random_weights:e}=this._sample_random_triplets(n,r,c);f=f.concat(t,"vertical"),m=Float64Array.from([...m,...e])}d=f.shape[0];let y=-1/0;for(let t=0;t<d;++t)isNaN(m[t])&&(m[t]=0),y<m[t]&&(y=m[t]);let w=-1/0;for(let t=0;t<d;++t)m[t]/=y,m[t]+=1e-4,m[t]=Math.log(1+i*m[t]),w<m[t]&&(w=m[t]);for(let t=0;t<d;++t)m[t]/=w;return{triplets:f,weights:m}}
/**
     * Calculates the similarity matrix P
     * @private
     * @param {Matrix} knn_distances - matrix of pairwise knn distances
     * @param {Float64Array} sig - scaling factor for the distances
     * @param {Matrix} nbrs - nearest neighbors
     * @returns {Matrix} pairwise similarity matrix
     */_find_p(t,e,r){const[s,i]=t.shape;return new Matrix(s,i,((s,i)=>Math.exp(-(t.entry(s,i)**2)/e[s]/e[r.entry(s,i)])))}
/**
     * Sample nearest neighbors triplets based on the similarity values given in P.
     * @private
     * @param {Matrix} P - Matrix of pairwise similarities between each point and its neighbors given in matrix nbrs.
     * @param {Matrix} nbrs - Nearest neighbors indices for each point. The similarity values are given in matrix {@link P}. Row i corresponds to the i-th point.
     * @param {Number} n_inliers - Number of inlier points.
     * @param {Number} n_outliers - Number of outlier points.
     * 
     */_sample_knn_triplets(t,e,r,s){const i=e.shape[0],n=new Matrix(i*r*s,3);for(let o=0;o<i;++o){let a=o*r*s;const h=this.__argsort(t.row(o).map((t=>-t)));for(let t=0;t<r;++t){let r=t*s;const l=e.entry(o,h[t]),_=this._rejection_sample(s,i,h.slice(0,t+1));for(let t=0;t<s;++t){const e=a+r+t,s=_[t];n.set_entry(e,0,o),n.set_entry(e,1,l),n.set_entry(e,2,s)}}}return n}
/**
     * Should do the same as np.argsort()
     * @private
     * @param {Array} A 
     */__argsort(t){return t.map(((t,e)=>({d:t,i:e}))).sort(((t,e)=>t.d-e.d)).map((t=>t.i))}
/**
     * Samples {@link n_samples} integers from a given interval [0, {@link max_int}] while rejection the values that are in the {@link rejects}.
     * @private
     * @param {*} n_samples 
     * @param {*} max_int 
     * @param {*} rejects 
     */_rejection_sample(t,e,r){const s=this._randomizer,i=linspace(0,e-1).filter((t=>r.indexOf(t)<0));return s.choice(i,Math.min(t,i.length-2))}
/**
     * Calculates the weights for the sampled nearest neighbors triplets
     * @private
     * @param {Matrix} triplets - Sampled Triplets.
     * @param {Matrix} P - Pairwise similarity matrix.
     * @param {Matrix} nbrs - nearest Neighbors
     * @param {Float64Array} outlier_distances - Matrix of pairwise outlier distances
     * @param {Float64Array} sig - scaling factor for the distances.
     */_find_weights(t,e,r,s,i){const n=t.shape[0],o=new Float64Array(n);for(let a=0;a<n;++a){const n=t.entry(a,0),h=r.row(n).indexOf(t.entry(a,1)),l=e.entry(n,h);let _=Math.exp(-(s[a]**2)/(i[n]*i[t.entry(a,2)]));_<1e-20&&(_=1e-20),o[a]=l/_}return o}
/**
     * Sample uniformly ranom triplets
     * @private
     * @param {Matrix} X - Data matrix.
     * @param {Number} n_random - Number of random triplets per point
     * @param {Float64Array} sig - Scaling factor for the distances
     */_sample_random_triplets(t,e,r){const s=this._metric,i=this._randomizer,n=t.shape[0],o=new Matrix(n*e,3),a=new Float64Array(n*e);for(let h=0;h<n;++h){const l=h*e,_=[...linspace(0,h-1),...linspace(h+1,n-1)];for(let n=0;n<e;++n){let[e,c]=i.choice(_,2),u=Math.exp(-(s(t.row(h),t.row(e))**2)/(r[h]*r[e]));u<1e-20&&(u=1e-20);let f=Math.exp(-(s(t.row(h),t.row(c))**2)/(r[h]*r[c]));f<1e-20&&(f=1e-20),u<f&&([e,c]=[c,e],[u,f]=[f,u]);const d=l+n;o.set_entry(d,0,h),o.set_entry(d,1,e),o.set_entry(d,2,c),a[d]=u/f}}return{random_triplets:o,random_weights:a}}
/**
     * Computes the gradient for updating the embedding.
     * @param {Matrix} Y - The embedding
     */_grad(t){const e=this.n_inliers,r=this.n_outliers,s=this.triplets,i=this.weights,[n,o]=t.shape,a=s.shape[0],h=new Matrix(n,o,0);let l=new Array(o).fill(0),_=new Array(o).fill(0),c=1,u=1,f=0,d=0;const p=n*e*r;for(let e=0;e<a;++e){const[n,a,m]=s.row(e);
// update y_ij, y_ik, d_ij, d_ik
if(e%r==0||e>=p){c=1,u=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(a,e),i=t.entry(m,e);l[e]=r-s,_[e]=r-i,c+=l[e]**2,u+=_[e]**2}
// update y_ik and d_ik only
}else{u=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(m,e);_[e]=r-s,u+=_[e]**2}}c>u&&++f,d+=i[e]/(1+u/c);const y=(i[e]/(c+u))**2;for(let t=0;t<o;++t){const e=l[t]*u*y,r=_[t]*c*y;h.set_entry(n,t,h.entry(n,t)+e-r),h.set_entry(a,t,h.entry(a,t)-e),h.set_entry(m,t,h.entry(m,t)+r)}}return{grad:h,loss:d,n_viol:f}}
/**
     * 
     * @param {Number} max_iteration 
     */transform(t=400){this.check_init();for(let e=0;e<t;++e)this._next(e);return this.projection}
/**
     * @yields {Matrix}
     * @returns {Matrix}
     */*generator(){this.check_init();for(let t=0;t<800;++t)this._next(t),yield this.projection;return this.projection}
/**
     * Does the iteration step.
     * @private
     * @param {Number} iter 
     */_next(t){const e=t>150?.5:.3,r=this.C,s=this.vel,i=this.Y.add(s.mult(e)),{grad:n,loss:o,n_viol:a}=this._grad(i);return this.C=o,this.Y=this._update_embedding(i,t,n),this.lr*=r>o+this.tol?1.01:.9,this.Y}
/**
     * Updates the embedding.
     * @private
     * @param {Matrix} Y 
     * @param {Number} iter 
     * @param {Matrix} grad 
     */_update_embedding(t,e,r){const[s,i]=t.shape,n=e>150?.9:.5,o=this.gain,a=this.vel,h=this.lr;for(let e=0;e<s;++e)for(let s=0;s<i;++s){const i=Math.sign(a.entry(e,s))!=Math.sign(r.entry(e,s))?o.entry(e,s)+.2:Math.max(.8*o.entry(e,s),.01);o.set_entry(e,s,i),a.set_entry(e,s,n*a.entry(e,s)-h*o.entry(e,s)*r.entry(e,s)),t.set_entry(e,s,t.entry(e,s)+a.entry(e,s))}return t}}
/**
 * @class
 * @alias Hierarchical_Clustering
 */class Hierarchical_Clustering{
/**
     * @constructor
     * @memberof module:clustering
     * @alias Hierarchical_Clustering
     * @todo needs restructuring.
     * @param {Matrix} - Data or distance matrix if metric is 'precomputed'
     * @param {("single"|"complete"|"average")} [linkage = "complete"]
     * @param {Function|"precomputed"} [metric = euclidean]
     * @returns {Hierarchical_Clustering}
     */
constructor(t,e="complete",r=euclidean){if(this._id=0,this._matrix=t instanceof Matrix?t:Matrix.from(t),this._metric=r,this._linkage=e,"precomputed"===r&&this._matrix.shape[0]!==this._matrix.shape[1])throw new Error("If metric is 'precomputed', then matrix has to be square!");return this.init(),this.root=this.do(),this}
/**
     *
     * @param {Number} value - value where to cut the tree.
     * @param {("distance"|"depth")} [type = "distance"] - type of value.
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}.
     */get_clusters(t,e="distance"){let r,s=[];switch(e){case"distance":r=t=>t.dist;break;case"depth":r=t=>t.depth;break;default:throw new Error("invalid type")}return this._traverse(this.root,r,t,s),s}
/**
     * @private
     * @param {} node
     * @param {*} f
     * @param {*} value
     * @param {*} result
     */_traverse(t,e,r,s){e(t)<=r?s.push(t.leaves()):(this._traverse(t.left,e,r,s),this._traverse(t.right,e,r,s))}
/**
     * computes the tree.
     */init(){const t=this._metric,e=this._matrix,r=this._n=e.shape[0],s=this._d_min=new Float64Array(r);let i;if("precomputed"!==t){i=new Matrix(r,r,0);//new Array(n);
for(let n=0;n<r;++n){s[n]=0;
//distance_matrix[i] = new Float64Array(n);
for(let o=0;o<r;++o)i.set_entry(n,o,n===o?1/0:t(e.row(n),e.row(o))),i.entry(n,s[n])>i.entry(n,o)&&(s[n]=o)}}else{i=this._matrix.clone();for(let t=0;t<r;++t)for(let e=0;e<r;++e)t===e?i.set_entry(t,e,1/0):i.entry(t,s[t])>i.entry(t,e)&&(s[t]=e)}this._distance_matrix=i;const n=this._clusters=new Array(r),o=this._c_size=new Uint16Array(r);for(let t=0;t<r;++t)n[t]=[],n[t][0]=new Cluster(this._id++,null,null,0,e.row(t),t,1,0),o[t]=1;return this}
/**
     * computes the tree.
     */do(){const t=this._n,e=this._d_min,r=this._distance_matrix,s=this._clusters,i=this._c_size,n=this._linkage;let o=null;for(let a=0,h=t-1;a<h;++a){let a=0;for(let s=0;s<t;++s){let i=r.entry(s,e[s]);for(let n=s+1;n<t;++n)i>r.entry(s,n)&&(e[s]=n,i=r.entry(s,e[s]))}for(let s=0;s<t;++s)r.entry(s,e[s])<r.entry(a,e[a])&&(a=s);let h=e[a],l=s[a][0],_=s[h][0],c=l.isLeaf?[l.index]:l.index,u=_.isLeaf?[_.index]:_.index,f=c.concat(u),d=new Cluster(this._id++,l,_,r.entry(a,h),null,f);l.parent=d,_.parent=d,s[a].unshift(d),i[a]+=i[h];for(let e=0;e<t;++e){const t=r.entry(a,e),s=r.entry(h,e);let o;switch(n){case"single":o=Math.min(t,s);break;case"complete":o=Math.max(t,s);break;case"average":o=(i[a]*t+i[h]*s)/(i[a]+i[e])}r.set_entry(e,a,o),r.set_entry(a,e,o)}r.set_entry(a,a,1/0);for(let e=0;e<t;++e)r.set_entry(e,h,1/0),r.set_entry(h,e,1/0);
/* for (let j = 0; j < n; ++j) {
                if (d_min[j] === c2) {
                    d_min[j] = c1;
                }
                if (D.entry(c1, j) < D.entry(c1, d_min[c1])) {
                    d_min[c1] = j;
                }
            } */o=d}return o}}class Cluster{constructor(t,e,r,s,i,n,o,a){return this.id=t,this.left=e,this.right=r,this.dist=s,this.index=n,this.size=o??e.size+r.size,this.depth=a??1+Math.max(e.depth,r.depth),this.centroid=i??this._calculate_centroid(e,r),this.parent=null,this}_calculate_centroid(t,e){const r=t.size,s=e.size,i=t.centroid,n=e.centroid,o=this.size,a=t.centroid.length,h=new Float64Array(a);for(let t=0;t<a;++t)h[t]=(r*i[t]+s*n[t])/o;return h}get isLeaf(){return 0===this.depth}leaves(){if(this.isLeaf)return[this];const t=this.left,e=this.right;return(t.isLeaf?[t]:t.leaves()).concat(e.isLeaf?[e]:e.leaves())}descendants(){if(this.isLeaf)return[this];const t=this.left.descendants(),e=this.right.descendants();return t.concat(e).concat([this])}}
/**
 * @class
 * @alias KMeans
 */class KMeans{
/**
     * @constructor
     * @memberof module:clustering
     * @alias KMeans
     * @todo needs restructuring. 
     * @param {Matrix} matrix 
     * @param {Numbers} K 
     * @param {Function} [metric = euclidean] 
     * @param {Number} [seed = 1987]
     * @param {Boolean} [init = true]
     * @returns {KMeans}
     */
constructor(t,e,r=euclidean,s=1987,i=!0){this._metric=r,this._matrix=t,this._K=e;const[n,o]=t.shape;return this._N=n,this._D=o,e>n&&(e=n),this._randomizer=new Randomizer(s),this._clusters=new Array(n).fill(void 0),this._cluster_centroids=this._get_random_centroids(e),i&&this.init(e,this._cluster_centroids),this}
/**
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. 
     */get_clusters(){const t=this._K,e=this._clusters,r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>r[t].push(e))),r}
/**
     * @private
     * @param {Array} points 
     * @param {Array} candidates 
     */_furthest_point(t,e){const r=this._matrix,s=this._metric;let i=t.length;return Heap.heapify(e,(e=>{const n=r.row(e);let o=0;for(let e=0;e<i;++e)o+=s(n,t[e]);return o}),"max").pop().element}_get_random_centroids(t){const e=this._N,r=this._randomizer,s=this._matrix,i=new Array(t).fill(),n=linspace(0,e-1),o=r.random_int%(e-1);i[0]=s.row(o);const a=[o],h=Math.floor((e-t)/t);// / K
for(let e=1;e<t;++e){
// sampling + kmeans++ improvement?
const t=r.choice(n.filter((t=>-1==a.indexOf(t))),h),o=this._furthest_point(i.slice(0,e),t);a.push(o),i[e]=s.row(o)}return i}_iteration(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._metric,o=this._clusters;let a=!1;
// find nearest cluster centroid.
for(let s=0;s<r;++s){const r=i.row(s);let h=1/0,l=null;for(let s=0;s<e;++s){let e=n(t[s],r);e<h&&(h=e,l=s)}o[s]!==l&&(a=!0),o[s]=l}
// update cluster centroid
// reset cluster centroids to 0
for(let r=0;r<e;++r){const e=t[r];for(let t=0;t<s;++t)e[t]=0}
// compute centroid
return this._compute_centroid(t),{clusters_changed:a,cluster_centroids:t}}_compute_centroid(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._clusters,o=new Array(e).fill(0);for(let e=0;e<r;++e){const r=i.row(e),a=n[e];o[a]++;const h=t[a];for(let t=0;t<s;++t)h[t]+=r[t]}for(let r=0;r<e;++r){const e=o[r];t[r]=t[r].map((t=>t/e))}}
/**
     * Computes {@link K} clusters out of the {@link matrix}.
     * @param {Number} K - number of clusters.
     */init(t,e){t||(t=this._K),e||(e=this._get_random_centroids(t));let r=!1;do{const t=this._iteration(e);e=t.cluster_centroids,r=t.clusters_changed}while(r)}}
/**
 * @class
 * @alias KMedoids
 */class KMedoids{
/**
     * @constructor
     * @memberof module:clustering
     * @alias KMedoids
     * @todo needs restructuring. 
     * @param {Matrix} matrix - data matrix
     * @param {Numbers} K - number of clusters
     * @param {number} [max_iter=null] - maximum number of iterations. Default is 10 * Math.log10(N)
     * @param {Function} [metric = euclidean] - metric defining the dissimilarity 
     * @param {Number} [seed = 1212] - seed value for random number generator
     * @returns {KMedoids}
     * @see {@link https://link.springer.com/chapter/10.1007/978-3-030-32047-8_16} Faster k-Medoids Clustering: Improving the PAM, CLARA, and CLARANS Algorithms
     */
constructor(t,e,r=null,s=euclidean,i=1212){this._metric=s,this._matrix=t,this._A=this._matrix.to2dArray,this._K=e;const[n,o]=t.shape;return this._N=n,this._D=o,this._max_iter=r||10*Math.log10(n),this._distance_matrix=new Matrix(n,n,"zeros"),
/* for (let i = 1; i < N; ++i) {
            for (let j = i + 1; j < N; ++j) {
                let dist = metric(this._A[i], this._A[j]);
                this._distance_matrix.set_entry(i, j, dist);
                this._distance_matrix.set_entry(j, i, dist)
            }
        } */
e>n&&(e=n),this._randomizer=new Randomizer(i),this._clusters=new Array(n).fill(void 0),this._cluster_medoids=this._get_random_medoids(e),
//if (init) this.init(K, this._cluster_medoids);
this._is_initialized=!1,this}
/**
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. 
     */get_clusters(){const t=this._K,e=this._A;this._is_initialized||this.init(t,this._cluster_medoids);const r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>{r[this._nearest_medoid(t,e).index_nearest].push(e)})),r.medoids=this._cluster_medoids,r}async*generator(){const t=this._max_iter;yield this.get_clusters();let e=!1,r=0;do{e=this._iteration(),yield this.get_clusters()}while(!e&&++r<t)}
/**
     * Algorithm 1. FastPAM1: Improved SWAP algorithm
     */
/* _iteration_1() {
        const A = this._A;
        const N = this._N;
        const K = this._K;
        const medoids = this._cluster_medoids;
        let DeltaTD = 0;
        let m0 = null;
        let x0 = null;
        A.forEach((x_j, j) => {
            if (medoids.findIndex(m => m === j) < 0) {
                const nearest_medoid = this._nearest_medoid(x_j, j);
                const d_j = nearest_medoid.distance_nearest; // distance to current medoid
                const deltaTD = new Array(K).fill(-d_j); // change if making j a medoid
                A.forEach((x_o, o) => {
                    // disance to new medoid
                    const d_oj = this._get_distance(o, j, x_o, x_j);
                    const {
                        "index_nearest": n,
                        "distance_nearest": d_n,
                        "distance_second": d_s,
                    } = this._nearest_medoid(x_o, o); 
                    this._clusters[o] = n; // cached values
                    deltaTD[n] += Math.min(d_oj, d_s) - d_n; // loss change
                    if (d_oj < d_n) { // reassignment check
                        deltaTD.forEach((d_i, i) => {
                            if (n !== i) {
                                deltaTD[i] = d_i + d_oj - d_n; // update loss change
                            }
                        });
                    }
                });
                // choose best medoid i;
                const i = deltaTD
                    .map((d, i) => [d, i])
                    .sort((d1, d2) => d1[0] - d2[0])[0][1];
                const deltaTD_i = deltaTD[i];
                // store
                if (deltaTD_i < DeltaTD) {
                    DeltaTD = deltaTD_i;
                    m0 = i;
                    x0 = j;
                }
            }
        });

        if (DeltaTD >= 0) {
            return true // break loop if DeltaTD >= 0
        }
        // swap roles of medoid m and non-medoid x;
        medoids[m0] = x0;
        this._cluster_medoids = medoids;
        return false
    } */
/** Algorithm 2. FastPAM2: SWAP with multiple candidates
     * 
     */_iteration(){const t=this._A,e=this._K,r=this._cluster_medoids,s=t.map(((t,e)=>this._nearest_medoid(t,e))),i=new Array(e).fill(0),n=new Array(e).fill(null);
// stop if no improvements were found
if(t.forEach(((o,a)=>{if(r.findIndex((t=>t===a))<0){const r=s[a].distance_nearest,h=new Array(e).fill(-r);// distance to current medoid
// change if making j a medoid
t.forEach(((t,r)=>{if(a===r)return;const i=this._get_distance(r,a,t,o),{index_nearest:n,distance_nearest:l,distance_second:_}=s[r];// distance to new medoid
// loss change for x_o
// Reassignment check
if(// cached
h[n]+=Math.min(i,_)-l,i<l)
// update loss change
for(let t=0;t<e;++t)t!==n&&(h[t]+=i-l)})),
// remember best swap for i;
h.map(((t,e)=>[t,e])).filter((([t,e])=>t<i[e])).forEach((([t,e])=>{t<i[e]&&(i[e]=t,n[e]=a)}))}})),min(i)>=0)return!0;
// execute all improvements
for(;min(i)<0;){
// swap roles of medoid m_i and non_medoid xs_i
const e=i.map(((t,e)=>[t,e])).sort((([t],[e])=>t-e))[0][1];0==r.filter((t=>t==n[e])).length&&(r[e]=n[e]),
// disable the swap just performed
i[e]=0,
// recompute TD for remaining swap candidates
i.map(((t,e)=>[t,e])).filter((([t])=>t<0)).forEach((([n,o])=>{const a=t[o];let h=0;t.forEach(((t,i)=>{r.findIndex((t=>t!=o&&t==i))>=0||e!=o&&(s[i].index_nearest===r[o]?h+=Math.min(this._get_distance(i,o,t,a),s[i].distance_second)-s[i].distance_nearest:h+=Math.min(this._get_distance(i,o,t,a)-s[i].distance_nearest,0))})),i[o]=h}))}return this._cluster_medoids=r,!1}_get_distance(t,e,r=null,s=null){if(t===e)return 0;const i=this._distance_matrix,n=this._A,o=this._metric;let a=i.entry(t,e);return 0===a&&(a=o(r||n[t],s||n[e]),i.set_entry(t,e,a),i.set_entry(e,t,a)),a}_nearest_medoid(t,e){const r=this._cluster_medoids,s=this._A,[i,n]=r.map(((r,i)=>{const n=s[r];return[this._get_distance(e,r,t,n),i]})).sort(((t,e)=>t[0]-e[0]));return{distance_nearest:i[0],index_nearest:i[1],distance_second:n[0],index_second:n[1]}}
/**
     * Computes {@link K} clusters out of the {@link matrix}.
     * @param {Number} K - number of clusters.
     */init(t,e){t||(t=this._K),e||(e=this._get_random_medoids(t));const r=this._max_iter;let s=!1,i=0;do{s=this._iteration()}while(!s&&++i<r);return this}
/**
     * Algorithm 3. FastPAM LAB: Linear Approximate BUILD initialization.
     * @param {number} K - number of clusters
     * 
     */_get_random_medoids(t){const e=this._N,r=this._A,s=linspace(0,e-1),i=this._randomizer,n=Math.min(e,10+Math.ceil(Math.sqrt(e))),o=new Array(n).fill(1/0),a=[];
// first medoid
let h=1/0,l=i.choice(s,n);for(let t=0;t<n;++t){const e=l[t],s=r[e];for(let e=0;e<n;++e){if(e===t)continue;const i=r[l[e]];o[t]+=this._get_distance(t,e,s,i)}o[t]<h&&(h=o[t],// smallest distance sum
a.push(e))}
// other medoids
for(let e=1;e<t;++e){let t=1/0;l=i.choice(s.filter((t=>a.findIndex((e=>e===t))<0)),n);for(let e=0;e<n;++e){let s=0;const i=l[e],o=r[i];for(let t=0;t<n;++t){if(t===e)continue;const n=l[t],h=r[n];let _=this._get_distance(i,n,o,h)-min(a.map((t=>this._get_distance(n,t,h))));_<0&&(s+=_)}
// best reduction
s<t&&(t=s,a.push(i))}h+=t}return a.slice(0,t)}}
/**
 * @class
 * @alias OPTICS
 */class OPTICS{
/**
     * **O**rdering **P**oints **T**o **I**dentify the **C**lustering **S**tructure.
     * @constructor
     * @memberof module:clustering
     * @alias OPTICS
     * @todo needs restructuring. 
     * @param {Matrix} matrix - the data.
     * @param {Number} epsilon - the minimum distance which defines whether a point is a neighbor or not.
     * @param {Number} min_points - the minimum number of points which a point needs to create a cluster. (Should be higher than 1, else each point creates a cluster.)
     * @param {Function} [metric = euclidean] - the distance metric which defines the distance between two points of the {@link matrix}.
     * @returns {OPTICS}
     * @see {@link https://www.dbs.ifi.lmu.de/Publikationen/Papers/OPTICS.pdf}
     * @see {@link https://en.wikipedia.org/wiki/OPTICS_algorithm}
     */
constructor(t,e,r,s=euclidean){return this._matrix=t,this._epsilon=e,this._min_points=r,this._metric=s,this._ordered_list=[],this._clusters=[],this._DB=new Array(t.shape[0]).fill(),this.init(),this}
/**
     * Computes the clustering.
     */init(){const t=this._ordered_list,e=this._matrix,r=e.shape[0],s=this._DB,i=this._clusters;let n=this._cluster_index=0;for(let t=0;t<r;++t)s[t]={element:e.row(t),index:t,reachability_distance:void 0,processed:!1};for(const e of s)if(!e.processed&&(e.neighbors=this._get_neighbors(e),e.processed=!0,i.push([e.index]),n=i.length-1,t.push(e),null!=this._core_distance(e))){const t=new Heap(null,(t=>t.reachability_distance),"min");this._update(e,t),this._expand_cluster(t,i[n])}return this}
/**
     * 
     * @private
     * @param {Object} p - a point of {@link matrix}.
     * @returns {Array} An array consisting of the {@link epsilon}-neighborhood of {@link p}.
     */_get_neighbors(t){if("neighbors"in t)return t.neighbors;const e=this._DB,r=this._metric,s=this._epsilon,i=[];for(const n of e)n.index!=t.index&&r(t.element,n.element)<s&&i.push(n);return i}
/**
     * 
     * @private
     * @param {Object} p - a point of {@link matrix}.
     * @returns {Number} The distance to the {@link min_points}-th nearest point of {@link p}, or undefined if the {@link epsilon}-neighborhood has fewer elements than {@link min_points}.
     */_core_distance(t){const e=this._min_points,r=this._metric;if(!(t.neighbors&&t.neighbors.length<=e))return r(t.element,t.neighbors[e].element)}
/**
     * Updates the reachability distance of the points.
     * @private
     * @param {Object} p 
     * @param {Heap} seeds 
     */_update(t,e){const r=this._metric,s=this._core_distance(t),i=this._get_neighbors(t);//p.neighbors;
for(const n of i){if(n.processed)continue;const i=Math.max(s,r(t.element,n.element));
//if (q.reachability_distance == undefined) { // q is not in seeds
e.raw_data().findIndex((t=>t.element==n))<0?(n.reachability_distance=i,e.push(n)):// q is in seeds
i<n.reachability_distance&&(n.reachability_distance=i,e=Heap.heapify(e.data(),(t=>t.reachability_distance),"min"))}}
/**
     * Expands the {@link cluster} with points in {@link seeds}.
     * @private
     * @param {Heap} seeds 
     * @param {Array} cluster 
     */_expand_cluster(t,e){const r=this._ordered_list;for(;!t.empty;){const s=t.pop().element;s.neighbors=this._get_neighbors(s),s.processed=!0,e.push(s.index),r.push(s),null!=this._core_distance(s)&&(this._update(s,t),this._expand_cluster(t,e))}}
/**
     * Returns an array of clusters.
     * @returns {Array<Array>} Array of clusters with the indices of the rows in given {@link matrix}.
     */get_clusters(){const t=[],e=[],r=this._min_points;for(const s of this._clusters)s.length<r?e.push(...s):t.push(s);return t.push(e),t}
/**
     * @returns {Array} Returns an array, where the ith entry defines the cluster affirmation of the ith point of {@link matrix}. (-1 stands for outlier)
     */get_cluster_affirmation(){const t=this._matrix.shape[0],e=new Array(t).fill(),r=this.get_clusters();for(let t=0,s=r.length;t<s;++t){const i=r[t];for(const r of i)e[r]=t<s-1?t:-1}return e}}
/**
 * @class
 * @alias LSP
 * @extends DR
 */class LSP extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LSP
     * @param {Matrix} X - the high-dimensional data. 
     * @param {number} [k = Math.max(Math.floor(N / 10), 2)] - number of neighbors to consider.
     * @param {number} [control_points = Math.ceil(Math.sqrt(N))] - number of controlpoints
     * @param {number} [d = 2] - the dimensionality of the projection.
     * @param {function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @returns {LSP}
     * @see {@link https://ieeexplore.ieee.org/document/4378370}
     */
constructor(t,e,r,s=2,i=euclidean,n=1212){return super(t,s,i,n),super.parameter_list=["k","control_points"],this.parameter("k",Math.min(e??Math.max(Math.floor(this._N/10),2),this._N-1)),this.parameter("control_points",Math.min(r??Math.ceil(Math.sqrt(this._N)),this._N-1)),this._is_initialized=!1,this}
/**
     * 
     * @param {DR} DR - method used for position control points.
     * @param {DR_parameters} DR_parameters - array containing parameters for the DR method which projects the control points
     * @returns {LSP} 
     */init(t=MDS,e=[],r=BallTree){if(this._is_initialized)return this;const s=this.X,i=this._N,n=this.parameter("k"),o=this._d,a=this._metric,h=this.parameter("control_points"),l=new KMedoids(s,h,null,a).get_clusters().medoids,_=new Matrix(h,i,"zeros");l.forEach(((t,e)=>{_.set_entry(e,t,1)}));const c=new t(Matrix.from(l.map((t=>s.row(t)))),...e,o).transform(),u=s.to2dArray,f=new r(u,a),d=new Matrix(i,i,"I"),p=-1/n;u.forEach(((t,e)=>{for(const{index:r}of f.search(t,n).iterate())e!==r&&d.set_entry(e,r,p)}));const m=d.concat(_,"vertical"),y=new Matrix(i,o,"zeros").concat(c,"vertical");return this._A=m,this._b=y,this._is_initialized=!0,this}
/**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */transform(){this.check_init();const t=this._A,e=t.T,r=this._b,s=e.dot(t),i=e.dot(r);return this.Y=Matrix.solve_CG(s,i,this._randomizer),this.projection}}
/**
 * @class
 * @alias TopoMap
 * @memberof module:dimensionality_reduction
 * @extends DR
 */class TopoMap extends DR{
/**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TopoMap
     * @param {Matrix} X - the high-dimensional data.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @returns {TopoMap}
     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}
     */
constructor(t,e=2,r=euclidean,s=1212){return super(t,e,r,s),super.parameter_list=[],[this._N,this._D]=this.X.shape,this._distance_matrix=new Matrix(this._N,this._N,0),this}
/**
     * @private
     */__lazy_distance_matrix(t,e,r){const s=this._distance_matrix,i=this.X,n=s.entry(t,e);if(0===n){let n=r(i.row(t),i.row(e));return s.set_entry(t,e,n),s.set_entry(e,t,n),n}return n}
/**
     * Computes the minimum spanning tree, using a given metric
     * @private
     * @param {Function} metric
     * @see {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}
     */_make_minimum_spanning_tree(t=euclidean){const e=this._N,r=[...this.X];let s=new DisjointSet(r);const i=[];let n=[];for(let r=0;r<e;++r)for(let s=r+1;s<e;++s)n.push([r,s,this.__lazy_distance_matrix(r,s,t)]);n=n.sort(((t,e)=>t[2]-e[2]));for(const[t,e,o]of n){const n=s.find(r[t]),a=s.find(r[e]);n!==a&&(i.push([t,e,o]),s.union(n,a))}return i.sort(((t,e)=>t[2]-e[2]))}
/**
     * initializes TopoMap. Sets all projcted points to zero, and computes a minimum spanning tree.
     */init(){return this.Y=new Matrix(this._N,this._d,0),this._Emst=this._make_minimum_spanning_tree(this._metric),this._is_initialized=!0,this}
/**
     * Returns true if Point C is left of line AB.
     * @private
     * @param {Array} PointA - Point A of line AB
     * @param {Array} PointB - Point B of line AB
     * @param {Array} PointC - Point C
     * @returns {Boolean}
     */__hull_cross([t,e],[r,s],[i,n]){return(r-t)*(n-e)-(s-e)*(i-t)<=0}
/**
     * Computes the convex hull of the set of Points S
     * @private
     * @param {Array} S - Set of Points.
     * @see {@link https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript}
     * @returns {Array} convex hull of S. Starts at the bottom-most point and continues counter-clockwise.
     */__hull(t){const e=t.sort((([t,e],[r,s])=>e-s||t-r)),r=e.length;if(r<=2)return e;const s=[];for(let t=0;t<r;++t){for(;s.length>=2&&this.__hull_cross(s[s.length-2],s[s.length-1],e[t]);)s.pop();s.push(e[t])}const i=[];for(let t=r-1;t>=0;--t){for(;i.length>=2&&this.__hull_cross(i[i.length-2],i[i.length-1],e[t]);)i.pop();i.push(e[t])}return i.pop(),s.pop(),s.concat(i)}
/**
     * Finds the angle to rotate Point A and B to lie on a line parallel to the x-axis.
     * @private
     * @param {Array} PointA
     * @param {Array} PointB
     * @return {Object} Object containing the sinus- and cosinus-values for a rotation.
     */__findAngle([t,e],[r,s]){const i=euclidean([t,e],[r,s]);if(0===i)return{sin:0,cos:1};const n=[(r-t)/i,(s-e)/i],o=n[0];let a=Math.sqrt(1-o*o);return a=n[1]>=0?-a:a,{sin:a,cos:o}}
/**
     * @private
     * @param {Array} hull
     * @param {Array} p
     * @param {Bool} topEdge
     */__align_hull(t,e,r){let s,i,n,o=-1;for(let r=0;r<t.length;++r){const i=euclidean(t[r],e);(-1===o||s>i)&&(s=i,o=r)}r?(i=t[o],n=t[(o+1)%t.length]):(0==o&&(o=t.length-1),i=t[o],n=t[(o-1)%t.length]);const a={tx:-t[o][0],ty:-t[o][1]};if(t.length>=2){const{sin:t,cos:e}=this.__findAngle(i,n);a.sin=t,a.cos=e}else a.sin=0,a.cos=1;return a}
/**
     * @private
     * @param {Array} Point - The point which should get transformed.
     * @param {Object} Transformation - contains the values for translation and rotation.
     */__transform([t,e],{tx:r,ty:s,sin:i,cos:n}){let o=t+r,a=e+s;return[o*n-a*i,o*i+a*n]}
/**
     * Calls {@link __transform} for each point in Set C
     * @private
     * @param {Array} C - Set of points.
     * @param {Object} t - Transform object.
     * @param {Number} yOffset - value to offset set C.
     */__transform_component(t,e,r){const s=t.length;for(let i=0;i<s;++i){const s=t[i],[n,o]=this.__transform(s,e);s[0]=n,s[1]=o+r}}
/**
     * @private
     * @param {Array} u - point u
     * @param {Array} v - point v
     * @param {Number} w - edge weight w
     */__align_components(t,e,r){const s=[...t.__disjoint_set.children],i=[...e.__disjoint_set.children],n=this.__hull(s),o=this.__hull(i),a=this.__align_hull(n,t,!1),h=this.__align_hull(o,e,!0);this.__transform_component(s,a,0),this.__transform_component(i,h,r)}
/**
     * Transforms the inputdata {@link X} to dimensionality 2.
     */transform(){this._is_initialized||this.init();const t=this._Emst,e=[...this.Y],r=new DisjointSet(e.map(((t,e)=>(t.i=e,t))));for(const[s,i,n]of t){const t=r.find(e[s]),o=r.find(e[i]);t!==o&&(this.__align_components(t,o,n),r.union(t,o))}return this.projection}*generator(){this._is_initialized||this.init();const t=this._Emst,e=[...this.Y],r=new DisjointSet(e.map(((t,e)=>(t.i=e,t))));for(const[s,i,n]of t){const t=r.find(e[s]),o=r.find(e[i]);t!==o&&(this.__align_components(t,o,n),r.union(t,o),yield this.projection)}return this.projection}}
/**
 * @class
 * @alias SAMMON
 * @extends DR
 */class SAMMON extends DR{
/**
     * 
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias SAMMON
     * @param {Matrix} X - the high-dimensional data. 
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @returns {SAMMON}
     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}
     */
constructor(t,e=.1,r=2,s=euclidean,i=1212){return super(t,r,s,i),super.parameter_list=["magic"],this.parameter("magic",e),[this._N,this._D]=this.X.shape,this}
/**
     * initializes SAMMON. Sets all projcted points to zero, and computes a minimum spanning tree.
     */init(t="random",e=null){const r=this._N,s=this._d;if("random"===t){const t=this._randomizer;this.Y=new Matrix(r,s,(()=>t.random))}else t instanceof DR&&(this.Y=t.transform(this.X));return this.distance_matrix=e||this.__distance_matrix(this.X),this}
/**
     * @private
     * @param {Matrix} A
     * @returns {Matrix} 
     */__distance_matrix(t){const e=this._metric,r=t.shape[0],s=new Matrix(r,r);for(let i=0;i<r;++i){const n=t.row(i);for(let o=i;o<r;++o){let r=i===o?0:e(n,t.row(o));s.set_entry(i,o,r),s.set_entry(o,i,r)}}return s}
/**
     * Transforms the inputdata {@link X} to dimenionality 2.
     */transform(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step();return this.projection}*generator(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step(),yield this.projection;return this.projection}_step(){const t=this.parameter("magic"),e=this.distance_matrix,r=this._N,s=this._d,i=this._metric;let n=this.Y,o=new Matrix(r,s,0),a=new Float64Array(s);for(let h=0;h<r;++h){let l=new Float64Array(s),_=new Float64Array(s);const c=n.row(h);for(let t=0;t<r;++t){if(h===t)continue;const r=n.row(t),o=new Float64Array(s);for(let t=0;t<s;++t)o[t]=c[t]-r[t];const a=i(c,r),u=e.entry(h,t),f=u-a,d=Math.max(u*a,.01);for(let t=0;t<s;++t)l[t]+=o[t]*f/d,_[t]+=(f-Math.pow(o[t],2)*(1+f/a)/a)/d}for(let e=0;e<s;++e){const r=n.entry(h,e)+(t*l[e]/Math.abs(_[e])||0);o.set_entry(h,e,r),a[e]+=r}}for(let t=0;t<s;++t)a[t]/=r;for(let t=0;t<r;++t)for(let e=0;e<s;++e)n.set_entry(t,e,o.entry(t,e)-a[e]);return n}}var t="0.4.0";export{BallTree,DisjointSet,FASTMAP,Heap,Hierarchical_Clustering,ISOMAP,KMeans,KMedoids,KNN,LDA,LLE,LSP,LTSA,MDS,Matrix,OPTICS,PCA,Randomizer,SAMMON,TSNE,TopoMap,TriMap,UMAP,canberra,chebyshev,cosine,distance_matrix,euclidean,euclidean_squared,hamming,jaccard,k_nearest_neighbors,kahan_sum,linspace,manhattan,max,min,neumair_sum,norm,powell,qr,simultaneous_poweriteration$1 as simultaneous_poweriteration,sokal_michener,t as version,yule};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJ1aWQuZXNtLmpzIiwic291cmNlcyI6WyIuLi9tZXRyaWNzL2V1Y2xpZGVhbi5qcyIsIi4uL251bWVyaWNhbC9rYWhhbl9zdW0uanMiLCIuLi9udW1lcmljYWwvbmV1bWFpcl9zdW0uanMiLCIuLi9tZXRyaWNzL2V1Y2xpZGVhbl9zcXVhcmVkLmpzIiwiLi4vbWV0cmljcy9jb3NpbmUuanMiLCIuLi9tZXRyaWNzL21hbmhhdHRhbi5qcyIsIi4uL21ldHJpY3MvY2hlYnlzaGV2LmpzIiwiLi4vbWV0cmljcy9jYW5iZXJyYS5qcyIsIi4uL21ldHJpY3MvamFjY2FyZC5qcyIsIi4uL21ldHJpY3MvaGFtbWluZy5qcyIsIi4uL21ldHJpY3Mvc29rYWxfbWljaGVuZXIuanMiLCIuLi9tZXRyaWNzL3l1bGUuanMiLCIuLi9tYXRyaXgva19uZWFyZXN0X25laWdoYm9ycy5qcyIsIi4uL21hdHJpeC9NYXRyaXguanMiLCIuLi9tYXRyaXgvZGlzdGFuY2VfbWF0cml4LmpzIiwiLi4vbWF0cml4L2xpbnNwYWNlLmpzIiwiLi4vbWF0cml4L25vcm0uanMiLCIuLi91dGlsL3JhbmRvbWl6ZXIuanMiLCIuLi91dGlsL21heC5qcyIsIi4uL3V0aWwvbWluLmpzIiwiLi4vZGF0YXN0cnVjdHVyZS9IZWFwLmpzIiwiLi4vZGF0YXN0cnVjdHVyZS9EaXNqb2ludFNldC5qcyIsIi4uL2tubi9CYWxsVHJlZS5qcyIsIi4uL2tubi9LTk4uanMiLCIuLi9saW5lYXJfYWxnZWJyYS9xci5qcyIsIi4uL2xpbmVhcl9hbGdlYnJhL3NpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbi5qcyIsIi4uL2RpbXJlZC9EUi5qcyIsIi4uL2RpbXJlZC9QQ0EuanMiLCIuLi9kaW1yZWQvTURTLmpzIiwiLi4vZGltcmVkL0lTT01BUC5qcyIsIi4uL2RpbXJlZC9GQVNUTUFQLmpzIiwiLi4vZGltcmVkL0xEQS5qcyIsIi4uL2RpbXJlZC9MTEUuanMiLCIuLi9kaW1yZWQvTFRTQS5qcyIsIi4uL2RpbXJlZC9UU05FLmpzIiwiLi4vb3B0aW1pemF0aW9uL3Bvd2VsbC5qcyIsIi4uL2RpbXJlZC9VTUFQLmpzIiwiLi4vZGltcmVkL1RyaU1hcC5qcyIsIi4uL2NsdXN0ZXJpbmcvSGllcmFyY2hpY2FsX0NsdXN0ZXJpbmcuanMiLCIuLi9jbHVzdGVyaW5nL0tNZWFucy5qcyIsIi4uL2NsdXN0ZXJpbmcvS01lZG9pZHMuanMiLCIuLi9jbHVzdGVyaW5nL09QVElDUy5qcyIsIi4uL2RpbXJlZC9MU1AuanMiLCIuLi9kaW1yZWQvVG9wb01hcC5qcyIsIi4uL2RpbXJlZC9TQU1NT04uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXVjbGlkZWFuX3NxdWFyZWQgfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuLyoqXG4gKiBDb21wdXRlcyB0aGUgZXVjbGlkZWFuIGRpc3RhbmNlIChsPHN1Yj4yPC9zdWI+KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgZXVjbGlkZWFuXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYlxuICogQHJldHVybnMge051bWJlcn0gdGhlIGV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoZXVjbGlkZWFuX3NxdWFyZWQoYSwgYikpO1xufVxuIiwiLyoqXG4gKiBOdW1lcmljYWwgc3RhYmxlIHN1bW1hdGlvbiB3aXRoIHRoZSBLYWhhbiBzdW1tYXRpb24gYWxnb3JpdGhtLlxuICogQG1lbWJlcm9mIG1vZHVsZTpudW1lcmljYWxcbiAqIEBhbGlhcyBrYWhhbl9zdW1cbiAqIEBwYXJhbSB7QXJyYXl9IHN1bW1hbmRzIC0gQXJyYXkgb2YgdmFsdWVzIHRvIHN1bSB1cC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzdW0uXG4gKiBAc2VlIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LYWhhbl9zdW1tYXRpb25fYWxnb3JpdGhtfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoc3VtbWFuZHMpIHtcbiAgICBsZXQgbiA9IHN1bW1hbmRzLmxlbmd0aDtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBsZXQgY29tcGVuc2F0aW9uID0gMDtcbiAgICBsZXQgeSwgdDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHkgPSBzdW1tYW5kc1tpXSAtIGNvbXBlbnNhdGlvbjtcbiAgICAgICAgdCA9IHN1bSArIHk7XG4gICAgICAgIGNvbXBlbnNhdGlvbiA9IHQgLSBzdW0gLSB5O1xuICAgICAgICBzdW0gPSB0O1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuIiwiLyoqXG4gKiBOdW1lcmljYWwgc3RhYmxlIHN1bW1hdGlvbiB3aXRoIHRoZSBOZXVtYWlyIHN1bW1hdGlvbiBhbGdvcml0aG0uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm51bWVyaWNhbFxuICogQGFsaWFzIG5ldW1haXJfc3VtXG4gKiBAcGFyYW0ge0FycmF5fSBzdW1tYW5kcyAtIEFycmF5IG9mIHZhbHVlcyB0byBzdW0gdXAuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3VtLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2FoYW5fc3VtbWF0aW9uX2FsZ29yaXRobSNGdXJ0aGVyX2VuaGFuY2VtZW50c31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN1bW1hbmRzKSB7XG4gICAgbGV0IG4gPSBzdW1tYW5kcy5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IGNvbXBlbnNhdGlvbiA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBsZXQgc3VtbWFuZCA9IHN1bW1hbmRzW2ldO1xuICAgICAgICBsZXQgdCA9IHN1bSArIHN1bW1hbmQ7XG4gICAgICAgIGlmIChNYXRoLmFicyhzdW0pID49IE1hdGguYWJzKHN1bW1hbmQpKSB7XG4gICAgICAgICAgICBjb21wZW5zYXRpb24gKz0gc3VtIC0gdCArIHN1bW1hbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wZW5zYXRpb24gKz0gc3VtbWFuZCAtIHQgKyBzdW07XG4gICAgICAgIH1cbiAgICAgICAgc3VtID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1bSArIGNvbXBlbnNhdGlvbjtcbn1cbiIsImltcG9ydCB7IG5ldW1haXJfc3VtIH0gZnJvbSBcIi4uL251bWVyaWNhbC9pbmRleC5qc1wiO1xuLyoqXG4gKiBDb21wdXRlcyB0aGUgc3F1YXJlZCBldWNsaWRlYW4gZGlzdGFuY2UgKGw8c3ViPjI8L3N1Yj48c3VwPjI8L3N1cD4pIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1ldHJpY3NcbiAqIEBhbGlhcyBldWNsaWRlYW5fc3F1YXJlZFxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBzcXVhcmVkIGV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgbiA9IGEubGVuZ3RoO1xuICAgIGxldCBzID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGxldCB4ID0gYVtpXTtcbiAgICAgICAgbGV0IHkgPSBiW2ldO1xuICAgICAgICBzW2ldID0gKHggLSB5KSAqICh4IC0geSk7XG4gICAgfVxuICAgIHJldHVybiBuZXVtYWlyX3N1bShzKTtcbn1cbiIsIi8qKlxuICogQ29tcHV0ZXMgdGhlIGNvc2luZSBkaXN0YW5jZSAobm90IHNpbWlsYXJpdHkpIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1ldHJpY3NcbiAqIEBhbGlhcyBjb3NpbmVcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAZXhhbXBsZVxuICogZHJ1aWQuY29zaW5lKFsxLDBdLFsxLDFdKSA9PSAwLjc4NTM5ODE2MzM5NzQ0ODQgPT0gz4AvNFxuICogQHJldHVybnMge051bWJlcn0gVGhlIGNvc2luZSBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBsZXQgc3VtX2EgPSAwO1xuICAgIGxldCBzdW1fYiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgc3VtICs9IGFbaV0gKiBiW2ldO1xuICAgICAgICBzdW1fYSArPSBhW2ldICogYVtpXTtcbiAgICAgICAgc3VtX2IgKz0gYltpXSAqIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmFjb3Moc3VtIC8gKE1hdGguc3FydChzdW1fYSkgKiBNYXRoLnNxcnQoc3VtX2IpKSk7XG59XG4iLCIvKipcbiAqIENvbXB1dGVzIHRoZSBtYW5oYXR0YW4gZGlzdGFuY2UgKGw8c3ViPjE8L3N1Yj4pIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1ldHJpY3NcbiAqIEBhbGlhcyBtYW5oYXR0YW5cbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbWFuaGF0dGFuIGRpc3RhbmNlIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKi8gXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgbiA9IGEubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHN1bSArPSBNYXRoLmFicyhhW2ldIC0gYltpXSk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4iLCIvKipcbiAqIENvbXB1dGVzIHRoZSBjaGVieXNoZXYgZGlzdGFuY2UgKEw8c3ViPuKInjwvc3ViPikgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGNoZWJ5c2hldlxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBjaGVieXNoZXYgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgcmVzLnB1c2goTWF0aC5hYnMoYVtpXSAtIGJbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLnJlcyk7XG59XG4iLCIvKipcbiAqIENvbXB1dGVzIHRoZSBjYW5iZXJyYSBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgY2FuYmVycmFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYSBcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYiBcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBjYW5iZXJyYSBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FuYmVycmFfZGlzdGFuY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgc3VtICs9IChNYXRoLmFicyhhW2ldIC0gYltpXSkgLyAoTWF0aC5hYnMoYVtpXSkgKyBNYXRoLmFicyhiW2ldKSkpXG4gICAgfVxuICAgIHJldHVybiBzdW07XG59IiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgamFjY2FyZCBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgamFjY2FyZFxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBqYWNjYXJkIGRpc3RhbmNlIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgbnVtX25vbl96ZXJvID0gMDtcbiAgICBsZXQgbnVtX2VxdWFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCB4ID0gYVtpXSAhPSAwO1xuICAgICAgICBjb25zdCB5ID0gYltpXSAhPSAwO1xuICAgICAgICBudW1fbm9uX3plcm8gKz0geCB8fCB5O1xuICAgICAgICBudW1fZXF1YWwgKz0geCAmJiB5O1xuICAgIH1cbiAgICByZXR1cm4gKG51bV9ub25femVybyAtIG51bV9lcXVhbCkgLyBudW1fbm9uX3plcm87XG59XG4iLCIvKipcbiAqIENvbXB1dGVzIHRoZSBoYW1taW5nIGRpc3RhbmNlIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1ldHJpY3NcbiAqIEBhbGlhcyBoYW1taW5nXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYlxuICogQHJldHVybnMge051bWJlcn0gdGhlIGhhbW1pbmcgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbiA9IGEubGVuZ3RoO1xuICAgIGxldCBkaXNhZ3JlZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY29uc3QgeCA9IGFbaV07XG4gICAgICAgIGNvbnN0IHkgPSBiW2ldO1xuICAgICAgICBkaXNhZ3JlZSArPSB4ICE9IHk7XG4gICAgfVxuICAgIHJldHVybiBkaXNhZ3JlZSAvIG47XG59XG4iLCIvKipcbiAqIENvbXB1dGVzIHRoZSBTb2thbC1NaWNoZW5lciBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgc29rYWxfbWljaGVuZXJcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYSBcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYiBcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBTb2thbC1NaWNoZW5lciBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LiAgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWRcbiAgICBjb25zdCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IG51bV9ub3RfZXF1YWwgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IHggPSBhW2ldICE9IDA7XG4gICAgICAgIGNvbnN0IHkgPSBiW2ldICE9IDA7XG4gICAgICAgIG51bV9ub3RfZXF1YWwgKz0geCAhPSB5O1xuICAgIH1cbiAgICByZXR1cm4gKDIgKiBudW1fbm90X2VxdWFsKSAvIChuICsgbnVtX25vdF9lcXVhbCk7XG59IiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgeXVsZSBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgeXVsZVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB5dWxlIGRpc3RhbmNlIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgbnVtX3RydWVfdHJ1ZSA9IDA7XG4gICAgbGV0IG51bV90cnVlX2ZhbHNlID0gMDtcbiAgICBsZXQgbnVtX2ZhbHNlX3RydWUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IHggPSBhW2ldICE9IDA7XG4gICAgICAgIGNvbnN0IHkgPSBiW2ldICE9IDA7XG4gICAgICAgIG51bV90cnVlX3RydWUgKz0geCAmJiB5O1xuICAgICAgICBudW1fdHJ1ZV9mYWxzZSArPSB4ICYmICF5O1xuICAgICAgICBudW1fZmFsc2VfdHJ1ZSArPSAheCAmJiB4O1xuICAgIH1cbiAgICBjb25zdCBudW1fZmFsc2VfZmFsc2UgPSBuIC0gbnVtX3RydWVfdHJ1ZSAtIG51bV90cnVlX2ZhbHNlIC0gbnVtX2ZhbHNlX3RydWU7XG4gICAgcmV0dXJuIG51bV90cnVlX2ZhbHNlID09IDAgfHwgbnVtX2ZhbHNlX3RydWUgPT0gMCA/IDAgOiAoMiAqIG51bV90cnVlX2ZhbHNlICogbnVtX2ZhbHNlX3RydWUpIC8gKG51bV90cnVlX3RydWUgKiBudW1fZmFsc2VfZmFsc2UgKyBudW1fdHJ1ZV9mYWxzZSAqIG51bV9mYWxzZV90cnVlKTtcbn1cbiIsImltcG9ydCB7IGRpc3RhbmNlX21hdHJpeCBhcyBkbWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBBXG4gKiBAcGFyYW0geyp9IGtcbiAqIEBwYXJhbSB7Kn0gZGlzdGFuY2VfbWF0cml4XG4gKiBAcGFyYW0geyp9IG1ldHJpY1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoQSwgaywgZGlzdGFuY2VfbWF0cml4ID0gbnVsbCwgbWV0cmljID0gZXVjbGlkZWFuKSB7XG4gICAgY29uc3Qgcm93cyA9IEEuc2hhcGVbMF07XG4gICAgbGV0IEQgPSBkaXN0YW5jZV9tYXRyaXggPz8gZG1hdHJpeChBLCBtZXRyaWMpO1xuICAgIGxldCBuTiA9IG5ldyBBcnJheShyb3dzKTtcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICBuTltyb3ddID0gQXJyYXkuZnJvbShELnJvdyhyb3cpKVxuICAgICAgICAgICAgLm1hcCgoZGlzdGFuY2UsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGk6IHJvdyxcbiAgICAgICAgICAgICAgICAgICAgajogY29sLFxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2UpXG4gICAgICAgICAgICAuc2xpY2UoMSwgayArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbk47XG59XG4iLCJpbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcbmltcG9ydCB7IFJhbmRvbWl6ZXIgfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBNYXRyaXhcbiAqIEByZXF1aXJlcyBtb2R1bGU6bnVtZXJpY2FsL25ldW1haXJfc3VtXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRyaXgge1xuICAgIC8qKlxuICAgICAqIGNyZWF0ZXMgYSBuZXcgTWF0cml4LiBFbnRyaWVzIGFyZSBzdG9yZWQgaW4gYSBGbG9hdDY0QXJyYXkuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTptYXRyaXhcbiAgICAgKiBAYWxpYXMgTWF0cml4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgLSBUaGUgYW1vdW50IG9mIHJvd3Mgb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29scyAtIFRoZSBhbW91bnQgb2YgY29sdW1ucyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9ufHN0cmluZ3xudW1iZXIpfSB2YWx1ZT0wIC0gQ2FuIGJlIGEgZnVuY3Rpb24gd2l0aCByb3cgYW5kIGNvbCBhcyBwYXJhbWV0ZXJzLCBhIG51bWJlciwgb3IgXCJ6ZXJvc1wiLCBcImlkZW50aXR5XCIgb3IgXCJJXCIsIG9yIFwiY2VudGVyXCIuXG4gICAgICogIC0gKipmdW5jdGlvbioqOiBmb3IgZWFjaCBlbnRyeSB0aGUgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgd2l0aCB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIGFjdHVhbCByb3cgYW5kIGNvbHVtbi5cbiAgICAgKiAgLSAqKnN0cmluZyoqOiBhbGxvd2VkIGFyZVxuICAgICAqICAgICAgLSBcInplcm9cIiwgY3JlYXRlcyBhIHplcm8gbWF0cml4LlxuICAgICAqICAgICAgLSBcImlkZW50aXR5XCIgb3IgXCJJXCIsIGNyZWF0ZXMgYW4gaWRlbnRpdHkgbWF0cml4LlxuICAgICAqICAgICAgLSBcImNlbnRlclwiLCBjcmVhdGVzIGFuIGNlbnRlciBtYXRyaXguXG4gICAgICogIC0gKipudW1iZXIqKjogY3JlYXRlIGEgbWF0cml4IGZpbGxlZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBuZXcgTWF0cml4KDEwLCAxMCwgKCkgPT4gTWF0aC5yYW5kb20oKSk7IC8vY3JlYXRlcyBhIDEwIHRpbWVzIDEwIHJhbmRvbSBtYXRyaXguXG4gICAgICogbGV0IEIgPSBuZXcgTWF0cml4KDMsIDMsIFwiSVwiKTsgLy8gY3JlYXRlcyBhIDMgdGltZXMgMyBpZGVudGl0eSBtYXRyaXguXG4gICAgICogQHJldHVybnMge01hdHJpeH0gcmV0dXJucyBhIHtAbGluayByb3dzfSB0aW1lcyB7QGxpbmsgY29sc30gTWF0cml4IGZpbGxlZCB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm93cyA9IG51bGwsIGNvbHMgPSBudWxsLCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuX2NvbHMgPSBjb2xzO1xuICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKHJvd3MgJiYgY29scykge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IHZhbHVlKHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiemVyb3NcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChyb3dzLCBjb2xzLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcImlkZW50aXR5XCIgfHwgdmFsdWUgPT09IFwiSVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbcm93ICogY29scyArIHJvd10gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiY2VudGVyXCIgJiYgcm93cyA9PSBjb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoaSwgaikgPT4gKGkgPT09IGogPyAxIDogMCkgLSAxIC8gcm93cztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IHZhbHVlKHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkocm93cyAqIGNvbHMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1hdHJpeCBvdXQgb2Yge0BsaW5rIEF9LlxuICAgICAqIEBwYXJhbSB7KE1hdHJpeHxBcnJheXxGbG9hdDY0QXJyYXl8bnVtYmVyKX0gQSAtIFRoZSBtYXRyaXgsIGFycmF5LCBvciBudW1iZXIsIHdoaWNoIHNob3VsZCBjb252ZXJ0ZWQgdG8gYSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtcInJvd1wifFwiY29sXCJ8XCJkaWFnXCJ9IFt0eXBlID0gXCJyb3dcIl0gLSBJZiB7QGxpbmsgQX0gaXMgYSBBcnJheSBvciBGbG9hdDY0QXJyYXksIHRoZW4gdHlwZSBkZWZpbmVzIGlmIGl0IGlzIGEgcm93LSBvciBhIGNvbHVtbiB2ZWN0b3IuXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDBdLCBbMCwgMV1dKTsgLy9jcmVhdGVzIGEgdHdvIGJ5IHR3byBpZGVudGl0eSBtYXRyaXguXG4gICAgICogbGV0IFMgPSBNYXRyaXguZnJvbShbMSwgMiwgM10sIFwiZGlhZ1wiKTsgLy8gY3JlYXRlcyBhIDMgYnkgMyBtYXRyaXggd2l0aCAxLCAyLCAzIG9uIGl0cyBkaWFnb25hbC4gW1sxLCAwLCAwXSwgWzAsIDIsIDBdLCBbMCwgMCwgM11dXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oQSwgdHlwZSA9IFwicm93XCIpIHtcbiAgICAgICAgaWYgKEEgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBBLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShBKSB8fCBBIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSB7XG4gICAgICAgICAgICBsZXQgbSA9IEEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG0gPT09IDApIHRocm93IG5ldyBFcnJvcihcIkFycmF5IGlzIGVtcHR5XCIpO1xuICAgICAgICAgICAgLy8gMWRcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShBWzBdKSAmJiAhKEFbMF0gaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicm93XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoMSwgbSwgKF8sIGopID0+IEFbal0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb2xcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtLCAxLCAoaSkgPT4gQVtpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRpYWdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtLCBtLCAoaSwgaikgPT4gKGkgPT0gaiA/IEFbaV0gOiAwKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiMWQgYXJyYXkgaGFzIE5hTiBlbnRyaWVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAyZFxuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEFbMF0pIHx8IEFbMF0gaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbiA9IEFbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG07ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBW3Jvd10ubGVuZ3RoICE9PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YXJpb3VzIGFycmF5IGxlbmd0aHNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgobSwgbiwgKGksIGopID0+IEFbaV1bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBBID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCgxLCAxLCBBKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVycm9yXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIHJvd308c3VwPnRoPC9zdXA+IHJvdyBmcm9tIHRoZSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgICAqIEByZXR1cm5zIHtGbG9hdDY0QXJyYXl9XG4gICAgICovXG4gICAgcm93KHJvdykge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICByZXR1cm4gZGF0YS5zdWJhcnJheShyb3cgKiBjb2xzLCAocm93ICsgMSkgKiBjb2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGdlbmVyYXRvciB5aWVsZGluZyBlYWNoIHJvdyBvZiB0aGUgTWF0cml4LlxuICAgICAqIEB5aWVsZHMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICAqaXRlcmF0ZV9yb3dzKCkge1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIHlpZWxkIGRhdGEuc3ViYXJyYXkocm93ICogY29scywgKHJvdyArIDEpICogY29scyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIHtAbGluayBNYXRyaXh9IG9iamVjdCBhbiBpdGVyYWJsZSBvYmplY3QuXG4gICAgICogQHlpZWxkcyB7RmxvYXQ2NEFycmF5fVxuICAgICAqL1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5pdGVyYXRlX3Jvd3MoKSkge1xuICAgICAgICAgICAgeWllbGQgcm93O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZW50cmllcyBvZiB7QGxpbmsgcm93fTxzdXA+dGg8L3N1cD4gcm93IGZyb20gdGhlIE1hdHJpeCB0byB0aGUgZW50cmllcyBmcm9tIHtAbGluayB2YWx1ZXN9LlxuICAgICAqIEBwYXJhbSB7aW50fSByb3dcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHNldF9yb3cocm93LCB2YWx1ZXMpIHtcbiAgICAgICAgbGV0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmIHZhbHVlcy5sZW5ndGggPT09IGNvbHMpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlc1tvZmZzZXQgKyBjb2xdID0gdmFsdWVzW2NvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWVzIGluc3RhbmNlb2YgTWF0cml4ICYmIHZhbHVlcy5zaGFwZVsxXSA9PT0gY29scyAmJiB2YWx1ZXMuc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlc1tvZmZzZXQgKyBjb2xdID0gdmFsdWVzLl9kYXRhW2NvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIGNvbH08c3VwPnRoPC9zdXA+IGNvbHVtbiBmcm9tIHRoZSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtpbnR9IGNvbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBjb2woY29sKSB7XG4gICAgICAgIGxldCByZXN1bHRfY29sID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLl9yb3dzKTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5fcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIHJlc3VsdF9jb2xbcm93XSA9IHRoaXMudmFsdWVzW3JvdyAqIHRoaXMuX2NvbHMgKyBjb2xdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRfY29sO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBjb2x9PHN1cD50aDwvc3VwPiBlbnRyeSBmcm9tIHRoZSB7QGxpbmsgcm93fTxzdXA+dGg8L3N1cD4gcm93IG9mIHRoZSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtpbnR9IHJvd1xuICAgICAqIEBwYXJhbSB7aW50fSBjb2xcbiAgICAgKiBAcmV0dXJucyB7ZmxvYXQ2NH1cbiAgICAgKi9cbiAgICBlbnRyeShyb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbcm93ICogdGhpcy5fY29scyArIGNvbF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUge0BsaW5rIGNvbH08c3VwPnRoPC9zdXA+IGVudHJ5IGZyb20gdGhlIHtAbGluayByb3d9PHN1cD50aDwvc3VwPiByb3cgb2YgdGhlIE1hdHJpeCB0byB0aGUgZ2l2ZW4ge0BsaW5rIHZhbHVlfS5cbiAgICAgKiBAcGFyYW0ge2ludH0gcm93XG4gICAgICogQHBhcmFtIHtpbnR9IGNvbFxuICAgICAqIEBwYXJhbSB7ZmxvYXQ2NH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHNldF9lbnRyeShyb3csIGNvbCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNbcm93ICogdGhpcy5fY29scyArIGNvbF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyB0cmFuc3Bvc2VkIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHRyYW5zcG9zZSgpIHtcbiAgICAgICAgbGV0IEIgPSBuZXcgTWF0cml4KHRoaXMuX2NvbHMsIHRoaXMuX3Jvd3MsIChyb3csIGNvbCkgPT4gdGhpcy5lbnRyeShjb2wsIHJvdykpO1xuICAgICAgICByZXR1cm4gQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHRyYW5zcG9zZWQgTWF0cml4LiBTaG9ydC1mb3JtIG9mIHtAZnVuY3Rpb24gdHJhbnNwb3NlfS5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIGdldCBUKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3Bvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBpbnZlcnNlKCkge1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgIGxldCBCID0gbmV3IE1hdHJpeChyb3dzLCAyICogY29scywgKGksIGopID0+IHtcbiAgICAgICAgICAgIGlmIChqID49IGNvbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA9PT0gaiAtIGNvbHMgPyAxIDogMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50cnkoaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaCA9IDA7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgd2hpbGUgKGggPCByb3dzICYmIGsgPCBjb2xzKSB7XG4gICAgICAgICAgICB2YXIgaV9tYXggPSAwO1xuICAgICAgICAgICAgbGV0IG1heF92YWwgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gaDsgaSA8IHJvd3M7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBNYXRoLmFicyhCLmVudHJ5KGksIGspKTtcbiAgICAgICAgICAgICAgICBpZiAobWF4X3ZhbCA8IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpX21heCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIG1heF92YWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEIuZW50cnkoaV9tYXgsIGspID09IDApIHtcbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgcm93c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMiAqIGNvbHM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaF92YWwgPSBCLmVudHJ5KGgsIGopO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaV92YWwgPSBCLmVudHJ5KGlfbWF4LCBqKTtcbiAgICAgICAgICAgICAgICAgICAgQi5zZXRfZW50cnkoaCwgaiwgaF92YWwpO1xuICAgICAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShpX21heCwgaiwgaV92YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaCArIDE7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGYgPSBCLmVudHJ5KGksIGspIC8gQi5lbnRyeShoLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgQi5zZXRfZW50cnkoaSwgaywgMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBrICsgMTsgaiA8IDIgKiBjb2xzOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEIuc2V0X2VudHJ5KGksIGosIEIuZW50cnkoaSwgaikgLSBCLmVudHJ5KGgsIGopICogZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaCsrO1xuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBsZXQgZiA9IEIuZW50cnkocm93LCByb3cpO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gcm93OyBjb2wgPCAyICogY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShyb3csIGNvbCwgQi5lbnRyeShyb3csIGNvbCkgLyBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IHJvd3MgLSAxOyByb3cgPj0gMDsgLS1yb3cpIHtcbiAgICAgICAgICAgIGxldCBCX3Jvd19yb3cgPSBCLmVudHJ5KHJvdywgcm93KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgQl9pX3JvdyA9IEIuZW50cnkoaSwgcm93KTtcbiAgICAgICAgICAgICAgICBsZXQgZiA9IEJfaV9yb3cgLyBCX3Jvd19yb3c7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCAyICogY29sczsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBCX2lfaiA9IEIuZW50cnkoaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBCX3Jvd19qID0gQi5lbnRyeShyb3csIGopO1xuICAgICAgICAgICAgICAgICAgICBCX2lfaiA9IEJfaV9qIC0gQl9yb3dfaiAqIGY7XG4gICAgICAgICAgICAgICAgICAgIEIuc2V0X2VudHJ5KGksIGosIEJfaV9qKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChyb3dzLCBjb2xzLCAoaSwgaikgPT4gQi5lbnRyeShpLCBqICsgY29scykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0LiBJZiB7QGxpbmsgQn0gaXMgYW4gQXJyYXkgb3IgRmxvYXQ2NEFycmF5IHRoZW4gYW4gQXJyYXkgZ2V0cyByZXR1cm5lZC4gSWYge0BsaW5rIEJ9IGlzIGEgTWF0cml4IHRoZW4gYSBNYXRyaXggZ2V0cyByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0geyhNYXRyaXh8QXJyYXl8RmxvYXQ2NEFycmF5KX0gQiB0aGUgcmlnaHQgc2lkZVxuICAgICAqIEByZXR1cm5zIHsoTWF0cml4fEFycmF5KX1cbiAgICAgKi9cbiAgICBkb3QoQikge1xuICAgICAgICBpZiAoQiBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IEEgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKEEuc2hhcGVbMV0gIT09IEIuc2hhcGVbMF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEuZG90KEIpOiBBIGlzIGEgJHtBLnNoYXBlLmpvaW4oXCIg4qivIFwiKX0tTWF0cml4LCBCIGlzIGEgJHtCLnNoYXBlLmpvaW4oXCIg4qivIFwiKX0tTWF0cml4OiBcbiAgICAgICAgICAgICAgICBBIGhhcyAke0Euc2hhcGVbMV19IGNvbHMgYW5kIEIgJHtCLnNoYXBlWzBdfSByb3dzLiBcbiAgICAgICAgICAgICAgICBNdXN0IGJlIGVxdWFsIWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IEkgPSBBLnNoYXBlWzFdO1xuICAgICAgICAgICAgbGV0IEMgPSBuZXcgTWF0cml4KEEuc2hhcGVbMF0sIEIuc2hhcGVbMV0sIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IEFfaSA9IEEucm93KHJvdyk7XG4gICAgICAgICAgICAgICAgY29uc3QgQl9pID0gQi5jb2woY29sKTtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gQV9pW2ldICogQl9pW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gQztcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEIpIHx8IEIgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgICAgIGlmIChCLmxlbmd0aCAhPT0gcm93cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQS5kb3QoQik6IEEgaGFzICR7cm93c30gY29scyBhbmQgQiBoYXMgJHtCLmxlbmd0aH0gcm93cy4gTXVzdCBiZSBlcXVhbCFgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBDID0gbmV3IEFycmF5KHJvd3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICBDW3Jvd10gPSBuZXVtYWlyX3N1bSh0aGlzLnJvdyhyb3cpLm1hcCgoZSkgPT4gZSAqIEJbcm93XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEIgbXVzdCBiZSBNYXRyaXggb3IgQXJyYXlgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBvdXRlciBwcm9kdWN0IGZyb20ge0BsaW5rIHRoaXN9IGFuZCB7QGxpbmsgQn0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEJcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIG91dGVyKEIpIHtcbiAgICAgICAgbGV0IEEgPSB0aGlzO1xuICAgICAgICBsZXQgbCA9IEEuX2RhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgciA9IEIuX2RhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobCAhPSByKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgQyA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgQy5zaGFwZSA9IFtcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgKGksIGopID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBLl9kYXRhW2ldICogQi5fZGF0YVtqXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQy5lbnRyeShqLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gQztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIG1hdHJpeCB7QGxpbmsgQn0gdG8gdGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQiAtIG1hdHJpeCB0byBhcHBlbmQuXG4gICAgICogQHBhcmFtIHtcImhvcml6b250YWxcInxcInZlcnRpY2FsXCJ8XCJkaWFnXCJ9IFt0eXBlID0gXCJob3Jpem9udGFsXCJdIC0gdHlwZSBvZiBjb25jYXRlbmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAxXSwgWzEsIDFdXSk7IC8vIDIgYnkgMiBtYXRyaXggZmlsbGVkIHdpdGggb25lcy5cbiAgICAgKiBsZXQgQiA9IE1hdHJpeC5mcm9tKFtbMiwgMl0sIFsyLCAyXV0pOyAvLyAyIGJ5IDIgbWF0cml4IGZpbGxlZCB3aXRoIHR3b3MuXG4gICAgICpcbiAgICAgKiBBLmNvbmNhdChCLCBcImhvcml6b250YWxcIik7IC8vIDIgYnkgNCBtYXRyaXguIFtbMSwgMSwgMiwgMl0sIFsxLCAxLCAyLCAyXV1cbiAgICAgKiBBLmNvbmNhdChCLCBcInZlcnRpY2FsXCIpOyAvLyA0IGJ5IDIgbWF0cml4LiBbWzEsIDFdLCBbMSwgMV0sIFsyLCAyXSwgWzIsIDJdXVxuICAgICAqIEEuY29uY2F0KEIsIFwiZGlhZ1wiKTsgLy8gNCBieSA0IG1hdHJpeC4gW1sxLCAxLCAwLCAwXSwgWzEsIDEsIDAsIDBdLCBbMCwgMCwgMiwgMl0sIFswLCAwLCAyLCAyXV1cbiAgICAgKi9cbiAgICBjb25jYXQoQiwgdHlwZSA9IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzO1xuICAgICAgICBjb25zdCBbcm93c19BLCBjb2xzX0FdID0gQS5zaGFwZTtcbiAgICAgICAgY29uc3QgW3Jvd3NfQiwgY29sc19CXSA9IEIuc2hhcGU7XG4gICAgICAgIGlmICh0eXBlID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICBpZiAocm93c19BICE9IHJvd3NfQikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQS5jb25jYXQoQiwgXCJob3Jpem9udGFsXCIpOiBBIGFuZCBCIG5lZWQgc2FtZSBudW1iZXIgb2Ygcm93cywgQSBoYXMgJHtyb3dzX0F9IHJvd3MsIEIgaGFzICR7cm93c19CfSByb3dzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgWCA9IG5ldyBNYXRyaXgocm93c19BLCBjb2xzX0EgKyBjb2xzX0IsIFwiemVyb3NcIik7XG4gICAgICAgICAgICBYLnNldF9ibG9jaygwLCAwLCBBKTtcbiAgICAgICAgICAgIFguc2V0X2Jsb2NrKDAsIGNvbHNfQSwgQik7XG4gICAgICAgICAgICByZXR1cm4gWDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgaWYgKGNvbHNfQSAhPSBjb2xzX0IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEuY29uY2F0KEIsIFwidmVydGljYWxcIik6IEEgYW5kIEIgbmVlZCBzYW1lIG51bWJlciBvZiBjb2x1bW5zLCBBIGhhcyAke2NvbHNfQX0gY29sdW1ucywgQiBoYXMgJHtjb2xzX0J9IGNvbHVtbnMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBYID0gbmV3IE1hdHJpeChyb3dzX0EgKyByb3dzX0IsIGNvbHNfQSwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgICAgIFguc2V0X2Jsb2NrKDAsIDAsIEEpO1xuICAgICAgICAgICAgWC5zZXRfYmxvY2socm93c19BLCAwLCBCKTtcbiAgICAgICAgICAgIHJldHVybiBYO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJkaWFnXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IFggPSBuZXcgTWF0cml4KHJvd3NfQSArIHJvd3NfQiwgY29sc19BICsgY29sc19CLCBcInplcm9zXCIpO1xuICAgICAgICAgICAgWC5zZXRfYmxvY2soMCwgMCwgQSk7XG4gICAgICAgICAgICBYLnNldF9ibG9jayhyb3dzX0EsIGNvbHNfQSwgQik7XG4gICAgICAgICAgICByZXR1cm4gWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdHlwZSBtdXN0IGJlIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIiwgYnV0IHR5cGUgaXMgJHt0eXBlfSFgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyaXRlcyB0aGUgZW50cmllcyBvZiBCIGluIEEgYXQgYW4gb2Zmc2V0IHBvc2l0aW9uIGdpdmVuIGJ5IHtAbGluayBvZmZzZXRfcm93fSBhbmQge0BsaW5rIG9mZnNldF9jb2x9LlxuICAgICAqIEBwYXJhbSB7aW50fSBvZmZzZXRfcm93XG4gICAgICogQHBhcmFtIHtpbnR9IG9mZnNldF9jb2xcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc2V0X2Jsb2NrKG9mZnNldF9yb3csIG9mZnNldF9jb2wsIEIpIHtcbiAgICAgICAgbGV0IFtyb3dzLCBjb2xzXSA9IEIuc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBpZiAocm93ID4gdGhpcy5fcm93cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sID4gdGhpcy5fY29scykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfZW50cnkocm93ICsgb2Zmc2V0X3JvdywgY29sICsgb2Zmc2V0X2NvbCwgQi5lbnRyeShyb3csIGNvbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBlbnRyaWVzIGZyb20gdGhlIHtAbGluayBzdGFydF9yb3d9PHN1cD50aDwvc3VwPiByb3cgdG8gdGhlIHtAbGluayBlbmRfcm93fTxzdXA+dGg8L3N1cD4gcm93LCB0aGUge0BsaW5rIHN0YXJ0X2NvbH08c3VwPnRoPC9zdXA+IGNvbHVtbiB0byB0aGUge0BsaW5rIGVuZF9jb2x9PHN1cD50aDwvc3VwPiBjb2x1bW4gb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBJZiB7QGxpbmsgZW5kX3Jvd30gb3Ige0BsaW5rIGVuZF9jb2x9IGlzIGVtcHR5LCB0aGUgcmVzcGVjdGl2ZSB2YWx1ZSBpcyBzZXQgdG8ge0BsaW5rIHRoaXMucm93c30gb3Ige0BsaW5rIHRoaXMuY29sc30uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0X3Jvd1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydF9jb2xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZF9yb3cgPSBudWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kX2NvbCA9IG51bGxdXG4gICAgICogQHJldHVybnMge01hdHJpeH0gUmV0dXJucyBhIGVuZF9yb3cgLSBzdGFydF9yb3cgdGltZXMgZW5kX2NvbCAtIHN0YXJ0X2NvbCBtYXRyaXgsIHdpdGggcmVzcGVjdGl2ZSBlbnRyaWVzIGZyb20gdGhlIG1hdHJpeC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDIsIDNdLCBbNCwgNSwgNl0sIFs3LCA4LCA5XV0pOyAvLyBhIDMgYnkgMyBtYXRyaXguXG4gICAgICpcbiAgICAgKiBBLmdldF9ibG9jaygxLCAxKTsgLy8gW1s1LCA2XSwgWzgsIDldXVxuICAgICAqIEEuZ2V0X2Jsb2NrKDAsIDAsIDEsIDEpOyAvLyBbWzFdXVxuICAgICAqIEEuZ2V0X2Jsb2NrKDEsIDEsIDIsIDIpOyAvLyBbWzVdXVxuICAgICAqIEEuZ2V0X2Jsb2NrKDAsIDAsIDIsIDIpOyAvLyBbWzEsIDJdLCBbNCwgNV1dXG4gICAgICovXG4gICAgZ2V0X2Jsb2NrKHN0YXJ0X3Jvdywgc3RhcnRfY29sLCBlbmRfcm93ID0gbnVsbCwgZW5kX2NvbCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgW3Jvd3MsIGNvbHNdID0gdGhpcy5zaGFwZTtcbiAgICAgICAgZW5kX3JvdyA9IGVuZF9yb3cgPz8gcm93cztcbiAgICAgICAgZW5kX2NvbCA9IGVuZF9jb2wgPz8gY29scztcbiAgICAgICAgaWYgKGVuZF9yb3cgPD0gc3RhcnRfcm93IHx8IGVuZF9jb2wgPD0gc3RhcnRfY29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgICAgICAgICAgIGVuZF9yb3cgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RhcnRfcm93LCBhbmQgXG4gICAgICAgICAgICAgICAgZW5kX2NvbCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdGFydF9jb2wsIGJ1dFxuICAgICAgICAgICAgICAgIGVuZF9yb3cgPSAke2VuZF9yb3d9LCBzdGFydF9yb3cgPSAke3N0YXJ0X3Jvd30sIGVuZF9jb2wgPSAke2VuZF9jb2x9LCBhbmQgc3RhcnRfY29sID0gJHtzdGFydF9jb2x9IWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFggPSBuZXcgTWF0cml4KGVuZF9yb3cgLSBzdGFydF9yb3csIGVuZF9jb2wgLSBzdGFydF9jb2wsIFwiemVyb3NcIik7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IHN0YXJ0X3JvdywgbmV3X3JvdyA9IDA7IHJvdyA8IGVuZF9yb3c7ICsrcm93LCArK25ld19yb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHN0YXJ0X2NvbCwgbmV3X2NvbCA9IDA7IGNvbCA8IGVuZF9jb2w7ICsrY29sLCArK25ld19jb2wpIHtcbiAgICAgICAgICAgICAgICBYLnNldF9lbnRyeShuZXdfcm93LCBuZXdfY29sLCB0aGlzLmVudHJ5KHJvdywgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFg7XG4gICAgICAgIC8vcmV0dXJuIG5ldyBNYXRyaXgoZW5kX3JvdyAtIHN0YXJ0X3JvdywgZW5kX2NvbCAtIHN0YXJ0X2NvbCwgKGksIGopID0+IHRoaXMuZW50cnkoaSArIHN0YXJ0X3JvdywgaiArIHN0YXJ0X2NvbCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgZ2F0aGVyaW5nIGVudHJpZXMgZGVmaW5lZCBieSB0aGUgaW5kaWNlcyBnaXZlbiBieSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHJvd19pbmRpY2VzIC0gQXJyYXkgY29uc2lzdHMgb2YgaW5kaWNlcyBvZiByb3dzIGZvciBnYXRoZXJpbmcgZW50cmllcyBvZiB0aGlzIG1hdHJpeFxuICAgICAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gY29sX2luZGljZXMgIC0gQXJyYXkgY29uc2lzdHMgb2YgaW5kaWNlcyBvZiBjb2xzIGZvciBnYXRoZXJpbmcgZW50cmllcyBvZiB0aGlzIG1hdHJpeFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgZ2F0aGVyKHJvd19pbmRpY2VzLCBjb2xfaW5kaWNlcykge1xuICAgICAgICBjb25zdCBOID0gcm93X2luZGljZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBEID0gY29sX2luZGljZXMubGVuZ3RoO1xuXG4gICAgICAgIGNvbnN0IFIgPSBuZXcgTWF0cml4KE4sIEQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgcm93X2luZGV4ID0gcm93X2luZGljZXNbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbF9pbmRleCA9IGNvbF9pbmRpY2VzW2pdO1xuICAgICAgICAgICAgICAgIFIuc2V0X2VudHJ5KGksIGosIHRoaXMuZW50cnkocm93X2luZGV4LCBjb2xfaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXguXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmIGZ1bmN0aW9uIHRha2VzIDIgcGFyYW1ldGVycywgdGhlIHZhbHVlIG9mIHRoZSBhY3R1YWwgZW50cnkgYW5kIGEgdmFsdWUgZ2l2ZW4gYnkgdGhlIGZ1bmN0aW9uIHtAbGluayB2fS4gVGhlIHJlc3VsdCBvZiB7QGxpbmsgZn0gZ2V0cyB3cml0ZW4gdG8gdGhlIE1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB2IGZ1bmN0aW9uIHRha2VzIDIgcGFyYW1ldGVycyBmb3Igcm93IGFuZCBjb2wsIGFuZCByZXR1cm5zIGEgdmFsdWUgd2l0Y2ggc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIGNvbHRoIGVudHJ5IG9mIHRoZSByb3d0aCByb3cgb2YgdGhlIG1hdHJpeC5cbiAgICAgKi9cbiAgICBfYXBwbHlfYXJyYXkoZiwgdikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IFtyb3dzLCBjb2xzXSA9IHRoaXMuc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gb2Zmc2V0ICsgY29sO1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBmKGRhdGFbaV0sIHYocm93LCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfYXBwbHlfcm93d2lzZV9hcnJheSh2YWx1ZXMsIGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5X2FycmF5KGYsIChfLCBqKSA9PiB2YWx1ZXNbal0pO1xuICAgIH1cblxuICAgIF9hcHBseV9jb2x3aXNlX2FycmF5KHZhbHVlcywgZikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IFtyb3dzLCBjb2xzXSA9IHRoaXMuc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gb2Zmc2V0ICsgY29sO1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBmKGRhdGFbaV0sIHZhbHVlc1tyb3ddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfYXBwbHkodmFsdWUsIGYpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgW3ZhbHVlX3Jvd3MsIHZhbHVlX2NvbHNdID0gdmFsdWUuc2hhcGU7XG4gICAgICAgICAgICBsZXQgW3Jvd3MsIGNvbHNdID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZV9yb3dzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHMgIT09IHZhbHVlX2NvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb2xzICE9PSB2YWx1ZV9jb2xzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gZihkYXRhW3JvdyAqIGNvbHMgKyBjb2xdLCB2YWx1ZS5lbnRyeSgwLCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVfY29scyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3dzICE9PSB2YWx1ZV9yb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcm93cyAhPT0gdmFsdWVfcm93c2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWUuZW50cnkocm93LCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJvd3MgPT0gdmFsdWVfcm93cyAmJiBjb2xzID09IHZhbHVlX2NvbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWUuZW50cnkocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgICAgICBsZXQgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSByb3dzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbcm93ICogY29scyArIGNvbF0gPSBmKGRhdGFbcm93ICogY29scyArIGNvbF0sIHZhbHVlW3Jvd10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IGNvbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWVbY29sXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXJyb3JgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fcm93cyAqIHRoaXMuX2NvbHM7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2ldID0gZihkYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgbGV0IEIgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIEIuX3Jvd3MgPSB0aGlzLl9yb3dzO1xuICAgICAgICBCLl9jb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgQi5fZGF0YSA9IHRoaXMudmFsdWVzLnNsaWNlKDApO1xuICAgICAgICByZXR1cm4gQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnRyeXdpc2UgbXVsdGlwbGljYXRpb24gd2l0aCB7QGxpbmsgdmFsdWV9LlxuICAgICAqIEBwYXJhbSB7TWF0cml4fEFycmF5fE51bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBsZXQgQSA9IE1hdHJpeC5mcm9tKFtbMSwgMl0sIFszLCA0XV0pOyAvLyBhIDIgYnkgMiBtYXRyaXguXG4gICAgICogbGV0IEIgPSBBLmNsb25lKCk7IC8vIEIgPT0gQTtcbiAgICAgKlxuICAgICAqIEEubXVsdCgyKTsgLy8gW1syLCA0XSwgWzYsIDhdXTtcbiAgICAgKiBBLm11bHQoQik7IC8vIFtbMSwgNF0sIFs5LCAxNl1dO1xuICAgICAqL1xuICAgIG11bHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYXBwbHkodmFsdWUsIChhLCBiKSA9PiBhICogYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW50cnl3aXNlIGRpdmlzaW9uIHdpdGgge0BsaW5rIHZhbHVlfS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeHxBcnJheXxOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDJdLCBbMywgNF1dKTsgLy8gYSAyIGJ5IDIgbWF0cml4LlxuICAgICAqIGxldCBCID0gQS5jbG9uZSgpOyAvLyBCID09IEE7XG4gICAgICpcbiAgICAgKiBBLmRpdmlkZSgyKTsgLy8gW1swLjUsIDFdLCBbMS41LCAyXV07XG4gICAgICogQS5kaXZpZGUoQik7IC8vIFtbMSwgMV0sIFsxLCAxXV07XG4gICAgICovXG4gICAgZGl2aWRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2FwcGx5KHZhbHVlLCAoYSwgYikgPT4gYSAvIGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudHJ5d2lzZSBhZGRpdGlvbiB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAyXSwgWzMsIDRdXSk7IC8vIGEgMiBieSAyIG1hdHJpeC5cbiAgICAgKiBsZXQgQiA9IEEuY2xvbmUoKTsgLy8gQiA9PSBBO1xuICAgICAqXG4gICAgICogQS5hZGQoMik7IC8vIFtbMywgNF0sIFs1LCA2XV07XG4gICAgICogQS5hZGQoQik7IC8vIFtbMiwgNF0sIFs2LCA4XV07XG4gICAgICovXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2FwcGx5KHZhbHVlLCAoYSwgYikgPT4gYSArIGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudHJ5d2lzZSBzdWJ0cmFjdGlvbiB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAyXSwgWzMsIDRdXSk7IC8vIGEgMiBieSAyIG1hdHJpeC5cbiAgICAgKiBsZXQgQiA9IEEuY2xvbmUoKTsgLy8gQiA9PSBBO1xuICAgICAqXG4gICAgICogQS5zdWIoMik7IC8vIFtbLTEsIDBdLCBbMSwgMl1dO1xuICAgICAqIEEuc3ViKEIpOyAvLyBbWzAsIDBdLCBbMCwgMF1dO1xuICAgICAqL1xuICAgIHN1Yih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9hcHBseSh2YWx1ZSwgKGEsIGIpID0+IGEgLSBiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgTWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gQXJyYXkgaW4gdGhlIGZvcm0gW3Jvd3MsIGNvbHVtbnNdLlxuICAgICAqL1xuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl9yb3dzLCB0aGlzLl9jb2xzXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRyaXggaW4gdGhlIGdpdmVuIHNoYXBlIHdpdGggdGhlIGdpdmVuIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdmFsdWVzIGZvciB0aGUgZW50cmllcyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtZXRlciAtIHRha2VzIGFuIEFycmF5IGluIHRoZSBmb3JtIFtyb3dzLCBjb2xzLCB2YWx1ZV0sIHdoZXJlIHJvd3MgYW5kIGNvbHMgYXJlIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgbWF0cml4LCBhbmQgdmFsdWUgaXMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gcGFyYW1ldGVycyAocm93IGFuZCBjb2wpIHdoaWNoIGhhcyB0byByZXR1cm4gYSB2YWx1ZSBmb3IgdGhlIGNvbHRoIGVudHJ5IG9mIHRoZSByb3d0aCByb3cuXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzZXQgc2hhcGUoW3Jvd3MsIGNvbHMsIHZhbHVlID0gKCkgPT4gMF0pIHtcbiAgICAgICAgdGhpcy5fcm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuX2NvbHMgPSBjb2xzO1xuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0NjRBcnJheShyb3dzICogY29scyk7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbcm93ICogY29scyArIGNvbF0gPSB2YWx1ZShyb3csIGNvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTWF0cml4IGFzIGEgQXJyYXkgb2YgRmxvYXQ2NEFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8RmxvYXQ2NEFycmF5Pn1cbiAgICAgKi9cbiAgICBnZXQgdG8yZEFycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5pdGVyYXRlX3Jvd3MoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE1hdHJpeCBhcyBhIEFycmF5IG9mIEFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fVxuICAgICAqL1xuICAgIGdldCBhc0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5pdGVyYXRlX3Jvd3MoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goQXJyYXkuZnJvbShyb3cpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpYWdvbmFsIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgZGlhZygpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICBjb25zdCBtaW5fcm93X2NvbCA9IE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEZsb2F0NjRBcnJheShtaW5fcm93X2NvbCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluX3Jvd19jb2w7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5lbnRyeShpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1lYW4gb2YgYWxsIGVudHJpZXMgb2YgdGhlIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBtZWFuKCkge1xuICAgICAgICBjb25zdCBzdW0gPSB0aGlzLnN1bTtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX3Jvd3MgKiB0aGlzLl9jb2xzO1xuICAgICAgICByZXR1cm4gc3VtIC8gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb29mIGFsbCBlbnRyaWVzIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3VtKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIHJldHVybiBuZXVtYWlyX3N1bShkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb29mIGFsbCBlbnRyaWVzIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWVhbiBvZiBlYWNoIHJvdyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtGbG9hdDY0QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IG1lYW5Sb3dzKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0aGlzLl9yb3dzO1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRmxvYXQ2NEFycmF5LmZyb20oeyBsZW5ndGg6IHJvd3MgfSk7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICByZXN1bHRbcm93XSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyb3ddICs9IGRhdGFbcm93ICogY29scyArIGNvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbcm93XSAvPSBjb2xzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgdGhlIG1lYW4gb2YgZWFjaCBjb2x1bW4gb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7RmxvYXQ2NEFycmF5fVxuICAgICAqL1xuICAgIGdldCBtZWFuQ29scygpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMudmFsdWVzO1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEZsb2F0NjRBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb2xzIH0pO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgcmVzdWx0W2NvbF0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY29sXSArPSBkYXRhW3JvdyAqIGNvbHMgKyBjb2xdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2NvbF0gLz0gcm93cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNvbHZlcyB0aGUgZXF1YXRpb24ge0BsaW5rIEF9eCA9IHtAbGluayBifSB1c2luZyB0aGUgY29uanVnYXRlIGdyYWRpZW50IG1ldGhvZC4gUmV0dXJucyB0aGUgcmVzdWx0IHguXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEEgLSBNYXRyaXhcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gYiAtIE1hdHJpeFxuICAgICAqIEBwYXJhbSB7UmFuZG9taXplcn0gW3JhbmRvbWl6ZXI9bnVsbF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RvbD0xZS0zXVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc3RhdGljIHNvbHZlX0NHKEEsIGIsIHJhbmRvbWl6ZXIsIHRvbCA9IDFlLTMpIHtcbiAgICAgICAgaWYgKHJhbmRvbWl6ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJhbmRvbWl6ZXIgPSBuZXcgUmFuZG9taXplcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvd3MgPSBBLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBjb2xzID0gYi5zaGFwZVsxXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBNYXRyaXgocm93cywgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sczsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBiX2kgPSBNYXRyaXguZnJvbShiLmNvbChpKSkuVDtcbiAgICAgICAgICAgIGxldCB4ID0gbmV3IE1hdHJpeChyb3dzLCAxLCAoKSA9PiByYW5kb21pemVyLnJhbmRvbSk7XG4gICAgICAgICAgICBsZXQgciA9IGJfaS5zdWIoQS5kb3QoeCkpO1xuICAgICAgICAgICAgbGV0IGQgPSByLmNsb25lKCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IEEuZG90KGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscGhhID0gci5ULmRvdChyKS5lbnRyeSgwLCAwKSAvIGQuVC5kb3QoeikuZW50cnkoMCwgMCk7XG4gICAgICAgICAgICAgICAgeCA9IHguYWRkKGQubXVsdChhbHBoYSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJfbmV4dCA9IHIuc3ViKHoubXVsdChhbHBoYSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJldGEgPSByX25leHQuVC5kb3Qocl9uZXh0KS5lbnRyeSgwLCAwKSAvIHIuVC5kb3QocikuZW50cnkoMCwgMCk7XG4gICAgICAgICAgICAgICAgZCA9IHJfbmV4dC5hZGQoZC5tdWx0KGJldGEpKTtcbiAgICAgICAgICAgICAgICByID0gcl9uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAoTWF0aC5hYnMoci5tZWFuKSA+IHRvbCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHgsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNvbHZlcyB0aGUgZXF1YXRpb24ge0BsaW5rIEF9eCA9IHtAbGluayBifS4gUmV0dXJucyB0aGUgcmVzdWx0IHguXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEEgLSBNYXRyaXggb3IgTFUgRGVjb21wb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBiIC0gTWF0cml4XG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzdGF0aWMgc29sdmUoQSwgYikge1xuICAgICAgICBsZXQgeyBMOiBMLCBVOiBVIH0gPSBcIkxcIiBpbiBBICYmIFwiVVwiIGluIEEgPyBBIDogTWF0cml4LkxVKEEpO1xuICAgICAgICBsZXQgcm93cyA9IEwuc2hhcGVbMF07XG4gICAgICAgIGxldCB4ID0gYi5jbG9uZSgpO1xuXG4gICAgICAgIC8vIGZvcndhcmRcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHJvdyAtIDE7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgeC5zZXRfZW50cnkoMCwgcm93LCB4LmVudHJ5KDAsIHJvdykgLSBMLmVudHJ5KHJvdywgY29sKSAqIHguZW50cnkoMSwgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4LnNldF9lbnRyeSgwLCByb3csIHguZW50cnkoMCwgcm93KSAvIEwuZW50cnkocm93LCByb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJhY2t3YXJkXG4gICAgICAgIGZvciAobGV0IHJvdyA9IHJvd3MgLSAxOyByb3cgPj0gMDsgLS1yb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHJvd3MgLSAxOyBjb2wgPiByb3c7IC0tY29sKSB7XG4gICAgICAgICAgICAgICAgeC5zZXRfZW50cnkoMCwgcm93LCB4LmVudHJ5KDAsIHJvdykgLSBVLmVudHJ5KHJvdywgY29sKSAqIHguZW50cnkoMCwgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4LnNldF9lbnRyeSgwLCByb3csIHguZW50cnkoMCwgcm93KSAvIFUuZW50cnkocm93LCByb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHtAbGluayBMfXtAbGluayBVfSBkZWNvbXBvc2l0aW9uIG9mIHRoZSBNYXRyaXgge0BsaW5rIEF9LiBDcmVhdGVzIHR3byBtYXRyaWNlcywgc28gdGhhdCB0aGUgZG90IHByb2R1Y3QgTFUgZXF1YWxzIEEuXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEFcbiAgICAgKiBAcmV0dXJucyB7e0w6IE1hdHJpeCwgVTogTWF0cml4fX0gcmVzdWx0IC0gUmV0dXJucyB0aGUgbGVmdCB0cmlhbmdsZSBtYXRyaXgge0BsaW5rIEx9IGFuZCB0aGUgdXBwZXIgdHJpYW5nbGUgbWF0cml4IHtAbGluayBVfS5cbiAgICAgKi9cbiAgICBzdGF0aWMgTFUoQSkge1xuICAgICAgICBjb25zdCByb3dzID0gQS5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgTCA9IG5ldyBNYXRyaXgocm93cywgcm93cywgXCJ6ZXJvc1wiKTtcbiAgICAgICAgY29uc3QgVSA9IG5ldyBNYXRyaXgocm93cywgcm93cywgXCJpZGVudGl0eVwiKTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd3M7ICsraikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGo7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGo7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gTC5lbnRyeShpLCBrKSAqIFUuZW50cnkoaywgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEwuc2V0X2VudHJ5KGksIGosIEEuZW50cnkoaSwgaikgLSBzdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGo7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoTC5lbnRyeShqLCBqKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGo7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gTC5lbnRyeShqLCBrKSAqIFUuZW50cnkoaywgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFUuc2V0X2VudHJ5KGosIGksIChBLmVudHJ5KGosIGkpIC0gc3VtKSAvIEwuZW50cnkoaiwgaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgTDogTCwgVTogVSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkZXRlcm1pbmFudGUgb2Yge0BsaW5rIEF9LCBieSB1c2luZyB0aGUgTFUgZGVjb21wb3NpdGlvbiBvZiB7QGxpbmsgQX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEFcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBkZXQgLSBSZXR1cm5zIHRoZSBkZXRlcm1pbmF0ZSBvZiB0aGUgTWF0cml4IHtAbGluayBBfS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGV0KEEpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IEEuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHsgTCwgVSB9ID0gTWF0cml4LkxVKEEpO1xuICAgICAgICBjb25zdCBMX2RpYWcgPSBMLmRpYWc7XG4gICAgICAgIGNvbnN0IFVfZGlhZyA9IFUuZGlhZztcbiAgICAgICAgbGV0IGRldCA9IExfZGlhZ1swXSAqIFVfZGlhZ1swXTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMTsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGRldCAqPSBMX2RpYWdbcm93XSAqIFVfZGlhZ1tyb3ddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHtAbGluayBrfSBjb21wb25lbnRzIG9mIHRoZSBTVkQgZGVjb21wb3NpdGlvbiBvZiB0aGUgbWF0cml4IHtAbGluayBNfVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBNXG4gICAgICogQHBhcmFtIHtpbnR9IFtrPTJdXG4gICAgICogQHJldHVybnMge3tVOiBNYXRyaXgsIFNpZ21hOiBNYXRyaXgsIFY6IE1hdHJpeH19XG4gICAgICovXG4gICAgc3RhdGljIFNWRChNLCBrID0gMikge1xuICAgICAgICBjb25zdCBNVCA9IE0uVDtcbiAgICAgICAgbGV0IE10TSA9IE1ULmRvdChNKTtcbiAgICAgICAgbGV0IE1NdCA9IE0uZG90KE1UKTtcbiAgICAgICAgbGV0IHsgZWlnZW52ZWN0b3JzOiBWLCBlaWdlbnZhbHVlczogU2lnbWEgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihNdE0sIGspO1xuICAgICAgICBsZXQgeyBlaWdlbnZlY3RvcnM6IFUgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihNTXQsIGspO1xuICAgICAgICByZXR1cm4geyBVOiBVLCBTaWdtYTogU2lnbWEubWFwKChzaWdtYSkgPT4gTWF0aC5zcXJ0KHNpZ21hKSksIFY6IFYgfTtcblxuICAgICAgICAvL0FsZ29yaXRobSAxYTogSG91c2Vob2xkZXIgcmVkdWN0aW9uIHRvIGJpZGlhZ29uYWwgZm9ybTpcbiAgICAgICAgLyogY29uc3QgW20sIG5dID0gQS5zaGFwZTtcbiAgICAgICAgbGV0IFUgPSBuZXcgTWF0cml4KG0sIG4sIChpLCBqKSA9PiBpID09IGogPyAxIDogMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFUudG8yZEFycmF5KVxuICAgICAgICBsZXQgViA9IG5ldyBNYXRyaXgobiwgbSwgKGksIGopID0+IGkgPT0gaiA/IDEgOiAwKTtcbiAgICAgICAgY29uc29sZS5sb2coVi50bzJkQXJyYXkpXG4gICAgICAgIGxldCBCID0gTWF0cml4LmJpZGlhZ29uYWwoQS5jbG9uZSgpLCBVLCBWKTtcbiAgICAgICAgY29uc29sZS5sb2coVSxWLEIpXG4gICAgICAgIHJldHVybiB7IFU6IFUsIFwiU2lnbWFcIjogQiwgVjogViB9OyAqL1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi9NYXRyaXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgbWF0cml4IG9mIGRhdGFtYXRyaXgge0BsaW5rIEF9LlxuICogQHBhcmFtIHtNYXRyaXh9IEEgLSBNYXRyaXhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWM9ZXVjbGlkZWFuXSAtIFRoZSBkaWlzdGFuY2UgbWV0cmljLlxuICogQHJldHVybnMge01hdHJpeH0gRCAtIFRoZSBkaXN0YW5jZSBtYXRyaXggb2Yge0BsaW5rIEF9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoQSwgbWV0cmljID0gZXVjbGlkZWFuKSB7XG4gICAgbGV0IG4gPSBBLnNoYXBlWzBdO1xuICAgIGNvbnN0IEQgPSBuZXcgTWF0cml4KG4sIG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IEFfaSA9IEEucm93KGkpO1xuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBtZXRyaWMoQV9pLCBBLnJvdyhqKSk7XG4gICAgICAgICAgICBELnNldF9lbnRyeShpLCBqLCBkaXN0KTtcbiAgICAgICAgICAgIEQuc2V0X2VudHJ5KGosIGksIGRpc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBEO1xufVxuIiwiLyoqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1hdHJpeFxuICogQ3JlYXRlcyBhbiBBcnJheSBjb250YWluaW5nIHtAbGluayBudW1iZXJ9IG51bWJlcnMgZnJvbSB7QGxpbmsgc3RhcnR9IHRvIHtAbGluayBlbmR9LiBJZiA8Y29kZT57QGxpbmsgbnVtYmVyfSA9IG51bGw8L251bGw+XG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbnVtYmVyID0gbnVsbF1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIG51bWJlciA9IG51bGwpIHtcbiAgICBpZiAoIW51bWJlcikge1xuICAgICAgICBudW1iZXIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGVuZCAtIHN0YXJ0KSArIDEsIDEpO1xuICAgIH1cbiAgICBpZiAobnVtYmVyIDwgMikge1xuICAgICAgICByZXR1cm4gbnVtYmVyID09PSAxID8gW3N0YXJ0XSA6IFtdO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gbmV3IEFycmF5KG51bWJlcik7XG4gICAgbnVtYmVyIC09IDE7XG4gICAgZm9yIChsZXQgaSA9IG51bWJlcjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgcmVzdWx0W2ldID0gKGkgKiBlbmQgKyAobnVtYmVyIC0gaSkgKiBzdGFydCkgLyBudW1iZXI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuLy9pbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odiwgbWV0cmljID0gZXVjbGlkZWFuKSB7XG4vL2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZlY3RvciwgcD0yLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICBsZXQgdmVjdG9yID0gbnVsbDtcbiAgICBpZiAodiBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICBsZXQgW3Jvd3MsIGNvbHNdID0gdi5zaGFwZTtcbiAgICAgICAgaWYgKHJvd3MgPT09IDEpIHZlY3RvciA9IHYucm93KDApO1xuICAgICAgICBlbHNlIGlmIChjb2xzID09PSAxKSB2ZWN0b3IgPSB2LmNvbCgwKTtcbiAgICAgICAgZWxzZSB0aHJvdyBcIm1hdHJpeCBtdXN0IGJlIDFkIVwiXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmVjdG9yID0gdjtcbiAgICB9XG4gICAgbGV0IG4gPSB2ZWN0b3IubGVuZ3RoO1xuICAgIGxldCB6ID0gbmV3IEFycmF5KG4pXG4gICAgei5maWxsKDApO1xuICAgIHJldHVybiBtZXRyaWModmVjdG9yLCB6KTtcbiAgICBcbiAgICBcbiAgICAvKmxldCB2O1xuICAgIGlmICh2ZWN0b3IgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgbGV0IFsgcm93cywgY29scyBdID0gdi5zaGFwZTtcbiAgICAgICAgaWYgKHJvd3MgPT09IDEpIHtcbiAgICAgICAgICAgIHYgPSB2ZWN0b3Iucm93KDApO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbHMgPT09IDEpIHtcbiAgICAgICAgICAgIHYgPSB2ZWN0b3IuY29sKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJtYXRyaXggbXVzdCBiZSAxZFwiXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gdmVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5wb3cobmV1bWFpcl9zdW0odi5tYXAoZSA9PiBNYXRoLnBvdyhlLCBwKSkpLCAxIC8gcCkqL1xufSIsImltcG9ydCB7IGxpbnNwYWNlLCBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnV0aWxzXG4gKiBAYWxpYXMgUmFuZG9taXplclxuICovXG5leHBvcnQgY2xhc3MgUmFuZG9taXplciB7XG4gICAgLyoqXG4gICAgICogTWVyc2VubmUgVHdpc3RlciByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW19zZWVkPW5ldyBEYXRlKCkuZ2V0VGltZSgpXSAtIFRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuIElmIDxjb2RlPl9zZWVkID09IG51bGw8L2NvZGU+IHRoZW4gdGhlIGFjdHVhbCB0aW1lIGdldHMgdXNlZCBhcyBzZWVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JtdXJyYXk3L21lcnNlbm5lLXR3aXN0ZXItZXhhbXBsZXMvYmxvYi9tYXN0ZXIvamF2YXNjcmlwdC1tZXJzZW5uZS10d2lzdGVyLmpzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX3NlZWQpIHtcbiAgICAgICAgdGhpcy5fTiA9IDYyNDtcbiAgICAgICAgdGhpcy5fTSA9IDM5NztcbiAgICAgICAgdGhpcy5fTUFUUklYX0EgPSAweDk5MDhiMGRmO1xuICAgICAgICB0aGlzLl9VUFBFUl9NQVNLID0gMHg4MDAwMDAwMDtcbiAgICAgICAgdGhpcy5fTE9XRVJfTUFTSyA9IDB4N2ZmZmZmZmY7XG4gICAgICAgIHRoaXMuX210ID0gbmV3IEFycmF5KHRoaXMuX04pO1xuICAgICAgICB0aGlzLl9tdGkgPSB0aGlzLk4gKyAxO1xuXG4gICAgICAgIHRoaXMuc2VlZCA9IF9zZWVkIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXQgc2VlZChfc2VlZCkge1xuICAgICAgICB0aGlzLl9zZWVkID0gX3NlZWQ7XG4gICAgICAgIGxldCBtdCA9IHRoaXMuX210O1xuXG4gICAgICAgIG10WzBdID0gX3NlZWQgPj4+IDA7XG4gICAgICAgIGZvciAodGhpcy5fbXRpID0gMTsgdGhpcy5fbXRpIDwgdGhpcy5fTjsgdGhpcy5fbXRpICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBtdGkgPSB0aGlzLl9tdGk7XG4gICAgICAgICAgICBsZXQgcyA9IG10W210aSAtIDFdIF4gKG10W210aSAtIDFdID4+PiAzMCk7XG4gICAgICAgICAgICBtdFttdGldID0gKCgoKHMgJiAweGZmZmYwMDAwKSA+Pj4gMTYpICogMTgxMjQzMzI1MykgPDwgMTYpICsgKHMgJiAweDAwMDBmZmZmKSAqIDE4MTI0MzMyNTMgKyBtdGk7XG4gICAgICAgICAgICBtdFttdGldID4+Pj0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlZWQgb2YgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIHNlZWQuXG4gICAgICovXG4gICAgZ2V0IHNlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybnMge051bWJlcn0gLSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBbMCwgMV1cbiAgICAgKi9cbiAgICBnZXQgcmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5kb21faW50ICogKDEuMCAvIDQyOTQ5NjcyOTYuMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgTUFYX0lOVEVHRVIuXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9IC0gQSByYW5kb20gaW50ZWdlci5cbiAgICAgKi9cbiAgICBnZXQgcmFuZG9tX2ludCgpIHtcbiAgICAgICAgbGV0IHksXG4gICAgICAgICAgICBtYWcwMSA9IG5ldyBBcnJheSgweDAsIHRoaXMuX01BVFJJWF9BKTtcbiAgICAgICAgaWYgKHRoaXMuX210aSA+PSB0aGlzLl9OKSB7XG4gICAgICAgICAgICBsZXQga2s7XG5cbiAgICAgICAgICAgIC8qIGlmICh0aGlzLl9tdGkgPT0gdGhpcy5fTiArIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlZWQgPSA1NDg5O1xuICAgICAgICAgICAgfSAqL1xuXG4gICAgICAgICAgICBsZXQgTl9NID0gdGhpcy5fTiAtIHRoaXMuX007XG4gICAgICAgICAgICBsZXQgTV9OID0gdGhpcy5fTSAtIHRoaXMuX047XG5cbiAgICAgICAgICAgIGZvciAoa2sgPSAwOyBrayA8IE5fTTsgKytraykge1xuICAgICAgICAgICAgICAgIHkgPSAodGhpcy5fbXRba2tdICYgdGhpcy5fVVBQRVJfTUFTSykgfCAodGhpcy5fbXRba2sgKyAxXSAmIHRoaXMuX0xPV0VSX01BU0spO1xuICAgICAgICAgICAgICAgIHRoaXMuX210W2trXSA9IHRoaXMuX210W2trICsgdGhpcy5fTV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyBrayA8IHRoaXMuX04gLSAxOyArK2trKSB7XG4gICAgICAgICAgICAgICAgeSA9ICh0aGlzLl9tdFtra10gJiB0aGlzLl9VUFBFUl9NQVNLKSB8ICh0aGlzLl9tdFtrayArIDFdICYgdGhpcy5fTE9XRVJfTUFTSyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbXRba2tdID0gdGhpcy5fbXRba2sgKyBNX05dIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHkgPSAodGhpcy5fbXRbdGhpcy5fTiAtIDFdICYgdGhpcy5fVVBQRVJfTUFTSykgfCAodGhpcy5fbXRbMF0gJiB0aGlzLl9MT1dFUl9NQVNLKTtcbiAgICAgICAgICAgIHRoaXMuX210W3RoaXMuX04gLSAxXSA9IHRoaXMuX210W3RoaXMuX00gLSAxXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdO1xuXG4gICAgICAgICAgICB0aGlzLl9tdGkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgeSA9IHRoaXMuX210Wyh0aGlzLl9tdGkgKz0gMSldO1xuICAgICAgICB5IF49IHkgPj4+IDExO1xuICAgICAgICB5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcbiAgICAgICAgeSBePSAoeSA8PCAxNSkgJiAweGVmYzYwMDAwO1xuICAgICAgICB5IF49IHkgPj4+IDE4O1xuXG4gICAgICAgIHJldHVybiB5ID4+PiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2FtcGxlcyBmcm9tIGFuIGlucHV0IE1hdHJpeCBvciBBcnJheS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeHxBcnJheXxGbG9hdDY0QXJyYXl9IEEgLSBUaGUgaW5wdXQgTWF0cml4IG9yIEFycmF5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSBBIHJhbmRvbSBzZWxlY3Rpb24gZm9ybSB7QGxpbmsgQX0gb2Yge0BsaW5rIG59IHNhbXBsZXMuXG4gICAgICovXG4gICAgY2hvaWNlKEEsIG4pIHtcbiAgICAgICAgaWYgKEEgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gQS5zaGFwZVswXTtcbiAgICAgICAgICAgIGlmIChuID4gcm93cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm4gYmlnZ2VyIHRoYW4gQSFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2FtcGxlID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgbGV0IGluZGV4X2xpc3QgPSBsaW5zcGFjZSgwLCByb3dzIC0gMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGluZGV4X2xpc3QubGVuZ3RoOyBpIDwgbjsgKytpLCAtLWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZG9tX2luZGV4ID0gdGhpcy5yYW5kb21faW50ICUgbDtcbiAgICAgICAgICAgICAgICBzYW1wbGVbaV0gPSBpbmRleF9saXN0LnNwbGljZShyYW5kb21faW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZS5tYXAoKGQpID0+IEEucm93KGQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEEpIHx8IEEgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gQS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobiA+IHJvd3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuIGJpZ2dlciB0aGFuIEEhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNhbXBsZSA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGxldCBpbmRleF9saXN0ID0gbGluc3BhY2UoMCwgcm93cyAtIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpbmRleF9saXN0Lmxlbmd0aDsgaSA8IG47ICsraSwgLS1sKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmRvbV9pbmRleCA9IHRoaXMucmFuZG9tX2ludCAlIGw7XG4gICAgICAgICAgICAgICAgc2FtcGxlW2ldID0gaW5kZXhfbGlzdC5zcGxpY2UocmFuZG9tX2luZGV4LCAxKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYW1wbGUubWFwKChkKSA9PiBBW2RdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBSZXR1cm5zIHNhbXBsZXMgZnJvbSBhbiBpbnB1dCBNYXRyaXggb3IgQXJyYXkuXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8RmxvYXQ2NEFycmF5fSBBIC0gVGhlIGlucHV0IE1hdHJpeCBvciBBcnJheS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiAtIFRoZSBudW1iZXIgb2Ygc2FtcGxlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VlZCAtIFRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIEEgcmFuZG9tIHNlbGVjdGlvbiBmb3JtIHtAbGluayBBfSBvZiB7QGxpbmsgbn0gc2FtcGxlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY2hvaWNlKEEsIG4sIHNlZWQgPSAxMjEyKSB7XG4gICAgICAgIGNvbnN0IFIgPSBuZXcgUmFuZG9taXplcihzZWVkKTtcbiAgICAgICAgcmV0dXJuIFIuY2hvaWNlKEEsIG4pO1xuICAgICAgICAvKiBsZXQgcm93cyA9IEEuc2hhcGVbMF07XG4gICAgICAgIGlmIChuID4gcm93cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibiBiaWdnZXIgdGhhbiBBIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZCA9IG5ldyBSYW5kb21pemVyKHNlZWQpO1xuICAgICAgICBsZXQgc2FtcGxlID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBsZXQgaW5kZXhfbGlzdCA9IGxpbnNwYWNlKDAsIHJvd3MgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpbmRleF9saXN0Lmxlbmd0aDsgaSA8IG47ICsraSwgLS1sKSB7XG4gICAgICAgICAgICBsZXQgcmFuZG9tX2luZGV4ID0gcmFuZC5yYW5kb21faW50ICUgbDtcbiAgICAgICAgICAgIHNhbXBsZVtpXSA9IGluZGV4X2xpc3Quc3BsaWNlKHJhbmRvbV9pbmRleCwgMSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy9yZXR1cm4gcmVzdWx0O1xuICAgICAgICAvL3JldHVybiBuZXcgTWF0cml4KG4sIGNvbHMsIChyb3csIGNvbCkgPT4gQS5lbnRyeShzYW1wbGVbcm93XSwgY29sKSlcbiAgICAgICAgcmV0dXJuIHNhbXBsZS5tYXAoKGQpID0+IEEucm93KGQpKTsgKi9cbiAgICB9XG59XG4iLCIvKipcbiAqIFJldHVybnMgbWF4aW11bSBpbiBBcnJheSB7QGxpbmsgdmFsdWVzfS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dXRpbHNcbiAqIEBhbGlhcyBtYXhcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICBsZXQgbWF4O1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbn0iLCIvKipcbiAqIFJldHVybnMgbWF4aW11bSBpbiBBcnJheSB7QGxpbmsgdmFsdWVzfS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dXRpbHNcbiAqIEBhbGlhcyBtaW5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIGxldCBtaW47XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA8PSB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluO1xufSIsIi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSGVhcFxuICovXG5leHBvcnQgY2xhc3MgSGVhcCB7XG4gICAgLyoqXG4gICAgICogQSBoZWFwIGlzIGEgZGF0YXN0cnVjdHVyZSBob2xkaW5nIGl0cyBlbGVtZW50cyBpbiBhIHNwZWNpZmljIHdheSwgc28gdGhhdCB0aGUgdG9wIGVsZW1lbnQgd291bGQgYmUgdGhlIGZpcnN0IGVudHJ5IG9mIGFuIG9yZGVyZWQgbGlzdC5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRhdGFzdHJ1Y3R1cmVcbiAgICAgKiBAYWxpYXMgSGVhcFxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBlbGVtZW50cyAtIENvbnRhaW5zIHRoZSBlbGVtZW50cyBmb3IgdGhlIEhlYXAuIHtAbGluayBlbGVtZW50c30gY2FuIGJlIG51bGwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2FjY2Vzc29yID0gKGQpID0+IGRdIC0gRnVuY3Rpb24gcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHsoXCJtaW5cInxcIm1heFwifEZ1bmN0aW9uKX0gW2NvbXBhcmF0b3IgPSBcIm1pblwiXSAtIEZ1bmN0aW9uIHJldHVybmluZyB0cnVlIG9yIGZhbHNlIGRlZmluaW5nIHRoZSB3aXNoZWQgb3JkZXIgb2YgdGhlIEhlYXAsIG9yIFN0cmluZyBmb3IgcHJlZGVmaW5lZCBmdW5jdGlvbi4gKFwibWluXCIgZm9yIGEgTWluLUhlYXAsIFwibWF4XCIgZm9yIGEgTWF4X2hlYXApXG4gICAgICogQHJldHVybnMge0hlYXB9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmluYXJ5X2hlYXB9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMgPSBudWxsLCBhY2Nlc3NvciA9IGQgPT4gZCwgY29tcGFyYXRvciA9IFwibWluXCIpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gSGVhcC5oZWFwaWZ5KGVsZW1lbnRzLCBhY2Nlc3NvciwgY29tcGFyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hY2Nlc3NvciA9IGFjY2Vzc29yO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gW107XG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvciA9PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IChhLCBiKSA9PiBhIDwgYjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGFyYXRvciA9PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IChhLCBiKSA9PiBhID4gYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEhlYXAgZnJvbSBhbiBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl8U2V0fSBlbGVtZW50cyAtIENvbnRhaW5zIHRoZSBlbGVtZW50cyBmb3IgdGhlIEhlYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbj19IFthY2Nlc3NvciA9IChkKSA9PiBkXSAtIEZ1bmN0aW9uIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7KFN0cmluZz18RnVuY3Rpb24pfSBbY29tcGFyYXRvciA9IFwibWluXCJdIC0gRnVuY3Rpb24gcmV0dXJuaW5nIHRydWUgb3IgZmFsc2UgZGVmaW5pbmcgdGhlIHdpc2hlZCBvcmRlciBvZiB0aGUgSGVhcCwgb3IgU3RyaW5nIGZvciBwcmVkZWZpbmVkIGZ1bmN0aW9uLiAoXCJtaW5cIiBmb3IgYSBNaW4tSGVhcCwgXCJtYXhcIiBmb3IgYSBNYXhfaGVhcClcbiAgICAgKiBAcmV0dXJucyB7SGVhcH1cbiAgICAgKi9cbiAgICBzdGF0aWMgaGVhcGlmeShlbGVtZW50cywgYWNjZXNzb3IgPSBkID0+IGQsIGNvbXBhcmF0b3IgPSBcIm1pblwiKSB7XG4gICAgICAgIGNvbnN0IGhlYXAgPSBuZXcgSGVhcChudWxsLCBhY2Nlc3NvciwgY29tcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGhlYXAuX2NvbnRhaW5lcjtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb250YWluZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgXCJlbGVtZW50XCI6IGUsXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBhY2Nlc3NvcihlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLmZsb29yKChlbGVtZW50cy5sZW5ndGggLyAyKSAtIDEpOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaGVhcC5faGVhcGlmeV9kb3duKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGVsZW1lbnRzIG9mIGNvbnRhaW5lciBhcnJheS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleF9hIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleF9iIFxuICAgICAqL1xuICAgIF9zd2FwKGluZGV4X2EsIGluZGV4X2IpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBbY29udGFpbmVyW2luZGV4X2JdLCBjb250YWluZXJbaW5kZXhfYV1dID0gW2NvbnRhaW5lcltpbmRleF9hXSwgY29udGFpbmVyW2luZGV4X2JdXTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hlYXBpZnlfdXAoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgbGV0IGluZGV4ID0gY29udGFpbmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRJbmRleCA9IE1hdGguZmxvb3IoKGluZGV4IC0gMSkgLyAyKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29tcGFyYXRvcihjb250YWluZXJbaW5kZXhdLnZhbHVlLCBjb250YWluZXJbcGFyZW50SW5kZXhdLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N3YXAocGFyZW50SW5kZXgsIGluZGV4KVxuICAgICAgICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1c2hlcyB0aGUgZWxlbWVudCB0byB0aGUgaGVhcC5cbiAgICAgKiBAcGFyYW0ge30gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtIZWFwfVxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2FjY2Vzc29yKGVsZW1lbnQpO1xuICAgICAgICAvL2NvbnN0IG5vZGUgPSBuZXcgTm9kZShlbGVtZW50LCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB7XCJlbGVtZW50XCI6IGVsZW1lbnQsIFwidmFsdWVcIjogdmFsdWV9O1xuICAgICAgICB0aGlzLl9jb250YWluZXIucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5faGVhcGlmeV91cCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRfaW5kZXggPSAwXSBcbiAgICAgKi9cbiAgICBfaGVhcGlmeV9kb3duKHN0YXJ0X2luZGV4PTApIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBjb25zdCBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY29udGFpbmVyLmxlbmd0aDtcbiAgICAgICAgbGV0IGxlZnQgPSAyICogc3RhcnRfaW5kZXggKyAxO1xuICAgICAgICBsZXQgcmlnaHQgPSAyICogc3RhcnRfaW5kZXggKyAyO1xuICAgICAgICBsZXQgaW5kZXggPSBzdGFydF9pbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoKSB0aHJvdyBcImluZGV4IGhpZ2hlciB0aGFuIGxlbmd0aFwiXG4gICAgICAgIGlmIChsZWZ0IDwgbGVuZ3RoICYmIGNvbXBhcmF0b3IoY29udGFpbmVyW2xlZnRdLnZhbHVlLCBjb250YWluZXJbaW5kZXhdLnZhbHVlKSkge1xuICAgICAgICAgICAgaW5kZXggPSBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCA8IGxlbmd0aCAmJiBjb21wYXJhdG9yKGNvbnRhaW5lcltyaWdodF0udmFsdWUsIGNvbnRhaW5lcltpbmRleF0udmFsdWUpKSB7XG4gICAgICAgICAgICBpbmRleCA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPT0gc3RhcnRfaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N3YXAoc3RhcnRfaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX2hlYXBpZnlfZG93bihpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSB0b3AgZW50cnkgb2YgdGhlIGhlYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IGNvbnNpc3RzIG9mIHRoZSBlbGVtZW50IGFuZCBpdHMgdmFsdWUgKGNvbXB1dGVkIGJ5IHtAbGluayBhY2Nlc3Nvcn0pLlxuICAgICAqL1xuICAgIHBvcCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zd2FwKDAsIGNvbnRhaW5lci5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgaXRlbSA9IGNvbnRhaW5lci5wb3AoKTtcbiAgICAgICAgdGhpcy5faGVhcGlmeV9kb3duKCk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvcCBlbnRyeSBvZiB0aGUgaGVhcCB3aXRob3V0IHJlbW92aW5nIGl0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb25zaXN0cyBvZiB0aGUgZWxlbWVudCBhbmQgaXRzIHZhbHVlIChjb21wdXRlZCBieSB7QGxpbmsgYWNjZXNzb3J9KS5cbiAgICAgKi9cbiAgICBnZXQgZmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXIubGVuZ3RoID4gMCA/IHRoaXMuX2NvbnRhaW5lclswXSA6IG51bGw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBZaWVsZHMgdGhlIHJhdyBkYXRhXG4gICAgICogQHlpZWxkcyB7T2JqZWN0fSBPYmplY3QgY29uc2lzdHMgb2YgdGhlIGVsZW1lbnQgYW5kIGl0cyB2YWx1ZSAoY29tcHV0ZWQgYnkge0BsaW5rIGFjY2Vzc29yfSkuXG4gICAgICovXG4gICAgKiBpdGVyYXRlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NvbnRhaW5lci5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX2NvbnRhaW5lcltpXS5lbGVtZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVhcCBhcyBvcmRlcmVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgY29uc2lzdGluZyB0aGUgZWxlbWVudHMgb3JkZXJlZCBieSB7QGxpbmsgY29tcGFyYXRvcn0uXG4gICAgICovXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpXG4gICAgICAgICAgICAuc29ydCgoYSxiKSA9PiB0aGlzLl9jb21wYXJhdG9yKGEsIGIpID8gLTEgOiAwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZWxlbWVudHMgb2YgY29udGFpbmVyIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgY29uc2lzdGluZyB0aGUgZWxlbWVudHMuXG4gICAgICovXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lclxuICAgICAgICAgICAgLm1hcChkID0+IGQuZWxlbWVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250YWluZXIgYXJyYXkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgY29udGFpbmVyIGFycmF5LlxuICAgICAqL1xuICAgIHJhd19kYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSBoZWFwLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lci5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmYWxzZSBpZiB0aGUgdGhlIGhlYXAgaGFzIGVudHJpZXMsIHRydWUgaWYgdGhlIGhlYXAgaGFzIG5vIGVudHJpZXMuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gICAgfVxufSIsIi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgRGlzam9pbnRTZXRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc2pvaW50LXNldF9kYXRhX3N0cnVjdHVyZX1cbiAqL1xuZXhwb3J0IGNsYXNzIERpc2pvaW50U2V0IHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgRGlzam9pbnRTZXRcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRhdGFzdHJ1Y3R1cmVcbiAgICAgKiBAcGFyYW0ge0FycmF5PX0gZWxlbWVudHMgXG4gICAgICogQHJldHVybnMge0Rpc2pvaW50U2V0fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9saXN0ID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMubWFrZV9zZXQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbWFrZV9zZXQoeCkge1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgaWYgKCFsaXN0Lmhhcyh4KSkge1xuICAgICAgICAgICAgbGlzdC5hZGQoeCk7XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0ID0ge307XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0LnBhcmVudCA9IHg7XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuID0gbmV3IFNldChbeF0pO1xuICAgICAgICAgICAgeC5fX2Rpc2pvaW50X3NldC5zaXplID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmaW5kKHgpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIGlmIChsaXN0Lmhhcyh4KSkge1xuICAgICAgICAgICAgaWYgKHguX19kaXNqb2ludF9zZXQucGFyZW50ICE9PSB4KSB7XG4gICAgICAgICAgICAgICAgeC5fX2Rpc2pvaW50X3NldC5jaGlsZHJlbi5hZGQoLi4ueCk7XG4gICAgICAgICAgICAgICAgeC5fX2Rpc2pvaW50X3NldC5wYXJlbnQgPSB0aGlzLmZpbmQoeC5fX2Rpc2pvaW50X3NldC5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB4Ll9fZGlzam9pbnRfc2V0LnBhcmVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuaW9uKHgsIHkpIHtcbiAgICAgICAgbGV0IG5vZGVfeCA9IHRoaXMuZmluZCh4KTtcbiAgICAgICAgbGV0IG5vZGVfeSA9IHRoaXMuZmluZCh5KTtcblxuICAgICAgICBpZiAobm9kZV94ID09PSBub2RlX3kpIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAobm9kZV94Ll9fZGlzam9pbnRfc2V0LnNpemUgPCBub2RlX3kuX19kaXNqb2ludF9zZXQuc2l6ZSkgW25vZGVfeCwgbm9kZV95XSA9IFtub2RlX3ksIG5vZGVfeF07XG5cbiAgICAgICAgbm9kZV95Ll9fZGlzam9pbnRfc2V0LnBhcmVudCA9IG5vZGVfeDtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbj9cbiAgICAgICAgbm9kZV95Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuLmZvckVhY2gobm9kZV94Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuLmFkZCwgbm9kZV94Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuKTtcbiAgICAgICAgbm9kZV94Ll9fZGlzam9pbnRfc2V0LnNpemUgKz0gbm9kZV95Ll9fZGlzam9pbnRfc2V0LnNpemU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBIZWFwIH0gZnJvbSBcIi4uL2RhdGFzdHJ1Y3R1cmUvaW5kZXguanNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgQmFsbFRyZWVcbiAqL1xuZXhwb3J0IGNsYXNzIEJhbGxUcmVlIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBCYWxsVHJlZSB3aXRoIGdpdmVuIHtAbGluayBlbGVtZW50c30uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTprbm5cbiAgICAgKiBAYWxpYXMgQmFsbFRyZWVcbiAgICAgKiBAcGFyYW0ge0FycmF5PX0gZWxlbWVudHMgLSBFbGVtZW50cyB3aGljaCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIEJhbGxUcmVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gbWV0cmljIHRvIHVzZTogKGEsIGIpID0+IGRpc3RhbmNlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFsbF90cmVlfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbnZpc2FsL25vb2Jqcy9ibG9iL21hc3Rlci9zcmMvdHJlZS9CYWxsVHJlZS5qc31cbiAgICAgKiBAcmV0dXJucyB7QmFsbFRyZWV9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMgPSBudWxsLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICAgICAgdGhpcy5fTm9kZSA9IGNsYXNzIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBpdm90LCBjaGlsZDE9bnVsbCwgY2hpbGQyPW51bGwsIHJhZGl1cz1udWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waXZvdCA9IHBpdm90O1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQxID0gY2hpbGQxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQyID0gY2hpbGQyO1xuICAgICAgICAgICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX0xlYWYgPSBjbGFzcyB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcihwb2ludHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZXRyaWMgPSBtZXRyaWM7XG4gICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5hZGQoZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXk8Kj59IGVsZW1lbnRzIC0gbmV3IGVsZW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtCYWxsVHJlZX1cbiAgICAgKi9cbiAgICBhZGQoZWxlbWVudHMpIHtcbiAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cy5tYXAoKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpbmRleCwgZWxlbWVudDogZWxlbWVudH1cbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX2NvbnN0cnVjdChlbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gZWxlbWVudHMgXG4gICAgICogQHJldHVybnMge05vZGV9IHJvb3Qgb2YgYmFsbHRyZWUuXG4gICAgICovXG4gICAgX2NvbnN0cnVjdChlbGVtZW50cykge1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuX0xlYWYoZWxlbWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGMgPSB0aGlzLl9ncmVhdGVzdF9zcHJlYWQoZWxlbWVudHMpO1xuICAgICAgICAgICAgbGV0IHNvcnRlZF9lbGVtZW50cyA9IGVsZW1lbnRzLnNvcnQoKGEsIGIpID0+IGEuZWxlbWVudFtjXSAtIGIuZWxlbWVudFtjXSk7XG4gICAgICAgICAgICBsZXQgbiA9IHNvcnRlZF9lbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcF9pbmRleCA9IE1hdGguZmxvb3IobiAvIDIpO1xuICAgICAgICAgICAgbGV0IHAgPSBlbGVtZW50c1twX2luZGV4XTtcbiAgICAgICAgICAgIGxldCBMID0gc29ydGVkX2VsZW1lbnRzLnNsaWNlKDAsIHBfaW5kZXgpO1xuICAgICAgICAgICAgbGV0IFIgPSBzb3J0ZWRfZWxlbWVudHMuc2xpY2UocF9pbmRleCwgbik7XG4gICAgICAgICAgICBsZXQgcmFkaXVzID0gTWF0aC5tYXgoLi4uZWxlbWVudHMubWFwKGQgPT4gdGhpcy5fbWV0cmljKHAuZWxlbWVudCwgZC5lbGVtZW50KSkpO1xuICAgICAgICAgICAgbGV0IEJcbiAgICAgICAgICAgIGlmIChMLmxlbmd0aCA+IDAgJiYgUi5sZW5ndGggPiAwKSB7ICAgICAgICAgXG4gICAgICAgICAgICAgICAgQiA9IG5ldyB0aGlzLl9Ob2RlKHAsIHRoaXMuX2NvbnN0cnVjdChMKSwgdGhpcy5fY29uc3RydWN0KFIpLCByYWRpdXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBCID0gbmV3IHRoaXMuX0xlYWYoZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gQiBcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIF9ncmVhdGVzdF9zcHJlYWQoQikge1xuICAgICAgICBsZXQgZCA9IEJbMF0uZWxlbWVudC5sZW5ndGg7XG4gICAgICAgIGxldCBzdGFydCA9IG5ldyBBcnJheShkKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQ7ICsraSkge1xuICAgICAgICAgICAgc3RhcnRbaV0gPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3ByZWFkID0gQi5yZWR1Y2UoKGFjYywgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkOyArK2kpIHtcbiAgICAgICAgICAgICAgICBhY2NbaV1bMF0gPSBNYXRoLm1pbihhY2NbaV1bMF0sIGN1cnJlbnQuZWxlbWVudFtpXSk7XG4gICAgICAgICAgICAgICAgYWNjW2ldWzFdID0gTWF0aC5tYXgoYWNjW2ldWzFdLCBjdXJyZW50LmVsZW1lbnRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgc3RhcnQpO1xuICAgICAgICBzcHJlYWQgPSBzcHJlYWQubWFwKGQgPT4gZFsxXSAtIGRbMF0pO1xuICAgICAgICBcbiAgICAgICAgbGV0IGMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQ7ICsraSkge1xuICAgICAgICAgICAgYyA9IHNwcmVhZFtpXSA+IHNwcmVhZFtjXSA/IGkgOiBjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Kn0gdCAtIHF1ZXJ5IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtrID0gNV0gLSBudW1iZXIgb2YgbmVhcmVzdCBuZWlnaGJvcnMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtIZWFwfSAtIEhlYXAgY29uc2lzdHMgb2YgdGhlIHtAbGluayBrfSBuZWFyZXN0IG5laWdoYm9ycy5cbiAgICAgKi9cbiAgICBzZWFyY2godCwgayA9IDUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaCh0LCBrLCBuZXcgSGVhcChudWxsLCBkID0+IHRoaXMuX21ldHJpYyhkLmVsZW1lbnQsIHQpLCBcIm1heFwiKSwgdGhpcy5fcm9vdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHQgLSBxdWVyeSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbayA9IDVdIC0gbnVtYmVyIG9mIG5lYXJlc3QgbmVpZ2hib3JzIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0ge0hlYXB9IFEgLSBIZWFwIGNvbnNpc3RzIG9mIHRoZSBjdXJyZW50bHkgZm91bmQge0BsaW5rIGt9IG5lYXJlc3QgbmVpZ2hib3JzLlxuICAgICAqIEBwYXJhbSB7Tm9kZXxMZWFmfSBCIFxuICAgICAqL1xuICAgIF9zZWFyY2godCwgaywgUSwgQikge1xuICAgICAgICAvLyBCIGlzIE5vZGVcbiAgICAgICAgaWYgKFEubGVuZ3RoID49IGsgJiYgQi5waXZvdCAmJiBCLnJhZGl1cyAmJiB0aGlzLl9tZXRyaWModCwgQi5waXZvdC5lbGVtZW50KSAtIEIucmFkaXVzID49IFEuZmlyc3QudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9IFxuICAgICAgICBpZiAoQi5jaGlsZDEpIHRoaXMuX3NlYXJjaCh0LCBrLCBRLCBCLmNoaWxkMSk7XG4gICAgICAgIGlmIChCLmNoaWxkMikgdGhpcy5fc2VhcmNoKHQsIGssIFEsIEIuY2hpbGQyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEIgaXMgbGVhZlxuICAgICAgICBpZiAoQi5wb2ludHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gQi5wb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHAgPSBCLnBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoayA+IFEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIFEucHVzaChwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBRLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIFEucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBRO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSGVhcCB9IGZyb20gXCIuLi9kYXRhc3RydWN0dXJlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkaXN0YW5jZV9tYXRyaXgsIE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBLTk5cbiAqL1xuZXhwb3J0IGNsYXNzIEtOTiB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgS05OIGxpc3Qgd2l0aCBnaXZlbiB7QGxpbmsgZWxlbWVudHN9LlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6a25uXG4gICAgICogQGFsaWFzIEtOTlxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBlbGVtZW50cyAtIEVsZW1lbnRzIHdoaWNoIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgS05OIGxpc3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFwicHJlY29tcHV0ZWRcIn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gbWV0cmljIGlzIGVpdGhlciBwcmVjb21wdXRlZCBvciBhIGZ1bmN0aW9uIHRvIHVzZTogKGEsIGIpID0+IGRpc3RhbmNlXG4gICAgICogQHJldHVybnMge0tOTn1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cz1udWxsLCBtZXRyaWM9ZXVjbGlkZWFuKSB7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBlbGVtZW50cyBpbnN0YW5jZW9mIE1hdHJpeCA/IGVsZW1lbnRzIDogTWF0cml4LmZyb20oZWxlbWVudHMpO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fZWxlbWVudHMuc2hhcGVbMF07XG4gICAgICAgIGlmIChtZXRyaWMgPT09IFwicHJlY29tcHV0ZWRcIikge1xuICAgICAgICAgICAgdGhpcy5fRCA9IHRoaXMuX2VsZW1lbnRzLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9EID0gZGlzdGFuY2VfbWF0cml4KHRoaXMuX2VsZW1lbnRzLCBtZXRyaWMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuS05OID0gW107XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IE47ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSB0aGlzLl9ELnJvdyhyb3cpO1xuICAgICAgICAgICAgY29uc3QgSCA9IG5ldyBIZWFwKG51bGwsIGQgPT4gZC52YWx1ZSwgXCJtaW5cIik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIEgucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkaXN0YW5jZXNbal0sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBqLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5LTk4ucHVzaChIKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSB0IC0gcXVlcnkgZWxlbWVudCBvciBpbmRleC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2sgPSA1XSAtIG51bWJlciBvZiBuZWFyZXN0IG5laWdoYm9ycyB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0hlYXB9IC0gSGVhcCBjb25zaXN0cyBvZiB0aGUge0BsaW5rIGt9IG5lYXJlc3QgbmVpZ2hib3JzLlxuICAgICAqL1xuICAgIHNlYXJjaCh0LCBrID0gNSkge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IEtOTiA9IHRoaXMuS05OO1xuICAgICAgICBsZXQgSDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZXRyaWMgPT0gXCJwcmVjb21wdXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJTZWFyY2ggYnkgcXVlcnkgZWxlbWVudCBpcyBvbmx5IHBvc3NpYmxlIHdoZW4gbm90IHVzaW5nIGEgcHJlY29tcHV0ZWQgZGlzdGFuY2UgbWF0cml4IVwiXG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cztcbiAgICAgICAgICAgIGNvbnN0IE4gPSBLTk4ubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG5lYXJlc3RfZWxlbWVudF9pbmRleCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbmVhcmVzdF9kaXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50cy5yb3coaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IG1ldHJpYyh0LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG5lYXJlc3RfZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0X2VsZW1lbnRfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0X2Rpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEggPSBLTk5bbmVhcmVzdF9lbGVtZW50X2luZGV4XTtcbiAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHQpKSB7XG4gICAgICAgICAgICBIID0gS05OW3RdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0ID0gW11cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKEgucG9wKCkpXG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmZvckVhY2gocmVzID0+IEgucHVzaChyZXMuZWxlbWVudCkpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9ICAgIFxufVxuIiwiaW1wb3J0IHsgTWF0cml4LCBub3JtIH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IG5ldW1haXJfc3VtIH0gZnJvbSBcIi4uL251bWVyaWNhbC9pbmRleC5qc1wiO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBRUiBEZWNvbXBvc2l0aW9uIG9mIHRoZSBNYXRyaXgge0BsaW5rIEF9IHVzaW5nIEdyYW0tU2NobWlkdCBwcm9jZXNzLlxuICogQG1lbWJlcm9mIG1vZHVsZTpsaW5lYXJfYWxnZWJyYVxuICogQGFsaWFzIHFyXG4gKiBAcGFyYW0ge01hdHJpeH0gQVxuICogQHJldHVybnMge3tSOiBNYXRyaXgsIFE6IE1hdHJpeH19XG4gKiBAc2VlIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RUl9kZWNvbXBvc2l0aW9uI1VzaW5nX3RoZV9HcmFtJUUyJTgwJTkzU2NobWlkdF9wcm9jZXNzfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihBKSB7XG4gICAgY29uc3QgW3Jvd3MsIGNvbHNdID0gQS5zaGFwZTtcbiAgICBjb25zdCBRID0gbmV3IE1hdHJpeChyb3dzLCBjb2xzLCBcImlkZW50aXR5XCIpO1xuICAgIGNvbnN0IFIgPSBuZXcgTWF0cml4KGNvbHMsIGNvbHMsIDApO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcbiAgICAgICAgbGV0IHYgPSBBLmNvbChqKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHEgPSBRLmNvbChpKTtcbiAgICAgICAgICAgIGNvbnN0IHFfZG90X3YgPSBuZXVtYWlyX3N1bShxLm1hcCgocV8sIGspID0+IHFfICogdltrXSkpO1xuICAgICAgICAgICAgUi5zZXRfZW50cnkoaSxqLCBxX2RvdF92KTtcbiAgICAgICAgICAgIHYgPSB2Lm1hcCgodl8sIGspID0+IHZfIC0gcV9kb3RfdiAqIHFba10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZfbm9ybSA9IG5vcm0odiwgZXVjbGlkZWFuKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3dzOyArK2spIHtcbiAgICAgICAgICAgIFEuc2V0X2VudHJ5KGssIGosIHZba10gLyB2X25vcm0pO1xuICAgICAgICB9XG4gICAgICAgIFIuc2V0X2VudHJ5KGosaiwgdl9ub3JtKVxuICAgIH1cbiAgICByZXR1cm4ge1wiUlwiOiBSLCBcIlFcIjogUX07XG59XG5cbiIsImltcG9ydCB7IHFyIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IFJhbmRvbWl6ZXIgfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4LmpzXCI7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHtAbGluayBrfSBiaWdnZXN0IEVpZ2VudmVjdG9ycyBhbmQgRWlnZW52YWx1ZXMgZnJvbSBNYXRyaXgge0BsaW5rIEF9IHdpdGggdGhlIFFSLUFsZ29yaXRobS5cbiAqIEBwYXJhbSB7TWF0cml4fSBBIC0gVGhlIE1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IGsgLSBUaGUgbnVtYmVyIG9mIGVpZ2VudmVjdG9ycyBhbmQgZWlnZW52YWx1ZXMgdG8gY29tcHV0ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4X2l0ZXJhdGlvbnM9MTAwXSAtIFRoZSBudW1iZXIgb2YgbWF4aXVtdW0gaXRlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHNob3VsZCBydW4uXG4gKiBAcGFyYW0ge051bWJlcnxSYW5kb21pemVyfSBbc2VlZD0xMjEyXSAtIFRoZSBzZWVkIHZhbHVlIG9yIGEgcmFuZG9taXplciB1c2VkIGluIHRoZSBhbGdvcml0aG0uXG4gKiBAcmV0dXJucyB7e2VpZ2VudmFsdWVzOiBBcnJheSwgZWlnZW52ZWN0b3JzOiBBcnJheX19IC0gVGhlIHtAbGluayBrfSBiaWdnZXN0IGVpZ2VudmVjdG9ycyBhbmQgZWlnZW52YWx1ZXMgb2YgTWF0cml4IHtAbGluayBBfS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oQSwgayA9IDIsIG1heF9pdGVyYXRpb25zPTEwMCwgc2VlZD0xMjEyKSB7XG4gICAgY29uc3QgcmFuZG9taXplciA9IHNlZWQgaW5zdGFuY2VvZiBSYW5kb21pemVyID8gc2VlZCA6IG5ldyBSYW5kb21pemVyKHNlZWQpO1xuICAgIGlmICghKEEgaW5zdGFuY2VvZiBNYXRyaXgpKSBBID0gTWF0cml4LmZyb20oQSk7XG4gICAgY29uc3QgbiA9IEEuc2hhcGVbMF1cbiAgICBsZXQgeyBROiBRLCBSOiBSIH0gPSBxcihuZXcgTWF0cml4KG4sIGssICgpID0+IHJhbmRvbWl6ZXIucmFuZG9tKSk7XG4gICAgd2hpbGUgKG1heF9pdGVyYXRpb25zLS0pIHtcbiAgICAgICAgY29uc3Qgb2xkUiA9IFIuY2xvbmUoKTtcbiAgICAgICAgY29uc3QgWiA9IEEuZG90KFEpO1xuICAgICAgICBjb25zdCBRUiA9IHFyKFopOyBcbiAgICAgICAgUSA9IFFSLlE7XG4gICAgICAgIFIgPSBRUi5SO1xuICAgICAgICBpZiAobmV1bWFpcl9zdW0oUi5zdWIob2xkUikuZGlhZykgLyBuIDwgMWUtMTIpIHtcbiAgICAgICAgICAgIG1heF9pdGVyYXRpb25zID0gMDtcbiAgICAgICAgfSAgICAgICAgXG4gICAgfVxuXG4gICAgY29uc3QgZWlnZW52YWx1ZXMgPSBSLmRpYWc7XG4gICAgY29uc3QgZWlnZW52ZWN0b3JzID0gUS50cmFuc3Bvc2UoKS50bzJkQXJyYXk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJlaWdlbnZhbHVlc1wiOiBlaWdlbnZhbHVlcyxcbiAgICAgICAgXCJlaWdlbnZlY3RvcnNcIjogZWlnZW52ZWN0b3JzLFxuICAgIH07XG59XG5cbiIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBSYW5kb21pemVyIH0gZnJvbSBcIi4uL3V0aWwvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBEUlxuICogQGJvcnJvd3MgRFIjcGFyYW1ldGVyIGFzIERSI3BhcmFcbiAqIEBib3Jyb3dzIERSI3BhcmFtZXRlciBhcyBEUiNwXG4gKi9cbmV4cG9ydCBjbGFzcyBEUiB7XG4gICAgLy9zdGF0aWMgcGFyYW1ldGVyX2xpc3QgPSBbXTtcbiAgICBnZXQgcGFyYW1ldGVyX2xpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJfbGlzdDtcbiAgICB9XG5cbiAgICBzZXQgcGFyYW1ldGVyX2xpc3QobGlzdCkge1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJfbGlzdCA9IGxpc3Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIERSXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXk8QXJyYXk8TnVtYmVyPj59IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtzZWVkfSBbc2VlZCA9IDEyMTJdIC0gdGhlIHNlZWQgdmFsdWUgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7RFJ9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgZCA9IDIsIG1ldHJpYyA9IGV1Y2xpZGVhbiwgc2VlZCA9IDEyMTIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoWCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgICB0aGlzLlggPSBNYXRyaXguZnJvbShYKTtcbiAgICAgICAgfSBlbHNlIGlmIChYIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gXCJtYXRyaXhcIjtcbiAgICAgICAgICAgIHRoaXMuWCA9IFg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyB2YWxpZCB0eXBlIGZvciBYXCIpO1xuICAgICAgICB9XG4gICAgICAgIFt0aGlzLl9OLCB0aGlzLl9EXSA9IHRoaXMuWC5zaGFwZTtcbiAgICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcbiAgICAgICAgdGhpcy5fc2VlZCA9IHNlZWQ7XG4gICAgICAgIHRoaXMuX3JhbmRvbWl6ZXIgPSBuZXcgUmFuZG9taXplcihzZWVkKTtcbiAgICAgICAgdGhpcy5faXNfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGFuZCBnZXQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdmFsdWUgPSBudWxsXSAtIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIgdG8gc2V0LCBpZiA8Y29kZT52YWx1ZSA9PSBudWxsPC9jb2RlPiB0aGVuIHJldHVybiBhY3R1YWwgcGFyYW1ldGVyIHZhbHVlLlxuICAgICAqIEBtZW1iZXJvZiBEUlxuICAgICAqL1xuICAgIHBhcmFtZXRlcihuYW1lLCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVyX2xpc3QuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBpcyBub3QgYSB2YWxpZCBwYXJhbWV0ZXIhYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW2BfJHtuYW1lfWBdID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9pc19pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tgXyR7bmFtZX1gXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhcmEobmFtZSwgdmFsdWUgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcChuYW1lLCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVyKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgKmdlbmVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCk7XG4gICAgfVxuXG4gICAgY2hlY2tfaW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc19pbml0aWFsaXplZCAmJiB0eXBlb2YgdGhpcy5pbml0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5faXNfaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge01hdHJpeH0gUmV0dXJucyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgcHJvamVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUgPT09IFwibWF0cml4XCIgPyB0aGlzLlkgOiB0aGlzLlkudG8yZEFycmF5O1xuICAgIH1cblxuICAgIGFzeW5jIHRyYW5zZm9ybV9hc3luYyguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGRyID0gbmV3IHRoaXMoLi4uYXJncyk7XG4gICAgICAgIHJldHVybiBkci50cmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGRyID0gbmV3IHRoaXMoLi4uYXJncyk7XG4gICAgICAgIHJldHVybiBkci50cmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgdHJhbnNmb3JtX2FzeW5jKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIHN0YXRpYyAqZ2VuZXJhdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZHIgPSBuZXcgdGhpcyguLi5hcmdzKTtcbiAgICAgICAgY29uc3QgZ2VuID0gZHIuZ2VuZXJhdG9yKCk7XG4gICAgICAgIGZvciAoY29uc3QgcmVzIG9mIGdlbikge1xuICAgICAgICAgICAgeWllbGQgcmVzO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9ufSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBQQ0FcbiAqIEBhdWdtZW50cyBEUlxuICovXG5leHBvcnQgY2xhc3MgUENBIGV4dGVuZHMgRFJ7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgUENBIFxuICAgICAqIEBwYXJhbSB7TWF0cml4fEFycmF5PEFycmF5PE51bWJlcj4+fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2QgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7UENBfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIGQ9Mikge1xuICAgICAgICBzdXBlcihYLCBkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXRkYXRhIHtAbGluayBYfSB0byBkaW1lbmlvbmFsaXR5IHtAbGluayBkfS5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IFYgPSB0aGlzLnByaW5jaXBhbF9jb21wb25lbnRzKCk7XG4gICAgICAgIHRoaXMuWSA9IFguZG90KFYpXG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHtAbGluayBkfSBwcmluY2lwYWwgY29tcG9uZW50cyBvZiBNYXRyaXgge0BsaW5rIFh9LlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IFxuICAgICAqL1xuICAgIHByaW5jaXBhbF9jb21wb25lbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5WKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5WO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IG1lYW5zID0gTWF0cml4LmZyb20oWC5tZWFuQ29scyk7XG4gICAgICAgIGNvbnN0IFhfY2VudCA9IFguc3ViKG1lYW5zKTtcbiAgICAgICAgY29uc3QgQyA9IFhfY2VudC50cmFuc3Bvc2UoKS5kb3QoWF9jZW50KTtcbiAgICAgICAgY29uc3QgeyBlaWdlbnZlY3RvcnM6IFYgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihDLCB0aGlzLl9kKTtcbiAgICAgICAgdGhpcy5WID0gTWF0cml4LmZyb20oVikudHJhbnNwb3NlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLlY7XG4gICAgfVxufSAiLCJpbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb259IGZyb20gXCIuLi9saW5lYXJfYWxnZWJyYS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGlzdGFuY2VfbWF0cml4LCBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIE1EU1xuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIE1EUyBleHRlbmRzIERSe1xuICAgIC8qKlxuICAgICAqIENsYXNzaWNhbCBNRFMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgTURTXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLiAgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWVkID0gMTIxMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgZD0yLCBtZXRyaWM9ZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgc3VwZXIoWCwgZCwgbWV0cmljLCBzZWVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXRkYXRhIHtAbGluayBYfSB0byBkaW1lbnNpb25hbGl0eSB7QGxpbmsgZH0uXG4gICAgICogQHJldHVybnMge01hdHJpeHxBcnJheX1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBYLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IEEgPSBtZXRyaWMgPT09IFwicHJlY29tcHV0ZWRcIiA/IFggOiBkaXN0YW5jZV9tYXRyaXgoWCwgbWV0cmljKTsgXG4gICAgICAgIGNvbnN0IGFpXyA9IEEubWVhbkNvbHM7XG4gICAgICAgIGNvbnN0IGFfaiA9IEEubWVhblJvd3M7XG4gICAgICAgIGNvbnN0IGFfXyA9IEEubWVhbjtcblxuICAgICAgICB0aGlzLl9kX1ggPSBBO1xuICAgICAgICBjb25zdCBCID0gbmV3IE1hdHJpeChyb3dzLCByb3dzLCAoaSwgaikgPT4gKEEuZW50cnkoaSwgaikgLSBhaV9baV0gLSBhX2pbal0gKyBhX18pKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgY29uc3QgeyBlaWdlbnZlY3RvcnM6IFYgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihCLCB0aGlzLl9kKTtcbiAgICAgICAgdGhpcy5ZID0gTWF0cml4LmZyb20oVikudHJhbnNwb3NlKClcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge051bWJlcn0gLSB0aGUgc3RyZXNzIG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgIHN0cmVzcygpIHtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgWSA9IHRoaXMuWTtcbiAgICAgICAgY29uc3QgZF9YID0gdGhpcy5fZF9YOyAvKm5ldyBNYXRyaXgoKTtcbiAgICAgICAgZF9YLnNoYXBlID0gW04sIE4sIChpLCBqKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaSA8IGogPyBtZXRyaWMoWC5yb3coaSksIFgucm93KGopKSA6IGRfWC5lbnRyeShqLCBpKTtcbiAgICAgICAgfV0qL1xuICAgICAgICBjb25zdCBkX1kgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIGRfWS5zaGFwZSA9IFtOLCBOLCAoaSwgaikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGkgPCBqID8gZXVjbGlkZWFuKFkucm93KGkpLCBZLnJvdyhqKSkgOiBkX1kuZW50cnkoaiwgaSk7XG4gICAgICAgIH1dXG4gICAgICAgIGxldCB0b3Bfc3VtID0gMDtcbiAgICAgICAgbGV0IGJvdHRvbV9zdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgdG9wX3N1bSArPSBNYXRoLnBvdyhkX1guZW50cnkoaSwgaikgLSBkX1kuZW50cnkoaSwgaiksIDIpO1xuICAgICAgICAgICAgICAgIGJvdHRvbV9zdW0gKz0gTWF0aC5wb3coZF9YLmVudHJ5KGksIGopLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRvcF9zdW0gLyBib3R0b21fc3VtKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9ufSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBIZWFwIH0gZnJvbSBcIi4uL2RhdGFzdHJ1Y3R1cmUvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJU09NQVBcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBJU09NQVAgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgSVNPTUFQXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbmVpZ2hib3JzIC0gdGhlIG51bWJlciBvZiBuZWlnaGJvcnMge0BsaW5rIElTT01BUH0gc2hvdWxkIHVzZSB0byBwcm9qZWN0IHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLiBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBuZWlnaGJvcnMsIGQgPSAyLCBtZXRyaWMgPSBldWNsaWRlYW4sIHNlZWQ9MTIxMikge1xuICAgICAgICBzdXBlcihYLCBkLCBtZXRyaWMsIHNlZWQpO1xuICAgICAgICBzdXBlci5wYXJhbWV0ZXJfbGlzdCA9IFtcImtcIl07XG4gICAgICAgIHRoaXMucGFyYW1ldGVyKFwia1wiLCBNYXRoLm1pbihuZWlnaGJvcnMgPz8gTWF0aC5tYXgoTWF0aC5mbG9vcih0aGlzLlguc2hhcGVbMF0gLyAxMCksIDIpLCB0aGlzLl9OIC0xKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IFJldHVybnMgdGhlIHByb2plY3Rpb24uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgLy8gVE9ETzogbWFrZSBrbm4gZXh0ZXJuIGFuZCBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdG9yIG9yIHRyYW5zZm9ybT9cbiAgICAgICAgY29uc3QgRCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgRC5zaGFwZSA9IFtyb3dzLCByb3dzLCAoaSxqKSA9PiBpIDw9IGogPyBtZXRyaWMoWC5yb3coaSksIFgucm93KGopKSA6IEQuZW50cnkoaixpKV1cbiAgICAgICAgY29uc3Qga05lYXJlc3ROZWlnaGJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dzOyArK2opIHtcbiAgICAgICAgICAgICAgICByb3cucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIFwiaW5kZXhcIjogaixcbiAgICAgICAgICAgICAgICAgICAgXCJkaXN0YW5jZVwiOiBELmVudHJ5KGksIGopLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBIID0gbmV3IEhlYXAocm93LCBkID0+IGQuZGlzdGFuY2UsIFwibWluXCIpO1xuICAgICAgICAgICAga05lYXJlc3ROZWlnaGJvcnMucHVzaChILnRvQXJyYXkoKS5zbGljZSgxLCB0aGlzLl9rICsgMSkpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8qRCA9IGRpamtzdHJhKGtOZWFyZXN0TmVpZ2hib3JzKTsqL1xuICAgICAgICAvLyBjb21wdXRlIHNob3J0ZXN0IHBhdGhzXG4gICAgICAgIC8vIFRPRE86IG1ha2UgZXh0ZXJuXG4gICAgICAgIC8qKiBAc2VlIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZCVFMiU4MCU5M1dhcnNoYWxsX2FsZ29yaXRobX0gKi9cbiAgICAgICAgY29uc3QgRyA9IG5ldyBNYXRyaXgocm93cywgcm93cywgKGksaikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBrTmVhcmVzdE5laWdoYm9yc1tpXS5maW5kKG4gPT4gbi5pbmRleCA9PT0gaik7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPyBvdGhlci5kaXN0YW5jZSA6IEluZmluaXR5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd3M7ICsraikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcm93czsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIEcuc2V0X2VudHJ5KGksIGosIE1hdGgubWluKEcuZW50cnkoaSwgaiksIEcuZW50cnkoaSwgaykgKyBHLmVudHJ5KGssIGopKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgYWlfID0gbmV3IEZsb2F0NjRBcnJheShyb3dzKTtcbiAgICAgICAgbGV0IGFfaiA9IG5ldyBGbG9hdDY0QXJyYXkocm93cyk7XG4gICAgICAgIGxldCBhX18gPSAwO1xuICAgICAgICBsZXQgQSA9IG5ldyBNYXRyaXgocm93cywgcm93cywgKGksaikgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbCA9IEcuZW50cnkoaSwgaik7XG4gICAgICAgICAgICB2YWwgPSB2YWwgPT09IEluZmluaXR5ID8gMCA6IHZhbDtcbiAgICAgICAgICAgIGFpX1tpXSArPSB2YWw7XG4gICAgICAgICAgICBhX2pbal0gKz0gdmFsO1xuICAgICAgICAgICAgYV9fICs9IHZhbDtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgYWlfID0gYWlfLm1hcCh2ID0+IHYgLyByb3dzKTtcbiAgICAgICAgYV9qID0gYV9qLm1hcCh2ID0+IHYgLyByb3dzKTtcbiAgICAgICAgYV9fIC89IChyb3dzICoqIDIpO1xuICAgICAgICBjb25zdCBCID0gbmV3IE1hdHJpeChyb3dzLCByb3dzLCAoaSxqKSA9PiAoQS5lbnRyeShpLGopIC0gYWlfW2ldIC0gYV9qW2pdICsgYV9fKSk7XG4gICAgICAgICAgICAgXG4gICAgICAgIC8vIGNvbXB1dGUgZCBlaWdlbnZlY3RvcnNcbiAgICAgICAgY29uc3QgeyBlaWdlbnZlY3RvcnM6IFYgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihCLCB0aGlzLl9kKTtcbiAgICAgICAgdGhpcy5ZID0gTWF0cml4LmZyb20oVikudHJhbnNwb3NlKCk7XG4gICAgICAgIC8vIHJldHVybiBlbWJlZGRpbmdcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cblxufSIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEZBU1RNQVBcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBGQVNUTUFQIGV4dGVuZHMgRFJ7XG4gICAgLyoqXG4gICAgICogRmFzdE1hcDogYSBmYXN0IGFsZ29yaXRobSBmb3IgaW5kZXhpbmcsIGRhdGEtbWluaW5nIGFuZCB2aXN1YWxpemF0aW9uIG9mIHRyYWRpdGlvbmFsIGFuZCBtdWx0aW1lZGlhIGRhdGFzZXRzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgRkFTVE1BUFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS4gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy4gIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VlZCA9IDEyMTJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGQVNUTUFQfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9pLm9yZy8xMC4xMTQ1LzIyMzc4NC4yMjM4MTJ9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgZD0yLCBtZXRyaWM9ZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgc3VwZXIoWCwgZCwgbWV0cmljLCBzZWVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hvb3NlcyB0d28gcG9pbnRzIHdoaWNoIGFyZSB0aGUgbW9zdCBkaXN0YW50IGluIHRoZSBhY3R1YWwgcHJvamVjdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpc3QgXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBjb25zaXN0aW5nIG9mIGZpcnN0IGluZGV4LCBzZWNvbmQgaW5kZXgsIGFuZCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzLlxuICAgICAqL1xuICAgIF9jaG9vc2VfZGlzdGFudF9vYmplY3RzKGRpc3QpIHtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgTiA9IFguc2hhcGVbMF07XG4gICAgICAgIGxldCBhX2luZGV4ID0gdGhpcy5fcmFuZG9taXplci5yYW5kb21faW50ICUgTiAtIDE7XG4gICAgICAgIGxldCBiX2luZGV4ID0gbnVsbDtcbiAgICAgICAgbGV0IG1heF9kaXN0ID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZF9haSA9IGRpc3QoYV9pbmRleCwgaSlcbiAgICAgICAgICAgIGlmIChkX2FpID4gbWF4X2Rpc3QpIHtcbiAgICAgICAgICAgICAgICBtYXhfZGlzdCA9IGRfYWk7XG4gICAgICAgICAgICAgICAgYl9pbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWF4X2Rpc3QgPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBkX2JpID0gZGlzdChiX2luZGV4LCBpKVxuICAgICAgICAgICAgaWYgKGRfYmkgPiBtYXhfZGlzdCkge1xuICAgICAgICAgICAgICAgIG1heF9kaXN0ID0gZF9iaTtcbiAgICAgICAgICAgICAgICBhX2luZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FfaW5kZXgsIGJfaW5kZXgsIG1heF9kaXN0XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSBUaGUge0BsaW5rIGR9LWRpbWVuc2lvbmFsIHByb2plY3Rpb24gb2YgdGhlIGRhdGEgbWF0cml4IHtAbGluayBYfS5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IE4gPSBYLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBkID0gdGhpcy5fZDtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBZID0gbmV3IE1hdHJpeChOLCBkLCAwKTtcbiAgICAgICAgbGV0IGRpc3QgPSAoYSwgYikgPT4gbWV0cmljKFgucm93KGEpLCBYLnJvdyhiKSk7XG5cbiAgICAgICAgZm9yIChsZXQgX2NvbCA9IDA7IF9jb2wgPCBkOyArK19jb2wpIHtcbiAgICAgICAgICAgIGxldCBvbGRfZGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAvLyBjaG9vc2UgcGl2b3Qgb2JqZWN0c1xuICAgICAgICAgICAgY29uc3QgW2FfaW5kZXgsIGJfaW5kZXgsIGRfYWJdID0gdGhpcy5fY2hvb3NlX2Rpc3RhbnRfb2JqZWN0cyhkaXN0KTtcbiAgICAgICAgICAgIC8vIHJlY29yZCBpZCBvZiBwaXZvdCBvYmplY3RzXG4gICAgICAgICAgICAvL1BBWzBdLnB1c2goYV9pbmRleCk7XG4gICAgICAgICAgICAvL1BBWzFdLnB1c2goYl9pbmRleCk7XG4gICAgICAgICAgICAvKiBpZiAoZF9hYiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgYWxsIGludGVyLW9iamVjdCBkaXN0YW5jZXMgYXJlIHplcm9zXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgWS5zZXRfZW50cnkoaSwgX2NvbCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHsgKi9cbiAgICAgICAgICAgIGlmIChkX2FiICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJvamVjdCB0aGUgb2JqZWN0cyBvbiB0aGUgbGluZSAoT19hLCBPX2IpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZF9haSA9IGRpc3QoYV9pbmRleCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRfYmkgPSBkaXN0KGJfaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5X2kgPSAoZF9haSAqKiAyICsgZF9hYiAqKiAyIC0gZF9iaSAqKiAyKSAvICgyICogZF9hYik7XG4gICAgICAgICAgICAgICAgICAgIFkuc2V0X2VudHJ5KGksIF9jb2wsIHlfaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBwcm9qZWN0aW9ucyBvZiB0aGUgb2JqZWN0cyBvbiBhXG4gICAgICAgICAgICAgICAgLy8gaHlwZXJwbGFuZSBwZXJwZW5kaWNsdWFyIHRvIHRoZSBsaW5lIChhLCBiKTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgZGlzdGFuY2UgZnVuY3Rpb24gRCcoKSBiZXR3ZWVuIHR3byBcbiAgICAgICAgICAgICAgICAvLyBwcm9qZWN0aW9ucyBpcyBnaXZlbiBieSBFcS40XG4gICAgICAgICAgICAgICAgZGlzdCA9IChhLCBiKSA9PiBNYXRoLnNxcnQob2xkX2Rpc3QoYSwgYikgKiogMiAtIChZLmVudHJ5KGEsIF9jb2wpIC0gWS5lbnRyeShiLCBfY29sKSkgKiogMilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gZW1iZWRkaW5nXG4gICAgICAgIHRoaXMuWSA9IFk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxufSIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb259IGZyb20gXCIuLi9saW5lYXJfYWxnZWJyYS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIExEQVxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIExEQSBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBMREFcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGFiZWxzIC0gdGhlIGxhYmVsIC8gY2xhc3Mgb2YgZWFjaCBkYXRhIHBvaW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuICBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBsYWJlbHMsIGQgPSAyLCBtZXRyaWMgPSBldWNsaWRlYW4sIHNlZWQ9MTIxMikge1xuICAgICAgICBzdXBlcihYLCBkLCBtZXRyaWMsIHNlZWQpO1xuICAgICAgICBzdXBlci5wYXJhbWV0ZXJfbGlzdCA9IFtcImxhYmVsc1wiXTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJsYWJlbHNcIiwgbGFiZWxzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXRkYXRhIHtAbGluayBYfSB0byBkaW1lbmlvbmFsaXR5IHtAbGluayBkfS5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIGxldCBYID0gdGhpcy5YO1xuICAgICAgICBsZXQgWyByb3dzLCBjb2xzIF0gPSBYLnNoYXBlO1xuICAgICAgICBsZXQgbGFiZWxzID0gdGhpcy5fbGFiZWxzO1xuICAgICAgICBsZXQgdW5pcXVlX2xhYmVscyA9IHt9O1xuICAgICAgICBsZXQgbGFiZWxfaWQgPSAwO1xuICAgICAgICBsYWJlbHMuZm9yRWFjaCgobCwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGwgaW4gdW5pcXVlX2xhYmVscykge1xuICAgICAgICAgICAgICAgIHVuaXF1ZV9sYWJlbHNbbF0uY291bnQrKztcbiAgICAgICAgICAgICAgICB1bmlxdWVfbGFiZWxzW2xdLnJvd3MucHVzaChYLnJvdyhpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuaXF1ZV9sYWJlbHNbbF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogbGFiZWxfaWQrKyxcbiAgICAgICAgICAgICAgICAgICAgXCJjb3VudFwiOiAxLFxuICAgICAgICAgICAgICAgICAgICBcInJvd3NcIjogW1gucm93KGkpXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICAvLyBjcmVhdGUgWF9tZWFuIGFuZCB2ZWN0b3IgbWVhbnM7XG4gICAgICAgIGxldCBYX21lYW4gPSBYLm1lYW47XG4gICAgICAgIGxldCBWX21lYW4gPSBuZXcgTWF0cml4KGxhYmVsX2lkLCBjb2xzKVxuICAgICAgICBmb3IgKGxldCBsYWJlbCBpbiB1bmlxdWVfbGFiZWxzKSB7XG4gICAgICAgICAgICBsZXQgViA9IE1hdHJpeC5mcm9tKHVuaXF1ZV9sYWJlbHNbbGFiZWxdLnJvd3MpO1xuICAgICAgICAgICAgbGV0IHZfbWVhbiA9IFYubWVhbkNvbHM7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7ICsraikge1xuICAgICAgICAgICAgICAgIFZfbWVhbi5zZXRfZW50cnkodW5pcXVlX2xhYmVsc1tsYWJlbF0uaWQsIGosIHZfbWVhbltqXSk7XG4gICAgICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICAvLyBzY2F0dGVyX2JldHdlZW5cbiAgICAgICAgbGV0IFNfYiA9IG5ldyBNYXRyaXgoY29scywgY29scyk7XG4gICAgICAgIGZvciAobGV0IGxhYmVsIGluIHVuaXF1ZV9sYWJlbHMpIHtcbiAgICAgICAgICAgIGxldCB2ID0gVl9tZWFuLnJvdyh1bmlxdWVfbGFiZWxzW2xhYmVsXS5pZCk7XG4gICAgICAgICAgICBsZXQgbSA9IG5ldyBNYXRyaXgoY29scywgMSwgKGopID0+IHZbal0gLSBYX21lYW4pO1xuICAgICAgICAgICAgbGV0IE4gPSB1bmlxdWVfbGFiZWxzW2xhYmVsXS5jb3VudDtcbiAgICAgICAgICAgIFNfYiA9IFNfYi5hZGQobS5kb3QobS50cmFuc3Bvc2UoKSkubXVsdChOKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzY2F0dGVyX3dpdGhpblxuICAgICAgICBsZXQgU193ID0gbmV3IE1hdHJpeChjb2xzLCBjb2xzKTtcbiAgICAgICAgZm9yIChsZXQgbGFiZWwgaW4gdW5pcXVlX2xhYmVscykge1xuICAgICAgICAgICAgbGV0IHYgPSBWX21lYW4ucm93KHVuaXF1ZV9sYWJlbHNbbGFiZWxdLmlkKTtcbiAgICAgICAgICAgIGxldCBtID0gbmV3IE1hdHJpeChjb2xzLCAxLCAoaikgPT4gdltqXSlcbiAgICAgICAgICAgIGxldCBSID0gdW5pcXVlX2xhYmVsc1tsYWJlbF0ucm93cztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdW5pcXVlX2xhYmVsc1tsYWJlbF0uY291bnQ7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm93X3YgPSBuZXcgTWF0cml4KGNvbHMsIDEsIChqLF8pID0+IFJbaV1bal0gLSBtLmVudHJ5KGosIDApKTtcbiAgICAgICAgICAgICAgICBTX3cgPSBTX3cuYWRkKHJvd192LmRvdChyb3dfdi50cmFuc3Bvc2UoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHsgZWlnZW52ZWN0b3JzOiBWIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oU193LmludmVyc2UoKS5kb3QoU19iKSwgdGhpcy5fZClcbiAgICAgICAgViA9IE1hdHJpeC5mcm9tKFYpLnRyYW5zcG9zZSgpXG4gICAgICAgIHRoaXMuWSA9IFguZG90KFYpXG5cbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZ1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9ufSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IGtfbmVhcmVzdF9uZWlnaGJvcnMgfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBMTEVcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBMTEUgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgTExFXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuZWlnaGJvcnMgLSB0aGUgbGFiZWwgLyBjbGFzcyBvZiBlYWNoIGRhdGEgcG9pbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy4gIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VlZCA9IDEyMTJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIG5laWdoYm9ycywgZD0yLCBtZXRyaWM9ZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgc3VwZXIoWCwgZCwgbWV0cmljLCBzZWVkKTtcbiAgICAgICAgc3VwZXIucGFyYW1ldGVyX2xpc3QgPSBbXCJrXCJdO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcImtcIiwgTWF0aC5taW4obmVpZ2hib3JzID8/IE1hdGgubWF4KE1hdGguZmxvb3IodGhpcy5fTiAvIDEwKSwgMiksIHRoaXMuX04gLSAxKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0ZGF0YSB7QGxpbmsgWH0gdG8gZGltZW5pb25hbGl0eSB7QGxpbmsgZH0uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBkID0gdGhpcy5fZDtcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9EO1xuICAgICAgICBjb25zdCBrID0gdGhpcy5wYXJhbWV0ZXIoXCJrXCIpO1xuICAgICAgICBjb25zdCBuTiA9IGtfbmVhcmVzdF9uZWlnaGJvcnMoWCwgaywgbnVsbCwgdGhpcy5fbWV0cmljKTtcbiAgICAgICAgY29uc3QgTyA9IG5ldyBNYXRyaXgoaywgMSwgMSk7XG4gICAgICAgIGNvbnN0IFcgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MpO1xuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBuTl9yb3cgPSBuTltyb3ddO1xuICAgICAgICAgICAgY29uc3QgWiA9IG5ldyBNYXRyaXgoaywgY29scywgKGksIGopID0+IFguZW50cnkobk5fcm93W2ldLmosIGopIC0gWC5lbnRyeShyb3csIGopKTtcbiAgICAgICAgICAgIGNvbnN0IEMgPSBaLmRvdChaLlQpO1xuICAgICAgICAgICAgaWYgKCBrID4gY29scyApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBDX3RyYWNlID0gbmV1bWFpcl9zdW0oQy5kaWFnKSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgQy5zZXRfZW50cnkoaiwgaiwgQy5lbnRyeShqLCBqKSArIENfdHJhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlY29uc3RydWN0O1xuICAgICAgICAgICAgbGV0IHcgPSBNYXRyaXguc29sdmVfQ0coQywgTywgdGhpcy5fcmFuZG9taXplcik7XG4gICAgICAgICAgICB3ID0gdy5kaXZpZGUody5zdW0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrOyArK2opIHtcbiAgICAgICAgICAgICAgICBXLnNldF9lbnRyeShyb3csIG5OX3Jvd1tqXS5qLCB3LmVudHJ5KGosIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wIGVtYmVkZGluZ1xuICAgICAgICBjb25zdCBJID0gbmV3IE1hdHJpeChyb3dzLCByb3dzLCBcImlkZW50aXR5XCIpO1xuICAgICAgICBjb25zdCBJVyA9IEkuc3ViKFcpO1xuICAgICAgICBjb25zdCBNID0gSVcuVC5kb3QoSVcpO1xuICAgICAgICBjb25zdCB7IGVpZ2VudmVjdG9yczogViB9ID0gc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uKE0uVC5pbnZlcnNlKCksIGQgKyAxKTtcbiAgICAgICAgdGhpcy5ZID0gTWF0cml4LmZyb20oVi5zbGljZSgxLCAxICsgZCkpLlQ7XG5cbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZ1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBNYXRyaXgsIGtfbmVhcmVzdF9uZWlnaGJvcnMgfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9ufSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBMVFNBXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgTFRTQSBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBMVFNBXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuZWlnaGJvcnMgLSB0aGUgbGFiZWwgLyBjbGFzcyBvZiBlYWNoIGRhdGEgcG9pbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy4gIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VlZCA9IDEyMTJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZXB1YnMuc2lhbS5vcmcvZG9pL2Ficy8xMC4xMTM3L1MxMDY0ODI3NTAyNDE5MTU0fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIG5laWdoYm9ycywgZD0yLCBtZXRyaWM9ZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgc3VwZXIoWCwgZCwgbWV0cmljLCBzZWVkKTtcbiAgICAgICAgc3VwZXIucGFyYW1ldGVyX2xpc3QgPSBbXCJrXCJdO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcImtcIiwgTWF0aC5taW4obmVpZ2hib3JzID8/IE1hdGgubWF4KE1hdGguZmxvb3IodGhpcy5fTiAvIDEwKSwgMiksIHRoaXMuX04gLSAxKSk7XG4gICAgICAgIGlmICh0aGlzLl9EIDw9IGQpIHRocm93IGBEaW1lbnNpb25hbGl0eSBvZiBYIChEID0gJHt0aGlzLl9EfSkgbXVzdCBiZSBncmVhdGVyIHRoYW4gdGhlIHJlcXVpcmVkIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSByZXN1bHQgKGQgPSAke2R9KSFgO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuaW9uYWxpdHkge0BsaW5rIGR9LlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuX2Q7XG4gICAgICAgIGNvbnN0IFsgcm93cywgRCBdID0gWC5zaGFwZTtcbiAgICAgICAgY29uc3QgayA9IHRoaXMucGFyYW1ldGVyKFwia1wiKTtcbiAgICAgICAgLy8gMS4xIGRldGVybWluZSBrIG5lYXJlc3QgbmVpZ2hib3JzXG4gICAgICAgIGNvbnN0IG5OID0ga19uZWFyZXN0X25laWdoYm9ycyhYLCBrLCBudWxsLCB0aGlzLl9tZXRyaWMpO1xuICAgICAgICAvLyBjZW50ZXIgbWF0cml4XG4gICAgICAgIGNvbnN0IE8gPSBuZXcgTWF0cml4KEQsIEQsIFwiY2VudGVyXCIpO1xuICAgICAgICBjb25zdCBCID0gbmV3IE1hdHJpeChyb3dzLCByb3dzLCAwKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAvLyAxLjIgY29tcHV0ZSB0aGUgZCBsYXJnZXN0IGVpZ2VudmVjdG9ycyBvZiB0aGUgY29ycmVsYXRpb24gbWF0cml4XG4gICAgICAgICAgICBjb25zdCBJX2kgPSBbcm93LCAuLi5uTltyb3ddLm1hcChuID0+IG4uaildXG4gICAgICAgICAgICBsZXQgWF9pID0gTWF0cml4LmZyb20oSV9pLm1hcChuID0+IFgucm93KG4pKSk7XG4gICAgICAgICAgICAvLyBjZW50ZXIgWF9pXG4gICAgICAgICAgICBYX2kgPSBYX2kuZG90KE8pXG4gICAgICAgICAgICAvLyBjb3JyZWxhdGlvbiBtYXRyaXhcbiAgICAgICAgICAgIGNvbnN0IEMgPSBYX2kuZG90KFhfaS50cmFuc3Bvc2UoKSk7XG4gICAgICAgICAgICBjb25zdCB7IGVpZ2VudmVjdG9yczogZyB9ID0gc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uKEMsIGQpO1xuICAgICAgICAgICAgLy9nLnB1c2gobGluc3BhY2UoMCwgaykubWFwKF8gPT4gMSAvIE1hdGguc3FydChrICsgMSkpKTtcbiAgICAgICAgICAgIGNvbnN0IEdfaV90ID0gTWF0cml4LmZyb20oZyk7XG4gICAgICAgICAgICAvLyAyLiBDb25zdHJ1Y3RpbmcgYWxpZ25tZW50IG1hdHJpeFxuICAgICAgICAgICAgY29uc3QgV19pID0gR19pX3QudHJhbnNwb3NlKCkuZG90KEdfaV90KS5hZGQoMSAvIE1hdGguc3FydChrICsgMSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrICsgMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrICsgMTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIEIuc2V0X2VudHJ5KElfaVtpXSwgSV9pW2pdLCBCLmVudHJ5KElfaVtpXSwgSV9pW2pdKSAtIChpID09PSBqID8gMSA6IDAgKSArIFdfaS5lbnRyeShpLCBqKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gQWxpZ25pbmcgZ2xvYmFsIGNvb3JkaW5hdGVzXG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBZIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oQiwgZCArIDEpO1xuICAgICAgICB0aGlzLlkgPSBNYXRyaXguZnJvbShZLnNsaWNlKDEpKS50cmFuc3Bvc2UoKTtcblxuICAgICAgICAvLyByZXR1cm4gZW1iZWRkaW5nXG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxufSIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgVFNORVxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIFRTTkUgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgVFNORVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS4gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwZXJwbGV4aXR5ID0gNTBdIC0gcGVycGxleGl0eS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Vwc2lsb24gPSAxMF0gLSBsZWFybmluZyBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy4gIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VlZCA9IDEyMTJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtUU05FfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBlcnBsZXhpdHk9NTAsIGVwc2lsb249MTAsIGQ9MiwgbWV0cmljPWV1Y2xpZGVhbiwgc2VlZD0xMjEyKSB7XG4gICAgICAgIHN1cGVyKFgsIGQsIG1ldHJpYywgc2VlZCk7XG4gICAgICAgIHN1cGVyLnBhcmFtZXRlcl9saXN0ID0gW1wicGVycGxleGl0eVwiLCBcImVwc2lsb25cIl07XG4gICAgICAgIFsgdGhpcy5fTiwgdGhpcy5fRCBdID0gdGhpcy5YLnNoYXBlO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcInBlcnBsZXhpdHlcIiwgTWF0aC5taW4ocGVycGxleGl0eSwgdGhpcy5fTiAtIDEpKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJlcHNpbG9uXCIsIGVwc2lsb24pO1xuICAgICAgICB0aGlzLl9pdGVyID0gMDtcbiAgICAgICAgdGhpcy5ZID0gbmV3IE1hdHJpeCh0aGlzLl9OLCB0aGlzLl9kLCAoKSA9PiB0aGlzLl9yYW5kb21pemVyLnJhbmRvbSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBkaXN0YW5jZV9tYXRyaXggLSBhY2NlcHRzIGEgcHJlY29tcHV0ZWQgZGlzdGFuY2UgbWF0cml4XG4gICAgICogQHJldHVybnMge1RTTkV9XG4gICAgICovXG4gICAgaW5pdChkaXN0YW5jZV9tYXRyaXg9bnVsbCkge1xuICAgICAgICAvLyBpbml0XG4gICAgICAgIGNvbnN0IEh0YXJnZXQgPSBNYXRoLmxvZyh0aGlzLl9wZXJwbGV4aXR5KTtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9EO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGxldCBEZWx0YTtcbiAgICAgICAgaWYgKGRpc3RhbmNlX21hdHJpeCkge1xuICAgICAgICAgICAgRGVsdGEgPSBkaXN0YW5jZV9tYXRyaXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBEZWx0YSA9IG5ldyBNYXRyaXgoTiwgTik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFhfaSA9IFgucm93KGkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IG1ldHJpYyhYX2ksIFgucm93KGopKVxuICAgICAgICAgICAgICAgICAgICBEZWx0YS5zZXRfZW50cnkoaSwgaiwgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBEZWx0YS5zZXRfZW50cnkoaiwgaSwgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IFxuICAgICAgICAgICAgXG4gICAgICAgIGNvbnN0IFAgPSBuZXcgTWF0cml4KE4sIE4sIFwiemVyb3NcIik7XG5cbiAgICAgICAgdGhpcy5feXN0ZXAgPSBuZXcgTWF0cml4KE4sIEQsIFwiemVyb3NcIik7XG4gICAgICAgIHRoaXMuX2dhaW5zID0gbmV3IE1hdHJpeChOLCBELCAxKTtcblxuICAgICAgICAvLyBzZWFyY2ggZm9yIGZpdHRpbmcgc2lnbWFcbiAgICAgICAgbGV0IHByb3cgPSBuZXcgQXJyYXkoTikuZmlsbCgwKTtcbiAgICAgICAgY29uc3QgdG9sID0gMWUtNDtcbiAgICAgICAgY29uc3QgbWF4dHJpZXMgPSA1MDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBiZXRhbWluID0gLUluZmluaXR5O1xuICAgICAgICAgICAgbGV0IGJldGFtYXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBiZXRhID0gMTtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGxldCBudW0gPSAwO1xuICAgICAgICAgICAgd2hpbGUoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBqID0gTWF0aC5leHAoLURlbHRhLmVudHJ5KGksIGopICogYmV0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSBwaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHByb3dbal0gPSBwajtcbiAgICAgICAgICAgICAgICAgICAgcHN1bSArPSBwajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IEhoZXJlID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGogPSAocHN1bSA9PT0gMCkgPyAwIDogcHJvd1tqXSAvIHBzdW07XG4gICAgICAgICAgICAgICAgICAgIHByb3dbal0gPSBwajtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBqID4gMWUtNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgSGhlcmUgLT0gcGogKiBNYXRoLmxvZyhwaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEhoZXJlID4gSHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBiZXRhbWluID0gYmV0YTtcbiAgICAgICAgICAgICAgICAgICAgYmV0YSA9IChiZXRhbWF4ID09PSBJbmZpbml0eSkgPyAoYmV0YSAqIDIpIDogKChiZXRhICsgYmV0YW1heCkgLyAyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiZXRhbWF4ID0gYmV0YTtcbiAgICAgICAgICAgICAgICAgICAgYmV0YSA9IChiZXRhbWluID09PSAtSW5maW5pdHkpID8gKGJldGEgLyAyKSA6ICgoYmV0YSArIGJldGFtaW4pIC8gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsrbnVtO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhIaGVyZSAtIEh0YXJnZXQpIDwgdG9sKSBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobnVtID49IG1heHRyaWVzKSBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBQLnNldF9lbnRyeShpLCBqLCBwcm93W2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29tcHV0ZSBwcm9iYWJpbGl0aWVzXG4gICAgICAgIGNvbnN0IFBvdXQgPSBuZXcgTWF0cml4KE4sIE4sIFwiemVyb3NcIilcbiAgICAgICAgY29uc3QgTjIgPSBOICogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IE1hdGgubWF4KChQLmVudHJ5KGksIGopICsgUC5lbnRyeShqLCBpKSkgLyBOMiwgMWUtMTAwKTtcbiAgICAgICAgICAgICAgICBQb3V0LnNldF9lbnRyeShpLCBqLCBwKTtcbiAgICAgICAgICAgICAgICBQb3V0LnNldF9lbnRyeShqLCBpLCBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9QID0gUG91dDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpdGVyYXRpb25zPTUwMF0gLSBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAgICAgKiBAeWllbGRzIHtNYXRyaXh8QXJyYXk8QXJyYXk+fSAtIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybShpdGVyYXRpb25zPTUwMCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpdGVyYXRpb25zPTUwMF0gLSBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAgICAgKiBAeWllbGRzIHtNYXRyaXh8QXJyYXk8QXJyYXk+fSAtIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgICogZ2VuZXJhdG9yKGl0ZXJhdGlvbnM9NTAwKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnByb2plY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwZXJmb3JtcyBhIG9wdGltaXphdGlvbiBzdGVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSArK3RoaXMuX2l0ZXI7XG4gICAgICAgIGNvbnN0IFAgPSB0aGlzLl9QO1xuICAgICAgICBjb25zdCB5c3RlcCA9IHRoaXMuX3lzdGVwO1xuICAgICAgICBjb25zdCBnYWlucyA9IHRoaXMuX2dhaW5zO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuX2Vwc2lsb247XG4gICAgICAgIGNvbnN0IGRpbSA9IHRoaXMuX2Q7XG4gICAgICAgIGxldCBZID0gdGhpcy5ZO1xuXG4gICAgICAgIC8vY2FsYyBjb3N0IGdyYWRpZW50O1xuICAgICAgICBjb25zdCBwbXVsID0gaXRlciA8IDEwMCA/IDQgOiAxO1xuICAgICAgICBcbiAgICAgICAgLy8gY29tcHV0ZSBRIGRpc3QgKHVubm9ybWFsaXplZClcbiAgICAgICAgY29uc3QgUXUgPSBuZXcgTWF0cml4KE4sIE4sIFwiemVyb3NcIilcbiAgICAgICAgbGV0IHFzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGhlcmUgPSBZLmVudHJ5KGksIGQpIC0gWS5lbnRyeShqLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgZHN1bSArPSBkaGVyZSAqIGRoZXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBxdSA9IDEgLyAoMSArIGRzdW0pO1xuICAgICAgICAgICAgICAgIFF1LnNldF9lbnRyeShpLCBqLCBxdSk7XG4gICAgICAgICAgICAgICAgUXUuc2V0X2VudHJ5KGosIGksIHF1KTtcbiAgICAgICAgICAgICAgICBxc3VtICs9IDIgKiBxdTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBRIGRpc3RcbiAgICAgICAgY29uc3QgUSA9IG5ldyBNYXRyaXgoTiwgTiwgMClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IE1hdGgubWF4KFF1LmVudHJ5KGksIGopIC8gcXN1bSwgMWUtMTAwKTtcbiAgICAgICAgICAgICAgICBRLnNldF9lbnRyeShpLCBqLCB2YWwpO1xuICAgICAgICAgICAgICAgIFEuc2V0X2VudHJ5KGosIGksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBncmFkID0gbmV3IE1hdHJpeChOLCBkaW0sIFwiemVyb3NcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZW11bHQgPSA0ICogKHBtdWwgKiBQLmVudHJ5KGksIGopIC0gUS5lbnRyeShpLCBqKSkgKiBRdS5lbnRyeShpLCBqKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWQuc2V0X2VudHJ5KGksIGQsIGdyYWQuZW50cnkoaSwgZCkgKyBwcmVtdWx0ICogKFkuZW50cnkoaSwgZCkgLSBZLmVudHJ5KGosIGQpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVyZm9ybSBncmFkaWVudCBzdGVwXG4gICAgICAgIGxldCB5bWVhbiA9IG5ldyBGbG9hdDY0QXJyYXkoZGltKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnaWQgPSBncmFkLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZCA9IHlzdGVwLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhaW5pZCA9IGdhaW5zLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBuZXdnYWluID0gTWF0aC5zaWduKGdpZCkgPT09IE1hdGguc2lnbihzaWQpID8gZ2FpbmlkICogLjggOiBnYWluaWQgKyAuMjtcbiAgICAgICAgICAgICAgICBpZiAobmV3Z2FpbiA8IC4wMSkgbmV3Z2FpbiA9IC4wMTtcbiAgICAgICAgICAgICAgICBnYWlucy5zZXRfZW50cnkoaSwgZCwgbmV3Z2Fpbik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtb212YWwgPSBpdGVyIDwgMjUwID8gLjUgOiAuODtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdzaWQgPSBtb212YWwgKiBzaWQgLSBlcHNpbG9uICogbmV3Z2FpbiAqIGdpZDtcbiAgICAgICAgICAgICAgICB5c3RlcC5zZXRfZW50cnkoaSwgZCwgbmV3c2lkKTtcblxuICAgICAgICAgICAgICAgIFkuc2V0X2VudHJ5KGksIGQsIFkuZW50cnkoaSwgZCkgKyBuZXdzaWQpO1xuICAgICAgICAgICAgICAgIHltZWFuW2RdICs9IFkuZW50cnkoaSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCAyOyArK2QpIHtcbiAgICAgICAgICAgICAgICBZLnNldF9lbnRyeShpLCBkLCBZLmVudHJ5KGksIGQpIC0geW1lYW5bZF0gLyBOKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuWTtcbiAgICB9XG59ICIsIi8qKlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6b3B0aW1pemF0aW9uXG4gKiBAYWxpYXMgcG93ZWxsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0ge0FycmF5fSB4MFxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhfaXRlciA9IDMwMF1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBzZWUgaHR0cDovL29wdGltaXphdGlvbi1qcy5naXRodWIuaW8vb3B0aW1pemF0aW9uLWpzL29wdGltaXphdGlvbi5qcy5odG1sI2xpbmU0MzhcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGYsIHgwLCBtYXhfaXRlciA9IDMwMCkge1xuICAgIGNvbnN0IGVwc2lsb24gPSAxZS0yO1xuICAgIGNvbnN0IG4gPSB4MC5sZW5ndGg7XG4gICAgbGV0IGFscGhhID0gMWUtMztcbiAgICBsZXQgcGZ4ID0gMTAwMDA7XG4gICAgbGV0IHggPSB4MC5zbGljZSgpO1xuICAgIGxldCBmeCA9IGYoeCk7XG4gICAgbGV0IGNvbnZlcmdlbmNlID0gZmFsc2U7XG5cbiAgICB3aGlsZSAobWF4X2l0ZXItLSA+PSAwICYmICFjb252ZXJnZW5jZSkge1xuICAgICAgICBjb252ZXJnZW5jZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB4W2ldICs9IDFlLTY7XG4gICAgICAgICAgICBsZXQgZnhpID0gZih4KTtcbiAgICAgICAgICAgIHhbaV0gLT0gMWUtNjtcbiAgICAgICAgICAgIGxldCBkeCA9IChmeGkgLSBmeCkgLyAxZS02O1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGR4KSA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICBjb252ZXJnZW5jZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeFtpXSAtPSBhbHBoYSAqIGR4O1xuICAgICAgICAgICAgZnggPSBmKHgpO1xuICAgICAgICB9XG4gICAgICAgIGFscGhhICo9IHBmeCA+PSBmeCA/IDEuMDUgOiAwLjQ7XG4gICAgICAgIHBmeCA9IGZ4O1xuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiwgZXVjbGlkZWFuX3NxdWFyZWQgfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQmFsbFRyZWUgfSBmcm9tIFwiLi4va25uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcbmltcG9ydCB7IGxpbnNwYWNlIH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcG93ZWxsIH0gZnJvbSBcIi4uL29wdGltaXphdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuaW1wb3J0IHsgbWF4IH0gZnJvbSBcIi4uL3V0aWwvaW5kZXguanNcIjtcbmltcG9ydCB7IEtOTiB9IGZyb20gXCIuLi9rbm4vaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBVTUFQXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgVU1BUCBleHRlbmRzIERSIHtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIFVNQVBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbl9uZWlnaGJvcnMgPSAxNV0gLSBzaXplIG9mIHRoZSBsb2NhbCBuZWlnaGJvcmhvb2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsb2NhbF9jb25uZWN0aXZpdHkgPSAxXSAtIG51bWJlciBvZiBuZWFyZXN0IG5laWdoYm9ycyBjb25uZWN0ZWQgaW4gdGhlIGxvY2FsIG5laWdoYm9yaG9vZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW21pbl9kaXN0ID0gMV0gLSBjb250cm9scyBob3cgdGlnaHRseSBwb2ludHMgZ2V0IHBhY2tlZCB0b2dldGhlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2QgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzIGluIHRoZSBoaWdoLWRpbWVuc2lvbmFsIHNwYWNlLiAgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWVkID0gMTIxMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHJldHVybnMge1VNQVB9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgbl9uZWlnaGJvcnM9MTUsIGxvY2FsX2Nvbm5lY3Rpdml0eT0xLCBtaW5fZGlzdD0xLCBkPTIsIG1ldHJpYz1ldWNsaWRlYW4sIHNlZWQ9MTIxMikge1xuICAgICAgICBzdXBlcihYLCBkLCBtZXRyaWMsIHNlZWQpXG4gICAgICAgIHN1cGVyLnBhcmFtZXRlcl9saXN0ID0gW1wibl9uZWlnaGJvcnNcIiwgXCJsb2NhbF9jb25uZWN0aXZpdHlcIiwgXCJtaW5fZGlzdFwiXTtcbiAgICAgICAgWyB0aGlzLl9OLCB0aGlzLl9EIF0gPSB0aGlzLlguc2hhcGU7XG4gICAgICAgIG5fbmVpZ2hib3JzID0gTWF0aC5taW4odGhpcy5fTiAtIDEsIG5fbmVpZ2hib3JzKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJuX25laWdoYm9yc1wiLCBuX25laWdoYm9ycyk7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyKFwibG9jYWxfY29ubmVjdGl2aXR5XCIsIE1hdGgubWluKGxvY2FsX2Nvbm5lY3Rpdml0eSwgbl9uZWlnaGJvcnMgLSAxKSk7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyKFwibWluX2Rpc3RcIiwgbWluX2Rpc3QpO1xuICAgICAgICB0aGlzLl9pdGVyID0gMDtcbiAgICAgICAgdGhpcy5fc3ByZWFkID0gMTtcbiAgICAgICAgdGhpcy5fc2V0X29wX21peF9yYXRpbyA9IDE7XG4gICAgICAgIHRoaXMuX3JlcHVsc2lvbl9zdHJlbmd0aCA9IDE7XG4gICAgICAgIHRoaXMuX25lZ2F0aXZlX3NhbXBsZV9yYXRlID0gNTtcbiAgICAgICAgdGhpcy5fbl9lcG9jaHMgPSAzNTA7XG4gICAgICAgIHRoaXMuX2luaXRpYWxfYWxwaGEgPSAxO1xuICAgICAgICB0aGlzLlkgPSBuZXcgTWF0cml4KHRoaXMuX04sIHRoaXMuX2QsICgpID0+IHRoaXMuX3JhbmRvbWl6ZXIucmFuZG9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3ByZWFkIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5fZGlzdCBcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgX2ZpbmRfYWJfcGFyYW1zKHNwcmVhZCwgbWluX2Rpc3QpIHtcbiAgICAgICAgY29uc3QgY3VydmUgPSAoeCwgYSwgYikgPT4gMSAvICgxICsgYSAqIE1hdGgucG93KHgsIDIgKiBiKSk7XG4gICAgICAgIGNvbnN0IHh2ID0gbGluc3BhY2UoMCwgc3ByZWFkICogMywgMzAwKTtcbiAgICAgICAgY29uc3QgeXYgPSBsaW5zcGFjZSgwLCBzcHJlYWQgKiAzLCAzMDApO1xuICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB4di5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHh2X2kgPSB4dltpXTtcbiAgICAgICAgICAgIHl2W2ldID0gKHh2X2kgPCBtaW5fZGlzdCA/IDEgOiBNYXRoLmV4cCgtKHh2X2kgLSBtaW5fZGlzdCkgLyBzcHJlYWQpKTtcbiAgICAgICAgfVxuICAgICAgXG4gICAgICAgIGNvbnN0IGVyciA9IChwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGxpbnNwYWNlKDEsIDMwMCkubWFwKChfLCBpKSA9PiB5dltpXSAtIGN1cnZlKHh2W2ldLCBwWzBdLCBwWzFdKSk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KG5ldW1haXJfc3VtKGVycm9yLm1hcChlID0+IGUgKiBlKSkpO1xuICAgICAgICB9XG4gICAgICBcbiAgICAgICAgcmV0dXJuIHBvd2VsbChlcnIsIFsxLCAxXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gZGlzdGFuY2VzIFxuICAgICAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gc2lnbWFzIFxuICAgICAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gcmhvcyBcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgX2NvbXB1dGVfbWVtYmVyc2hpcF9zdHJlbmd0aHMoZGlzdGFuY2VzLCBzaWdtYXMsIHJob3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBkaXN0YW5jZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbSA9IGRpc3RhbmNlc1tpXS5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gZGlzdGFuY2VzW2ldW2pdLnZhbHVlIC0gcmhvc1tpXTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXNbaV1bal0udmFsdWUgPSB2ID4gMCA/IE1hdGguZXhwKC12IC8gc2lnbWFzW2ldKSA6IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7S05OfEJhbGxUcmVlfSBrbm4gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGsgXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBfc21vb3RoX2tubl9kaXN0KGtubiwgaykge1xuICAgICAgICBjb25zdCBTTU9PVEhfS19UT0xFUkFOQ0UgPSAxZS01O1xuICAgICAgICBjb25zdCBNSU5fS19ESVNUX1NDQUxFID0gMWUtMztcbiAgICAgICAgY29uc3Qgbl9pdGVyID0gNjQ7XG4gICAgICAgIGNvbnN0IGxvY2FsX2Nvbm5lY3Rpdml0eSA9IHRoaXMuX2xvY2FsX2Nvbm5lY3Rpdml0eTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gTWF0aC5sb2cyKGspO1xuICAgICAgICBjb25zdCByaG9zID0gW107XG4gICAgICAgIGNvbnN0IHNpZ21hcyA9IFtdO1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgLy9jb25zdCBkaXN0YW5jZXMgPSBbLi4uWF0ubWFwKHhfaSA9PiBrbm4uc2VhcmNoKHhfaSwgaykucmF3X2RhdGEoKS5yZXZlcnNlKCkpO1xuXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5fbWV0cmljID09PSBcInByZWNvbXB1dGVkXCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzLnB1c2goa25uLnNlYXJjaChpLCBrKS5yZXZlcnNlKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGZvciAoY29uc3QgeF9pIG9mIFgpIHtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXMucHVzaChrbm4uc2VhcmNoKHhfaSwgaykucmF3X2RhdGEoKS5yZXZlcnNlKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgbGV0IGxvID0gMDtcbiAgICAgICAgICAgIGxldCBoaSA9IEluZmluaXR5O1xuICAgICAgICAgICAgbGV0IG1pZCA9IDE7XG5cbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaF9yZXN1bHQgPSBkaXN0YW5jZXNbaV1cbiAgICAgICAgICAgIGNvbnN0IG5vbl96ZXJvX2Rpc3QgPSBzZWFyY2hfcmVzdWx0LmZpbHRlcihkID0+IGQudmFsdWUgPiAwKTtcbiAgICAgICAgICAgIGNvbnN0IG5vbl96ZXJvX2Rpc3RfbGVuZ3RoID0gbm9uX3plcm9fZGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobm9uX3plcm9fZGlzdF9sZW5ndGggPj0gbG9jYWxfY29ubmVjdGl2aXR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKGxvY2FsX2Nvbm5lY3Rpdml0eSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IGxvY2FsX2Nvbm5lY3Rpdml0eSAtIGluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmhvcy5wdXNoKG5vbl96ZXJvX2Rpc3RbaW5kZXggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uID4gU01PT1RIX0tfVE9MRVJBTkNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaG9zW2ldLnZhbHVlICs9IGludGVycG9sYXRpb24gKiAobm9uX3plcm9fZGlzdFtpbmRleF0udmFsdWUgLSBub25femVyb19kaXN0W2luZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmhvc1tpXS52YWx1ZSA9IGludGVycG9sYXRpb24gKiBub25femVyb19kaXN0WzBdLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9uX3plcm9fZGlzdF9sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmhvc1tpXSA9IG5vbl96ZXJvX2Rpc3Rbbm9uX3plcm9fZGlzdF9sZW5ndGggLSAxXS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbl9pdGVyOyArK3gpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZCA9IHNlYXJjaF9yZXN1bHRbal0udmFsdWUgLSByaG9zW2ldO1xuICAgICAgICAgICAgICAgICAgICBwc3VtICs9IChkID4gMCA/IE1hdGguZXhwKC0oZCAvIG1pZCkpIDogMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhwc3VtIC0gdGFyZ2V0KSA8IFNNT09USF9LX1RPTEVSQU5DRSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBzdW0gPiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgW2hpLCBtaWRdID0gW21pZCwgKGxvICsgaGkpIC8gMl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2xvLCBtaWRdID0gW21pZCwgbWlkICogMl07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbbG8sIG1pZF0gPSBbbWlkLCAobG8gKyBoaSkgLyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpZ21hc1tpXSA9IG1pZDtcblxuICAgICAgICAgICAgY29uc3QgbWVhbl9pdGhkID0gc2VhcmNoX3Jlc3VsdC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLnZhbHVlLCAwKSAvIHNlYXJjaF9yZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgLy9sZXQgbWVhbl9kID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyaG9zW2ldID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzaWdtYXNbaV0gPCBNSU5fS19ESVNUX1NDQUxFICogbWVhbl9pdGhkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ21hc1tpXSA9IE1JTl9LX0RJU1RfU0NBTEUgKiBtZWFuX2l0aGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZWFuX2QgPSBkaXN0YW5jZXMucmVkdWNlKChhY2MsIHJlcykgPT4gYWNjICsgcmVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIudmFsdWUsIDApIC8gcmVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ21hc1tpXSA+IE1JTl9LX0RJU1RfU0NBTEUgKiBtZWFuX2QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbWFzW2ldID0gTUlOX0tfRElTVF9TQ0FMRSAqIG1lYW5fZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwiZGlzdGFuY2VzXCI6IGRpc3RhbmNlcywgXG4gICAgICAgICAgICBcInNpZ21hc1wiOiBzaWdtYXMsIFxuICAgICAgICAgICAgXCJyaG9zXCI6IHJob3NcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5fbmVpZ2hib3JzIFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgX2Z1enp5X3NpbXBsaWNpYWxfc2V0KFgsIG5fbmVpZ2hib3JzKSB7XG4gICAgICAgIGNvbnN0IE4gPSBYLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IGtubiA9IG1ldHJpYyA9PT0gXCJwcmVjb21wdXRlZFwiID8gbmV3IEtOTihYLCBcInByZWNvbXB1dGVkXCIpIDogbmV3IEJhbGxUcmVlKFgudG8yZEFycmF5LCBtZXRyaWMpO1xuICAgICAgICBsZXQgeyBkaXN0YW5jZXMsIHNpZ21hcywgcmhvcyB9ID0gdGhpcy5fc21vb3RoX2tubl9kaXN0KGtubiwgbl9uZWlnaGJvcnMpO1xuICAgICAgICBkaXN0YW5jZXMgPSB0aGlzLl9jb21wdXRlX21lbWJlcnNoaXBfc3RyZW5ndGhzKGRpc3RhbmNlcywgc2lnbWFzLCByaG9zKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeChOLCBOLCBcInplcm9zXCIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VzX2kgPSBkaXN0YW5jZXNbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRpc3RhbmNlc19pLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldF9lbnRyeShpLCBkaXN0YW5jZXNfaVtqXS5lbGVtZW50LmluZGV4LCBkaXN0YW5jZXNfaVtqXS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNwb3NlZF9yZXN1bHQgPSByZXN1bHQuVDtcbiAgICAgICAgY29uc3QgcHJvZF9tYXRyaXggPSByZXN1bHQubXVsdCh0cmFuc3Bvc2VkX3Jlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIC5hZGQodHJhbnNwb3NlZF9yZXN1bHQpXG4gICAgICAgICAgICAuc3ViKHByb2RfbWF0cml4KVxuICAgICAgICAgICAgLm11bHQodGhpcy5fc2V0X29wX21peF9yYXRpbylcbiAgICAgICAgICAgIC5hZGQocHJvZF9tYXRyaXgubXVsdCgxIC0gdGhpcy5fc2V0X29wX21peF9yYXRpbykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5fZXBvY2hzIFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBfbWFrZV9lcG9jaHNfcGVyX3NhbXBsZShuX2Vwb2Nocykge1xuICAgICAgICBjb25zdCB3ZWlnaHRzID0gdGhpcy5fd2VpZ2h0cztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSh3ZWlnaHRzLmxlbmd0aCkuZmlsbCgtMSk7XG4gICAgICAgIGNvbnN0IHdlaWdodHNfbWF4ID0gbWF4KHdlaWdodHMpO1xuICAgICAgICBjb25zdCBuX3NhbXBsZXMgPSB3ZWlnaHRzLm1hcCh3ID0+IG5fZXBvY2hzICogKHcgLyB3ZWlnaHRzX21heCkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkgXG4gICAgICAgICAgaWYgKG5fc2FtcGxlc1tpXSA+IDApIHJlc3VsdFtpXSA9IE1hdGgucm91bmQobl9lcG9jaHMgLyBuX3NhbXBsZXNbaV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGdyYXBoIFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgX3RvY29vKGdyYXBoKSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICAgICAgY29uc3QgY29scyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGNvbnN0IFsgcm93c19uLCBjb2xzX24gXSA9IGdyYXBoLnNoYXBlO1xuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzX247ICsrcm93KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzX247ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBncmFwaC5lbnRyeShyb3csIGNvbCk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgICAgICBjb2xzLnB1c2goY29sKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwicm93c1wiOiByb3dzLCBcbiAgICAgICAgICAgIFwiY29sc1wiOiBjb2xzLCBcbiAgICAgICAgICAgIFwiZGF0YVwiOiBkYXRhXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYWxsIG5lY2Vzc2FyeSBcbiAgICAgKiBAcmV0dXJucyB7VU1BUH1cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBbIGEsIGIgXSA9IHRoaXMuX2ZpbmRfYWJfcGFyYW1zKHRoaXMuX3NwcmVhZCwgdGhpcy5fbWluX2Rpc3QpO1xuICAgICAgICB0aGlzLl9hID0gYTtcbiAgICAgICAgdGhpcy5fYiA9IGI7XG4gICAgICAgIHRoaXMuX2dyYXBoID0gdGhpcy5fZnV6enlfc2ltcGxpY2lhbF9zZXQodGhpcy5YLCB0aGlzLl9uX25laWdoYm9ycyk7XG4gICAgICAgIGNvbnN0IHsgcm93cywgY29scywgZGF0YTogd2VpZ2h0cyB9ID0gdGhpcy5fdG9jb28odGhpcy5fZ3JhcGgpO1xuICAgICAgICB0aGlzLl9oZWFkID0gcm93cztcbiAgICAgICAgdGhpcy5fdGFpbCA9IGNvbHM7XG4gICAgICAgIHRoaXMuX3dlaWdodHMgPSB3ZWlnaHRzO1xuICAgICAgICB0aGlzLl9lcG9jaHNfcGVyX3NhbXBsZSA9IHRoaXMuX21ha2VfZXBvY2hzX3Blcl9zYW1wbGUodGhpcy5fbl9lcG9jaHMpO1xuICAgICAgICB0aGlzLl9lcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZSA9IHRoaXMuX2Vwb2Noc19wZXJfc2FtcGxlLm1hcChkID0+IGQgKiB0aGlzLl9uZWdhdGl2ZV9zYW1wbGVfcmF0ZSk7XG4gICAgICAgIHRoaXMuX2Vwb2NoX29mX25leHRfc2FtcGxlID0gdGhpcy5fZXBvY2hzX3Blcl9zYW1wbGUuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5fZXBvY2hfb2ZfbmV4dF9uZWdhdGl2ZV9zYW1wbGUgPSB0aGlzLl9lcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXQgbG9jYWxfY29ubmVjdGl2aXR5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsX2Nvbm5lY3Rpdml0eSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBsb2NhbF9jb25uZWN0aXZpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbF9jb25uZWN0aXZpdHk7XG4gICAgfVxuXG4gICAgc2V0IG1pbl9kaXN0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX21pbl9kaXN0ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IG1pbl9kaXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluX2Rpc3Q7XG4gICAgfVxuXG4gICAgZ3JhcGgoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICByZXR1cm4geyBjb2xzOiB0aGlzLl9oZWFkLCByb3dzOiB0aGlzLl90YWlsLCB3ZWlnaHRzOiB0aGlzLl93ZWlnaHRzIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpdGVyYXRpb25zPTM1MF0gLSBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fEFycmF5fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybShpdGVyYXRpb25zPTM1MCkge1xuICAgICAgICBpZiAodGhpcy5fbl9lcG9jaHMgIT0gaXRlcmF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fbl9lcG9jaHMgPSBpdGVyYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpdGVyYXRpb25zPTM1MF0gLSBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fEFycmF5fVxuICAgICAqL1xuICAgICogZ2VuZXJhdG9yKGl0ZXJhdGlvbnM9MzUwKSB7XG4gICAgICAgIGlmICh0aGlzLl9uX2Vwb2NocyAhPSBpdGVyYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9uX2Vwb2NocyA9IGl0ZXJhdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIF9jbGlwKHgpIHtcbiAgICAgICAgaWYgKHggPiA0KSByZXR1cm4gNDtcbiAgICAgICAgaWYgKHggPCAtNCkgcmV0dXJuIC00O1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwZXJmb3JtcyB0aGUgb3B0aW1pemF0aW9uIHN0ZXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gaGVhZF9lbWJlZGRpbmcgXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IHRhaWxfZW1iZWRkaW5nIFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBoZWFkIFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSB0YWlsIFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgX29wdGltaXplX2xheW91dChoZWFkX2VtYmVkZGluZywgdGFpbF9lbWJlZGRpbmcsIGhlYWQsIHRhaWwpIHtcbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIF9kOiBkaW0sIFxuICAgICAgICAgICAgX2FscGhhOiBhbHBoYSwgXG4gICAgICAgICAgICBfcmVwdWxzaW9uX3N0cmVuZ3RoOiByZXB1bHNpb25fc3RyZW5ndGgsIFxuICAgICAgICAgICAgX2E6IGEsIFxuICAgICAgICAgICAgX2I6IGIsXG4gICAgICAgICAgICBfZXBvY2hzX3Blcl9zYW1wbGU6IGVwb2Noc19wZXJfc2FtcGxlLFxuICAgICAgICAgICAgX2Vwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlOiBlcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZSxcbiAgICAgICAgICAgIF9lcG9jaF9vZl9uZXh0X25lZ2F0aXZlX3NhbXBsZTogZXBvY2hfb2ZfbmV4dF9uZWdhdGl2ZV9zYW1wbGUsXG4gICAgICAgICAgICBfZXBvY2hfb2ZfbmV4dF9zYW1wbGU6IGVwb2NoX29mX25leHRfc2FtcGxlLFxuICAgICAgICAgICAgX2NsaXA6IGNsaXBcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRhaWxfbGVuZ3RoID0gdGFpbC5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBlcG9jaHNfcGVyX3NhbXBsZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChlcG9jaF9vZl9uZXh0X3NhbXBsZVtpXSA8PSB0aGlzLl9pdGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaiA9IGhlYWRbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgayA9IHRhaWxbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGhlYWRfZW1iZWRkaW5nLnJvdyhqKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlciA9IHRhaWxfZW1iZWRkaW5nLnJvdyhrKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gZXVjbGlkZWFuX3NxdWFyZWQoY3VycmVudCwgb3RoZXIpO1xuICAgICAgICAgICAgICAgIGxldCBncmFkX2NvZWZmID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZF9jb2VmZiA9ICgtMiAqIGEgKiBiICogTWF0aC5wb3coZGlzdCwgYiAtIDEpKSAvIChhICogTWF0aC5wb3coZGlzdCwgYikgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBncmFkX2QgPSBjbGlwKGdyYWRfY29lZmYgKiAoY3VycmVudFtkXSAtIG90aGVyW2RdKSkgKiBhbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGN1cnJlbnRbZF0gKyBncmFkX2Q7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBvdGhlcltkXSAtIGdyYWRfZDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFtkXSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyW2RdID0gbztcbiAgICAgICAgICAgICAgICAgICAgaGVhZF9lbWJlZGRpbmcuc2V0X2VudHJ5KGosIGQsIGMpO1xuICAgICAgICAgICAgICAgICAgICB0YWlsX2VtYmVkZGluZy5zZXRfZW50cnkoaywgZCwgbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVwb2NoX29mX25leHRfc2FtcGxlW2ldICs9IGVwb2Noc19wZXJfc2FtcGxlW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5fbmVnX3NhbXBsZXMgPSAodGhpcy5faXRlciAtIGVwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlW2ldKSAvIGVwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbl9uZWdfc2FtcGxlczsgKytwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGsgPSBNYXRoLmZsb29yKHRoaXMuX3JhbmRvbWl6ZXIucmFuZG9tICogdGFpbF9sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlciA9IHRhaWxfZW1iZWRkaW5nLnJvdyh0YWlsW2tdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IGV1Y2xpZGVhbl9zcXVhcmVkKGN1cnJlbnQsIG90aGVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGdyYWRfY29lZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRfY29lZmYgPSAoMiAqIHJlcHVsc2lvbl9zdHJlbmd0aCAqIGIpIC8gKCguMDEgKyBkaXN0KSAqIChhICogTWF0aC5wb3coZGlzdCwgYikgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaiA9PT0gaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3JhZF9kID0gY2xpcChncmFkX2NvZWZmICogKGN1cnJlbnRbZF0gLSBvdGhlcltkXSkpICogYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gY3VycmVudFtkXSArIGdyYWRfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBvdGhlcltkXSAtIGdyYWRfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRbZF0gPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJbZF0gPSBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZF9lbWJlZGRpbmcuc2V0X2VudHJ5KGosIGQsIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFpbF9lbWJlZGRpbmcuc2V0X2VudHJ5KHRhaWxba10sIGQsIG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlW2ldICs9IChuX25lZ19zYW1wbGVzICogZXBvY2hzX3Blcl9uZWdhdGl2ZV9zYW1wbGVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkX2VtYmVkZGluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IGl0ZXIgPSArK3RoaXMuX2l0ZXI7XG4gICAgICAgIGxldCBZID0gdGhpcy5ZO1xuXG4gICAgICAgIHRoaXMuX2FscGhhID0gKHRoaXMuX2luaXRpYWxfYWxwaGEgKiAoMSAtIGl0ZXIgLyB0aGlzLl9uX2Vwb2NocykpO1xuICAgICAgICB0aGlzLlkgPSB0aGlzLl9vcHRpbWl6ZV9sYXlvdXQoWSwgWSwgdGhpcy5faGVhZCwgdGhpcy5fdGFpbCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuWTtcbiAgICB9XG59ICIsImltcG9ydCB7IE1hdHJpeCwgbGluc3BhY2UgfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUENBIH0gZnJvbSBcIi4vUENBLmpzXCI7XG5pbXBvcnQgeyBCYWxsVHJlZSB9IGZyb20gXCIuLi9rbm4vaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBUcmlNYXBcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmlNYXAgZXh0ZW5kcyBEUntcbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBUcmlNYXBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbd2VpZ2h0X2FkaiA9IDUwMF0gLSBzY2FsaW5nIGZhY3Rvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2MgPSA1XSAtIG51bWJlciBvZiB0cmlwbGV0cyBtdWx0aXBsaWVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuICBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7VHJpTWFwfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXJ4aXYub3JnL3BkZi8xOTEwLjAwMjA0djEucGRmfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lYW1pZC90cmltYXB9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgd2VpZ2h0X2FkaiA9IDUwMCwgYyA9IDUsIGQgPSAyLCBtZXRyaWMgPSBldWNsaWRlYW4sIHNlZWQ9MTIxMikge1xuICAgICAgICBzdXBlcihYLCBkLCBtZXRyaWMsIHNlZWQpO1xuICAgICAgICBzdXBlci5wYXJhbWV0ZXJfbGlzdCA9IFtcIndlaWdodF9hZGpcIiwgXCJjXCJdO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcIndlaWdodF9hZGpcIiwgd2VpZ2h0X2Fkaik7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyKFwiY1wiLCBjKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gW3BjYSA9IG51bGxdIC0gSW5pdGlhbCBFbWJlZGRpbmcgKGlmIG51bGwgdGhlbiBQQ0EgZ2V0cyB1c2VkKS4gXG4gICAgICogQHBhcmFtIHtLTk59IFtrbm4gPSBudWxsXSAtIEtOTiBPYmplY3QgKGlmIG51bGwgdGhlbiBCYWxsVHJlZSBnZXRzIHVzZWQpLiBcbiAgICAgKi9cbiAgICBpbml0KHBjYSA9IG51bGwsIGtubiA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgTiA9IFguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLl9kO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLl9jO1xuICAgICAgICB0aGlzLm5faW5saWVycyA9IDIgKiBjO1xuICAgICAgICB0aGlzLm5fb3V0bGllcnMgPSAxICogYztcbiAgICAgICAgdGhpcy5uX3JhbmRvbSA9IDEgKiBjO1xuICAgICAgICB0aGlzLlkgPSBwY2EgfHwgbmV3IFBDQShYLCBkKS50cmFuc2Zvcm0oKS8vLm11bHQoLjAxKTtcbiAgICAgICAgdGhpcy5rbm4gPSBrbm4gfHwgbmV3IEJhbGxUcmVlKFgudG8yZEFycmF5LCBtZXRyaWMpO1xuICAgICAgICBjb25zdCB7dHJpcGxldHMsIHdlaWdodHN9ID0gdGhpcy5fZ2VuZXJhdGVfdHJpcGxldHModGhpcy5uX2lubGllcnMsIHRoaXMubl9vdXRsaWVycywgdGhpcy5uX3JhbmRvbSk7XG4gICAgICAgIHRoaXMudHJpcGxldHMgPSB0cmlwbGV0cztcbiAgICAgICAgdGhpcy53ZWlnaHRzID0gd2VpZ2h0cztcbiAgICAgICAgdGhpcy5sciA9IDEwMDAgKiBOIC8gdHJpcGxldHMuc2hhcGVbMF07XG4gICAgICAgIHRoaXMuQyA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLnRvbCA9IDFlLTc7XG4gICAgICAgIHRoaXMudmVsID0gbmV3IE1hdHJpeChOLCBkLCAwKTtcbiAgICAgICAgdGhpcy5nYWluID0gbmV3IE1hdHJpeChOLCBkLCAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHtAbGluayBuX2lubGllcnN9IHgge0BsaW5rIG5fb3V0bGllcnN9IHgge0BsaW5rIG5fcmFuZG9tfSB0cmlwbGV0cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbl9pbmxpZXJzIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX291dGxpZXJzIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX3JhbmRvbSBcbiAgICAgKi9cbiAgICBfZ2VuZXJhdGVfdHJpcGxldHMobl9pbmxpZXJzLCBuX291dGxpZXJzLCBuX3JhbmRvbSkge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IHdlaWdodF9hZGogPSB0aGlzLl93ZWlnaHRfYWRqO1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3Qga25uID0gdGhpcy5rbm47XG4gICAgICAgIGNvbnN0IG5fZXh0cmEgPSBNYXRoLm1pbihuX2lubGllcnMgKyAyMCwgTik7XG4gICAgICAgIGNvbnN0IG5icnMgPSBuZXcgTWF0cml4KE4sIG5fZXh0cmEpO1xuICAgICAgICBjb25zdCBrbm5fZGlzdGFuY2VzID0gbmV3IE1hdHJpeChOLCBuX2V4dHJhKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGtubi5zZWFyY2goWC5yb3coaSksIG5fZXh0cmEgKyAxKVxuICAgICAgICAgICAgICAgIC5yYXdfZGF0YSgpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihkID0+IGQudmFsdWUgIT0gMClcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS52YWx1ZSAtIGIudmFsdWUpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGQsIGopID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbmJycy5zZXRfZW50cnkoaSwgaiwgZC5lbGVtZW50LmluZGV4KVxuICAgICAgICAgICAgICAgICAgICBrbm5fZGlzdGFuY2VzLnNldF9lbnRyeShpLCBqLCBkLnZhbHVlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNjYWxlIHBhcmFtZXRlclxuICAgICAgICBjb25zdCBzaWcgPSBuZXcgRmxvYXQ2NEFycmF5KE4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgc2lnW2ldID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgKGtubl9kaXN0YW5jZXMuZW50cnkoaSwgMykgK1xuICAgICAgICAgICAgICAgICAgICBrbm5fZGlzdGFuY2VzLmVudHJ5KGksIDQpICtcbiAgICAgICAgICAgICAgICAgICAga25uX2Rpc3RhbmNlcy5lbnRyeShpLCA1KSArXG4gICAgICAgICAgICAgICAgICAgIGtubl9kaXN0YW5jZXMuZW50cnkoaSwgNikpIC8gNCxcbiAgICAgICAgICAgICAgICAgICAgMWUtMTApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBQID0gdGhpcy5fZmluZF9wKGtubl9kaXN0YW5jZXMsIHNpZywgbmJycyk7XG4gICAgICAgIFxuICAgICAgICBsZXQgdHJpcGxldHMgPSB0aGlzLl9zYW1wbGVfa25uX3RyaXBsZXRzKFAsIG5icnMsIG5faW5saWVycywgbl9vdXRsaWVycyk7XG4gICAgICAgIGxldCBuX3RyaXBsZXRzID0gdHJpcGxldHMuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IG91dGxpZXJfZGlzdGFuY2VzID0gbmV3IEZsb2F0NjRBcnJheShuX3RyaXBsZXRzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuX3RyaXBsZXRzOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSB0cmlwbGV0cy5lbnRyeShpLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGsgPSB0cmlwbGV0cy5lbnRyeShpLCAyKTtcbiAgICAgICAgICAgIG91dGxpZXJfZGlzdGFuY2VzW2ldID0gbWV0cmljKFgucm93KGopLCBYLnJvdyhrKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdlaWdodHMgPSB0aGlzLl9maW5kX3dlaWdodHModHJpcGxldHMsIFAsIG5icnMsIG91dGxpZXJfZGlzdGFuY2VzLCBzaWcpO1xuICAgICAgICBcbiAgICAgICAgaWYgKG5fcmFuZG9tID4gMCkge1xuICAgICAgICAgICAgY29uc3Qge3JhbmRvbV90cmlwbGV0cywgcmFuZG9tX3dlaWdodHN9ID0gdGhpcy5fc2FtcGxlX3JhbmRvbV90cmlwbGV0cyhYLCBuX3JhbmRvbSwgc2lnKTtcbiAgICAgICAgICAgIHRyaXBsZXRzID0gdHJpcGxldHMuY29uY2F0KHJhbmRvbV90cmlwbGV0cywgXCJ2ZXJ0aWNhbFwiKTtcbiAgICAgICAgICAgIHdlaWdodHMgPSBGbG9hdDY0QXJyYXkuZnJvbShbLi4ud2VpZ2h0cywgLi4ucmFuZG9tX3dlaWdodHNdKVxuICAgICAgICB9XG4gICAgICAgIG5fdHJpcGxldHMgPSB0cmlwbGV0cy5zaGFwZVswXTtcbiAgICAgICAgbGV0IG1heF93ZWlnaHQgPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbl90cmlwbGV0czsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4od2VpZ2h0c1tpXSkpIHt3ZWlnaHRzW2ldID0gMDt9XG4gICAgICAgICAgICBpZiAobWF4X3dlaWdodCA8IHdlaWdodHNbaV0pIG1heF93ZWlnaHQgPSB3ZWlnaHRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXhfd2VpZ2h0XzIgPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbl90cmlwbGV0czsgKytpKSB7XG4gICAgICAgICAgICB3ZWlnaHRzW2ldIC89IG1heF93ZWlnaHQ7XG4gICAgICAgICAgICB3ZWlnaHRzW2ldICs9IC4wMDAxO1xuICAgICAgICAgICAgd2VpZ2h0c1tpXSA9IE1hdGgubG9nKDEgKyB3ZWlnaHRfYWRqICogd2VpZ2h0c1tpXSk7XG4gICAgICAgICAgICBpZiAobWF4X3dlaWdodF8yIDwgd2VpZ2h0c1tpXSkgbWF4X3dlaWdodF8yID0gd2VpZ2h0c1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5fdHJpcGxldHM7ICsraSkge1xuICAgICAgICAgICAgd2VpZ2h0c1tpXSAvPSBtYXhfd2VpZ2h0XzI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwidHJpcGxldHNcIjogdHJpcGxldHMsXG4gICAgICAgICAgICBcIndlaWdodHNcIjogd2VpZ2h0cyxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNpbWlsYXJpdHkgbWF0cml4IFBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBrbm5fZGlzdGFuY2VzIC0gbWF0cml4IG9mIHBhaXJ3aXNlIGtubiBkaXN0YW5jZXNcbiAgICAgKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gc2lnIC0gc2NhbGluZyBmYWN0b3IgZm9yIHRoZSBkaXN0YW5jZXNcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbmJycyAtIG5lYXJlc3QgbmVpZ2hib3JzXG4gICAgICogQHJldHVybnMge01hdHJpeH0gcGFpcndpc2Ugc2ltaWxhcml0eSBtYXRyaXhcbiAgICAgKi9cbiAgICBfZmluZF9wKGtubl9kaXN0YW5jZXMsIHNpZywgbmJycykge1xuICAgICAgICBjb25zdCBbTiwgbl9uZWlnaGJvcnNdID0ga25uX2Rpc3RhbmNlcy5zaGFwZTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoTiwgbl9uZWlnaGJvcnMsIChpLCBqKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5leHAoLSgoa25uX2Rpc3RhbmNlcy5lbnRyeShpLCBqKSAqKiAyKSAvIHNpZ1tpXSAvIHNpZ1tuYnJzLmVudHJ5KGksIGopXSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYW1wbGUgbmVhcmVzdCBuZWlnaGJvcnMgdHJpcGxldHMgYmFzZWQgb24gdGhlIHNpbWlsYXJpdHkgdmFsdWVzIGdpdmVuIGluIFAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gUCAtIE1hdHJpeCBvZiBwYWlyd2lzZSBzaW1pbGFyaXRpZXMgYmV0d2VlbiBlYWNoIHBvaW50IGFuZCBpdHMgbmVpZ2hib3JzIGdpdmVuIGluIG1hdHJpeCBuYnJzLlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBuYnJzIC0gTmVhcmVzdCBuZWlnaGJvcnMgaW5kaWNlcyBmb3IgZWFjaCBwb2ludC4gVGhlIHNpbWlsYXJpdHkgdmFsdWVzIGFyZSBnaXZlbiBpbiBtYXRyaXgge0BsaW5rIFB9LiBSb3cgaSBjb3JyZXNwb25kcyB0byB0aGUgaS10aCBwb2ludC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbl9pbmxpZXJzIC0gTnVtYmVyIG9mIGlubGllciBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5fb3V0bGllcnMgLSBOdW1iZXIgb2Ygb3V0bGllciBwb2ludHMuXG4gICAgICogXG4gICAgICovXG4gICAgX3NhbXBsZV9rbm5fdHJpcGxldHMoUCwgbmJycywgbl9pbmxpZXJzLCBuX291dGxpZXJzKSB7XG4gICAgICAgIGNvbnN0IE4gPSBuYnJzLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCB0cmlwbGV0cyA9IG5ldyBNYXRyaXgoTiAqIG5faW5saWVycyAqIG5fb3V0bGllcnMsIDMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgbGV0IG5faSA9IGkgKiBuX2lubGllcnMgKiBuX291dGxpZXJzO1xuICAgICAgICAgICAgY29uc3Qgc29ydF9pbmRpY2VzID0gdGhpcy5fX2FyZ3NvcnQoUC5yb3coaSkubWFwKGQgPT4gLWQpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbl9pbmxpZXJzOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgbl9qID0gaiAqIG5fb3V0bGllcnM7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2ltID0gbmJycy5lbnRyeShpLCBzb3J0X2luZGljZXNbal0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhbXBsZXMgPSB0aGlzLl9yZWplY3Rpb25fc2FtcGxlKG5fb3V0bGllcnMsIE4sIHNvcnRfaW5kaWNlcy5zbGljZSgwLCBqICsgMSkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbl9vdXRsaWVyczsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbl9pICsgbl9qICsgaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gc2FtcGxlc1trXTtcbiAgICAgICAgICAgICAgICAgICAgdHJpcGxldHMuc2V0X2VudHJ5KGluZGV4LCAwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpcGxldHMuc2V0X2VudHJ5KGluZGV4LCAxLCBzaW0pO1xuICAgICAgICAgICAgICAgICAgICB0cmlwbGV0cy5zZXRfZW50cnkoaW5kZXgsIDIsIG91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmlwbGV0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgZG8gdGhlIHNhbWUgYXMgbnAuYXJnc29ydCgpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBBIFxuICAgICAqL1xuICAgIF9fYXJnc29ydChBKSB7XG4gICAgICAgIHJldHVybiBBXG4gICAgICAgICAgICAubWFwKChkLCBpKSA9PiB7cmV0dXJuIHtkOiBkLCBpOiBpfTt9KVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZCAtIGIuZClcbiAgICAgICAgICAgIC5tYXAoKGQpID0+IGQuaSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2FtcGxlcyB7QGxpbmsgbl9zYW1wbGVzfSBpbnRlZ2VycyBmcm9tIGEgZ2l2ZW4gaW50ZXJ2YWwgWzAsIHtAbGluayBtYXhfaW50fV0gd2hpbGUgcmVqZWN0aW9uIHRoZSB2YWx1ZXMgdGhhdCBhcmUgaW4gdGhlIHtAbGluayByZWplY3RzfS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gbl9zYW1wbGVzIFxuICAgICAqIEBwYXJhbSB7Kn0gbWF4X2ludCBcbiAgICAgKiBAcGFyYW0geyp9IHJlamVjdHMgXG4gICAgICovXG4gICAgX3JlamVjdGlvbl9zYW1wbGUobl9zYW1wbGVzLCBtYXhfaW50LCByZWplY3RzKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbWl6ZXIgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IGxpbnNwYWNlKDAsIG1heF9pbnQgLSAxKS5maWx0ZXIoZCA9PiByZWplY3RzLmluZGV4T2YoZCkgPCAwKTtcbiAgICAgICAgcmV0dXJuIHJhbmRvbWl6ZXIuY2hvaWNlKGludGVydmFsLCBNYXRoLm1pbihuX3NhbXBsZXMsIGludGVydmFsLmxlbmd0aCAtIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB3ZWlnaHRzIGZvciB0aGUgc2FtcGxlZCBuZWFyZXN0IG5laWdoYm9ycyB0cmlwbGV0c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IHRyaXBsZXRzIC0gU2FtcGxlZCBUcmlwbGV0cy5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gUCAtIFBhaXJ3aXNlIHNpbWlsYXJpdHkgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBuYnJzIC0gbmVhcmVzdCBOZWlnaGJvcnNcbiAgICAgKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gb3V0bGllcl9kaXN0YW5jZXMgLSBNYXRyaXggb2YgcGFpcndpc2Ugb3V0bGllciBkaXN0YW5jZXNcbiAgICAgKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gc2lnIC0gc2NhbGluZyBmYWN0b3IgZm9yIHRoZSBkaXN0YW5jZXMuXG4gICAgICovXG4gICAgX2ZpbmRfd2VpZ2h0cyh0cmlwbGV0cywgUCwgbmJycywgb3V0bGllcl9kaXN0YW5jZXMsIHNpZykge1xuICAgICAgICBjb25zdCBuX3RyaXBsZXRzID0gdHJpcGxldHMuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHdlaWdodHMgPSBuZXcgRmxvYXQ2NEFycmF5KG5fdHJpcGxldHMpO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IG5fdHJpcGxldHM7ICsrdCkge1xuICAgICAgICAgICAgY29uc3QgaSA9IHRyaXBsZXRzLmVudHJ5KHQsIDApO1xuICAgICAgICAgICAgY29uc3Qgc2ltID0gbmJycy5yb3coaSkuaW5kZXhPZih0cmlwbGV0cy5lbnRyeSh0LCAxKSk7XG4gICAgICAgICAgICBjb25zdCBwX3NpbSA9IFAuZW50cnkoaSwgc2ltKTtcbiAgICAgICAgICAgIGxldCBwX291dCA9IE1hdGguZXhwKC0ob3V0bGllcl9kaXN0YW5jZXNbdF0gKiogMiAvIChzaWdbaV0gKiBzaWdbdHJpcGxldHMuZW50cnkodCwgMildKSkpO1xuICAgICAgICAgICAgaWYgKHBfb3V0IDwgMWUtMjApIHBfb3V0ID0gMWUtMjA7XG4gICAgICAgICAgICB3ZWlnaHRzW3RdID0gcF9zaW0gLyBwX291dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2VpZ2h0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYW1wbGUgdW5pZm9ybWx5IHJhbm9tIHRyaXBsZXRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIERhdGEgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX3JhbmRvbSAtIE51bWJlciBvZiByYW5kb20gdHJpcGxldHMgcGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IHNpZyAtIFNjYWxpbmcgZmFjdG9yIGZvciB0aGUgZGlzdGFuY2VzXG4gICAgICovXG4gICAgX3NhbXBsZV9yYW5kb21fdHJpcGxldHMoWCwgbl9yYW5kb20sIHNpZykge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IHJhbmRvbWl6ZXIgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgcmFuZG9tX3RyaXBsZXRzID0gbmV3IE1hdHJpeChOICogbl9yYW5kb20sIDMpO1xuICAgICAgICBjb25zdCByYW5kb21fd2VpZ2h0cyA9IG5ldyBGbG9hdDY0QXJyYXkoTiAqIG5fcmFuZG9tKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG5faSA9IGkgKiBuX3JhbmRvbTtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBbLi4ubGluc3BhY2UoMCwgaSAtIDEpLCAuLi5saW5zcGFjZShpICsgMSwgTiAtIDEpXVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuX3JhbmRvbTsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IFtzaW0sIG91dF0gPSByYW5kb21pemVyLmNob2ljZShpbmRpY2VzLCAyKTtcbiAgICAgICAgICAgICAgICBsZXQgcF9zaW0gPSBNYXRoLmV4cCgtKChtZXRyaWMoWC5yb3coaSksIFgucm93KHNpbSkpICoqIDIpIC8gKHNpZ1tpXSAqIHNpZ1tzaW1dKSkpO1xuICAgICAgICAgICAgICAgIGlmIChwX3NpbSA8IDFlLTIwKSBwX3NpbSA9IDFlLTIwO1xuICAgICAgICAgICAgICAgIGxldCBwX291dCA9IE1hdGguZXhwKC0oKG1ldHJpYyhYLnJvdyhpKSwgWC5yb3cob3V0KSkgKiogMikgLyAoc2lnW2ldICogc2lnW291dF0pKSk7IFxuICAgICAgICAgICAgICAgIGlmIChwX291dCA8IDFlLTIwKSBwX291dCA9IDFlLTIwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBfc2ltIDwgcF9vdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgW3NpbSwgb3V0XSA9IFtvdXQsIHNpbV07XG4gICAgICAgICAgICAgICAgICAgIFtwX3NpbSwgcF9vdXRdID0gW3Bfb3V0LCBwX3NpbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbl9pICsgajtcbiAgICAgICAgICAgICAgICByYW5kb21fdHJpcGxldHMuc2V0X2VudHJ5KGluZGV4LCAwLCBpKTtcbiAgICAgICAgICAgICAgICByYW5kb21fdHJpcGxldHMuc2V0X2VudHJ5KGluZGV4LCAxLCBzaW0pO1xuICAgICAgICAgICAgICAgIHJhbmRvbV90cmlwbGV0cy5zZXRfZW50cnkoaW5kZXgsIDIsIG91dCk7XG4gICAgICAgICAgICAgICAgcmFuZG9tX3dlaWdodHNbaW5kZXhdID0gcF9zaW0gLyBwX291dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJyYW5kb21fdHJpcGxldHNcIjogcmFuZG9tX3RyaXBsZXRzLFxuICAgICAgICAgICAgXCJyYW5kb21fd2VpZ2h0c1wiOiByYW5kb21fd2VpZ2h0cyxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBncmFkaWVudCBmb3IgdXBkYXRpbmcgdGhlIGVtYmVkZGluZy5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWSAtIFRoZSBlbWJlZGRpbmdcbiAgICAgKi9cbiAgICBfZ3JhZChZKSB7XG4gICAgICAgIGNvbnN0IG5faW5saWVycyA9IHRoaXMubl9pbmxpZXJzO1xuICAgICAgICBjb25zdCBuX291dGxpZXJzID0gdGhpcy5uX291dGxpZXJzO1xuICAgICAgICBjb25zdCB0cmlwbGV0cyA9IHRoaXMudHJpcGxldHM7XG4gICAgICAgIGNvbnN0IHdlaWdodHMgPSB0aGlzLndlaWdodHM7XG4gICAgICAgIGNvbnN0IFtOLCBkaW1dID0gWS5zaGFwZTtcbiAgICAgICAgY29uc3Qgbl90cmlwbGV0cyA9IHRyaXBsZXRzLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBncmFkID0gbmV3IE1hdHJpeChOLCBkaW0sIDApO1xuICAgICAgICBsZXQgeV9paiA9IG5ldyBBcnJheShkaW0pLmZpbGwoMCk7XG4gICAgICAgIGxldCB5X2lrID0gbmV3IEFycmF5KGRpbSkuZmlsbCgwKTtcbiAgICAgICAgbGV0IGRfaWogPSAxO1xuICAgICAgICBsZXQgZF9payA9IDE7XG4gICAgICAgIGxldCBuX3Zpb2wgPSAwO1xuICAgICAgICBsZXQgbG9zcyA9IDA7XG4gICAgICAgIGNvbnN0IG5fa25uX3RyaXBsZXRzID0gTiAqIG5faW5saWVycyAqIG5fb3V0bGllcnM7XG5cbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBuX3RyaXBsZXRzOyArK3QpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpLCBqLCBrXSA9IHRyaXBsZXRzLnJvdyh0KTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB5X2lqLCB5X2lrLCBkX2lqLCBkX2lrXG4gICAgICAgICAgICBpZiAodCAlIG5fb3V0bGllcnMgPT0gMCB8fCB0ID49IG5fa25uX3RyaXBsZXRzKSB7XG4gICAgICAgICAgICAgICAgZF9paiA9IDFcbiAgICAgICAgICAgICAgICBkX2lrID0gMVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWV9pZCA9IFkuZW50cnkoaSwgZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFlfamQgPSBZLmVudHJ5KGosIGQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBZX2tkID0gWS5lbnRyeShrLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgeV9paltkXSA9IFlfaWQgLSBZX2pkO1xuICAgICAgICAgICAgICAgICAgICB5X2lrW2RdID0gWV9pZCAtIFlfa2Q7XG4gICAgICAgICAgICAgICAgICAgIGRfaWogKz0gKHlfaWpbZF0gKiogMik7XG4gICAgICAgICAgICAgICAgICAgIGRfaWsgKz0gKHlfaWtbZF0gKiogMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXBkYXRlIHlfaWsgYW5kIGRfaWsgb25seVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkX2lrID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFlfaWQgPSBZLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBZX2tkID0gWS5lbnRyeShrLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgeV9pa1tkXSA9IFlfaWQgLSBZX2tkO1xuICAgICAgICAgICAgICAgICAgICBkX2lrICs9ICh5X2lrW2RdICoqIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRfaWogPiBkX2lrKSArK25fdmlvbDtcbiAgICAgICAgICAgIGxvc3MgKz0gd2VpZ2h0c1t0XSAvICgxICsgZF9payAvIGRfaWopO1xuICAgICAgICAgICAgY29uc3QgdyA9ICh3ZWlnaHRzW3RdIC8gKGRfaWogKyBkX2lrKSkgKiogMjtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBncyA9IHlfaWpbZF0gKiBkX2lrICogdztcbiAgICAgICAgICAgICAgICBjb25zdCBnbyA9IHlfaWtbZF0gKiBkX2lqICogdztcbiAgICAgICAgICAgICAgICBncmFkLnNldF9lbnRyeShpLCBkLCBncmFkLmVudHJ5KGksIGQpICsgZ3MgLSBnbyk7XG4gICAgICAgICAgICAgICAgZ3JhZC5zZXRfZW50cnkoaiwgZCwgZ3JhZC5lbnRyeShqLCBkKSAtIGdzKTtcbiAgICAgICAgICAgICAgICBncmFkLnNldF9lbnRyeShrLCBkLCBncmFkLmVudHJ5KGssIGQpICsgZ28pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcImdyYWRcIjogZ3JhZCxcbiAgICAgICAgICAgIFwibG9zc1wiOiBsb3NzLFxuICAgICAgICAgICAgXCJuX3Zpb2xcIjogbl92aW9sLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhfaXRlcmF0aW9uIFxuICAgICAqL1xuICAgIHRyYW5zZm9ybShtYXhfaXRlcmF0aW9uID0gNDAwKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICBmb3IgKGxldCBpdGVyID0gMDsgaXRlciA8IG1heF9pdGVyYXRpb247ICsraXRlcikge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChpdGVyKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHlpZWxkcyB7TWF0cml4fVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICBmb3IgKGxldCBpdGVyID0gMDsgaXRlciA8IDgwMDsgKytpdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGl0ZXIpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgaXRlcmF0aW9uIHN0ZXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaXRlciBcbiAgICAgKi9cbiAgICBfbmV4dChpdGVyKSB7XG4gICAgICAgIGNvbnN0IGdhbW1hID0gaXRlciA+IDE1MCA/IC41IDogLjM7XG4gICAgICAgIGNvbnN0IG9sZF9DID0gdGhpcy5DO1xuICAgICAgICBjb25zdCB2ZWwgPSB0aGlzLnZlbDtcbiAgICAgICAgY29uc3QgWSA9IHRoaXMuWS5hZGQodmVsLm11bHQoZ2FtbWEpKTtcbiAgICAgICAgY29uc3Qge2dyYWQsIGxvc3MsIG5fdmlvbH0gPSB0aGlzLl9ncmFkKFkpO1xuICAgICAgICB0aGlzLkMgPSBsb3NzO1xuICAgICAgICB0aGlzLlkgPSB0aGlzLl91cGRhdGVfZW1iZWRkaW5nKFksIGl0ZXIsIGdyYWQpO1xuICAgICAgICB0aGlzLmxyICo9IChvbGRfQyA+IGxvc3MgKyB0aGlzLnRvbCkgID8gMS4wMSA6IC45O1xuICAgICAgICByZXR1cm4gdGhpcy5ZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGVtYmVkZGluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBZIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyIFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBncmFkIFxuICAgICAqL1xuICAgIF91cGRhdGVfZW1iZWRkaW5nKFksIGl0ZXIsIGdyYWQpIHtcbiAgICAgICAgY29uc3QgW04sIGRpbV0gPSBZLnNoYXBlO1xuICAgICAgICBjb25zdCBnYW1tYSA9IGl0ZXIgPiAxNTAgPyAuOSA6IC41OyAvLyBtb21lbnQgcGFyYW1ldGVyXG4gICAgICAgIGNvbnN0IG1pbl9nYWluID0gLjAxO1xuICAgICAgICBjb25zdCBnYWluID0gdGhpcy5nYWluO1xuICAgICAgICBjb25zdCB2ZWwgPSB0aGlzLnZlbDtcbiAgICAgICAgY29uc3QgbHIgPSB0aGlzLmxyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld19nYWluID0gKE1hdGguc2lnbih2ZWwuZW50cnkoaSwgZCkpICE9IE1hdGguc2lnbihncmFkLmVudHJ5KGksIGQpKSkgPyBnYWluLmVudHJ5KGksIGQpICsgLjIgOiBNYXRoLm1heChnYWluLmVudHJ5KGksIGQpICogLjgsIG1pbl9nYWluKTtcbiAgICAgICAgICAgICAgICBnYWluLnNldF9lbnRyeShpLCBkLCBuZXdfZ2Fpbik7XG4gICAgICAgICAgICAgICAgdmVsLnNldF9lbnRyeShpLCBkLCBnYW1tYSAqIHZlbC5lbnRyeShpLCBkKSAtIGxyICogZ2Fpbi5lbnRyeShpLCBkKSAqIGdyYWQuZW50cnkoaSwgZCkpO1xuICAgICAgICAgICAgICAgIFkuc2V0X2VudHJ5KGksIGQsIFkuZW50cnkoaSwgZCkgKyB2ZWwuZW50cnkoaSwgZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBZO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBIaWVyYXJjaGljYWxfQ2x1c3RlcmluZ1xuICovXG5leHBvcnQgY2xhc3MgSGllcmFyY2hpY2FsX0NsdXN0ZXJpbmcge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y2x1c3RlcmluZ1xuICAgICAqIEBhbGlhcyBIaWVyYXJjaGljYWxfQ2x1c3RlcmluZ1xuICAgICAqIEB0b2RvIG5lZWRzIHJlc3RydWN0dXJpbmcuXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IC0gRGF0YSBvciBkaXN0YW5jZSBtYXRyaXggaWYgbWV0cmljIGlzICdwcmVjb21wdXRlZCdcbiAgICAgKiBAcGFyYW0geyhcInNpbmdsZVwifFwiY29tcGxldGVcInxcImF2ZXJhZ2VcIil9IFtsaW5rYWdlID0gXCJjb21wbGV0ZVwiXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbbWV0cmljID0gZXVjbGlkZWFuXVxuICAgICAqIEByZXR1cm5zIHtIaWVyYXJjaGljYWxfQ2x1c3RlcmluZ31cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIGxpbmthZ2UgPSBcImNvbXBsZXRlXCIsIG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgICAgICB0aGlzLl9pZCA9IDA7XG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeCBpbnN0YW5jZW9mIE1hdHJpeCA/IG1hdHJpeCA6IE1hdHJpeC5mcm9tKG1hdHJpeCk7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcbiAgICAgICAgdGhpcy5fbGlua2FnZSA9IGxpbmthZ2U7XG4gICAgICAgIGlmIChtZXRyaWMgPT09IFwicHJlY29tcHV0ZWRcIiAmJiB0aGlzLl9tYXRyaXguc2hhcGVbMF0gIT09IHRoaXMuX21hdHJpeC5zaGFwZVsxXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWYgbWV0cmljIGlzICdwcmVjb21wdXRlZCcsIHRoZW4gbWF0cml4IGhhcyB0byBiZSBzcXVhcmUhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLmRvKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdmFsdWUgd2hlcmUgdG8gY3V0IHRoZSB0cmVlLlxuICAgICAqIEBwYXJhbSB7KFwiZGlzdGFuY2VcInxcImRlcHRoXCIpfSBbdHlwZSA9IFwiZGlzdGFuY2VcIl0gLSB0eXBlIG9mIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IC0gQXJyYXkgb2YgY2x1c3RlcnMgd2l0aCB0aGUgaW5kaWNlcyBvZiB0aGUgcm93cyBpbiBnaXZlbiB7QGxpbmsgbWF0cml4fS5cbiAgICAgKi9cbiAgICBnZXRfY2x1c3RlcnModmFsdWUsIHR5cGUgPSBcImRpc3RhbmNlXCIpIHtcbiAgICAgICAgbGV0IGNsdXN0ZXJzID0gW107XG4gICAgICAgIGxldCBhY2Nlc3NvcjtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGlzdGFuY2VcIjpcbiAgICAgICAgICAgICAgICBhY2Nlc3NvciA9IChkKSA9PiBkLmRpc3Q7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVwdGhcIjpcbiAgICAgICAgICAgICAgICBhY2Nlc3NvciA9IChkKSA9PiBkLmRlcHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhdmVyc2UodGhpcy5yb290LCBhY2Nlc3NvciwgdmFsdWUsIGNsdXN0ZXJzKTtcbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IG5vZGVcbiAgICAgKiBAcGFyYW0geyp9IGZcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSByZXN1bHRcbiAgICAgKi9cbiAgICBfdHJhdmVyc2Uobm9kZSwgZiwgdmFsdWUsIHJlc3VsdCkge1xuICAgICAgICBpZiAoZihub2RlKSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZS5sZWF2ZXMoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmF2ZXJzZShub2RlLmxlZnQsIGYsIHZhbHVlLCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5fdHJhdmVyc2Uobm9kZS5yaWdodCwgZiwgdmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlcyB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9tYXRyaXg7XG4gICAgICAgIGNvbnN0IG4gPSAodGhpcy5fbiA9IEEuc2hhcGVbMF0pO1xuICAgICAgICBjb25zdCBkX21pbiA9ICh0aGlzLl9kX21pbiA9IG5ldyBGbG9hdDY0QXJyYXkobikpO1xuICAgICAgICBsZXQgZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICBpZiAobWV0cmljICE9PSBcInByZWNvbXB1dGVkXCIpIHtcbiAgICAgICAgICAgIGRpc3RhbmNlX21hdHJpeCA9IG5ldyBNYXRyaXgobiwgbiwgMCk7IC8vbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkX21pbltpXSA9IDA7XG4gICAgICAgICAgICAgICAgLy9kaXN0YW5jZV9tYXRyaXhbaV0gPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlX21hdHJpeC5zZXRfZW50cnkoaSwgaiwgaSA9PT0gaiA/IEluZmluaXR5IDogbWV0cmljKEEucm93KGkpLCBBLnJvdyhqKSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VfbWF0cml4LmVudHJ5KGksIGRfbWluW2ldKSA+IGRpc3RhbmNlX21hdHJpeC5lbnRyeShpLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZF9taW5baV0gPSBqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzdGFuY2VfbWF0cml4ID0gdGhpcy5fbWF0cml4LmNsb25lKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZV9tYXRyaXguc2V0X2VudHJ5KGksIGosIEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZV9tYXRyaXguZW50cnkoaSwgZF9taW5baV0pID4gZGlzdGFuY2VfbWF0cml4LmVudHJ5KGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkX21pbltpXSA9IGo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzdGFuY2VfbWF0cml4ID0gZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9ICh0aGlzLl9jbHVzdGVycyA9IG5ldyBBcnJheShuKSk7XG4gICAgICAgIGNvbnN0IGNfc2l6ZSA9ICh0aGlzLl9jX3NpemUgPSBuZXcgVWludDE2QXJyYXkobikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgY2x1c3RlcnNbaV0gPSBbXTtcbiAgICAgICAgICAgIGNsdXN0ZXJzW2ldWzBdID0gbmV3IENsdXN0ZXIodGhpcy5faWQrKywgbnVsbCwgbnVsbCwgMCwgQS5yb3coaSksIGksIDEsIDApO1xuICAgICAgICAgICAgY19zaXplW2ldID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlcyB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBkbygpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX247XG4gICAgICAgIGNvbnN0IGRfbWluID0gdGhpcy5fZF9taW47XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9kaXN0YW5jZV9tYXRyaXg7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gdGhpcy5fY2x1c3RlcnM7XG4gICAgICAgIGNvbnN0IGNfc2l6ZSA9IHRoaXMuX2Nfc2l6ZTtcbiAgICAgICAgY29uc3QgbGlua2FnZSA9IHRoaXMuX2xpbmthZ2U7XG4gICAgICAgIGxldCByb290ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgcCA9IDAsIHBfbWF4ID0gbiAtIDE7IHAgPCBwX21heDsgKytwKSB7XG4gICAgICAgICAgICBsZXQgYzEgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgRF9pX21pbiA9IEQuZW50cnkoaSwgZF9taW5baV0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRF9pX21pbiA+IEQuZW50cnkoaSwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRfbWluW2ldID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIERfaV9taW4gPSBELmVudHJ5KGksIGRfbWluW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEQuZW50cnkoaSwgZF9taW5baV0pIDwgRC5lbnRyeShjMSwgZF9taW5bYzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBjMSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGMyID0gZF9taW5bYzFdO1xuICAgICAgICAgICAgbGV0IGMxX2NsdXN0ZXIgPSBjbHVzdGVyc1tjMV1bMF07XG4gICAgICAgICAgICBsZXQgYzJfY2x1c3RlciA9IGNsdXN0ZXJzW2MyXVswXTtcbiAgICAgICAgICAgIGxldCBjMV9jbHVzdGVyX2luZGljZXMgPSBjMV9jbHVzdGVyLmlzTGVhZiA/IFtjMV9jbHVzdGVyLmluZGV4XSA6IGMxX2NsdXN0ZXIuaW5kZXg7XG4gICAgICAgICAgICBsZXQgYzJfY2x1c3Rlcl9pbmRpY2VzID0gYzJfY2x1c3Rlci5pc0xlYWYgPyBbYzJfY2x1c3Rlci5pbmRleF0gOiBjMl9jbHVzdGVyLmluZGV4O1xuICAgICAgICAgICAgbGV0IGluZGljZXMgPSBjMV9jbHVzdGVyX2luZGljZXMuY29uY2F0KGMyX2NsdXN0ZXJfaW5kaWNlcyk7XG4gICAgICAgICAgICBsZXQgbmV3X2NsdXN0ZXIgPSBuZXcgQ2x1c3Rlcih0aGlzLl9pZCsrLCBjMV9jbHVzdGVyLCBjMl9jbHVzdGVyLCBELmVudHJ5KGMxLCBjMiksIG51bGwsIGluZGljZXMpO1xuICAgICAgICAgICAgYzFfY2x1c3Rlci5wYXJlbnQgPSBuZXdfY2x1c3RlcjtcbiAgICAgICAgICAgIGMyX2NsdXN0ZXIucGFyZW50ID0gbmV3X2NsdXN0ZXI7XG4gICAgICAgICAgICBjbHVzdGVyc1tjMV0udW5zaGlmdChuZXdfY2x1c3Rlcik7XG4gICAgICAgICAgICBjX3NpemVbYzFdICs9IGNfc2l6ZVtjMl07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IERfYzFfaiA9IEQuZW50cnkoYzEsIGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IERfYzJfaiA9IEQuZW50cnkoYzIsIGopO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGxpbmthZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNpbmdsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihEX2MxX2osIERfYzJfaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KERfYzFfaiwgRF9jMl9qKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXZlcmFnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoY19zaXplW2MxXSAqIERfYzFfaiArIGNfc2l6ZVtjMl0gKiBEX2MyX2opIC8gKGNfc2l6ZVtjMV0gKyBjX3NpemVbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEQuc2V0X2VudHJ5KGosIGMxLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgRC5zZXRfZW50cnkoYzEsIGosIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgRC5zZXRfZW50cnkoYzEsIGMxLCBJbmZpbml0eSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIEQuc2V0X2VudHJ5KGksIGMyLCBJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgRC5zZXRfZW50cnkoYzIsIGksIEluZmluaXR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogZm9yIChsZXQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAoZF9taW5bal0gPT09IGMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRfbWluW2pdID0gYzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChELmVudHJ5KGMxLCBqKSA8IEQuZW50cnkoYzEsIGRfbWluW2MxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZF9taW5bYzFdID0gajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICovXG4gICAgICAgICAgICByb290ID0gbmV3X2NsdXN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxufVxuXG5jbGFzcyBDbHVzdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgbGVmdCwgcmlnaHQsIGRpc3QsIGNlbnRyb2lkLCBpbmRleCwgc2l6ZSwgZGVwdGgpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuZGlzdCA9IGRpc3Q7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZSA/PyBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGggPz8gMSArIE1hdGgubWF4KGxlZnQuZGVwdGgsIHJpZ2h0LmRlcHRoKTtcbiAgICAgICAgdGhpcy5jZW50cm9pZCA9IGNlbnRyb2lkID8/IHRoaXMuX2NhbGN1bGF0ZV9jZW50cm9pZChsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZV9jZW50cm9pZChsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBsX3NpemUgPSBsZWZ0LnNpemU7XG4gICAgICAgIGNvbnN0IHJfc2l6ZSA9IHJpZ2h0LnNpemU7XG4gICAgICAgIGNvbnN0IGxfY2VudHJvaWQgPSBsZWZ0LmNlbnRyb2lkO1xuICAgICAgICBjb25zdCByX2NlbnRyb2lkID0gcmlnaHQuY2VudHJvaWQ7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGNvbnN0IG4gPSBsZWZ0LmNlbnRyb2lkLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3X2NlbnRyb2lkID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIG5ld19jZW50cm9pZFtpXSA9IChsX3NpemUgKiBsX2NlbnRyb2lkW2ldICsgcl9zaXplICogcl9jZW50cm9pZFtpXSkgLyBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdfY2VudHJvaWQ7XG4gICAgfVxuXG4gICAgZ2V0IGlzTGVhZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGggPT09IDA7XG4gICAgfVxuXG4gICAgbGVhdmVzKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xlYWYpIHJldHVybiBbdGhpc107XG4gICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodDtcbiAgICAgICAgcmV0dXJuIChsZWZ0LmlzTGVhZiA/IFtsZWZ0XSA6IGxlZnQubGVhdmVzKCkpLmNvbmNhdChyaWdodC5pc0xlYWYgPyBbcmlnaHRdIDogcmlnaHQubGVhdmVzKCkpO1xuICAgIH1cblxuICAgIGRlc2NlbmRhbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xlYWYpIHJldHVybiBbdGhpc107XG4gICAgICAgIGNvbnN0IGxlZnRfZGVzY2VuZGFudHMgPSB0aGlzLmxlZnQuZGVzY2VuZGFudHMoKTtcbiAgICAgICAgY29uc3QgcmlnaHRfZGVzY2VuZGFudHMgPSB0aGlzLnJpZ2h0LmRlc2NlbmRhbnRzKCk7XG4gICAgICAgIHJldHVybiBsZWZ0X2Rlc2NlbmRhbnRzLmNvbmNhdChyaWdodF9kZXNjZW5kYW50cykuY29uY2F0KFt0aGlzXSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFJhbmRvbWl6ZXIgfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSGVhcCB9IGZyb20gXCIuLi9kYXRhc3RydWN0dXJlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBsaW5zcGFjZSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBLTWVhbnNcbiAqL1xuZXhwb3J0IGNsYXNzIEtNZWFucyB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjbHVzdGVyaW5nXG4gICAgICogQGFsaWFzIEtNZWFuc1xuICAgICAqIEB0b2RvIG5lZWRzIHJlc3RydWN0dXJpbmcuIFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXggXG4gICAgICogQHBhcmFtIHtOdW1iZXJzfSBLIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VlZCA9IDE5ODddXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5pdCA9IHRydWVdXG4gICAgICogQHJldHVybnMge0tNZWFuc31cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIEssIG1ldHJpYyA9IGV1Y2xpZGVhbiwgc2VlZD0xOTg3LCBpbml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9tZXRyaWMgPSBtZXRyaWM7XG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeDtcbiAgICAgICAgdGhpcy5fSyA9IEs7XG4gICAgICAgIGNvbnN0IFtOLCBEXSA9IG1hdHJpeC5zaGFwZTtcbiAgICAgICAgdGhpcy5fTiA9IE47XG4gICAgICAgIHRoaXMuX0QgPSBEO1xuICAgICAgICBpZiAoSyA+IE4pIEsgPSBOO1xuICAgICAgICB0aGlzLl9yYW5kb21pemVyID0gbmV3IFJhbmRvbWl6ZXIoc2VlZCk7XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJzID0gbmV3IEFycmF5KE4pLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fY2x1c3Rlcl9jZW50cm9pZHMgPSB0aGlzLl9nZXRfcmFuZG9tX2NlbnRyb2lkcyhLKTtcbiAgICAgICAgaWYgKGluaXQpIHRoaXMuaW5pdChLLCB0aGlzLl9jbHVzdGVyX2NlbnRyb2lkcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IC0gQXJyYXkgb2YgY2x1c3RlcnMgd2l0aCB0aGUgaW5kaWNlcyBvZiB0aGUgcm93cyBpbiBnaXZlbiB7QGxpbmsgbWF0cml4fS4gXG4gICAgICovXG4gICAgZ2V0X2NsdXN0ZXJzKCkge1xuICAgICAgICBjb25zdCBLID0gdGhpcy5fSztcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSB0aGlzLl9jbHVzdGVycztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KEspLmZpbGwoKS5tYXAoKCkgPT4gbmV3IEFycmF5KCkpO1xuICAgICAgICBjbHVzdGVycy5mb3JFYWNoKChjLCBpKSA9PiByZXN1bHRbY10ucHVzaChpKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2FuZGlkYXRlcyBcbiAgICAgKi9cbiAgICBfZnVydGhlc3RfcG9pbnQocG9pbnRzLCBjYW5kaWRhdGVzKSB7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9tYXRyaXg7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgbGV0IGkgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBsZXQgSCA9IEhlYXAuaGVhcGlmeShcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMsIFxuICAgICAgICAgICAgKGQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBBZCA9IEEucm93KGQpXG4gICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IG1ldHJpYyhBZCwgcG9pbnRzW2pdKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICBcIm1heFwiXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIEgucG9wKCkuZWxlbWVudDtcbiAgICB9XG5cbiAgICBfZ2V0X3JhbmRvbV9jZW50cm9pZHMoSykge1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgcmFuZG9taXplciA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9tYXRyaXg7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJfY2VudHJvaWRzID0gbmV3IEFycmF5KEspLmZpbGwoKVxuICAgICAgICBjb25zdCBpbmRpY2VzID0gbGluc3BhY2UoMCwgTiAtIDEpO1xuICAgICAgICBjb25zdCByYW5kb21fcG9pbnQgPSByYW5kb21pemVyLnJhbmRvbV9pbnQgJSAoTiAtIDEpO1xuICAgICAgICBjbHVzdGVyX2NlbnRyb2lkc1swXSA9IEEucm93KHJhbmRvbV9wb2ludCk7XG4gICAgICAgIGNvbnN0IGluaXRfcG9pbnRzID0gW3JhbmRvbV9wb2ludF07XG4gICAgICAgIGNvbnN0IHNhbXBsZV9zaXplID0gTWF0aC5mbG9vcigoTiAtIEspIC8gSyk7Ly8gLyBLXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgSzsgKytpKSB7XG4gICAgICAgICAgICAvLyBzYW1wbGluZyArIGttZWFucysrIGltcHJvdmVtZW50P1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlID0gcmFuZG9taXplci5jaG9pY2UoaW5kaWNlcy5maWx0ZXIoZCA9PiBpbml0X3BvaW50cy5pbmRleE9mKGQpID09IC0xKSwgc2FtcGxlX3NpemUpO1xuICAgICAgICAgICAgY29uc3QgZnVydGhlc3RfcG9pbnQgPSB0aGlzLl9mdXJ0aGVzdF9wb2ludChjbHVzdGVyX2NlbnRyb2lkcy5zbGljZSgwLCBpKSwgc2FtcGxlKTtcbiAgICAgICAgICAgIGluaXRfcG9pbnRzLnB1c2goZnVydGhlc3RfcG9pbnQpO1xuICAgICAgICAgICAgY2x1c3Rlcl9jZW50cm9pZHNbaV0gPSBBLnJvdyhmdXJ0aGVzdF9wb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJfY2VudHJvaWRzO1xuICAgIH1cblxuICAgIF9pdGVyYXRpb24oY2x1c3Rlcl9jZW50cm9pZHMpIHtcbiAgICAgICAgY29uc3QgSyA9IGNsdXN0ZXJfY2VudHJvaWRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9EO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fbWF0cml4O1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gdGhpcy5fY2x1c3RlcnM7XG4gICAgICAgIGxldCBjbHVzdGVyc19jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIC8vIGZpbmQgbmVhcmVzdCBjbHVzdGVyIGNlbnRyb2lkLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgQWkgPSBBLnJvdyhpKVxuICAgICAgICAgICAgbGV0IG1pbl9kaXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBsZXQgbWluX2NsdXN0ZXIgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBLOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgZCA9IG1ldHJpYyhjbHVzdGVyX2NlbnRyb2lkc1tqXSwgQWkpO1xuICAgICAgICAgICAgICAgIGlmIChkIDwgbWluX2Rpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluX2Rpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICBtaW5fY2x1c3RlciA9IGo7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbHVzdGVyc1tpXSAhPT0gbWluX2NsdXN0ZXIpIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyc19jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsdXN0ZXJzW2ldID0gbWluX2NsdXN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGNsdXN0ZXIgY2VudHJvaWRcbiAgICAgICAgLy8gcmVzZXQgY2x1c3RlciBjZW50cm9pZHMgdG8gMFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEs7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY2VudHJvaWQgPSBjbHVzdGVyX2NlbnRyb2lkc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgRDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2VudHJvaWRbal0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXB1dGUgY2VudHJvaWRcbiAgICAgICAgdGhpcy5fY29tcHV0ZV9jZW50cm9pZChjbHVzdGVyX2NlbnRyb2lkcyk7XG5cbiAgICAgICAgcmV0dXJuIHsgICBcbiAgICAgICAgICAgIFwiY2x1c3RlcnNfY2hhbmdlZFwiOiBjbHVzdGVyc19jaGFuZ2VkLFxuICAgICAgICAgICAgXCJjbHVzdGVyX2NlbnRyb2lkc1wiOiBjbHVzdGVyX2NlbnRyb2lkc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9jb21wdXRlX2NlbnRyb2lkKGNsdXN0ZXJfY2VudHJvaWRzKSB7XG4gICAgICAgIGNvbnN0IEsgPSBjbHVzdGVyX2NlbnRyb2lkcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBEID0gdGhpcy5fRDtcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX21hdHJpeDtcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSB0aGlzLl9jbHVzdGVycztcbiAgICAgICAgY29uc3QgY2x1c3Rlcl9jb3VudGVyID0gbmV3IEFycmF5KEspLmZpbGwoMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IEFpID0gQS5yb3coaSk7XG4gICAgICAgICAgICBjb25zdCBjaSA9IGNsdXN0ZXJzW2ldO1xuICAgICAgICAgICAgY2x1c3Rlcl9jb3VudGVyW2NpXSsrO1xuICAgICAgICAgICAgY29uc3QgY2VudHJvaWQgPSBjbHVzdGVyX2NlbnRyb2lkc1tjaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IEQ7ICsraikge1xuICAgICAgICAgICAgICAgIGNlbnRyb2lkW2pdICs9IEFpW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSzsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gY2x1c3Rlcl9jb3VudGVyW2ldO1xuICAgICAgICAgICAgY2x1c3Rlcl9jZW50cm9pZHNbaV0gPSBjbHVzdGVyX2NlbnRyb2lkc1tpXS5tYXAoYyA9PiBjIC8gbik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMge0BsaW5rIEt9IGNsdXN0ZXJzIG91dCBvZiB0aGUge0BsaW5rIG1hdHJpeH0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IEsgLSBudW1iZXIgb2YgY2x1c3RlcnMuXG4gICAgICovXG4gICAgaW5pdChLLCBjbHVzdGVyX2NlbnRyb2lkcykge1xuICAgICAgICBpZiAoIUspIEsgPSB0aGlzLl9LO1xuICAgICAgICBpZiAoIWNsdXN0ZXJfY2VudHJvaWRzKSBjbHVzdGVyX2NlbnRyb2lkcyA9IHRoaXMuX2dldF9yYW5kb21fY2VudHJvaWRzKEspO1xuICAgICAgICBsZXQgY2x1c3RlcnNfY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBpdGVyYXRpb25fcmVzdWx0ID0gdGhpcy5faXRlcmF0aW9uKGNsdXN0ZXJfY2VudHJvaWRzKVxuICAgICAgICAgICAgY2x1c3Rlcl9jZW50cm9pZHMgPSBpdGVyYXRpb25fcmVzdWx0LmNsdXN0ZXJfY2VudHJvaWRzO1xuICAgICAgICAgICAgY2x1c3RlcnNfY2hhbmdlZCA9IGl0ZXJhdGlvbl9yZXN1bHQuY2x1c3RlcnNfY2hhbmdlZDtcbiAgICAgICAgfSB3aGlsZSAoY2x1c3RlcnNfY2hhbmdlZClcbiAgICB9XG4gICAgXG59XG4iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUmFuZG9taXplciB9IGZyb20gXCIuLi91dGlsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBsaW5zcGFjZSwgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbWluIH0gZnJvbSBcIi4uL3V0aWwvaW5kZXguanNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgS01lZG9pZHNcbiAqL1xuZXhwb3J0IGNsYXNzIEtNZWRvaWRzIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNsdXN0ZXJpbmdcbiAgICAgKiBAYWxpYXMgS01lZG9pZHNcbiAgICAgKiBAdG9kbyBuZWVkcyByZXN0cnVjdHVyaW5nLiBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4IC0gZGF0YSBtYXRyaXhcbiAgICAgKiBAcGFyYW0ge051bWJlcnN9IEsgLSBudW1iZXIgb2YgY2x1c3RlcnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heF9pdGVyPW51bGxdIC0gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucy4gRGVmYXVsdCBpcyAxMCAqIE1hdGgubG9nMTAoTilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIG1ldHJpYyBkZWZpbmluZyB0aGUgZGlzc2ltaWxhcml0eSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHNlZWQgdmFsdWUgZm9yIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gICAgICogQHJldHVybnMge0tNZWRvaWRzfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbGluay5zcHJpbmdlci5jb20vY2hhcHRlci8xMC4xMDA3Lzk3OC0zLTAzMC0zMjA0Ny04XzE2fSBGYXN0ZXIgay1NZWRvaWRzIENsdXN0ZXJpbmc6IEltcHJvdmluZyB0aGUgUEFNLCBDTEFSQSwgYW5kIENMQVJBTlMgQWxnb3JpdGhtc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1hdHJpeCwgSywgbWF4X2l0ZXI9bnVsbCwgbWV0cmljID0gZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgdGhpcy5fbWV0cmljID0gbWV0cmljO1xuICAgICAgICB0aGlzLl9tYXRyaXggPSBtYXRyaXg7XG4gICAgICAgIHRoaXMuX0EgPSB0aGlzLl9tYXRyaXgudG8yZEFycmF5O1xuICAgICAgICB0aGlzLl9LID0gSztcbiAgICAgICAgY29uc3QgW04sIERdID0gbWF0cml4LnNoYXBlO1xuICAgICAgICB0aGlzLl9OID0gTjtcbiAgICAgICAgdGhpcy5fRCA9IEQ7XG4gICAgICAgIHRoaXMuX21heF9pdGVyID0gbWF4X2l0ZXIgfHwgMTAgKiBNYXRoLmxvZzEwKE4pIFxuICAgICAgICB0aGlzLl9kaXN0YW5jZV9tYXRyaXggPSBuZXcgTWF0cml4KE4sIE4sIFwiemVyb3NcIik7XG4gICAgICAgIC8qIGZvciAobGV0IGkgPSAxOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IG1ldHJpYyh0aGlzLl9BW2ldLCB0aGlzLl9BW2pdKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZV9tYXRyaXguc2V0X2VudHJ5KGksIGosIGRpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlX21hdHJpeC5zZXRfZW50cnkoaiwgaSwgZGlzdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAqL1xuICAgICAgICBpZiAoSyA+IE4pIEsgPSBOO1xuICAgICAgICB0aGlzLl9yYW5kb21pemVyID0gbmV3IFJhbmRvbWl6ZXIoc2VlZCk7XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJzID0gbmV3IEFycmF5KE4pLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fY2x1c3Rlcl9tZWRvaWRzID0gdGhpcy5fZ2V0X3JhbmRvbV9tZWRvaWRzKEspO1xuICAgICAgICAvL2lmIChpbml0KSB0aGlzLmluaXQoSywgdGhpcy5fY2x1c3Rlcl9tZWRvaWRzKTtcbiAgICAgICAgdGhpcy5faXNfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gLSBBcnJheSBvZiBjbHVzdGVycyB3aXRoIHRoZSBpbmRpY2VzIG9mIHRoZSByb3dzIGluIGdpdmVuIHtAbGluayBtYXRyaXh9LiBcbiAgICAgKi9cbiAgICBnZXRfY2x1c3RlcnMoKSB7XG4gICAgICAgIGNvbnN0IEsgPSB0aGlzLl9LO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc19pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0KEssIHRoaXMuX2NsdXN0ZXJfbWVkb2lkcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KEspLmZpbGwoKS5tYXAoKCkgPT4gbmV3IEFycmF5KCkpO1xuICAgICAgICBBLmZvckVhY2goKHhfaiwgaikgPT4ge1xuICAgICAgICAgICAgcmVzdWx0W3RoaXMuX25lYXJlc3RfbWVkb2lkKHhfaiwgaikuaW5kZXhfbmVhcmVzdF0ucHVzaChqKTtcbiAgICAgICAgfSlcbiAgICAgICAgcmVzdWx0Lm1lZG9pZHMgPSB0aGlzLl9jbHVzdGVyX21lZG9pZHM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMqIGdlbmVyYXRvcigpIHtcbiAgICAgICAgY29uc3QgbWF4X2l0ZXIgPSB0aGlzLl9tYXhfaXRlcjtcbiAgICAgICAgeWllbGQgdGhpcy5nZXRfY2x1c3RlcnMoKVxuICAgICAgICBsZXQgZmluaXNoID0gZmFsc2U7XG4gICAgICAgIGxldCBpID0gMFxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBmaW5pc2ggPSB0aGlzLl9pdGVyYXRpb24oKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0X2NsdXN0ZXJzKCk7XG4gICAgICAgIH0gd2hpbGUgKCFmaW5pc2ggJiYgKytpIDwgbWF4X2l0ZXIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxnb3JpdGhtIDEuIEZhc3RQQU0xOiBJbXByb3ZlZCBTV0FQIGFsZ29yaXRobVxuICAgICAqL1xuICAgIC8qIF9pdGVyYXRpb25fMSgpIHtcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX0E7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBLID0gdGhpcy5fSztcbiAgICAgICAgY29uc3QgbWVkb2lkcyA9IHRoaXMuX2NsdXN0ZXJfbWVkb2lkcztcbiAgICAgICAgbGV0IERlbHRhVEQgPSAwO1xuICAgICAgICBsZXQgbTAgPSBudWxsO1xuICAgICAgICBsZXQgeDAgPSBudWxsO1xuICAgICAgICBBLmZvckVhY2goKHhfaiwgaikgPT4ge1xuICAgICAgICAgICAgaWYgKG1lZG9pZHMuZmluZEluZGV4KG0gPT4gbSA9PT0gaikgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmVhcmVzdF9tZWRvaWQgPSB0aGlzLl9uZWFyZXN0X21lZG9pZCh4X2osIGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRfaiA9IG5lYXJlc3RfbWVkb2lkLmRpc3RhbmNlX25lYXJlc3Q7IC8vIGRpc3RhbmNlIHRvIGN1cnJlbnQgbWVkb2lkXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFURCA9IG5ldyBBcnJheShLKS5maWxsKC1kX2opOyAvLyBjaGFuZ2UgaWYgbWFraW5nIGogYSBtZWRvaWRcbiAgICAgICAgICAgICAgICBBLmZvckVhY2goKHhfbywgbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBkaXNhbmNlIHRvIG5ldyBtZWRvaWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZF9vaiA9IHRoaXMuX2dldF9kaXN0YW5jZShvLCBqLCB4X28sIHhfaik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5kZXhfbmVhcmVzdFwiOiBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXN0YW5jZV9uZWFyZXN0XCI6IGRfbixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzdGFuY2Vfc2Vjb25kXCI6IGRfcyxcbiAgICAgICAgICAgICAgICAgICAgfSA9IHRoaXMuX25lYXJlc3RfbWVkb2lkKHhfbywgbyk7IFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbHVzdGVyc1tvXSA9IG47IC8vIGNhY2hlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFURFtuXSArPSBNYXRoLm1pbihkX29qLCBkX3MpIC0gZF9uOyAvLyBsb3NzIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZF9vaiA8IGRfbikgeyAvLyByZWFzc2lnbm1lbnQgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVEQuZm9yRWFjaCgoZF9pLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFURFtpXSA9IGRfaSArIGRfb2ogLSBkX247IC8vIHVwZGF0ZSBsb3NzIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gY2hvb3NlIGJlc3QgbWVkb2lkIGk7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IGRlbHRhVERcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoZCwgaSkgPT4gW2QsIGldKVxuICAgICAgICAgICAgICAgICAgICAuc29ydCgoZDEsIGQyKSA9PiBkMVswXSAtIGQyWzBdKVswXVsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVREX2kgPSBkZWx0YVREW2ldO1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlXG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhVERfaSA8IERlbHRhVEQpIHtcbiAgICAgICAgICAgICAgICAgICAgRGVsdGFURCA9IGRlbHRhVERfaTtcbiAgICAgICAgICAgICAgICAgICAgbTAgPSBpO1xuICAgICAgICAgICAgICAgICAgICB4MCA9IGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoRGVsdGFURCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZSAvLyBicmVhayBsb29wIGlmIERlbHRhVEQgPj0gMFxuICAgICAgICB9XG4gICAgICAgIC8vIHN3YXAgcm9sZXMgb2YgbWVkb2lkIG0gYW5kIG5vbi1tZWRvaWQgeDtcbiAgICAgICAgbWVkb2lkc1ttMF0gPSB4MDtcbiAgICAgICAgdGhpcy5fY2x1c3Rlcl9tZWRvaWRzID0gbWVkb2lkcztcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSAqL1xuXG4gICAgLyoqIEFsZ29yaXRobSAyLiBGYXN0UEFNMjogU1dBUCB3aXRoIG11bHRpcGxlIGNhbmRpZGF0ZXNcbiAgICAgKiBcbiAgICAgKi9cbiAgICBfaXRlcmF0aW9uKCkge1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgSyA9IHRoaXMuX0s7XG4gICAgICAgIGNvbnN0IG1lZG9pZHMgPSB0aGlzLl9jbHVzdGVyX21lZG9pZHM7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gQS5tYXAoKHhfbywgbykgPT4gdGhpcy5fbmVhcmVzdF9tZWRvaWQoeF9vLCBvKSk7XG4gICAgICAgIC8vIGVtcHR5IGJlc3QgY2FuZGlkYXRlcyBhcnJheVxuICAgICAgICBjb25zdCBEZWx0YVREID0gbmV3IEFycmF5KEspLmZpbGwoMCk7XG4gICAgICAgIGNvbnN0IHhzID0gbmV3IEFycmF5KEspLmZpbGwobnVsbCk7XG4gICAgICAgIEEuZm9yRWFjaCgoeF9qLCBqKSA9PiB7XG4gICAgICAgICAgICBpZiAobWVkb2lkcy5maW5kSW5kZXgobSA9PiBtID09PSBqKSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkX2ogPSBjYWNoZVtqXS5kaXN0YW5jZV9uZWFyZXN0OyAvLyBkaXN0YW5jZSB0byBjdXJyZW50IG1lZG9pZFxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhVEQgPSBuZXcgQXJyYXkoSykuZmlsbCgtZF9qKTsgLy8gY2hhbmdlIGlmIG1ha2luZyBqIGEgbWVkb2lkXG4gICAgICAgICAgICAgICAgQS5mb3JFYWNoKCh4X28sIG8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IG8pIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZF9vaiA9IHRoaXMuX2dldF9kaXN0YW5jZShvLCBqLCB4X28sIHhfaik7IC8vIGRpc3RhbmNlIHRvIG5ldyBtZWRvaWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qge1wiaW5kZXhfbmVhcmVzdFwiOiBuLCBcImRpc3RhbmNlX25lYXJlc3RcIjogZF9uLCBcImRpc3RhbmNlX3NlY29uZFwiOiBkX3N9ID0gY2FjaGVbb107IC8vIGNhY2hlZFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVREW25dICs9IE1hdGgubWluKGRfb2osIGRfcykgLSBkX247IC8vIGxvc3MgY2hhbmdlIGZvciB4X29cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhc3NpZ25tZW50IGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChkX29qIDwgZF9uKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGxvc3MgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEs7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBuKSBkZWx0YVREW2ldICs9IGRfb2ogLSBkX247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyByZW1lbWJlciBiZXN0IHN3YXAgZm9yIGk7XG4gICAgICAgICAgICAgICAgZGVsdGFURFxuICAgICAgICAgICAgICAgICAgICAubWFwKChkLCBpKSA9PiBbZCwgaV0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtkLCBpXSkgPT4gZCA8IERlbHRhVERbaV0pXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKChbZCwgaV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgRGVsdGFURFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlbHRhVERbaV0gPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhzW2ldID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLy8gc3RvcCBpZiBubyBpbXByb3ZlbWVudHMgd2VyZSBmb3VuZFxuICAgICAgICBpZiAobWluKERlbHRhVEQpID49IDApIHJldHVybiB0cnVlOyBcblxuICAgICAgICAvLyBleGVjdXRlIGFsbCBpbXByb3ZlbWVudHNcbiAgICAgICAgd2hpbGUgKG1pbihEZWx0YVREKSA8IDApIHtcbiAgICAgICAgICAgIC8vIHN3YXAgcm9sZXMgb2YgbWVkb2lkIG1faSBhbmQgbm9uX21lZG9pZCB4c19pXG4gICAgICAgICAgICBjb25zdCBpID0gRGVsdGFURFxuICAgICAgICAgICAgICAgIC5tYXAoKGQsIGkpID0+IFtkLCBpXSlcbiAgICAgICAgICAgICAgICAuc29ydCgoW2FdLCBbYl0pID0+IGEgLSBiKVswXVsxXTtcbiAgICAgICAgICAgIGlmIChtZWRvaWRzLmZpbHRlcihtID0+IG0gPT0geHNbaV0pLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbWVkb2lkc1tpXSA9IHhzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGlzYWJsZSB0aGUgc3dhcCBqdXN0IHBlcmZvcm1lZFxuICAgICAgICAgICAgRGVsdGFURFtpXSA9IDA7IFxuICAgICAgICAgICAgLy8gcmVjb21wdXRlIFREIGZvciByZW1haW5pbmcgc3dhcCBjYW5kaWRhdGVzXG4gICAgICAgICAgICBEZWx0YVREXG4gICAgICAgICAgICAgICAgLm1hcCgoZF9qLCBqKSA9PiBbZF9qLCBqXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbZF9qXSkgPT4gZF9qIDwgMClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoW18sIGpdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhfaiA9IEFbal07XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBBLmZvckVhY2goKHhfbywgbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lZG9pZHMuZmluZEluZGV4KG0gPT4gbSAhPSBqICYmIG0gPT0gbykgPj0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gaikgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlW29dLmluZGV4X25lYXJlc3QgPT09IG1lZG9pZHNbal0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IChNYXRoLm1pbih0aGlzLl9nZXRfZGlzdGFuY2UobywgaiwgeF9vLCB4X2opLCBjYWNoZVtvXS5kaXN0YW5jZV9zZWNvbmQpIC0gY2FjaGVbb10uZGlzdGFuY2VfbmVhcmVzdCk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IChNYXRoLm1pbih0aGlzLl9nZXRfZGlzdGFuY2UobywgaiwgeF9vLCB4X2opIC0gY2FjaGVbb10uZGlzdGFuY2VfbmVhcmVzdCwgMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgRGVsdGFURFtqXSA9IHN1bTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJfbWVkb2lkcyA9IG1lZG9pZHM7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBfZ2V0X2Rpc3RhbmNlKGksIGosIHhfaT1udWxsLCB4X2o9bnVsbCkge1xuICAgICAgICBpZiAoaSA9PT0gaikgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9kaXN0YW5jZV9tYXRyaXg7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9BO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGxldCBkX2lqID0gRC5lbnRyeShpLCBqKTtcbiAgICAgICAgaWYgKGRfaWogPT09IDApIHtcbiAgICAgICAgICAgIGRfaWogPSBtZXRyaWMoeF9pIHx8IEFbaV0sIHhfaiB8fCBBW2pdKTtcbiAgICAgICAgICAgIEQuc2V0X2VudHJ5KGksIGosIGRfaWopO1xuICAgICAgICAgICAgRC5zZXRfZW50cnkoaiwgaSwgZF9paik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRfaWo7XG4gICAgfVxuXG4gICAgX25lYXJlc3RfbWVkb2lkKHhfaiwgaikge1xuICAgICAgICBjb25zdCBtZWRvaWRzID0gdGhpcy5fY2x1c3Rlcl9tZWRvaWRzO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgW25lYXJlc3QsIHNlY29uZF0gPSBtZWRvaWRzXG4gICAgICAgICAgICAubWFwKChtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeF9tID0gQVttXTsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLl9nZXRfZGlzdGFuY2UoaiwgbSwgeF9qLCB4X20pLCBpXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc29ydCgobTEsIG0yKSA9PiBtMVswXSAtIG0yWzBdKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgXCJkaXN0YW5jZV9uZWFyZXN0XCI6IG5lYXJlc3RbMF0sIFxuICAgICAgICAgICAgXCJpbmRleF9uZWFyZXN0XCI6IG5lYXJlc3RbMV0sXG4gICAgICAgICAgICBcImRpc3RhbmNlX3NlY29uZFwiOiBzZWNvbmRbMF0sXG4gICAgICAgICAgICBcImluZGV4X3NlY29uZFwiOiBzZWNvbmRbMV0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMge0BsaW5rIEt9IGNsdXN0ZXJzIG91dCBvZiB0aGUge0BsaW5rIG1hdHJpeH0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IEsgLSBudW1iZXIgb2YgY2x1c3RlcnMuXG4gICAgICovXG4gICAgaW5pdChLLCBjbHVzdGVyX21lZG9pZHMpIHtcbiAgICAgICAgaWYgKCFLKSBLID0gdGhpcy5fSztcbiAgICAgICAgaWYgKCFjbHVzdGVyX21lZG9pZHMpIGNsdXN0ZXJfbWVkb2lkcyA9IHRoaXMuX2dldF9yYW5kb21fbWVkb2lkcyhLKTtcbiAgICAgICAgY29uc3QgbWF4X2l0ZXIgPSB0aGlzLl9tYXhfaXRlcjtcbiAgICAgICAgbGV0IGZpbmlzaCA9IGZhbHNlO1xuICAgICAgICBsZXQgaSA9IDBcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZmluaXNoID0gdGhpcy5faXRlcmF0aW9uKCk7XG4gICAgICAgIH0gd2hpbGUgKCFmaW5pc2ggJiYgKytpIDwgbWF4X2l0ZXIpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsZ29yaXRobSAzLiBGYXN0UEFNIExBQjogTGluZWFyIEFwcHJveGltYXRlIEJVSUxEIGluaXRpYWxpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBLIC0gbnVtYmVyIG9mIGNsdXN0ZXJzXG4gICAgICogXG4gICAgICovXG4gICAgX2dldF9yYW5kb21fbWVkb2lkcyhLKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IGxpbnNwYWNlKDAsIE4gLSAxKTtcbiAgICAgICAgY29uc3QgcmFuZG9taXplciA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihOLCAxMCArIE1hdGguY2VpbChNYXRoLnNxcnQoTikpKTtcbiAgICAgICAgY29uc3QgVEQgPSBuZXcgQXJyYXkobikuZmlsbChJbmZpbml0eSk7XG4gICAgICAgIGNvbnN0IG1lZG9pZHMgPSBbXTtcbiAgICAgICAgLy8gZmlyc3QgbWVkb2lkXG4gICAgICAgIGxldCBURDAgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IFMgPSByYW5kb21pemVyLmNob2ljZShpbmRpY2VzLCBuKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IFNfaiA9IFNbal07XG4gICAgICAgICAgICBjb25zdCB4X2ogPSBBW1Nfal07XG4gICAgICAgICAgICBmb3IgKGxldCBvID0gMDsgbyA8IG47ICsrbykge1xuICAgICAgICAgICAgICAgIGlmIChvID09PSBqKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB4X28gPSBBW1Nbb11dO1xuICAgICAgICAgICAgICAgIFREW2pdICs9IHRoaXMuX2dldF9kaXN0YW5jZShqLCBvLCB4X2osIHhfbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVERbal0gPCBURDApIHtcbiAgICAgICAgICAgICAgICBURDAgPSBURFtqXTsgLy8gc21hbGxlc3QgZGlzdGFuY2Ugc3VtXG4gICAgICAgICAgICAgICAgbWVkb2lkcy5wdXNoKFNfaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXIgbWVkb2lkc1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEs7ICsraSkge1xuICAgICAgICAgICAgbGV0IERlbHRhVEQgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIFMgPSByYW5kb21pemVyLmNob2ljZShpbmRpY2VzLmZpbHRlcihpbmRleCA9PiBtZWRvaWRzLmZpbmRJbmRleChkID0+IGQgPT09IGluZGV4KSA8IDApLCBuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlbHRhVEQgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IFNfaiA9IFNbal07XG4gICAgICAgICAgICAgICAgY29uc3QgeF9qID0gQVtTX2pdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgbjsgKytvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvID09PSBqKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgU19vID0gU1tvXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeF9vID0gQVtTX29dO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGEgPSB0aGlzLl9nZXRfZGlzdGFuY2UoU19qLCBTX28sIHhfaiwgeF9vKSAtIG1pbihtZWRvaWRzLm1hcChtID0+IHRoaXMuX2dldF9kaXN0YW5jZShTX28sIG0sIHhfbykpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFURCA9IGRlbHRhVEQgKyBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBiZXN0IHJlZHVjdGlvblxuICAgICAgICAgICAgICAgIGlmIChkZWx0YVREIDwgRGVsdGFURCkge1xuICAgICAgICAgICAgICAgICAgICBEZWx0YVREID0gZGVsdGFURDtcbiAgICAgICAgICAgICAgICAgICAgbWVkb2lkcy5wdXNoKFNfaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVEQwICs9IERlbHRhVEQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lZG9pZHMuc2xpY2UoMCwgSyk7XG4gICAgfVxuICAgIFxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IEhlYXAgfSBmcm9tIFwiLi4vZGF0YXN0cnVjdHVyZS9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIE9QVElDU1xuICovXG5leHBvcnQgY2xhc3MgT1BUSUNTIHtcbiAgICAvKipcbiAgICAgKiAqKk8qKnJkZXJpbmcgKipQKipvaW50cyAqKlQqKm8gKipJKipkZW50aWZ5IHRoZSAqKkMqKmx1c3RlcmluZyAqKlMqKnRydWN0dXJlLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y2x1c3RlcmluZ1xuICAgICAqIEBhbGlhcyBPUFRJQ1NcbiAgICAgKiBAdG9kbyBuZWVkcyByZXN0cnVjdHVyaW5nLiBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4IC0gdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVwc2lsb24gLSB0aGUgbWluaW11bSBkaXN0YW5jZSB3aGljaCBkZWZpbmVzIHdoZXRoZXIgYSBwb2ludCBpcyBhIG5laWdoYm9yIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluX3BvaW50cyAtIHRoZSBtaW5pbXVtIG51bWJlciBvZiBwb2ludHMgd2hpY2ggYSBwb2ludCBuZWVkcyB0byBjcmVhdGUgYSBjbHVzdGVyLiAoU2hvdWxkIGJlIGhpZ2hlciB0aGFuIDEsIGVsc2UgZWFjaCBwb2ludCBjcmVhdGVzIGEgY2x1c3Rlci4pXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgZGlzdGFuY2UgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBvZiB0aGUge0BsaW5rIG1hdHJpeH0uXG4gICAgICogQHJldHVybnMge09QVElDU31cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5kYnMuaWZpLmxtdS5kZS9QdWJsaWthdGlvbmVuL1BhcGVycy9PUFRJQ1MucGRmfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09QVElDU19hbGdvcml0aG19XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF0cml4LCBlcHNpbG9uLCBtaW5fcG9pbnRzLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbWF0cml4O1xuICAgICAgICB0aGlzLl9lcHNpbG9uID0gZXBzaWxvbjtcbiAgICAgICAgdGhpcy5fbWluX3BvaW50cyA9IG1pbl9wb2ludHM7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcblxuICAgICAgICB0aGlzLl9vcmRlcmVkX2xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fREIgPSBuZXcgQXJyYXkobWF0cml4LnNoYXBlWzBdKS5maWxsKCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgY2x1c3RlcmluZy5cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBvcmRlcmVkX2xpc3QgPSB0aGlzLl9vcmRlcmVkX2xpc3Q7XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcbiAgICAgICAgY29uc3QgTiA9IG1hdHJpeC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgREIgPSB0aGlzLl9EQjtcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSB0aGlzLl9jbHVzdGVycztcbiAgICAgICAgbGV0IGNsdXN0ZXJfaW5kZXggPSB0aGlzLl9jbHVzdGVyX2luZGV4ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgREJbaV0gPSB7XG4gICAgICAgICAgICAgICAgXCJlbGVtZW50XCI6IG1hdHJpeC5yb3coaSksXG4gICAgICAgICAgICAgICAgXCJpbmRleFwiOiBpLFxuICAgICAgICAgICAgICAgIFwicmVhY2hhYmlsaXR5X2Rpc3RhbmNlXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcInByb2Nlc3NlZFwiOiBmYWxzZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgREIpIHtcbiAgICAgICAgICAgIGlmIChwLnByb2Nlc3NlZCkgY29udGludWU7XG4gICAgICAgICAgICBwLm5laWdoYm9ycyA9IHRoaXMuX2dldF9uZWlnaGJvcnMocCk7XG4gICAgICAgICAgICBwLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICBjbHVzdGVycy5wdXNoKFtwLmluZGV4XSlcbiAgICAgICAgICAgIGNsdXN0ZXJfaW5kZXggPSBjbHVzdGVycy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgb3JkZXJlZF9saXN0LnB1c2gocCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29yZV9kaXN0YW5jZShwKSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWVkcyA9IG5ldyBIZWFwKG51bGwsIGQgPT4gZC5yZWFjaGFiaWxpdHlfZGlzdGFuY2UsIFwibWluXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKHAsIHNlZWRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRfY2x1c3RlcihzZWVkcywgY2x1c3RlcnNbY2x1c3Rlcl9pbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHAgLSBhIHBvaW50IG9mIHtAbGluayBtYXRyaXh9LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgY29uc2lzdGluZyBvZiB0aGUge0BsaW5rIGVwc2lsb259LW5laWdoYm9yaG9vZCBvZiB7QGxpbmsgcH0uXG4gICAgICovXG4gICAgX2dldF9uZWlnaGJvcnMocCkge1xuICAgICAgICBpZiAoXCJuZWlnaGJvcnNcIiBpbiBwKSByZXR1cm4gcC5uZWlnaGJvcnM7XG4gICAgICAgIGNvbnN0IERCID0gdGhpcy5fREI7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuX2Vwc2lsb247XG4gICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHEgb2YgREIpIHtcbiAgICAgICAgICAgIGlmIChxLmluZGV4ID09IHAuaW5kZXgpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG1ldHJpYyhwLmVsZW1lbnQsIHEuZWxlbWVudCkgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5laWdoYm9ycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwIC0gYSBwb2ludCBvZiB7QGxpbmsgbWF0cml4fS5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZGlzdGFuY2UgdG8gdGhlIHtAbGluayBtaW5fcG9pbnRzfS10aCBuZWFyZXN0IHBvaW50IG9mIHtAbGluayBwfSwgb3IgdW5kZWZpbmVkIGlmIHRoZSB7QGxpbmsgZXBzaWxvbn0tbmVpZ2hib3Job29kIGhhcyBmZXdlciBlbGVtZW50cyB0aGFuIHtAbGluayBtaW5fcG9pbnRzfS5cbiAgICAgKi9cbiAgICBfY29yZV9kaXN0YW5jZShwKSB7XG4gICAgICAgIGNvbnN0IG1pbl9wb2ludHMgPSB0aGlzLl9taW5fcG9pbnRzO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGlmIChwLm5laWdoYm9ycyAmJiBwLm5laWdoYm9ycy5sZW5ndGggPD0gbWluX3BvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0cmljKHAuZWxlbWVudCwgcC5uZWlnaGJvcnNbbWluX3BvaW50c10uZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVhY2hhYmlsaXR5IGRpc3RhbmNlIG9mIHRoZSBwb2ludHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcCBcbiAgICAgKiBAcGFyYW0ge0hlYXB9IHNlZWRzIFxuICAgICAqL1xuICAgIF91cGRhdGUocCwgc2VlZHMpIHtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBjb3JlX2Rpc3RhbmNlID0gdGhpcy5fY29yZV9kaXN0YW5jZShwKTtcbiAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gdGhpcy5fZ2V0X25laWdoYm9ycyhwKTsvL3AubmVpZ2hib3JzO1xuICAgICAgICBmb3IgKGNvbnN0IHEgb2YgbmVpZ2hib3JzKSB7XG4gICAgICAgICAgICBpZiAocS5wcm9jZXNzZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbmV3X3JlYWNoYWJpbGl0eV9kaXN0YW5jZSA9IE1hdGgubWF4KGNvcmVfZGlzdGFuY2UsIG1ldHJpYyhwLmVsZW1lbnQsIHEuZWxlbWVudCkpO1xuICAgICAgICAgICAgLy9pZiAocS5yZWFjaGFiaWxpdHlfZGlzdGFuY2UgPT0gdW5kZWZpbmVkKSB7IC8vIHEgaXMgbm90IGluIHNlZWRzXG4gICAgICAgICAgICBpZiAoc2VlZHMucmF3X2RhdGEoKS5maW5kSW5kZXgoZCA9PiBkLmVsZW1lbnQgPT0gcSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcS5yZWFjaGFiaWxpdHlfZGlzdGFuY2UgPSBuZXdfcmVhY2hhYmlsaXR5X2Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHNlZWRzLnB1c2gocSk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBxIGlzIGluIHNlZWRzXG4gICAgICAgICAgICAgICAgaWYgKG5ld19yZWFjaGFiaWxpdHlfZGlzdGFuY2UgPCBxLnJlYWNoYWJpbGl0eV9kaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBxLnJlYWNoYWJpbGl0eV9kaXN0YW5jZSA9IG5ld19yZWFjaGFiaWxpdHlfZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIHNlZWRzID0gSGVhcC5oZWFwaWZ5KHNlZWRzLmRhdGEoKSwgZCA9PiBkLnJlYWNoYWJpbGl0eV9kaXN0YW5jZSwgXCJtaW5cIik7IC8vIHNlZWRzIGNoYW5nZSBrZXkgPS9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSB7QGxpbmsgY2x1c3Rlcn0gd2l0aCBwb2ludHMgaW4ge0BsaW5rIHNlZWRzfS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SGVhcH0gc2VlZHMgXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2x1c3RlciBcbiAgICAgKi9cbiAgICBfZXhwYW5kX2NsdXN0ZXIoc2VlZHMsIGNsdXN0ZXIpIHtcbiAgICAgICAgY29uc3Qgb3JkZXJlZF9saXN0ID0gdGhpcy5fb3JkZXJlZF9saXN0O1xuICAgICAgICB3aGlsZSAoIXNlZWRzLmVtcHR5KSB7XG4gICAgICAgICAgICBjb25zdCBxID0gc2VlZHMucG9wKCkuZWxlbWVudDtcbiAgICAgICAgICAgIHEubmVpZ2hib3JzID0gdGhpcy5fZ2V0X25laWdoYm9ycyhxKTtcbiAgICAgICAgICAgIHEucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsdXN0ZXIucHVzaChxLmluZGV4KTtcbiAgICAgICAgICAgIG9yZGVyZWRfbGlzdC5wdXNoKHEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvcmVfZGlzdGFuY2UocSkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKHEsIHNlZWRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRfY2x1c3RlcihzZWVkcywgY2x1c3Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNsdXN0ZXJzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IEFycmF5IG9mIGNsdXN0ZXJzIHdpdGggdGhlIGluZGljZXMgb2YgdGhlIHJvd3MgaW4gZ2l2ZW4ge0BsaW5rIG1hdHJpeH0uXG4gICAgICovXG4gICAgZ2V0X2NsdXN0ZXJzKCkge1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9IFtdO1xuICAgICAgICBjb25zdCBvdXRsaWVycyA9IFtdO1xuICAgICAgICBjb25zdCBtaW5fcG9pbnRzID0gdGhpcy5fbWluX3BvaW50cztcbiAgICAgICAgZm9yIChjb25zdCBjbHVzdGVyIG9mIHRoaXMuX2NsdXN0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoY2x1c3Rlci5sZW5ndGggPCBtaW5fcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgb3V0bGllcnMucHVzaCguLi5jbHVzdGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2x1c3RlcnMucHVzaChjbHVzdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbHVzdGVycy5wdXNoKG91dGxpZXJzKTtcbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSwgd2hlcmUgdGhlIGl0aCBlbnRyeSBkZWZpbmVzIHRoZSBjbHVzdGVyIGFmZmlybWF0aW9uIG9mIHRoZSBpdGggcG9pbnQgb2Yge0BsaW5rIG1hdHJpeH0uICgtMSBzdGFuZHMgZm9yIG91dGxpZXIpXG4gICAgICovXG4gICAgZ2V0X2NsdXN0ZXJfYWZmaXJtYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9tYXRyaXguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShOKS5maWxsKCk7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gdGhpcy5nZXRfY2x1c3RlcnMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBjbHVzdGVycy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBjbHVzdGVyc1tpXVxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBjbHVzdGVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IChpIDwgbiAtIDEpID8gaSA6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuaW1wb3J0IHsgTURTIH0gZnJvbSBcIi4vTURTLmpzXCI7XG5pbXBvcnQgeyBLTWVkb2lkcyB9IGZyb20gXCIuLi9jbHVzdGVyaW5nL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQmFsbFRyZWUgfSBmcm9tIFwiLi4va25uL2luZGV4LmpzXCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIExTUFxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIExTUCBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBMU1BcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbayA9IE1hdGgubWF4KE1hdGguZmxvb3IoTiAvIDEwKSwgMildIC0gbnVtYmVyIG9mIG5laWdoYm9ycyB0byBjb25zaWRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbnRyb2xfcG9pbnRzID0gTWF0aC5jZWlsKE1hdGguc3FydChOKSldIC0gbnVtYmVyIG9mIGNvbnRyb2xwb2ludHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2QgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLiAgXG4gICAgICogQHJldHVybnMge0xTUH1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2llZWV4cGxvcmUuaWVlZS5vcmcvZG9jdW1lbnQvNDM3ODM3MH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBrLCBjb250cm9sX3BvaW50cywgZD0yLCBtZXRyaWM9ZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgc3VwZXIoWCwgZCwgbWV0cmljLCBzZWVkKTtcbiAgICAgICAgc3VwZXIucGFyYW1ldGVyX2xpc3QgPSBbXCJrXCIsIFwiY29udHJvbF9wb2ludHNcIl07XG4gICAgICAgIHRoaXMucGFyYW1ldGVyKFwia1wiLCBNYXRoLm1pbihrID8/IE1hdGgubWF4KE1hdGguZmxvb3IodGhpcy5fTiAvIDEwKSwgMiksIHRoaXMuX04gLSAxKSk7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyKFwiY29udHJvbF9wb2ludHNcIiwgTWF0aC5taW4oY29udHJvbF9wb2ludHMgPz8gTWF0aC5jZWlsKE1hdGguc3FydCh0aGlzLl9OKSksIHRoaXMuX04gLSAxKSk7XG4gICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RFJ9IERSIC0gbWV0aG9kIHVzZWQgZm9yIHBvc2l0aW9uIGNvbnRyb2wgcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7RFJfcGFyYW1ldGVyc30gRFJfcGFyYW1ldGVycyAtIGFycmF5IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBmb3IgdGhlIERSIG1ldGhvZCB3aGljaCBwcm9qZWN0cyB0aGUgY29udHJvbCBwb2ludHNcbiAgICAgKiBAcmV0dXJucyB7TFNQfSBcbiAgICAgKi9cbiAgICBpbml0KERSPU1EUywgRFJfcGFyYW1ldGVycz1bXSwgS05OPUJhbGxUcmVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc19pbml0aWFsaXplZCkgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBLID0gdGhpcy5wYXJhbWV0ZXIoXCJrXCIpO1xuICAgICAgICBjb25zdCBkID0gdGhpcy5fZDtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBuYyA9IHRoaXMucGFyYW1ldGVyKFwiY29udHJvbF9wb2ludHNcIik7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xfcG9pbnRzID0gbmV3IEtNZWRvaWRzKFgsIG5jLCBudWxsLCBtZXRyaWMpLmdldF9jbHVzdGVycygpLm1lZG9pZHM7XG4gICAgICAgIGNvbnN0IEMgPSBuZXcgTWF0cml4KG5jLCBOLCBcInplcm9zXCIpXG4gICAgICAgIGNvbnRyb2xfcG9pbnRzLmZvckVhY2goKGNfaSwgaSkgPT4ge1xuICAgICAgICAgICAgQy5zZXRfZW50cnkoaSwgY19pLCAxKTtcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgWV9DID0gbmV3IERSKE1hdHJpeC5mcm9tKGNvbnRyb2xfcG9pbnRzLm1hcChjX2kgPT4gWC5yb3coY19pKSkpLCAuLi5EUl9wYXJhbWV0ZXJzLCBkKS50cmFuc2Zvcm0oKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IFhBID0gWC50bzJkQXJyYXk7XG4gICAgICAgIGNvbnN0IGtubiA9IG5ldyBLTk4oWEEsIG1ldHJpYyk7XG4gICAgICAgIGNvbnN0IEwgPSBuZXcgTWF0cml4KE4sIE4sIFwiSVwiKTtcbiAgICAgICAgY29uc3QgYWxwaGEgPSAtMS9LO1xuICAgICAgICBYQS5mb3JFYWNoKCh4X2ksIGkpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qge1wiaW5kZXhcIjogan0gb2Yga25uLnNlYXJjaCh4X2ksIEspLml0ZXJhdGUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBMLnNldF9lbnRyeShpLCBqLCBhbHBoYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IEEgPSBMLmNvbmNhdChDLCBcInZlcnRpY2FsXCIpO1xuXG4gICAgICAgIGNvbnN0IHogPSBuZXcgTWF0cml4KE4sIGQsIFwiemVyb3NcIik7XG4gICAgICAgIGNvbnN0IGIgPSB6LmNvbmNhdChZX0MsIFwidmVydGljYWxcIik7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9BID0gQTtcbiAgICAgICAgdGhpcy5fYiA9IGI7XG4gICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9BO1xuICAgICAgICBjb25zdCBBVCA9IEEuVFxuICAgICAgICBjb25zdCBiID0gdGhpcy5fYjtcbiAgICAgICAgY29uc3QgQVRBID0gQVQuZG90KEEpO1xuICAgICAgICBjb25zdCBBVGIgPSBBVC5kb3QoYik7XG4gICAgICAgIHRoaXMuWSA9IE1hdHJpeC5zb2x2ZV9DRyhBVEEsIEFUYiwgdGhpcy5fcmFuZG9taXplcik7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxufSAiLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuaW1wb3J0IHsgRGlzam9pbnRTZXQgfSBmcm9tIFwiLi4vZGF0YXN0cnVjdHVyZS9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIFRvcG9NYXBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgVG9wb01hcCBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIFRvcG9NYXBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7VG9wb01hcH1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2FyeGl2Lm9yZy9wZGYvMjAwOS4wMTUxMi5wZGZ9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgZCA9IDIsIG1ldHJpYyA9IGV1Y2xpZGVhbiwgc2VlZCA9IDEyMTIpIHtcbiAgICAgICAgc3VwZXIoWCwgZCwgbWV0cmljLCBzZWVkKTtcbiAgICAgICAgc3VwZXIucGFyYW1ldGVyX2xpc3QgPSBbXTtcbiAgICAgICAgW3RoaXMuX04sIHRoaXMuX0RdID0gdGhpcy5YLnNoYXBlO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZV9tYXRyaXggPSBuZXcgTWF0cml4KHRoaXMuX04sIHRoaXMuX04sIDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fbGF6eV9kaXN0YW5jZV9tYXRyaXgoaSwgaiwgbWV0cmljKSB7XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9kaXN0YW5jZV9tYXRyaXg7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IERfaWogPSBELmVudHJ5KGksIGopO1xuICAgICAgICBpZiAoRF9paiA9PT0gMCkge1xuICAgICAgICAgICAgbGV0IGRpc3QgPSBtZXRyaWMoWC5yb3coaSksIFgucm93KGopKTtcbiAgICAgICAgICAgIEQuc2V0X2VudHJ5KGksIGosIGRpc3QpO1xuICAgICAgICAgICAgRC5zZXRfZW50cnkoaiwgaSwgZGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRF9pajtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSBzcGFubmluZyB0cmVlLCB1c2luZyBhIGdpdmVuIG1ldHJpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0cmljXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS3J1c2thbCUyN3NfYWxnb3JpdGhtfVxuICAgICAqL1xuICAgIF9tYWtlX21pbmltdW1fc3Bhbm5pbmdfdHJlZShtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IFggPSBbLi4udGhpcy5YXTtcblxuICAgICAgICBsZXQgZGlzam9pbnRfc2V0ID0gbmV3IERpc2pvaW50U2V0KFgpO1xuICAgICAgICBjb25zdCBGID0gW107XG4gICAgICAgIGxldCBFID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBFLnB1c2goW2ksIGosIHRoaXMuX19sYXp5X2Rpc3RhbmNlX21hdHJpeChpLCBqLCBtZXRyaWMpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgRSA9IEUuc29ydCgoYSwgYikgPT4gYVsyXSAtIGJbMl0pO1xuXG4gICAgICAgIGZvciAoY29uc3QgW3UsIHYsIHddIG9mIEUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldF91ID0gZGlzam9pbnRfc2V0LmZpbmQoWFt1XSk7XG4gICAgICAgICAgICBjb25zdCBzZXRfdiA9IGRpc2pvaW50X3NldC5maW5kKFhbdl0pO1xuICAgICAgICAgICAgaWYgKHNldF91ICE9PSBzZXRfdikge1xuICAgICAgICAgICAgICAgIEYucHVzaChbdSwgdiwgd10pO1xuICAgICAgICAgICAgICAgIGRpc2pvaW50X3NldC51bmlvbihzZXRfdSwgc2V0X3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEYuc29ydCgoYSwgYikgPT4gYVsyXSAtIGJbMl0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemVzIFRvcG9NYXAuIFNldHMgYWxsIHByb2pjdGVkIHBvaW50cyB0byB6ZXJvLCBhbmQgY29tcHV0ZXMgYSBtaW5pbXVtIHNwYW5uaW5nIHRyZWUuXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5ZID0gbmV3IE1hdHJpeCh0aGlzLl9OLCB0aGlzLl9kLCAwKTtcbiAgICAgICAgdGhpcy5fRW1zdCA9IHRoaXMuX21ha2VfbWluaW11bV9zcGFubmluZ190cmVlKHRoaXMuX21ldHJpYyk7XG4gICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIFBvaW50IEMgaXMgbGVmdCBvZiBsaW5lIEFCLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gUG9pbnRBIC0gUG9pbnQgQSBvZiBsaW5lIEFCXG4gICAgICogQHBhcmFtIHtBcnJheX0gUG9pbnRCIC0gUG9pbnQgQiBvZiBsaW5lIEFCXG4gICAgICogQHBhcmFtIHtBcnJheX0gUG9pbnRDIC0gUG9pbnQgQ1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIF9faHVsbF9jcm9zcyhbYXgsIGF5XSwgW2J4LCBieV0sIFtzeCwgc3ldKSB7XG4gICAgICAgIHJldHVybiAoYnggLSBheCkgKiAoc3kgLSBheSkgLSAoYnkgLSBheSkgKiAoc3ggLSBheCkgPD0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgY29udmV4IGh1bGwgb2YgdGhlIHNldCBvZiBQb2ludHMgU1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gUyAtIFNldCBvZiBQb2ludHMuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQWxnb3JpdGhtX0ltcGxlbWVudGF0aW9uL0dlb21ldHJ5L0NvbnZleF9odWxsL01vbm90b25lX2NoYWluI0phdmFTY3JpcHR9XG4gICAgICogQHJldHVybnMge0FycmF5fSBjb252ZXggaHVsbCBvZiBTLiBTdGFydHMgYXQgdGhlIGJvdHRvbS1tb3N0IHBvaW50IGFuZCBjb250aW51ZXMgY291bnRlci1jbG9ja3dpc2UuXG4gICAgICovXG4gICAgX19odWxsKFMpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gUy5zb3J0KChbeDEsIHkxXSwgW3gyLCB5Ml0pID0+IHkxIC0geTIgfHwgeDEgLSB4Mik7XG4gICAgICAgIGNvbnN0IE4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAoTiA8PSAyKSByZXR1cm4gcG9pbnRzO1xuXG4gICAgICAgIGNvbnN0IGxvd2VyID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICB3aGlsZSAobG93ZXIubGVuZ3RoID49IDIgJiYgdGhpcy5fX2h1bGxfY3Jvc3MobG93ZXJbbG93ZXIubGVuZ3RoIC0gMl0sIGxvd2VyW2xvd2VyLmxlbmd0aCAtIDFdLCBwb2ludHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgbG93ZXIucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb3dlci5wdXNoKHBvaW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBwZXIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IE4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgd2hpbGUgKHVwcGVyLmxlbmd0aCA+PSAyICYmIHRoaXMuX19odWxsX2Nyb3NzKHVwcGVyW3VwcGVyLmxlbmd0aCAtIDJdLCB1cHBlclt1cHBlci5sZW5ndGggLSAxXSwgcG9pbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgIHVwcGVyLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBwZXIucHVzaChwb2ludHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHVwcGVyLnBvcCgpO1xuICAgICAgICBsb3dlci5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyLmNvbmNhdCh1cHBlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGFuZ2xlIHRvIHJvdGF0ZSBQb2ludCBBIGFuZCBCIHRvIGxpZSBvbiBhIGxpbmUgcGFyYWxsZWwgdG8gdGhlIHgtYXhpcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFBvaW50QVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFBvaW50QlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNpbnVzLSBhbmQgY29zaW51cy12YWx1ZXMgZm9yIGEgcm90YXRpb24uXG4gICAgICovXG4gICAgX19maW5kQW5nbGUoW3AxeCwgcDF5XSwgW3AyeCwgcDJ5XSkge1xuICAgICAgICBjb25zdCBuID0gZXVjbGlkZWFuKFtwMXgsIHAxeV0sIFtwMngsIHAyeV0pO1xuICAgICAgICBpZiAobiA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2luOiAwLFxuICAgICAgICAgICAgICAgIGNvczogMSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZlYyA9IFsocDJ4IC0gcDF4KSAvIG4sIChwMnkgLSBwMXkpIC8gbl07XG4gICAgICAgIGNvbnN0IGNvcyA9IHZlY1swXTtcbiAgICAgICAgbGV0IHNpbiA9IE1hdGguc3FydCgxIC0gY29zICogY29zKTtcbiAgICAgICAgc2luID0gdmVjWzFdID49IDAgPyAtc2luIDogc2luO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2luOiBzaW4sXG4gICAgICAgICAgICBjb3M6IGNvcyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGh1bGxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwXG4gICAgICogQHBhcmFtIHtCb29sfSB0b3BFZGdlXG4gICAgICovXG4gICAgX19hbGlnbl9odWxsKGh1bGwsIHAsIHRvcEVkZ2UpIHtcbiAgICAgICAgbGV0IHYgPSAtMTtcbiAgICAgICAgbGV0IGQyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGh1bGwubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBldWNsaWRlYW4oaHVsbFtpXSwgcCk7XG4gICAgICAgICAgICBpZiAodiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkMiA9IGQ7XG4gICAgICAgICAgICAgICAgdiA9IGk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkMiA+IGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZDIgPSBkO1xuICAgICAgICAgICAgICAgICAgICB2ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdjE7XG4gICAgICAgIGxldCB2MjtcbiAgICAgICAgaWYgKHRvcEVkZ2UpIHtcbiAgICAgICAgICAgIHYxID0gaHVsbFt2XTtcbiAgICAgICAgICAgIHYyID0gaHVsbFsodiArIDEpICUgaHVsbC5sZW5ndGhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHYgPT0gMCkgdiA9IGh1bGwubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHYxID0gaHVsbFt2XTtcbiAgICAgICAgICAgIHYyID0gaHVsbFsodiAtIDEpICUgaHVsbC5sZW5ndGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHJhbnNmb3JtYXRpb24gPSB7XG4gICAgICAgICAgICB0eDogLWh1bGxbdl1bMF0sXG4gICAgICAgICAgICB0eTogLWh1bGxbdl1bMV0sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGh1bGwubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2luLCBjb3MgfSA9IHRoaXMuX19maW5kQW5nbGUodjEsIHYyKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uLnNpbiA9IHNpbjtcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uLmNvcyA9IGNvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uLnNpbiA9IDA7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbi5jb3MgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gUG9pbnQgLSBUaGUgcG9pbnQgd2hpY2ggc2hvdWxkIGdldCB0cmFuc2Zvcm1lZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gVHJhbnNmb3JtYXRpb24gLSBjb250YWlucyB0aGUgdmFsdWVzIGZvciB0cmFuc2xhdGlvbiBhbmQgcm90YXRpb24uXG4gICAgICovXG4gICAgX190cmFuc2Zvcm0oW3B4LCBweV0sIHsgdHgsIHR5LCBzaW4sIGNvcyB9KSB7XG4gICAgICAgIGxldCB4ID0gcHggKyB0eDtcbiAgICAgICAgbGV0IHkgPSBweSArIHR5O1xuICAgICAgICBsZXQgeHggPSB4ICogY29zIC0geSAqIHNpbjtcbiAgICAgICAgbGV0IHl5ID0geCAqIHNpbiArIHkgKiBjb3M7XG4gICAgICAgIHJldHVybiBbeHgsIHl5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB7QGxpbmsgX190cmFuc2Zvcm19IGZvciBlYWNoIHBvaW50IGluIFNldCBDXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBDIC0gU2V0IG9mIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdCAtIFRyYW5zZm9ybSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlPZmZzZXQgLSB2YWx1ZSB0byBvZmZzZXQgc2V0IEMuXG4gICAgICovXG4gICAgX190cmFuc2Zvcm1fY29tcG9uZW50KEMsIHQsIHlPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgTiA9IEMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYyA9IENbaV07XG4gICAgICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuX190cmFuc2Zvcm0oYywgdCk7XG4gICAgICAgICAgICBjWzBdID0gY3g7XG4gICAgICAgICAgICBjWzFdID0gY3kgKyB5T2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB1IC0gcG9pbnQgdVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHYgLSBwb2ludCB2XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHcgLSBlZGdlIHdlaWdodCB3XG4gICAgICovXG4gICAgX19hbGlnbl9jb21wb25lbnRzKHUsIHYsIHcpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzX3UgPSBbLi4udS5fX2Rpc2pvaW50X3NldC5jaGlsZHJlbl07XG4gICAgICAgIGNvbnN0IHBvaW50c192ID0gWy4uLnYuX19kaXNqb2ludF9zZXQuY2hpbGRyZW5dO1xuXG4gICAgICAgIGNvbnN0IGh1bGxfdSA9IHRoaXMuX19odWxsKHBvaW50c191KTtcbiAgICAgICAgY29uc3QgaHVsbF92ID0gdGhpcy5fX2h1bGwocG9pbnRzX3YpO1xuXG4gICAgICAgIGNvbnN0IHRfdSA9IHRoaXMuX19hbGlnbl9odWxsKGh1bGxfdSwgdSwgZmFsc2UpO1xuICAgICAgICBjb25zdCB0X3YgPSB0aGlzLl9fYWxpZ25faHVsbChodWxsX3YsIHYsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX190cmFuc2Zvcm1fY29tcG9uZW50KHBvaW50c191LCB0X3UsIDApO1xuICAgICAgICB0aGlzLl9fdHJhbnNmb3JtX2NvbXBvbmVudChwb2ludHNfdiwgdF92LCB3KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuc2lvbmFsaXR5IDIuXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzX2luaXRpYWxpemVkKSB0aGlzLmluaXQoKTtcbiAgICAgICAgY29uc3QgRW1zdCA9IHRoaXMuX0Vtc3Q7XG4gICAgICAgIGNvbnN0IFkgPSBbLi4udGhpcy5ZXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IG5ldyBEaXNqb2ludFNldChcbiAgICAgICAgICAgIFkubWFwKCh5LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgeS5pID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChjb25zdCBbdSwgdiwgd10gb2YgRW1zdCkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50X3UgPSBjb21wb25lbnRzLmZpbmQoWVt1XSk7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRfdiA9IGNvbXBvbmVudHMuZmluZChZW3ZdKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRfdSA9PT0gY29tcG9uZW50X3YpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5fX2FsaWduX2NvbXBvbmVudHMoY29tcG9uZW50X3UsIGNvbXBvbmVudF92LCB3KTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMudW5pb24oY29tcG9uZW50X3UsIGNvbXBvbmVudF92KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgICpnZW5lcmF0b3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNfaW5pdGlhbGl6ZWQpIHRoaXMuaW5pdCgpO1xuICAgICAgICBjb25zdCBFbXN0ID0gdGhpcy5fRW1zdDtcbiAgICAgICAgY29uc3QgWSA9IFsuLi50aGlzLlldO1xuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gbmV3IERpc2pvaW50U2V0KFxuICAgICAgICAgICAgWS5tYXAoKHksIGkpID0+IHtcbiAgICAgICAgICAgICAgICB5LmkgPSBpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGNvbnN0IFt1LCB2LCB3XSBvZiBFbXN0KSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRfdSA9IGNvbXBvbmVudHMuZmluZChZW3VdKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudF92ID0gY29tcG9uZW50cy5maW5kKFlbdl0pO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudF91ID09PSBjb21wb25lbnRfdikgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLl9fYWxpZ25fY29tcG9uZW50cyhjb21wb25lbnRfdSwgY29tcG9uZW50X3YsIHcpO1xuICAgICAgICAgICAgY29tcG9uZW50cy51bmlvbihjb21wb25lbnRfdSwgY29tcG9uZW50X3YpO1xuICAgICAgICAgICAgLyogbGV0IG9rID0gdHJ1ZVxuICAgICAgICAgICAgWS5mb3JFYWNoKChbeCwgeV0pID0+IG9rID0gb2sgJiYgIWlzTmFOKHgpICYmICFpc05hTih5KSlcbiAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyguLi5ZKSBcbiAgICAgICAgICAgICAgICB0aHJvdyBcImVycm9yXCIgXG4gICAgICAgICAgICB9ICovXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnByb2plY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgYXMgRGltUmVkfSBmcm9tIFwiLi9EUi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIFNBTU1PTlxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIFNBTU1PTiBleHRlbmRzIERpbVJlZCB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgU0FNTU9OXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2QgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLiAgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWVkID0gMTIxMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHJldHVybnMge1NBTU1PTn1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2FyeGl2Lm9yZy9wZGYvMjAwOS4wMTUxMi5wZGZ9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgbWFnaWM9MC4xLCBkPTIsIG1ldHJpYz1ldWNsaWRlYW4sIHNlZWQ9MTIxMikge1xuICAgICAgICBzdXBlcihYLCBkLCBtZXRyaWMsIHNlZWQpXG4gICAgICAgIHN1cGVyLnBhcmFtZXRlcl9saXN0ID0gW1wibWFnaWNcIl07XG4gICAgICAgIHRoaXMucGFyYW1ldGVyKFwibWFnaWNcIiwgbWFnaWMpO1xuICAgICAgICBbIHRoaXMuX04sIHRoaXMuX0QgXSA9IHRoaXMuWC5zaGFwZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZXMgU0FNTU9OLiBTZXRzIGFsbCBwcm9qY3RlZCBwb2ludHMgdG8gemVybywgYW5kIGNvbXB1dGVzIGEgbWluaW11bSBzcGFubmluZyB0cmVlLlxuICAgICAqL1xuICAgIGluaXQoRFI9XCJyYW5kb21cIiwgZGlzdGFuY2VfbWF0cml4PW51bGwpIHtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLl9kO1xuXG4gICAgICAgIGlmIChEUiA9PT0gXCJyYW5kb21cIikge1xuICAgICAgICAgICAgY29uc3QgcmFuZG9taXplciA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgICAgICB0aGlzLlkgPSBuZXcgTWF0cml4KE4sIGQsICgpID0+IHJhbmRvbWl6ZXIucmFuZG9tKTtcbiAgICAgICAgfSBlbHNlIGlmIChEUiBpbnN0YW5jZW9mIERpbVJlZCkge1xuICAgICAgICAgICAgdGhpcy5ZID0gRFIudHJhbnNmb3JtKHRoaXMuWCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXN0YW5jZV9tYXRyaXggPSBkaXN0YW5jZV9tYXRyaXggfHwgdGhpcy5fX2Rpc3RhbmNlX21hdHJpeCh0aGlzLlgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBBXG4gICAgICogQHJldHVybnMge01hdHJpeH0gXG4gICAgICovXG4gICAgX19kaXN0YW5jZV9tYXRyaXgoQSkge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IE4gPSBBLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBEID0gbmV3IE1hdHJpeChOLCBOKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IEFfaSA9IEEucm93KGkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSAoaSA9PT0gaiA/IDAgOiBtZXRyaWMoQV9pLCBBLnJvdyhqKSkpO1xuICAgICAgICAgICAgICAgIEQuc2V0X2VudHJ5KGksIGosIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBELnNldF9lbnRyeShqLCBpLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEQ7ICAgICAgICAgICAgICAgIFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0ZGF0YSB7QGxpbmsgWH0gdG8gZGltZW5pb25hbGl0eSAyLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybShtYXhfaXRlcj0yMDApIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc19pbml0aWFsaXplZCkgdGhpcy5pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF4X2l0ZXI7ICsraikge1xuICAgICAgICAgICAgdGhpcy5fc3RlcCgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICAqIGdlbmVyYXRvcihtYXhfaXRlcj0yMDApIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc19pbml0aWFsaXplZCkgdGhpcy5pbml0KCk7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXhfaXRlcjsgKytqKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGVwKClcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucHJvamVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgX3N0ZXAoKSB7XG4gICAgICAgIGNvbnN0IE1BR0lDID0gdGhpcy5wYXJhbWV0ZXIoXCJtYWdpY1wiKTtcbiAgICAgICAgY29uc3QgRCA9IHRoaXMuZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuX2Q7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgbGV0IFkgPSB0aGlzLlk7XG4gICAgICAgIFxuICAgICAgICBsZXQgRyA9IG5ldyBNYXRyaXgoTiwgZCwgMCk7XG5cbiAgICAgICAgbGV0IHN1bSA9IG5ldyBGbG9hdDY0QXJyYXkoZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBsZXQgZTEgPSBuZXcgRmxvYXQ2NEFycmF5KGQpO1xuICAgICAgICAgICAgbGV0IGUyID0gbmV3IEZsb2F0NjRBcnJheShkKTtcbiAgICAgICAgICAgIGNvbnN0IFlpID0gWS5yb3coaSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBZaiA9IFkucm93KGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gbmV3IEZsb2F0NjRBcnJheShkKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGQ7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVtrXSA9IFlpW2tdIC0gWWpba11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZFkgPSBtZXRyaWMoWWksIFlqKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkWCA9IEQuZW50cnkoaSwgaik7XG4gICAgICAgICAgICAgICAgY29uc3QgZHEgPSBkWCAtIGRZO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRyID0gTWF0aC5tYXgoZFggKiBkWSwgMWUtMik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgZTFba10gKz0gZGVsdGFba10gKiBkcSAvIGRyO1xuICAgICAgICAgICAgICAgICAgICBlMltrXSArPSAoZHEgLSBNYXRoLnBvdyhkZWx0YVtrXSwgMikgKiAoMSArIGRxIC8gZFkpIC8gZFkpIC8gZHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkOyArK2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBZLmVudHJ5KGksIGspICsgKE1BR0lDICogZTFba10gLyBNYXRoLmFicyhlMltrXSkgfHwgMCk7XG4gICAgICAgICAgICAgICAgRy5zZXRfZW50cnkoaSwgaywgdmFsKTtcbiAgICAgICAgICAgICAgICBzdW1ba10gKz0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZDsgKytrKSB7XG4gICAgICAgICAgICBzdW1ba10gLz0gTjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGQ7ICsraykge1xuICAgICAgICAgICAgICAgIFkuc2V0X2VudHJ5KGksIGssIEcuZW50cnkoaSwgaykgLSBzdW1ba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBZO1xuICAgIH1cbn0gIl0sIm5hbWVzIjpbImEiLCJiIiwiTWF0aCIsInNxcnQiLCJldWNsaWRlYW5fc3F1YXJlZCIsInN1bW1hbmRzIiwieSIsInQiLCJuIiwibGVuZ3RoIiwic3VtIiwiY29tcGVuc2F0aW9uIiwiaSIsInN1bW1hbmQiLCJhYnMiLCJzIiwiQXJyYXkiLCJ4IiwibmV1bWFpcl9zdW0iLCJzdW1fYSIsInN1bV9iIiwiYWNvcyIsInJlcyIsInB1c2giLCJtYXgiLCJudW1fbm9uX3plcm8iLCJudW1fZXF1YWwiLCJkaXNhZ3JlZSIsIm51bV9ub3RfZXF1YWwiLCJudW1fdHJ1ZV90cnVlIiwibnVtX3RydWVfZmFsc2UiLCJudW1fZmFsc2VfdHJ1ZSIsIkEiLCJrIiwiZGlzdGFuY2VfbWF0cml4IiwibWV0cmljIiwiZXVjbGlkZWFuIiwicm93cyIsInNoYXBlIiwiRCIsImRtYXRyaXgiLCJuTiIsInJvdyIsImZyb20iLCJtYXAiLCJkaXN0YW5jZSIsImNvbCIsImoiLCJzb3J0Iiwic2xpY2UiLCJNYXRyaXgiLCJjb25zdHJ1Y3RvciIsImNvbHMiLCJ2YWx1ZSIsInRoaXMiLCJfcm93cyIsIl9jb2xzIiwiX2RhdGEiLCJGbG9hdDY0QXJyYXkiLCJzdGF0aWMiLCJ0eXBlIiwiY2xvbmUiLCJpc0FycmF5IiwiRXJyb3IiLCJtIiwiXyIsImRhdGEiLCJ2YWx1ZXMiLCJzdWJhcnJheSIsIml0ZXJhdGVfcm93cyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwic2V0X3JvdyIsIm9mZnNldCIsInJlc3VsdF9jb2wiLCJlbnRyeSIsInNldF9lbnRyeSIsInRyYW5zcG9zZSIsIlQiLCJpbnZlcnNlIiwiQiIsImgiLCJpX21heCIsIm1heF92YWwiLCJJbmZpbml0eSIsInZhbCIsImhfdmFsIiwiaV92YWwiLCJmIiwiQl9yb3dfcm93IiwiQl9pX2oiLCJkb3QiLCJqb2luIiwiSSIsIkFfaSIsIkJfaSIsIkMiLCJlIiwib3V0ZXIiLCJsIiwiY29uY2F0Iiwicm93c19BIiwiY29sc19BIiwicm93c19CIiwiY29sc19CIiwiWCIsInNldF9ibG9jayIsIm9mZnNldF9yb3ciLCJvZmZzZXRfY29sIiwiZ2V0X2Jsb2NrIiwic3RhcnRfcm93Iiwic3RhcnRfY29sIiwiZW5kX3JvdyIsImVuZF9jb2wiLCJuZXdfcm93IiwibmV3X2NvbCIsImdhdGhlciIsInJvd19pbmRpY2VzIiwiY29sX2luZGljZXMiLCJOIiwiUiIsInJvd19pbmRleCIsImNvbF9pbmRleCIsIl9hcHBseV9hcnJheSIsInYiLCJfYXBwbHlfcm93d2lzZV9hcnJheSIsIl9hcHBseV9jb2x3aXNlX2FycmF5IiwiX2FwcGx5IiwidmFsdWVfcm93cyIsInZhbHVlX2NvbHMiLCJtdWx0IiwiZGl2aWRlIiwiYWRkIiwic3ViIiwidG8yZEFycmF5IiwicmVzdWx0IiwiYXNBcnJheSIsImRpYWciLCJtaW5fcm93X2NvbCIsIm1pbiIsIm1lYW4iLCJtZWFuUm93cyIsIm1lYW5Db2xzIiwicmFuZG9taXplciIsInRvbCIsIlJhbmRvbWl6ZXIiLCJiX2kiLCJyYW5kb20iLCJyIiwiZCIsInoiLCJhbHBoYSIsInJfbmV4dCIsImJldGEiLCJMIiwiVSIsIkxVIiwiTF9kaWFnIiwiVV9kaWFnIiwiZGV0IiwiTSIsIk1UIiwiTXRNIiwiTU10IiwiZWlnZW52ZWN0b3JzIiwiViIsImVpZ2VudmFsdWVzIiwiU2lnbWEiLCJzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24iLCJzaWdtYSIsImRpc3QiLCJzdGFydCIsImVuZCIsIm51bWJlciIsInJvdW5kIiwidmVjdG9yIiwiZmlsbCIsIl9zZWVkIiwiX04iLCJfTSIsIl9NQVRSSVhfQSIsIl9VUFBFUl9NQVNLIiwiX0xPV0VSX01BU0siLCJfbXQiLCJfbXRpIiwic2VlZCIsIkRhdGUiLCJnZXRUaW1lIiwibXQiLCJtdGkiLCJyYW5kb21faW50IiwibWFnMDEiLCJrayIsIk5fTSIsIk1fTiIsImNob2ljZSIsInNhbXBsZSIsImluZGV4X2xpc3QiLCJsaW5zcGFjZSIsInJhbmRvbV9pbmRleCIsInNwbGljZSIsInVuZGVmaW5lZCIsIkhlYXAiLCJlbGVtZW50cyIsImFjY2Vzc29yIiwiY29tcGFyYXRvciIsImhlYXBpZnkiLCJfYWNjZXNzb3IiLCJfY29udGFpbmVyIiwiX2NvbXBhcmF0b3IiLCJoZWFwIiwiY29udGFpbmVyIiwiZWxlbWVudCIsImZsb29yIiwiX2hlYXBpZnlfZG93biIsIl9zd2FwIiwiaW5kZXhfYSIsImluZGV4X2IiLCJfaGVhcGlmeV91cCIsImluZGV4IiwicGFyZW50SW5kZXgiLCJub2RlIiwic3RhcnRfaW5kZXgiLCJsZWZ0IiwicmlnaHQiLCJwb3AiLCJpdGVtIiwiZmlyc3QiLCJpdGVyYXRlIiwidG9BcnJheSIsInJhd19kYXRhIiwiZW1wdHkiLCJEaXNqb2ludFNldCIsIl9saXN0IiwiU2V0IiwibWFrZV9zZXQiLCJsaXN0IiwiaGFzIiwiX19kaXNqb2ludF9zZXQiLCJwYXJlbnQiLCJjaGlsZHJlbiIsInNpemUiLCJmaW5kIiwidW5pb24iLCJub2RlX3giLCJub2RlX3kiLCJmb3JFYWNoIiwiQmFsbFRyZWUiLCJfTm9kZSIsInBpdm90IiwiY2hpbGQxIiwiY2hpbGQyIiwicmFkaXVzIiwiX0xlYWYiLCJwb2ludHMiLCJfbWV0cmljIiwiX3Jvb3QiLCJfY29uc3RydWN0IiwiYyIsIl9ncmVhdGVzdF9zcHJlYWQiLCJzb3J0ZWRfZWxlbWVudHMiLCJwX2luZGV4IiwicCIsInNwcmVhZCIsInJlZHVjZSIsImFjYyIsImN1cnJlbnQiLCJzZWFyY2giLCJfc2VhcmNoIiwiUSIsIktOTiIsIl9lbGVtZW50cyIsIl9EIiwiZGlzdGFuY2VzIiwiSCIsIm5lYXJlc3RfZWxlbWVudF9pbmRleCIsIm5lYXJlc3RfZGlzdCIsIk51bWJlciIsImlzSW50ZWdlciIsInEiLCJxX2RvdF92IiwicV8iLCJ2XyIsInZfbm9ybSIsIm5vcm0iLCJtYXhfaXRlcmF0aW9ucyIsInFyIiwib2xkUiIsIlFSIiwiRFIiLCJwYXJhbWV0ZXJfbGlzdCIsIl9wYXJhbWV0ZXJfbGlzdCIsIl90eXBlIiwiX2QiLCJfcmFuZG9taXplciIsIl9pc19pbml0aWFsaXplZCIsInBhcmFtZXRlciIsIm5hbWUiLCJpbmNsdWRlcyIsInBhcmEiLCJ0cmFuc2Zvcm0iLCJjaGVja19pbml0IiwicHJvamVjdGlvbiIsImdlbmVyYXRvciIsImluaXQiLCJZIiwiYXN5bmMiLCJhcmdzIiwiZ2VuIiwiUENBIiwic3VwZXIiLCJwcmluY2lwYWxfY29tcG9uZW50cyIsIm1lYW5zIiwiWF9jZW50IiwiTURTIiwiYWlfIiwiYV9qIiwiYV9fIiwiX2RfWCIsInN0cmVzcyIsImRfWCIsImRfWSIsInRvcF9zdW0iLCJib3R0b21fc3VtIiwicG93IiwiSVNPTUFQIiwibmVpZ2hib3JzIiwia05lYXJlc3ROZWlnaGJvcnMiLCJfayIsIkciLCJvdGhlciIsIkZBU1RNQVAiLCJfY2hvb3NlX2Rpc3RhbnRfb2JqZWN0cyIsImFfaW5kZXgiLCJiX2luZGV4IiwibWF4X2Rpc3QiLCJkX2FpIiwiZF9iaSIsIl9jb2wiLCJvbGRfZGlzdCIsImRfYWIiLCJ5X2kiLCJMREEiLCJsYWJlbHMiLCJfbGFiZWxzIiwidW5pcXVlX2xhYmVscyIsImxhYmVsX2lkIiwiY291bnQiLCJpZCIsIlhfbWVhbiIsIlZfbWVhbiIsImxhYmVsIiwidl9tZWFuIiwiU19iIiwiU193Iiwicm93X3YiLCJMTEUiLCJrX25lYXJlc3RfbmVpZ2hib3JzIiwiTyIsIlciLCJuTl9yb3ciLCJaIiwiQ190cmFjZSIsInciLCJzb2x2ZV9DRyIsIklXIiwiTFRTQSIsIklfaSIsIlhfaSIsImciLCJHX2lfdCIsIldfaSIsIlRTTkUiLCJwZXJwbGV4aXR5IiwiZXBzaWxvbiIsIl9pdGVyIiwiSHRhcmdldCIsImxvZyIsIl9wZXJwbGV4aXR5IiwiRGVsdGEiLCJQIiwiX3lzdGVwIiwiX2dhaW5zIiwicHJvdyIsImJldGFtaW4iLCJiZXRhbWF4IiwiZG9uZSIsIm51bSIsInBzdW0iLCJwaiIsImV4cCIsIkhoZXJlIiwiUG91dCIsIk4yIiwiX1AiLCJpdGVyYXRpb25zIiwibmV4dCIsIml0ZXIiLCJ5c3RlcCIsImdhaW5zIiwiX2Vwc2lsb24iLCJkaW0iLCJwbXVsIiwiUXUiLCJxc3VtIiwiZHN1bSIsImRoZXJlIiwicXUiLCJncmFkIiwicHJlbXVsdCIsInltZWFuIiwiZ2lkIiwic2lkIiwiZ2FpbmlkIiwibmV3Z2FpbiIsInNpZ24iLCJuZXdzaWQiLCJ4MCIsIm1heF9pdGVyIiwicGZ4IiwiZngiLCJjb252ZXJnZW5jZSIsImZ4aSIsImR4IiwiVU1BUCIsIm5fbmVpZ2hib3JzIiwibG9jYWxfY29ubmVjdGl2aXR5IiwibWluX2Rpc3QiLCJfc3ByZWFkIiwiX3NldF9vcF9taXhfcmF0aW8iLCJfcmVwdWxzaW9uX3N0cmVuZ3RoIiwiX25lZ2F0aXZlX3NhbXBsZV9yYXRlIiwiX25fZXBvY2hzIiwiX2luaXRpYWxfYWxwaGEiLCJfZmluZF9hYl9wYXJhbXMiLCJ4diIsInl2IiwieHZfaSIsInBvd2VsbCIsImVycm9yIiwiX2NvbXB1dGVfbWVtYmVyc2hpcF9zdHJlbmd0aHMiLCJzaWdtYXMiLCJyaG9zIiwiX3Ntb290aF9rbm5fZGlzdCIsImtubiIsIlNNT09USF9LX1RPTEVSQU5DRSIsIk1JTl9LX0RJU1RfU0NBTEUiLCJfbG9jYWxfY29ubmVjdGl2aXR5IiwidGFyZ2V0IiwibG9nMiIsInJldmVyc2UiLCJ4X2kiLCJsbyIsImhpIiwibWlkIiwic2VhcmNoX3Jlc3VsdCIsIm5vbl96ZXJvX2Rpc3QiLCJmaWx0ZXIiLCJub25femVyb19kaXN0X2xlbmd0aCIsImludGVycG9sYXRpb24iLCJtZWFuX2l0aGQiLCJtZWFuX2QiLCJfZnV6enlfc2ltcGxpY2lhbF9zZXQiLCJkaXN0YW5jZXNfaSIsInRyYW5zcG9zZWRfcmVzdWx0IiwicHJvZF9tYXRyaXgiLCJfbWFrZV9lcG9jaHNfcGVyX3NhbXBsZSIsIm5fZXBvY2hzIiwid2VpZ2h0cyIsIl93ZWlnaHRzIiwiRmxvYXQzMkFycmF5Iiwid2VpZ2h0c19tYXgiLCJuX3NhbXBsZXMiLCJfdG9jb28iLCJncmFwaCIsInJvd3NfbiIsImNvbHNfbiIsIl9taW5fZGlzdCIsIl9hIiwiX2IiLCJfZ3JhcGgiLCJfbl9uZWlnaGJvcnMiLCJfaGVhZCIsIl90YWlsIiwiX2Vwb2Noc19wZXJfc2FtcGxlIiwiX2Vwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlIiwiX2Vwb2NoX29mX25leHRfc2FtcGxlIiwiX2Vwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlIiwiX2NsaXAiLCJfb3B0aW1pemVfbGF5b3V0IiwiaGVhZF9lbWJlZGRpbmciLCJ0YWlsX2VtYmVkZGluZyIsImhlYWQiLCJ0YWlsIiwiX2FscGhhIiwicmVwdWxzaW9uX3N0cmVuZ3RoIiwiZXBvY2hzX3Blcl9zYW1wbGUiLCJlcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZSIsImVwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlIiwiZXBvY2hfb2ZfbmV4dF9zYW1wbGUiLCJjbGlwIiwidGFpbF9sZW5ndGgiLCJncmFkX2NvZWZmIiwiZ3JhZF9kIiwibyIsIm5fbmVnX3NhbXBsZXMiLCJUcmlNYXAiLCJ3ZWlnaHRfYWRqIiwicGNhIiwiX2MiLCJuX2lubGllcnMiLCJuX291dGxpZXJzIiwibl9yYW5kb20iLCJ0cmlwbGV0cyIsIl9nZW5lcmF0ZV90cmlwbGV0cyIsImxyIiwidmVsIiwiZ2FpbiIsIl93ZWlnaHRfYWRqIiwibl9leHRyYSIsIm5icnMiLCJrbm5fZGlzdGFuY2VzIiwic2lnIiwiX2ZpbmRfcCIsIl9zYW1wbGVfa25uX3RyaXBsZXRzIiwibl90cmlwbGV0cyIsIm91dGxpZXJfZGlzdGFuY2VzIiwiX2ZpbmRfd2VpZ2h0cyIsInJhbmRvbV90cmlwbGV0cyIsInJhbmRvbV93ZWlnaHRzIiwiX3NhbXBsZV9yYW5kb21fdHJpcGxldHMiLCJtYXhfd2VpZ2h0IiwiaXNOYU4iLCJtYXhfd2VpZ2h0XzIiLCJuX2kiLCJzb3J0X2luZGljZXMiLCJfX2FyZ3NvcnQiLCJuX2oiLCJzaW0iLCJzYW1wbGVzIiwiX3JlamVjdGlvbl9zYW1wbGUiLCJvdXQiLCJtYXhfaW50IiwicmVqZWN0cyIsImludGVydmFsIiwiaW5kZXhPZiIsInBfc2ltIiwicF9vdXQiLCJpbmRpY2VzIiwiX2dyYWQiLCJ5X2lqIiwieV9payIsImRfaWoiLCJkX2lrIiwibl92aW9sIiwibG9zcyIsIm5fa25uX3RyaXBsZXRzIiwiWV9pZCIsIllfamQiLCJZX2tkIiwiZ3MiLCJnbyIsIm1heF9pdGVyYXRpb24iLCJfbmV4dCIsImdhbW1hIiwib2xkX0MiLCJfdXBkYXRlX2VtYmVkZGluZyIsIm5ld19nYWluIiwiSGllcmFyY2hpY2FsX0NsdXN0ZXJpbmciLCJtYXRyaXgiLCJsaW5rYWdlIiwiX2lkIiwiX21hdHJpeCIsIl9saW5rYWdlIiwicm9vdCIsImRvIiwiZ2V0X2NsdXN0ZXJzIiwiY2x1c3RlcnMiLCJkZXB0aCIsIl90cmF2ZXJzZSIsImxlYXZlcyIsIl9uIiwiZF9taW4iLCJfZF9taW4iLCJfZGlzdGFuY2VfbWF0cml4IiwiX2NsdXN0ZXJzIiwiY19zaXplIiwiX2Nfc2l6ZSIsIlVpbnQxNkFycmF5IiwiQ2x1c3RlciIsInBfbWF4IiwiYzEiLCJEX2lfbWluIiwiYzIiLCJjMV9jbHVzdGVyIiwiYzJfY2x1c3RlciIsImMxX2NsdXN0ZXJfaW5kaWNlcyIsImlzTGVhZiIsImMyX2NsdXN0ZXJfaW5kaWNlcyIsIm5ld19jbHVzdGVyIiwidW5zaGlmdCIsIkRfYzFfaiIsIkRfYzJfaiIsImNlbnRyb2lkIiwiX2NhbGN1bGF0ZV9jZW50cm9pZCIsImxfc2l6ZSIsInJfc2l6ZSIsImxfY2VudHJvaWQiLCJyX2NlbnRyb2lkIiwibmV3X2NlbnRyb2lkIiwiZGVzY2VuZGFudHMiLCJsZWZ0X2Rlc2NlbmRhbnRzIiwicmlnaHRfZGVzY2VuZGFudHMiLCJLTWVhbnMiLCJLIiwiX0siLCJfY2x1c3Rlcl9jZW50cm9pZHMiLCJfZ2V0X3JhbmRvbV9jZW50cm9pZHMiLCJfZnVydGhlc3RfcG9pbnQiLCJjYW5kaWRhdGVzIiwiQWQiLCJjbHVzdGVyX2NlbnRyb2lkcyIsInJhbmRvbV9wb2ludCIsImluaXRfcG9pbnRzIiwic2FtcGxlX3NpemUiLCJmdXJ0aGVzdF9wb2ludCIsIl9pdGVyYXRpb24iLCJjbHVzdGVyc19jaGFuZ2VkIiwiQWkiLCJtaW5fY2x1c3RlciIsIl9jb21wdXRlX2NlbnRyb2lkIiwiY2x1c3Rlcl9jb3VudGVyIiwiY2kiLCJpdGVyYXRpb25fcmVzdWx0IiwiS01lZG9pZHMiLCJfQSIsIl9tYXhfaXRlciIsImxvZzEwIiwiX2NsdXN0ZXJfbWVkb2lkcyIsIl9nZXRfcmFuZG9tX21lZG9pZHMiLCJ4X2oiLCJfbmVhcmVzdF9tZWRvaWQiLCJpbmRleF9uZWFyZXN0IiwibWVkb2lkcyIsImZpbmlzaCIsImNhY2hlIiwieF9vIiwiRGVsdGFURCIsInhzIiwiZmluZEluZGV4IiwiZF9qIiwiZGlzdGFuY2VfbmVhcmVzdCIsImRlbHRhVEQiLCJkX29qIiwiX2dldF9kaXN0YW5jZSIsImRfbiIsImRpc3RhbmNlX3NlY29uZCIsImRfcyIsIm5lYXJlc3QiLCJzZWNvbmQiLCJ4X20iLCJtMSIsIm0yIiwiaW5kZXhfc2Vjb25kIiwiY2x1c3Rlcl9tZWRvaWRzIiwiY2VpbCIsIlREIiwiVEQwIiwiUyIsIlNfaiIsIlNfbyIsImRlbHRhIiwiT1BUSUNTIiwibWluX3BvaW50cyIsIl9taW5fcG9pbnRzIiwiX29yZGVyZWRfbGlzdCIsIl9EQiIsIm9yZGVyZWRfbGlzdCIsIkRCIiwiY2x1c3Rlcl9pbmRleCIsIl9jbHVzdGVyX2luZGV4IiwicmVhY2hhYmlsaXR5X2Rpc3RhbmNlIiwicHJvY2Vzc2VkIiwiX2dldF9uZWlnaGJvcnMiLCJfY29yZV9kaXN0YW5jZSIsInNlZWRzIiwiX3VwZGF0ZSIsIl9leHBhbmRfY2x1c3RlciIsImNvcmVfZGlzdGFuY2UiLCJuZXdfcmVhY2hhYmlsaXR5X2Rpc3RhbmNlIiwiY2x1c3RlciIsIm91dGxpZXJzIiwiZ2V0X2NsdXN0ZXJfYWZmaXJtYXRpb24iLCJMU1AiLCJjb250cm9sX3BvaW50cyIsIkRSX3BhcmFtZXRlcnMiLCJuYyIsImNfaSIsIllfQyIsIlhBIiwiQVQiLCJBVEEiLCJBVGIiLCJUb3BvTWFwIiwiX19sYXp5X2Rpc3RhbmNlX21hdHJpeCIsIkRfaWoiLCJfbWFrZV9taW5pbXVtX3NwYW5uaW5nX3RyZWUiLCJkaXNqb2ludF9zZXQiLCJGIiwiRSIsInUiLCJzZXRfdSIsInNldF92IiwiX0Vtc3QiLCJfX2h1bGxfY3Jvc3MiLCJheCIsImF5IiwiYngiLCJieSIsInN4Iiwic3kiLCJfX2h1bGwiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImxvd2VyIiwidXBwZXIiLCJfX2ZpbmRBbmdsZSIsInAxeCIsInAxeSIsInAyeCIsInAyeSIsInNpbiIsImNvcyIsInZlYyIsIl9fYWxpZ25faHVsbCIsImh1bGwiLCJ0b3BFZGdlIiwiZDIiLCJ2MSIsInYyIiwidHJhbnNmb3JtYXRpb24iLCJ0eCIsInR5IiwiX190cmFuc2Zvcm0iLCJweCIsInB5IiwiX190cmFuc2Zvcm1fY29tcG9uZW50IiwieU9mZnNldCIsImN4IiwiY3kiLCJfX2FsaWduX2NvbXBvbmVudHMiLCJwb2ludHNfdSIsInBvaW50c192IiwiaHVsbF91IiwiaHVsbF92IiwidF91IiwidF92IiwiRW1zdCIsImNvbXBvbmVudHMiLCJjb21wb25lbnRfdSIsImNvbXBvbmVudF92IiwiU0FNTU9OIiwiRGltUmVkIiwibWFnaWMiLCJfX2Rpc3RhbmNlX21hdHJpeCIsIl9zdGVwIiwiTUFHSUMiLCJlMSIsImUyIiwiWWkiLCJZaiIsImRZIiwiZFgiLCJkcSIsImRyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFTZSxtQkFBVUEsRUFBR0MsR0FDeEIsT0FBT0MsS0FBS0MsS0FBS0Msa0JBQWtCSixFQUFHQzs7Ozs7Ozs7R0NGM0IsbUJBQVVJLEdBQ3JCLElBR0lDLEVBQUdDLEVBSEhDLEVBQUlILEVBQVNJLE9BQ2JDLEVBQU0sRUFDTkMsRUFBZSxFQUduQixJQUFLLElBQUlDLEVBQUksRUFBR0EsRUFBSUosSUFBS0ksRUFDckJOLEVBQUlELEVBQVNPLEdBQUtELEVBQ2xCSixFQUFJRyxFQUFNSixFQUNWSyxFQUFlSixFQUFJRyxFQUFNSixFQUN6QkksRUFBTUgsRUFFVixPQUFPRzs7Ozs7Ozs7R0NaSSxxQkFBVUwsR0FDckIsSUFBSUcsRUFBSUgsRUFBU0ksT0FDYkMsRUFBTSxFQUNOQyxFQUFlLEVBRW5CLElBQUssSUFBSUMsRUFBSSxFQUFHQSxFQUFJSixJQUFLSSxFQUFHLENBQ3hCLElBQUlDLEVBQVVSLEVBQVNPLEdBQ25CTCxFQUFJRyxFQUFNRyxFQUNWWCxLQUFLWSxJQUFJSixJQUFRUixLQUFLWSxJQUFJRCxHQUMxQkYsR0FBZ0JELEVBQU1ILEVBQUlNLEVBRTFCRixHQUFnQkUsRUFBVU4sRUFBSUcsRUFFbENBLEVBQU1ILEVBRVYsT0FBT0csRUFBTUM7Ozs7Ozs7O0dDZEYsMkJBQVVYLEVBQUdDLEdBQ3hCLEdBQUlELEVBQUVTLFFBQVVSLEVBQUVRLE9BQVEsT0FDMUIsSUFBSUQsRUFBSVIsRUFBRVMsT0FDTk0sRUFBSSxJQUFJQyxNQUFNUixHQUNsQixJQUFLLElBQUlJLEVBQUksRUFBR0EsRUFBSUosSUFBS0ksRUFBRyxDQUN4QixJQUFJSyxFQUFJakIsRUFBRVksR0FDTk4sRUFBSUwsRUFBRVcsR0FDVkcsRUFBRUgsSUFBTUssRUFBSVgsSUFBTVcsRUFBSVgsR0FFMUIsT0FBT1ksWUFBWUg7Ozs7Ozs7Ozs7R0NSUixnQkFBVWYsRUFBR0MsR0FDeEIsR0FBSUQsRUFBRVMsU0FBV1IsRUFBRVEsT0FBUSxPQUMzQixJQUFJRCxFQUFJUixFQUFFUyxPQUNOQyxFQUFNLEVBQ05TLEVBQVEsRUFDUkMsRUFBUSxFQUNaLElBQUssSUFBSVIsRUFBSSxFQUFHQSxFQUFJSixJQUFLSSxFQUNyQkYsR0FBT1YsRUFBRVksR0FBS1gsRUFBRVcsR0FDaEJPLEdBQVNuQixFQUFFWSxHQUFLWixFQUFFWSxHQUNsQlEsR0FBU25CLEVBQUVXLEdBQUtYLEVBQUVXLEdBRXRCLE9BQU9WLEtBQUttQixLQUFLWCxHQUFPUixLQUFLQyxLQUFLZ0IsR0FBU2pCLEtBQUtDLEtBQUtpQjs7Ozs7Ozs7R0NiMUMsbUJBQVVwQixFQUFHQyxHQUN4QixHQUFJRCxFQUFFUyxRQUFVUixFQUFFUSxPQUFRLE9BQzFCLElBQUlELEVBQUlSLEVBQUVTLE9BQ05DLEVBQU0sRUFDVixJQUFLLElBQUlFLEVBQUksRUFBR0EsRUFBSUosSUFBS0ksRUFDckJGLEdBQU9SLEtBQUtZLElBQUlkLEVBQUVZLEdBQUtYLEVBQUVXLElBRTdCLE9BQU9GOzs7Ozs7OztHQ1BJLG1CQUFVVixFQUFHQyxHQUN4QixHQUFJRCxFQUFFUyxRQUFVUixFQUFFUSxPQUFRLE9BQzFCLElBQUlELEVBQUlSLEVBQUVTLE9BQ05hLEVBQU0sR0FDVixJQUFLLElBQUlWLEVBQUksRUFBR0EsRUFBSUosSUFBS0ksRUFDckJVLEVBQUlDLEtBQUtyQixLQUFLWSxJQUFJZCxFQUFFWSxHQUFLWCxFQUFFVyxLQUUvQixPQUFPVixLQUFLc0IsT0FBT0Y7Ozs7Ozs7OztHQ05SLGtCQUFTdEIsRUFBR0MsR0FDdkIsR0FBSUQsRUFBRVMsU0FBV1IsRUFBRVEsT0FBUSxPQUMzQixJQUFJRCxFQUFJUixFQUFFUyxPQUNOQyxFQUFNLEVBQ1YsSUFBSyxJQUFJRSxFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQ3JCRixHQUFRUixLQUFLWSxJQUFJZCxFQUFFWSxHQUFLWCxFQUFFVyxLQUFPVixLQUFLWSxJQUFJZCxFQUFFWSxJQUFNVixLQUFLWSxJQUFJYixFQUFFVyxLQUVqRSxPQUFPRjs7Ozs7Ozs7R0NSSSxpQkFBVVYsRUFBR0MsR0FDeEIsR0FBSUQsRUFBRVMsUUFBVVIsRUFBRVEsT0FBUSxPQUMxQixNQUFNRCxFQUFJUixFQUFFUyxPQUNaLElBQUlnQixFQUFlLEVBQ2ZDLEVBQVksRUFDaEIsSUFBSyxJQUFJZCxFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQUcsQ0FDeEIsTUFBTUssRUFBWSxHQUFSakIsRUFBRVksR0FDTk4sRUFBWSxHQUFSTCxFQUFFVyxHQUNaYSxHQUFnQlIsR0FBS1gsRUFDckJvQixHQUFhVCxHQUFLWCxFQUV0QixPQUFRbUIsRUFBZUMsR0FBYUQ7Ozs7Ozs7O0dDWHpCLGlCQUFVekIsRUFBR0MsR0FDeEIsR0FBSUQsRUFBRVMsUUFBVVIsRUFBRVEsT0FBUSxPQUMxQixNQUFNRCxFQUFJUixFQUFFUyxPQUNaLElBQUlrQixFQUFXLEVBQ2YsSUFBSyxJQUFJZixFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQUcsQ0FHeEJlLEdBRlUzQixFQUFFWSxJQUNGWCxFQUFFVyxHQUdoQixPQUFPZSxFQUFXbkI7Ozs7Ozs7O0dDVFAsd0JBQVNSLEVBQUdDLEdBQ3ZCLEdBQUlELEVBQUVTLFFBQVVSLEVBQUVRLE9BQVEsT0FDMUIsTUFBTUQsRUFBSVIsRUFBRVMsT0FDWixJQUFJbUIsRUFBZ0IsRUFDcEIsSUFBSyxJQUFJaEIsRUFBSSxFQUFHQSxFQUFJSixJQUFLSSxFQUFHLENBR3hCZ0IsR0FGa0IsR0FBUjVCLEVBQUVZLEtBQ00sR0FBUlgsRUFBRVcsSUFHaEIsT0FBUSxFQUFJZ0IsR0FBa0JwQixFQUFJb0I7Ozs7Ozs7O0dDVHZCLGNBQVU1QixFQUFHQyxHQUN4QixHQUFJRCxFQUFFUyxRQUFVUixFQUFFUSxPQUFRLE9BQzFCLE1BQU1ELEVBQUlSLEVBQUVTLE9BQ1osSUFBSW9CLEVBQWdCLEVBQ2hCQyxFQUFpQixFQUNqQkMsRUFBaUIsRUFDckIsSUFBSyxJQUFJbkIsRUFBSSxFQUFHQSxFQUFJSixJQUFLSSxFQUFHLENBQ3hCLE1BQU1LLEVBQVksR0FBUmpCLEVBQUVZLEdBQ05OLEVBQVksR0FBUkwsRUFBRVcsR0FDWmlCLEdBQWlCWixHQUFLWCxFQUN0QndCLEdBQWtCYixJQUFNWCxFQUN4QnlCLElBQW1CZCxHQUFLQSxFQUc1QixPQUF5QixHQUFsQmEsR0FBeUMsR0FBbEJDLEVBQXNCLEVBQUssRUFBSUQsRUFBaUJDLEdBQW1CRixHQUR6RXJCLEVBQUlxQixFQUFnQkMsRUFBaUJDLEdBQ3NFRCxFQUFpQkM7Ozs7Ozs7R0NaekksNkJBQVVDLEVBQUdDLEVBQUdDLEVBQWtCLEtBQU1DLEVBQVNDLFdBQzVELE1BQU1DLEVBQU9MLEVBQUVNLE1BQU0sR0FDckIsSUFBSUMsRUFBSUwsR0FBbUJNLGdCQUFRUixFQUFHRyxHQUNsQ00sRUFBSyxJQUFJekIsTUFBTXFCLEdBQ25CLElBQUssSUFBSUssRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxFQUM1QkQsRUFBR0MsR0FBTzFCLE1BQU0yQixLQUFLSixFQUFFRyxJQUFJQSxJQUN0QkUsS0FBSSxDQUFDQyxFQUFVQyxLQUNMLENBQ0hsQyxFQUFHOEIsRUFDSEssRUFBR0QsRUFDSEQsU0FBVUEsTUFHakJHLE1BQUssQ0FBQ2hELEVBQUdDLElBQU1ELEVBQUU2QyxTQUFXNUMsRUFBRTRDLFdBQzlCSSxNQUFNLEVBQUdoQixFQUFJLEdBRXRCLE9BQU9ROzs7OztHQ25CSixNQUFNUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJUQyxZQUFZZCxFQUFPLEtBQU1lLEVBQU8sS0FBTUMsRUFBUSxNQUkxQyxHQUhBQyxLQUFLQyxNQUFRbEIsRUFDYmlCLEtBQUtFLE1BQVFKLEVBQ2JFLEtBQUtHLE1BQVEsS0FDVHBCLEdBQVFlLEVBQU0sQ0FDZCxJQUFLQyxFQUVELE9BREFDLEtBQUtHLE1BQVEsSUFBSUMsYUFBYXJCLEVBQU9lLEdBQzlCRSxLQUVYLEdBQXFCLG1CQUFWRCxFQUFzQixDQUM3QkMsS0FBS0csTUFBUSxJQUFJQyxhQUFhckIsRUFBT2UsR0FDckMsSUFBSyxJQUFJVixFQUFNLEVBQUdBLEVBQU1MLElBQVFLLEVBQzVCLElBQUssSUFBSUksRUFBTSxFQUFHQSxFQUFNTSxJQUFRTixFQUM1QlEsS0FBS0csTUFBTWYsRUFBTVUsRUFBT04sR0FBT08sRUFBTVgsRUFBS0ksR0FHbEQsT0FBT1EsS0FFWCxHQUFxQixpQkFBVkQsRUFBb0IsQ0FDM0IsR0FBYyxVQUFWQSxFQUNBLE9BQU8sSUFBSUgsT0FBT2IsRUFBTWUsRUFBTSxHQUVsQyxHQUFjLGFBQVZDLEdBQWtDLE1BQVZBLEVBQWUsQ0FDdkNDLEtBQUtHLE1BQVEsSUFBSUMsYUFBYXJCLEVBQU9lLEdBQ3JDLElBQUssSUFBSVYsRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxFQUM1QlksS0FBS0csTUFBTWYsRUFBTVUsRUFBT1YsR0FBTyxFQUVuQyxPQUFPWSxLQUVYLEdBQWMsV0FBVkQsR0FBc0JoQixHQUFRZSxFQUFNLENBQ3BDRSxLQUFLRyxNQUFRLElBQUlDLGFBQWFyQixFQUFPZSxHQUNyQ0MsRUFBUSxDQUFDekMsRUFBR21DLEtBQU9uQyxJQUFNbUMsRUFBSSxFQUFJLEdBQUssRUFBSVYsRUFDMUMsSUFBSyxJQUFJSyxFQUFNLEVBQUdBLEVBQU1MLElBQVFLLEVBQzVCLElBQUssSUFBSUksRUFBTSxFQUFHQSxFQUFNTSxJQUFRTixFQUM1QlEsS0FBS0csTUFBTWYsRUFBTVUsRUFBT04sR0FBT08sRUFBTVgsRUFBS0ksR0FHbEQsT0FBT1EsTUFHZixHQUFxQixpQkFBVkQsRUFBb0IsQ0FDM0JDLEtBQUtHLE1BQVEsSUFBSUMsYUFBYXJCLEVBQU9lLEdBQ3JDLElBQUssSUFBSVYsRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxFQUM1QixJQUFLLElBQUlJLEVBQU0sRUFBR0EsRUFBTU0sSUFBUU4sRUFDNUJRLEtBQUtHLE1BQU1mLEVBQU1VLEVBQU9OLEdBQU9PLEVBR3ZDLE9BQU9DLE1BR2YsT0FBT0E7Ozs7Ozs7Ozs7T0FhWEssWUFBWTNCLEVBQUc0QixFQUFPLE9BQ2xCLEdBQUk1QixhQUFha0IsT0FDYixPQUFPbEIsRUFBRTZCLFFBQ04sS0FBSTdDLE1BQU04QyxRQUFROUIsSUFBTUEsYUFBYTBCLGNBd0JyQyxDQUFBLEdBQWlCLGlCQUFOMUIsRUFDZCxPQUFPLElBQUlrQixPQUFPLEVBQUcsRUFBR2xCLEdBRXhCLE1BQU0sSUFBSStCLE1BQU0sU0EzQnNDLENBQ3RELElBQUlDLEVBQUloQyxFQUFFdkIsT0FDVixHQUFVLElBQU51RCxFQUFTLE1BQU0sSUFBSUQsTUFBTTtLQUU3QjtLQUFLL0MsTUFBTThDLFFBQVE5QixFQUFFLEtBQVNBLEVBQUUsYUFBYzBCLGNBQWUsQ0FDekQsR0FBYSxRQUFURSxFQUNBLE9BQU8sSUFBSVYsT0FBTyxFQUFHYyxHQUFHLENBQUNDLEVBQUdsQixJQUFNZixFQUFFZTtLQUNqQztHQUFhLFFBQVRhLEVBQ1AsT0FBTyxJQUFJVixPQUFPYyxFQUFHLEdBQUlwRCxHQUFNb0IsRUFBRXBCLEtBQzlCLEdBQWEsU0FBVGdELEVBQ1AsT0FBTyxJQUFJVixPQUFPYyxFQUFHQSxHQUFHLENBQUNwRCxFQUFHbUMsSUFBT25DLEdBQUttQyxFQUFJZixFQUFFcEIsR0FBSyxJQUVuRCxNQUFNLElBQUltRCxNQUFNLDRCQUdqQixHQUFJL0MsTUFBTThDLFFBQVE5QixFQUFFLEtBQU9BLEVBQUUsYUFBYzBCLGFBQWMsQ0FDNUQsSUFBSWxELEVBQUl3QixFQUFFLEdBQUd2QixPQUNiLElBQUssSUFBSWlDLEVBQU0sRUFBR0EsRUFBTXNCLElBQUt0QixFQUN6QixHQUFJVixFQUFFVSxHQUFLakMsU0FBV0QsRUFDbEIsTUFBTSxJQUFJdUQsTUFBTSx5QkFHeEIsT0FBTyxJQUFJYixPQUFPYyxFQUFHeEQsR0FBRyxDQUFDSSxFQUFHbUMsSUFBTWYsRUFBRXBCLEdBQUdtQzs7Ozs7T0FjbkRMLElBQUlBLEdBQ0EsTUFBTXdCLEVBQU9aLEtBQUthLE9BQ1pmLEVBQU9FLEtBQUtFLE1BQ2xCLE9BQU9VLEVBQUtFLFNBQVMxQixFQUFNVSxHQUFPVixFQUFNLEdBQUtVOzs7O09BT2pEaUIsZ0JBQ0ksTUFBTWpCLEVBQU9FLEtBQUtFLE1BQ1puQixFQUFPaUIsS0FBS0MsTUFDWlcsRUFBT1osS0FBS2EsT0FDbEIsSUFBSyxJQUFJekIsRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxRQUN0QndCLEVBQUtFLFNBQVMxQixFQUFNVSxHQUFPVixFQUFNLEdBQUtVOzs7O09BUXBELEVBQUVrQixPQUFPQyxZQUNMLElBQUssTUFBTTdCLEtBQU9ZLEtBQUtlLHFCQUNiM0I7Ozs7OztPQVVkOEIsUUFBUTlCLEVBQUt5QixHQUNULElBQUlmLEVBQU9FLEtBQUtFLE1BQ2hCLEdBQUl4QyxNQUFNOEMsUUFBUUssSUFBV0EsRUFBTzFELFNBQVcyQyxFQUFNLENBQ2pELElBQUlxQixFQUFTL0IsRUFBTVUsRUFDbkIsSUFBSyxJQUFJTixFQUFNLEVBQUdBLEVBQU1NLElBQVFOLEVBQzVCUSxLQUFLYSxPQUFPTSxFQUFTM0IsR0FBT3FCLEVBQU9yQixRQUVwQyxHQUFJcUIsYUFBa0JqQixRQUFVaUIsRUFBTzdCLE1BQU0sS0FBT2MsR0FBNEIsSUFBcEJlLEVBQU83QixNQUFNLEdBQVUsQ0FDdEYsSUFBSW1DLEVBQVMvQixFQUFNVSxFQUNuQixJQUFLLElBQUlOLEVBQU0sRUFBR0EsRUFBTU0sSUFBUU4sRUFDNUJRLEtBQUthLE9BQU9NLEVBQVMzQixHQUFPcUIsRUFBT1YsTUFBTVgsR0FHakQsT0FBT1E7Ozs7O09BUVhSLElBQUlBLEdBQ0EsSUFBSTRCLEVBQWEsSUFBSWhCLGFBQWFKLEtBQUtDLE9BQ3ZDLElBQUssSUFBSWIsRUFBTSxFQUFHQSxFQUFNWSxLQUFLQyxRQUFTYixFQUNsQ2dDLEVBQVdoQyxHQUFPWSxLQUFLYSxPQUFPekIsRUFBTVksS0FBS0UsTUFBUVYsR0FFckQsT0FBTzRCOzs7Ozs7T0FTWEMsTUFBTWpDLEVBQUtJLEdBQ1AsT0FBT1EsS0FBS2EsT0FBT3pCLEVBQU1ZLEtBQUtFLE1BQVFWOzs7Ozs7O09BVTFDOEIsVUFBVWxDLEVBQUtJLEVBQUtPLEdBRWhCLE9BREFDLEtBQUthLE9BQU96QixFQUFNWSxLQUFLRSxNQUFRVixHQUFPTyxFQUMvQkM7Ozs7T0FPWHVCLFlBRUksT0FEUSxJQUFJM0IsT0FBT0ksS0FBS0UsTUFBT0YsS0FBS0MsT0FBTyxDQUFDYixFQUFLSSxJQUFRUSxLQUFLcUIsTUFBTTdCLEVBQUtKOzs7O09BUXpFb0MsUUFDQSxPQUFPeEIsS0FBS3VCOzs7O09BT2hCRSxVQUNJLE1BQU0xQyxFQUFPaUIsS0FBS0MsTUFDWkgsRUFBT0UsS0FBS0UsTUFDbEIsSUFBSXdCLEVBQUksSUFBSTlCLE9BQU9iLEVBQU0sRUFBSWUsR0FBTSxDQUFDeEMsRUFBR21DLElBQy9CQSxHQUFLSyxFQUNFeEMsSUFBTW1DLEVBQUlLLEVBQU8sRUFBSSxFQUVyQkUsS0FBS3FCLE1BQU0vRCxFQUFHbUMsS0FHekJrQyxFQUFJLEVBQ0poRCxFQUFJLEVBQ1IsS0FBT2dELEVBQUk1QyxHQUFRSixFQUFJbUIsR0FBTSxDQUN6QixJQUFJOEIsRUFBUSxFQUNaLElBQUlDLEdBQVdDLEVBQUFBLEVBQ2YsSUFBSyxJQUFJeEUsRUFBSXFFLEVBQUdyRSxFQUFJeUIsSUFBUXpCLEVBQUcsQ0FDM0IsSUFBSXlFLEVBQU1uRixLQUFLWSxJQUFJa0UsRUFBRUwsTUFBTS9ELEVBQUdxQixJQUMxQmtELEVBQVVFLElBQ1ZILEVBQVF0RSxFQUNSdUUsRUFBVUUsR0FHbEIsR0FBeUIsR0FBckJMLEVBQUVMLE1BQU1PLEVBQU9qRCxHQUNmQSxRQUNHOztBQUVILElBQUssSUFBSWMsRUFBSSxFQUFHQSxFQUFJLEVBQUlLLElBQVFMLEVBQUcsQ0FDL0IsSUFBSXVDLEVBQVFOLEVBQUVMLE1BQU1NLEVBQUdsQyxHQUNuQndDLEVBQVFQLEVBQUVMLE1BQU1PLEVBQU9uQyxHQUMzQmlDLEVBQUVKLFVBQVVLLEVBQUdsQyxFQUFHdUMsR0FDbEJOLEVBQUVKLFVBQVVNLEVBQU9uQyxFQUFHd0MsR0FFMUIsSUFBSyxJQUFJM0UsRUFBSXFFLEVBQUksRUFBR3JFLEVBQUl5QixJQUFRekIsRUFBRyxDQUMvQixJQUFJNEUsRUFBSVIsRUFBRUwsTUFBTS9ELEVBQUdxQixHQUFLK0MsRUFBRUwsTUFBTU0sRUFBR2hELEdBQ25DK0MsRUFBRUosVUFBVWhFLEVBQUdxQixFQUFHLEdBQ2xCLElBQUssSUFBSWMsRUFBSWQsRUFBSSxFQUFHYyxFQUFJLEVBQUlLLElBQVFMLEVBQ2hDaUMsRUFBRUosVUFBVWhFLEVBQUdtQyxFQUFHaUMsRUFBRUwsTUFBTS9ELEVBQUdtQyxHQUFLaUMsRUFBRUwsTUFBTU0sRUFBR2xDLEdBQUt5QyxHQUcxRFAsSUFDQWhELEtBSVIsSUFBSyxJQUFJUyxFQUFNLEVBQUdBLEVBQU1MLElBQVFLLEVBQUssQ0FDakMsSUFBSThDLEVBQUlSLEVBQUVMLE1BQU1qQyxFQUFLQSxHQUNyQixJQUFLLElBQUlJLEVBQU1KLEVBQUtJLEVBQU0sRUFBSU0sSUFBUU4sRUFDbENrQyxFQUFFSixVQUFVbEMsRUFBS0ksRUFBS2tDLEVBQUVMLE1BQU1qQyxFQUFLSSxHQUFPMEMsR0FJbEQsSUFBSyxJQUFJOUMsRUFBTUwsRUFBTyxFQUFHSyxHQUFPLElBQUtBLEVBQUssQ0FDdEMsSUFBSStDLEVBQVlULEVBQUVMLE1BQU1qQyxFQUFLQSxHQUM3QixJQUFLLElBQUk5QixFQUFJLEVBQUdBLEVBQUk4QixFQUFLOUIsSUFBSyxDQUMxQixJQUNJNEUsRUFEVVIsRUFBRUwsTUFBTS9ELEVBQUc4QixHQUNQK0MsRUFDbEIsSUFBSyxJQUFJMUMsRUFBSW5DLEVBQUdtQyxFQUFJLEVBQUlLLElBQVFMLEVBQUcsQ0FDL0IsSUFBSTJDLEVBQVFWLEVBQUVMLE1BQU0vRCxFQUFHbUMsR0FFdkIyQyxHQURjVixFQUFFTCxNQUFNakMsRUFBS0ssR0FDRHlDLEVBQzFCUixFQUFFSixVQUFVaEUsRUFBR21DLEVBQUcyQyxLQUs5QixPQUFPLElBQUl4QyxPQUFPYixFQUFNZSxHQUFNLENBQUN4QyxFQUFHbUMsSUFBTWlDLEVBQUVMLE1BQU0vRCxFQUFHbUMsRUFBSUs7Ozs7O09BUTNEdUMsSUFBSVgsR0FDQSxHQUFJQSxhQUFhOUIsT0FBUSxDQUNyQixJQUFJbEIsRUFBSXNCLEtBQ1IsR0FBSXRCLEVBQUVNLE1BQU0sS0FBTzBDLEVBQUUxQyxNQUFNLEdBQ3ZCLE1BQU0sSUFBSXlCLE1BQU0sb0JBQW9CL0IsRUFBRU0sTUFBTXNELEtBQUsseUJBQXlCWixFQUFFMUMsTUFBTXNELEtBQUssMENBQy9FNUQsRUFBRU0sTUFBTSxpQkFBaUIwQyxFQUFFMUMsTUFBTSw2Q0FHN0MsSUFBSXVELEVBQUk3RCxFQUFFTSxNQUFNLEdBVWhCLE9BVFEsSUFBSVksT0FBT2xCLEVBQUVNLE1BQU0sR0FBSTBDLEVBQUUxQyxNQUFNLElBQUksQ0FBQ0ksRUFBS0ksS0FDN0MsTUFBTWdELEVBQU05RCxFQUFFVSxJQUFJQSxHQUNacUQsRUFBTWYsRUFBRWxDLElBQUlBLEdBQ2xCLElBQUlwQyxFQUFNLEVBQ1YsSUFBSyxJQUFJRSxFQUFJLEVBQUdBLEVBQUlpRixJQUFLakYsRUFDckJGLEdBQU9vRixFQUFJbEYsR0FBS21GLEVBQUluRixHQUV4QixPQUFPRixLQUdSLEdBQUlNLE1BQU04QyxRQUFRa0IsSUFBTUEsYUFBYXRCLGFBQWMsQ0FDdEQsSUFBSXJCLEVBQU9pQixLQUFLQyxNQUNoQixHQUFJeUIsRUFBRXZFLFNBQVc0QixFQUNiLE1BQU0sSUFBSTBCLE1BQU0sbUJBQW1CMUIsb0JBQXVCMkMsRUFBRXZFLCtCQUVoRSxJQUFJdUYsRUFBSSxJQUFJaEYsTUFBTXFCLEdBQ2xCLElBQUssSUFBSUssRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxFQUM1QnNELEVBQUV0RCxHQUFPeEIsWUFBWW9DLEtBQUtaLElBQUlBLEdBQUtFLEtBQUtxRCxHQUFNQSxFQUFJakIsRUFBRXRDLE1BRXhELE9BQU9zRCxFQUVQLE1BQU0sSUFBSWpDLE1BQU07Ozs7O09BU3hCbUMsTUFBTWxCLEdBQ0YsSUFBSWhELEVBQUlzQixLQUNKNkMsRUFBSW5FLEVBQUV5QixNQUFNaEQsT0FFaEIsR0FBSTBGLEdBREluQixFQUFFdkIsTUFBTWhELE9BQ0osT0FDWixJQUFJdUYsRUFBSSxJQUFJOUMsT0FZWixPQVhBOEMsRUFBRTFELE1BQVEsQ0FDTjZELEVBQ0FBLEVBQ0EsQ0FBQ3ZGLEVBQUdtQyxJQUNJbkMsR0FBS21DLEVBQ0VmLEVBQUV5QixNQUFNN0MsR0FBS29FLEVBQUV2QixNQUFNVixHQUVyQmlELEVBQUVyQixNQUFNNUIsRUFBR25DLElBSXZCb0Y7Ozs7Ozs7Ozs7Ozs7O09BaUJYSSxPQUFPcEIsRUFBR3BCLEVBQU8sY0FDYixNQUFNNUIsRUFBSXNCLE1BQ0grQyxFQUFRQyxHQUFVdEUsRUFBRU0sT0FDcEJpRSxFQUFRQyxHQUFVeEIsRUFBRTFDLE1BQzNCLEdBQVksY0FBUnNCLEVBQXNCLENBQ3RCLEdBQUl5QyxHQUFVRSxFQUNWLE1BQU0sSUFBSXhDLE1BQU0sc0VBQXNFc0MsaUJBQXNCRSxXQUVoSCxNQUFNRSxFQUFJLElBQUl2RCxPQUFPbUQsRUFBUUMsRUFBU0UsRUFBUSxTQUc5QyxPQUZBQyxFQUFFQyxVQUFVLEVBQUcsRUFBRzFFLEdBQ2xCeUUsRUFBRUMsVUFBVSxFQUFHSixFQUFRdEIsR0FDaEJ5QixFQUNKLEdBQVksWUFBUjdDLEVBQW9CLENBQzNCLEdBQUkwQyxHQUFVRSxFQUNWLE1BQU0sSUFBSXpDLE1BQU0sdUVBQXVFdUMsb0JBQXlCRSxjQUVwSCxNQUFNQyxFQUFJLElBQUl2RCxPQUFPbUQsRUFBU0UsRUFBUUQsRUFBUSxTQUc5QyxPQUZBRyxFQUFFQyxVQUFVLEVBQUcsRUFBRzFFLEdBQ2xCeUUsRUFBRUMsVUFBVUwsRUFBUSxFQUFHckIsR0FDaEJ5QixFQUNKLEdBQVksUUFBUjdDLEVBQWdCLENBQ3ZCLE1BQU02QyxFQUFJLElBQUl2RCxPQUFPbUQsRUFBU0UsRUFBUUQsRUFBU0UsRUFBUSxTQUd2RCxPQUZBQyxFQUFFQyxVQUFVLEVBQUcsRUFBRzFFLEdBQ2xCeUUsRUFBRUMsVUFBVUwsRUFBUUMsRUFBUXRCLEdBQ3JCeUIsRUFFUCxNQUFNLElBQUkxQyxNQUFNLHdEQUF3REg7Ozs7Ozs7T0FXaEY4QyxVQUFVQyxFQUFZQyxFQUFZNUIsR0FDOUIsSUFBSzNDLEVBQU1lLEdBQVE0QixFQUFFMUMsTUFDckIsSUFBSyxJQUFJSSxFQUFNLEVBQUdBLEVBQU1MLElBQVFLLEVBQzVCLEtBQUlBLEVBQU1ZLEtBQUtDLE9BR2YsSUFBSyxJQUFJVCxFQUFNLEVBQUdBLEVBQU1NLElBQVFOLEVBQ3hCQSxFQUFNUSxLQUFLRSxPQUdmRixLQUFLc0IsVUFBVWxDLEVBQU1pRSxFQUFZN0QsRUFBTThELEVBQVk1QixFQUFFTCxNQUFNakMsRUFBS0ksSUFHeEUsT0FBT1E7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0JYdUQsVUFBVUMsRUFBV0MsRUFBV0MsRUFBVSxLQUFNQyxFQUFVLE1BQ3RELE1BQU81RSxFQUFNZSxHQUFRRSxLQUFLaEIsTUFHMUIsR0FEQTJFLEVBQVVBLEdBQVc3RCxHQURyQjRELEVBQVVBLEdBQVczRSxJQUVOeUUsR0FBYUcsR0FBV0YsRUFDbkMsTUFBTSxJQUFJaEQsTUFBTSwwSkFHQWlELGtCQUF3QkYsZ0JBQXdCRyxzQkFBNEJGLE1BRWhHLE1BQU1OLEVBQUksSUFBSXZELE9BQU84RCxFQUFVRixFQUFXRyxFQUFVRixFQUFXLFNBQy9ELElBQUssSUFBSXJFLEVBQU1vRSxFQUFXSSxFQUFVLEVBQUd4RSxFQUFNc0UsSUFBV3RFLElBQU93RSxFQUMzRCxJQUFLLElBQUlwRSxFQUFNaUUsRUFBV0ksRUFBVSxFQUFHckUsRUFBTW1FLElBQVduRSxJQUFPcUUsRUFDM0RWLEVBQUU3QixVQUFVc0MsRUFBU0MsRUFBUzdELEtBQUtxQixNQUFNakMsRUFBS0ksSUFHdEQsT0FBTzJEOzs7Ozs7OztPQVVYVyxPQUFPQyxFQUFhQyxHQUNoQixNQUFNQyxFQUFJRixFQUFZNUcsT0FDaEI4QixFQUFJK0UsRUFBWTdHLE9BRWhCK0csRUFBSSxJQUFJdEUsT0FBT3FFLEVBQUdoRixHQUN4QixJQUFLLElBQUkzQixFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFBRyxDQUN4QixNQUFNNkcsRUFBWUosRUFBWXpHLEdBQzlCLElBQUssSUFBSW1DLEVBQUksRUFBR0EsRUFBSXdFLElBQUt4RSxFQUFHLENBQ3hCLE1BQU0yRSxFQUFZSixFQUFZdkUsR0FDOUJ5RSxFQUFFNUMsVUFBVWhFLEVBQUdtQyxFQUFHTyxLQUFLcUIsTUFBTThDLEVBQVdDLEtBSWhELE9BQU9GOzs7Ozs7T0FTWEcsYUFBYW5DLEVBQUdvQyxHQUNaLE1BQU0xRCxFQUFPWixLQUFLYSxRQUNYOUIsRUFBTWUsR0FBUUUsS0FBS2hCLE1BQzFCLElBQUssSUFBSUksRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxFQUFLLENBQ2pDLE1BQU0rQixFQUFTL0IsRUFBTVUsRUFDckIsSUFBSyxJQUFJTixFQUFNLEVBQUdBLEVBQU1NLElBQVFOLEVBQUssQ0FDakMsTUFBTWxDLEVBQUk2RCxFQUFTM0IsRUFDbkJvQixFQUFLdEQsR0FBSzRFLEVBQUV0QixFQUFLdEQsR0FBSWdILEVBQUVsRixFQUFLSSxLQUdwQyxPQUFPUSxLQUdYdUUscUJBQXFCMUQsRUFBUXFCLEdBQ3pCLE9BQU9sQyxLQUFLcUUsYUFBYW5DLEdBQUcsQ0FBQ3ZCLEVBQUdsQixJQUFNb0IsRUFBT3BCLEtBR2pEK0UscUJBQXFCM0QsRUFBUXFCLEdBQ3pCLE1BQU10QixFQUFPWixLQUFLYSxRQUNYOUIsRUFBTWUsR0FBUUUsS0FBS2hCLE1BQzFCLElBQUssSUFBSUksRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxFQUFLLENBQ2pDLE1BQU0rQixFQUFTL0IsRUFBTVUsRUFDckIsSUFBSyxJQUFJTixFQUFNLEVBQUdBLEVBQU1NLElBQVFOLEVBQUssQ0FDakMsTUFBTWxDLEVBQUk2RCxFQUFTM0IsRUFDbkJvQixFQUFLdEQsR0FBSzRFLEVBQUV0QixFQUFLdEQsR0FBSXVELEVBQU96QixLQUdwQyxPQUFPWSxLQUdYeUUsT0FBTzFFLEVBQU9tQyxHQUNWLElBQUl0QixFQUFPWixLQUFLYSxPQUNoQixHQUFJZCxhQUFpQkgsT0FBUSxDQUN6QixJQUFLOEUsRUFBWUMsR0FBYzVFLEVBQU1mLE9BQ2hDRCxFQUFNZSxHQUFRRSxLQUFLaEIsTUFDeEIsR0FBbUIsSUFBZjBGLEVBQWtCLENBQ2xCLEdBQUk1RSxJQUFTNkUsRUFDVCxNQUFNLElBQUlsRSxNQUFNLHVCQUVwQixJQUFLLElBQUlyQixFQUFNLEVBQUdBLEVBQU1MLElBQVFLLEVBQzVCLElBQUssSUFBSUksRUFBTSxFQUFHQSxFQUFNTSxJQUFRTixFQUM1Qm9CLEVBQUt4QixFQUFNVSxFQUFPTixHQUFPMEMsRUFBRXRCLEVBQUt4QixFQUFNVSxFQUFPTixHQUFNTyxFQUFNc0IsTUFBTSxFQUFHN0IsU0FHdkUsR0FBbUIsSUFBZm1GLEVBQWtCLENBQ3pCLEdBQUk1RixJQUFTMkYsRUFDVCxNQUFNLElBQUlqRSxNQUFNLHVCQUVwQixJQUFLLElBQUlyQixFQUFNLEVBQUdBLEVBQU1MLElBQVFLLEVBQzVCLElBQUssSUFBSUksRUFBTSxFQUFHQSxFQUFNTSxJQUFRTixFQUM1Qm9CLEVBQUt4QixFQUFNVSxFQUFPTixHQUFPMEMsRUFBRXRCLEVBQUt4QixFQUFNVSxFQUFPTixHQUFNTyxFQUFNc0IsTUFBTWpDLEVBQUssUUFHekUsQ0FBQSxHQUFJTCxHQUFRMkYsR0FBYzVFLEdBQVE2RSxFQU9yQyxNQUFNLElBQUlsRSxNQUFNLFNBTmhCLElBQUssSUFBSXJCLEVBQU0sRUFBR0EsRUFBTUwsSUFBUUssRUFDNUIsSUFBSyxJQUFJSSxFQUFNLEVBQUdBLEVBQU1NLElBQVFOLEVBQzVCb0IsRUFBS3hCLEVBQU1VLEVBQU9OLEdBQU8wQyxFQUFFdEIsRUFBS3hCLEVBQU1VLEVBQU9OLEdBQU1PLEVBQU1zQixNQUFNakMsRUFBS0ksVUFNN0UsR0FBSTlCLE1BQU04QyxRQUFRVCxHQUFRLENBQzdCLElBQUloQixFQUFPaUIsS0FBS0MsTUFDWkgsRUFBT0UsS0FBS0UsTUFDaEIsR0FBSUgsRUFBTTVDLFNBQVc0QixFQUNqQixJQUFLLElBQUlLLEVBQU0sRUFBR0EsRUFBTUwsSUFBUUssRUFDNUIsSUFBSyxJQUFJSSxFQUFNLEVBQUdBLEVBQU1NLElBQVFOLEVBQzVCb0IsRUFBS3hCLEVBQU1VLEVBQU9OLEdBQU8wQyxFQUFFdEIsRUFBS3hCLEVBQU1VLEVBQU9OLEdBQU1PLEVBQU1YLFFBRzlELENBQUEsR0FBSVcsRUFBTTVDLFNBQVcyQyxFQU94QixNQUFNLElBQUlXLE1BQU0sU0FOaEIsSUFBSyxJQUFJckIsRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxFQUM1QixJQUFLLElBQUlJLEVBQU0sRUFBR0EsRUFBTU0sSUFBUU4sRUFDNUJvQixFQUFLeEIsRUFBTVUsRUFBT04sR0FBTzBDLEVBQUV0QixFQUFLeEIsRUFBTVUsRUFBT04sR0FBTU8sRUFBTVAsVUFPckUsSUFBSyxJQUFJbEMsRUFBSSxFQUFHSixFQUFJOEMsS0FBS0MsTUFBUUQsS0FBS0UsTUFBTzVDLEVBQUlKLElBQUtJLEVBQ2xEc0QsRUFBS3RELEdBQUs0RSxFQUFFdEIsRUFBS3RELEdBQUl5QyxHQUc3QixPQUFPQzs7OztPQU9YTyxRQUNJLElBQUltQixFQUFJLElBQUk5QixPQUlaLE9BSEE4QixFQUFFekIsTUFBUUQsS0FBS0MsTUFDZnlCLEVBQUV4QixNQUFRRixLQUFLRSxNQUNmd0IsRUFBRXZCLE1BQVFILEtBQUthLE9BQU9sQixNQUFNLEdBQ3JCK0I7Ozs7Ozs7Ozs7OztPQWVYa0QsS0FBSzdFLEdBQ0QsT0FBT0MsS0FBS08sUUFBUWtFLE9BQU8xRSxHQUFPLENBQUNyRCxFQUFHQyxJQUFNRCxFQUFJQzs7Ozs7Ozs7Ozs7O09BZXBEa0ksT0FBTzlFLEdBQ0gsT0FBT0MsS0FBS08sUUFBUWtFLE9BQU8xRSxHQUFPLENBQUNyRCxFQUFHQyxJQUFNRCxFQUFJQzs7Ozs7Ozs7Ozs7O09BZXBEbUksSUFBSS9FLEdBQ0EsT0FBT0MsS0FBS08sUUFBUWtFLE9BQU8xRSxHQUFPLENBQUNyRCxFQUFHQyxJQUFNRCxFQUFJQzs7Ozs7Ozs7Ozs7O09BZXBEb0ksSUFBSWhGLEdBQ0EsT0FBT0MsS0FBS08sUUFBUWtFLE9BQU8xRSxHQUFPLENBQUNyRCxFQUFHQyxJQUFNRCxFQUFJQzs7OztPQU9oRHFDLFlBQ0EsTUFBTyxDQUFDZ0IsS0FBS0MsTUFBT0QsS0FBS0U7Ozs7O09BUXpCbEIsV0FBT0QsRUFBTWUsRUFBTUMsRUFBUSxLQUFNLEtBQ2pDQyxLQUFLQyxNQUFRbEIsRUFDYmlCLEtBQUtFLE1BQVFKLEVBQ2JFLEtBQUtHLE1BQVEsSUFBSUMsYUFBYXJCLEVBQU9lLEdBQ3JDLElBQUssSUFBSVYsRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxFQUM1QixJQUFLLElBQUlJLEVBQU0sRUFBR0EsRUFBTU0sSUFBUU4sRUFDNUJRLEtBQUtHLE1BQU1mLEVBQU1VLEVBQU9OLEdBQU9PLEVBQU1YLEVBQUtJLEdBR2xELE9BQU9ROzs7O09BT1BnRixnQkFDQSxNQUFNQyxFQUFTLEdBQ2YsSUFBSyxNQUFNN0YsS0FBT1ksS0FBS2UsZUFDbkJrRSxFQUFPaEgsS0FBS21CLEdBRWhCLE9BQU82Rjs7OztPQU9QQyxjQUNBLE1BQU1ELEVBQVMsR0FDZixJQUFLLE1BQU03RixLQUFPWSxLQUFLZSxlQUNuQmtFLEVBQU9oSCxLQUFLUCxNQUFNMkIsS0FBS0QsSUFFM0IsT0FBTzZGOzs7O09BT1BFLFdBQ0EsTUFBTXBHLEVBQU9pQixLQUFLQyxNQUNaSCxFQUFPRSxLQUFLRSxNQUNaa0YsRUFBY3hJLEtBQUt5SSxJQUFJdEcsRUFBTWUsR0FDbkMsSUFBSW1GLEVBQVMsSUFBSTdFLGFBQWFnRixHQUM5QixJQUFLLElBQUk5SCxFQUFJLEVBQUdBLEVBQUk4SCxJQUFlOUgsRUFDL0IySCxFQUFPM0gsR0FBSzBDLEtBQUtxQixNQUFNL0QsRUFBR0EsR0FFOUIsT0FBTzJIOzs7O09BT1BLLFdBR0EsT0FGWXRGLEtBQUs1QyxLQUNQNEMsS0FBS0MsTUFBUUQsS0FBS0U7Ozs7T0FRNUI5QyxVQUVBLE9BQU9RLFlBRE1vQyxLQUFLYTs7OztPQVFsQkEsYUFFQSxPQURhYixLQUFLRzs7OztPQVFsQm9GLGVBQ0EsTUFBTTNFLEVBQU9aLEtBQUthLE9BQ1o5QixFQUFPaUIsS0FBS0MsTUFDWkgsRUFBT0UsS0FBS0UsTUFDWitFLEVBQVM3RSxhQUFhZixLQUFLLENBQUVsQyxPQUFRNEIsSUFDM0MsSUFBSyxJQUFJSyxFQUFNLEVBQUdBLEVBQU1MLElBQVFLLEVBQUssQ0FDakM2RixFQUFPN0YsR0FBTyxFQUNkLElBQUssSUFBSUksRUFBTSxFQUFHQSxFQUFNTSxJQUFRTixFQUM1QnlGLEVBQU83RixJQUFRd0IsRUFBS3hCLEVBQU1VLEVBQU9OLEdBRXJDeUYsRUFBTzdGLElBQVFVLEVBRW5CLE9BQU9tRjs7O09BTVBPLGVBQ0EsTUFBTTVFLEVBQU9aLEtBQUthLE9BQ1o5QixFQUFPaUIsS0FBS0MsTUFDWkgsRUFBT0UsS0FBS0UsTUFDWitFLEVBQVM3RSxhQUFhZixLQUFLLENBQUVsQyxPQUFRMkMsSUFDM0MsSUFBSyxJQUFJTixFQUFNLEVBQUdBLEVBQU1NLElBQVFOLEVBQUssQ0FDakN5RixFQUFPekYsR0FBTyxFQUNkLElBQUssSUFBSUosRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxFQUM1QjZGLEVBQU96RixJQUFRb0IsRUFBS3hCLEVBQU1VLEVBQU9OLEdBRXJDeUYsRUFBT3pGLElBQVFULEVBRW5CLE9BQU9rRzs7Ozs7Ozs7T0FXWDVFLGdCQUFnQjNCLEVBQUcvQixFQUFHOEksRUFBWUMsRUFBTSxNQUNqQixPQUFmRCxJQUNBQSxFQUFhLElBQUlFLFlBRXJCLE1BQU01RyxFQUFPTCxFQUFFTSxNQUFNLEdBQ2ZjLEVBQU9uRCxFQUFFcUMsTUFBTSxHQUNyQixJQUFJaUcsRUFBUyxJQUFJckYsT0FBT2IsRUFBTSxHQUM5QixJQUFLLElBQUl6QixFQUFJLEVBQUdBLEVBQUl3QyxJQUFReEMsRUFBRyxDQUMzQixNQUFNc0ksRUFBTWhHLE9BQU9QLEtBQUsxQyxFQUFFNkMsSUFBSWxDLElBQUlrRSxFQUNsQyxJQUFJN0QsRUFBSSxJQUFJaUMsT0FBT2IsRUFBTSxHQUFHLElBQU0wRyxFQUFXSSxTQUN6Q0MsRUFBSUYsRUFBSWIsSUFBSXJHLEVBQUUyRCxJQUFJMUUsSUFDbEJvSSxFQUFJRCxFQUFFdkYsUUFDVixFQUFHLENBQ0MsTUFBTXlGLEVBQUl0SCxFQUFFMkQsSUFBSTBELEdBQ1ZFLEVBQVFILEVBQUV0RSxFQUFFYSxJQUFJeUQsR0FBR3pFLE1BQU0sRUFBRyxHQUFLMEUsRUFBRXZFLEVBQUVhLElBQUkyRCxHQUFHM0UsTUFBTSxFQUFHLEdBQzNEMUQsRUFBSUEsRUFBRW1ILElBQUlpQixFQUFFbkIsS0FBS3FCLElBQ2pCLE1BQU1DLEVBQVNKLEVBQUVmLElBQUlpQixFQUFFcEIsS0FBS3FCLElBQ3RCRSxFQUFPRCxFQUFPMUUsRUFBRWEsSUFBSTZELEdBQVE3RSxNQUFNLEVBQUcsR0FBS3lFLEVBQUV0RSxFQUFFYSxJQUFJeUQsR0FBR3pFLE1BQU0sRUFBRyxHQUNwRTBFLEVBQUlHLEVBQU9wQixJQUFJaUIsRUFBRW5CLEtBQUt1QixJQUN0QkwsRUFBSUksUUFDQ3RKLEtBQUtZLElBQUlzSSxFQUFFUixNQUFRSSxHQUM1QlQsRUFBU0EsRUFBT25DLE9BQU9uRixFQUFHLGNBRTlCLE9BQU9zSDs7Ozs7O09BU1g1RSxhQUFhM0IsRUFBRy9CLEdBQ1osSUFBTXlKLEVBQUdBLEVBQUdDLEVBQUdBLEdBQU0sTUFBTzNILEdBQUssTUFBT0EsRUFBSUEsRUFBSWtCLE9BQU8wRyxHQUFHNUgsR0FDdERLLEVBQU9xSCxFQUFFcEgsTUFBTSxHQUNmckIsRUFBSWhCLEVBQUU0RDs7QUFHVixJQUFLLElBQUluQixFQUFNLEVBQUdBLEVBQU1MLElBQVFLLEVBQUssQ0FDakMsSUFBSyxJQUFJSSxFQUFNLEVBQUdBLEVBQU1KLEVBQU0sSUFBS0ksRUFDL0I3QixFQUFFMkQsVUFBVSxFQUFHbEMsRUFBS3pCLEVBQUUwRCxNQUFNLEVBQUdqQyxHQUFPZ0gsRUFBRS9FLE1BQU1qQyxFQUFLSSxHQUFPN0IsRUFBRTBELE1BQU0sRUFBRzdCLElBRXpFN0IsRUFBRTJELFVBQVUsRUFBR2xDLEVBQUt6QixFQUFFMEQsTUFBTSxFQUFHakMsR0FBT2dILEVBQUUvRSxNQUFNakMsRUFBS0E7V0FJdkQ7SUFBSyxJQUFJQSxFQUFNTCxFQUFPLEVBQUdLLEdBQU8sSUFBS0EsRUFBSyxDQUN0QyxJQUFLLElBQUlJLEVBQU1ULEVBQU8sRUFBR1MsRUFBTUosSUFBT0ksRUFDbEM3QixFQUFFMkQsVUFBVSxFQUFHbEMsRUFBS3pCLEVBQUUwRCxNQUFNLEVBQUdqQyxHQUFPaUgsRUFBRWhGLE1BQU1qQyxFQUFLSSxHQUFPN0IsRUFBRTBELE1BQU0sRUFBRzdCLElBRXpFN0IsRUFBRTJELFVBQVUsRUFBR2xDLEVBQUt6QixFQUFFMEQsTUFBTSxFQUFHakMsR0FBT2lILEVBQUVoRixNQUFNakMsRUFBS0EsSUFHdkQsT0FBT3pCOzs7OztPQVFYMEMsVUFBVTNCLEdBQ04sTUFBTUssRUFBT0wsRUFBRU0sTUFBTSxHQUNmb0gsRUFBSSxJQUFJeEcsT0FBT2IsRUFBTUEsRUFBTSxTQUMzQnNILEVBQUksSUFBSXpHLE9BQU9iLEVBQU1BLEVBQU0sWUFFakMsSUFBSyxJQUFJVSxFQUFJLEVBQUdBLEVBQUlWLElBQVFVLEVBQUcsQ0FDM0IsSUFBSyxJQUFJbkMsRUFBSW1DLEVBQUduQyxFQUFJeUIsSUFBUXpCLEVBQUcsQ0FDM0IsSUFBSUYsRUFBTSxFQUNWLElBQUssSUFBSXVCLEVBQUksRUFBR0EsRUFBSWMsSUFBS2QsRUFDckJ2QixHQUFPZ0osRUFBRS9FLE1BQU0vRCxFQUFHcUIsR0FBSzBILEVBQUVoRixNQUFNMUMsRUFBR2MsR0FFdEMyRyxFQUFFOUUsVUFBVWhFLEVBQUdtQyxFQUFHZixFQUFFMkMsTUFBTS9ELEVBQUdtQyxHQUFLckMsR0FFdEMsSUFBSyxJQUFJRSxFQUFJbUMsRUFBR25DLEVBQUl5QixJQUFRekIsRUFBRyxDQUMzQixHQUFzQixJQUFsQjhJLEVBQUUvRSxNQUFNNUIsRUFBR0EsR0FDWCxPQUVKLElBQUlyQyxFQUFNLEVBQ1YsSUFBSyxJQUFJdUIsRUFBSSxFQUFHQSxFQUFJYyxJQUFLZCxFQUNyQnZCLEdBQU9nSixFQUFFL0UsTUFBTTVCLEVBQUdkLEdBQUswSCxFQUFFaEYsTUFBTTFDLEVBQUdyQixHQUV0QytJLEVBQUUvRSxVQUFVN0IsRUFBR25DLEdBQUlvQixFQUFFMkMsTUFBTTVCLEVBQUduQyxHQUFLRixHQUFPZ0osRUFBRS9FLE1BQU01QixFQUFHQSxLQUk3RCxNQUFPLENBQUUyRyxFQUFHQSxFQUFHQyxFQUFHQTs7Ozs7T0FRdEJoRyxXQUFXM0IsR0FDUCxNQUFNSyxFQUFPTCxFQUFFTSxNQUFNLElBQ2ZvSCxFQUFFQSxFQUFDQyxFQUFFQSxHQUFNekcsT0FBTzBHLEdBQUc1SCxHQUNyQjZILEVBQVNILEVBQUVqQixLQUNYcUIsRUFBU0gsRUFBRWxCLEtBQ2pCLElBQUlzQixFQUFNRixFQUFPLEdBQUtDLEVBQU8sR0FDN0IsSUFBSyxJQUFJcEgsRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxFQUM1QnFILEdBQU9GLEVBQU9uSCxHQUFPb0gsRUFBT3BILEdBRWhDLE9BQU9xSDs7Ozs7O09BU1hwRyxXQUFXcUcsRUFBRy9ILEVBQUksR0FDZCxNQUFNZ0ksRUFBS0QsRUFBRWxGLEVBQ2IsSUFBSW9GLEVBQU1ELEVBQUd0RSxJQUFJcUUsR0FDYkcsRUFBTUgsRUFBRXJFLElBQUlzRSxJQUNWRyxhQUFjQyxFQUFHQyxZQUFhQyxHQUFVQyw0QkFBNEJOLEVBQUtqSSxJQUN6RW1JLGFBQWNULEdBQU1hLDRCQUE0QkwsRUFBS2xJLEdBQzNELE1BQU8sQ0FBRTBILEVBQUdBLEVBQUdZLE1BQU9BLEVBQU0zSCxLQUFLNkgsR0FBVXZLLEtBQUtDLEtBQUtzSyxLQUFTSixFQUFHQTs7Ozs7Ozs7Ozs7Ozs7O0dDLzRCMUQseUJBQVVySSxFQUFHRyxFQUFTQyxXQUNqQyxJQUFJNUIsRUFBSXdCLEVBQUVNLE1BQU0sR0FDaEIsTUFBTUMsRUFBSSxJQUFJVyxPQUFPMUMsRUFBR0EsR0FDeEIsSUFBSyxJQUFJSSxFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQUcsQ0FDeEIsTUFBTWtGLEVBQU05RCxFQUFFVSxJQUFJOUIsR0FDbEIsSUFBSyxJQUFJbUMsRUFBSW5DLEVBQUksRUFBR21DLEVBQUl2QyxJQUFLdUMsRUFBRyxDQUM1QixNQUFNMkgsRUFBT3ZJLEVBQU8yRCxFQUFLOUQsRUFBRVUsSUFBSUssSUFDL0JSLEVBQUVxQyxVQUFVaEUsRUFBR21DLEVBQUcySCxHQUNsQm5JLEVBQUVxQyxVQUFVN0IsRUFBR25DLEVBQUc4SixJQUcxQixPQUFPbkk7Ozs7Ozs7O0dDWkksa0JBQVVvSSxFQUFPQyxFQUFLQyxFQUFTLE1BSTFDLEdBSEtBLElBQ0RBLEVBQVMzSyxLQUFLc0IsSUFBSXRCLEtBQUs0SyxNQUFNRixFQUFNRCxHQUFTLEVBQUcsSUFFL0NFLEVBQVMsRUFDVCxPQUFrQixJQUFYQSxFQUFlLENBQUNGLEdBQVMsR0FFcEMsSUFBSXBDLEVBQVMsSUFBSXZILE1BQU02SixHQUV2QixJQUFLLElBQUlqSyxFQURUaUssR0FBVSxFQUNXakssR0FBSyxJQUFLQSxFQUMzQjJILEVBQU8zSCxJQUFNQSxFQUFJZ0ssR0FBT0MsRUFBU2pLLEdBQUsrSixHQUFTRSxFQUVuRCxPQUFPdEM7bURDaEJJO2NBQVNYLEVBQUd6RixFQUFTQzs7QUFFaEMsSUFBSTJJLEVBQVMsS0FDYixHQUFJbkQsYUFBYTFFLE9BQVEsQ0FDckIsSUFBS2IsRUFBTWUsR0FBUXdFLEVBQUV0RixNQUNyQixHQUFhLElBQVRELEVBQVkwSSxFQUFTbkQsRUFBRWxGLElBQUksT0FDMUIsQ0FBQSxHQUFhLElBQVRVLEVBQ0osS0FBTSxxQkFEVTJILEVBQVNuRCxFQUFFOUUsSUFBSSxTQUdwQ2lJLEVBQVNuRCxFQUViLElBQUlwSCxFQUFJdUssRUFBT3RLLE9BQ1g2SSxFQUFJLElBQUl0SSxNQUFNUixHQUVsQixPQURBOEksRUFBRTBCLEtBQUssR0FDQTdJLEVBQU80SSxFQUFRekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0NYbkIsTUFBTUw7Ozs7Ozs7QUFPVDlGLFlBQVk4SCxHQVVSLE9BVEEzSCxLQUFLNEgsR0FBSyxJQUNWNUgsS0FBSzZILEdBQUssSUFDVjdILEtBQUs4SCxVQUFZLFdBQ2pCOUgsS0FBSytILFlBQWMsV0FDbkIvSCxLQUFLZ0ksWUFBYyxXQUNuQmhJLEtBQUtpSSxJQUFNLElBQUl2SyxNQUFNc0MsS0FBSzRILElBQzFCNUgsS0FBS2tJLEtBQU9sSSxLQUFLaUUsRUFBSSxFQUVyQmpFLEtBQUttSSxLQUFPUixJQUFTLElBQUlTLE1BQU9DLFVBQ3pCckksS0FHUG1JLFNBQUtSLEdBQ0wzSCxLQUFLMkgsTUFBUUEsRUFDYixJQUFJVyxFQUFLdEksS0FBS2lJLElBR2QsSUFEQUssRUFBRyxHQUFLWCxJQUFVLEVBQ2IzSCxLQUFLa0ksS0FBTyxFQUFHbEksS0FBS2tJLEtBQU9sSSxLQUFLNEgsR0FBSTVILEtBQUtrSSxNQUFRLEVBQUcsQ0FDckQsSUFBSUssRUFBTXZJLEtBQUtrSSxLQUNYekssRUFBSTZLLEVBQUdDLEVBQU0sR0FBTUQsRUFBR0MsRUFBTSxLQUFPLEdBQ3ZDRCxFQUFHQyxJQUFxQyxhQUF0QixXQUFKOUssS0FBb0IsS0FBcUIsSUFBeUIsWUFBZCxNQUFKQSxHQUErQjhLLEVBQzdGRCxFQUFHQyxNQUFVOzs7O09BUWpCSixXQUNBLE9BQU9uSSxLQUFLMkg7Ozs7T0FPWjlCLGFBQ0EsT0FBTzdGLEtBQUt3SSxZQUFjLEVBQU07Ozs7T0FPaENBLGlCQUNBLElBQUl4TCxFQUNBeUwsRUFBUSxJQUFJL0ssTUFBTSxFQUFLc0MsS0FBSzhILFdBQ2hDLEdBQUk5SCxLQUFLa0ksTUFBUWxJLEtBQUs0SCxHQUFJLENBQ3RCLElBQUljLEVBTUFDLEVBQU0zSSxLQUFLNEgsR0FBSzVILEtBQUs2SCxHQUNyQmUsRUFBTTVJLEtBQUs2SCxHQUFLN0gsS0FBSzRIOzs7Z0JBRXpCLElBQUtjLEVBQUssRUFBR0EsRUFBS0MsSUFBT0QsRUFDckIxTCxFQUFLZ0QsS0FBS2lJLElBQUlTLEdBQU0xSSxLQUFLK0gsWUFBZ0IvSCxLQUFLaUksSUFBSVMsRUFBSyxHQUFLMUksS0FBS2dJLFlBQ2pFaEksS0FBS2lJLElBQUlTLEdBQU0xSSxLQUFLaUksSUFBSVMsRUFBSzFJLEtBQUs2SCxJQUFPN0ssSUFBTSxFQUFLeUwsRUFBVSxFQUFKekwsR0FFOUQsS0FBTzBMLEVBQUsxSSxLQUFLNEgsR0FBSyxJQUFLYyxFQUN2QjFMLEVBQUtnRCxLQUFLaUksSUFBSVMsR0FBTTFJLEtBQUsrSCxZQUFnQi9ILEtBQUtpSSxJQUFJUyxFQUFLLEdBQUsxSSxLQUFLZ0ksWUFDakVoSSxLQUFLaUksSUFBSVMsR0FBTTFJLEtBQUtpSSxJQUFJUyxFQUFLRSxHQUFRNUwsSUFBTSxFQUFLeUwsRUFBVSxFQUFKekwsR0FHMURBLEVBQUtnRCxLQUFLaUksSUFBSWpJLEtBQUs0SCxHQUFLLEdBQUs1SCxLQUFLK0gsWUFBZ0IvSCxLQUFLaUksSUFBSSxHQUFLakksS0FBS2dJLFlBQ3JFaEksS0FBS2lJLElBQUlqSSxLQUFLNEgsR0FBSyxHQUFLNUgsS0FBS2lJLElBQUlqSSxLQUFLNkgsR0FBSyxHQUFNN0ssSUFBTSxFQUFLeUwsRUFBVSxFQUFKekwsR0FFbEVnRCxLQUFLa0ksS0FBTyxFQVNoQixPQU5BbEwsRUFBSWdELEtBQUtpSSxJQUFLakksS0FBS2tJLE1BQVEsR0FDM0JsTCxHQUFLQSxJQUFNLEdBQ1hBLEdBQU1BLEdBQUssRUFBSyxXQUNoQkEsR0FBTUEsR0FBSyxHQUFNLFdBQ2pCQSxHQUFLQSxJQUFNLEdBRUpBLElBQU07Ozs7OztPQVNqQjZMLE9BQU9uSyxFQUFHeEIsR0FDTixHQUFJd0IsYUFBYWtCLE9BQVEsQ0FDckIsSUFBSWIsRUFBT0wsRUFBRU0sTUFBTSxHQUNuQixHQUFJOUIsRUFBSTZCLEVBQ0osTUFBTSxJQUFJMEIsTUFBTSxvQkFFcEIsSUFBSXFJLEVBQVMsSUFBSXBMLE1BQU1SLEdBQ25CNkwsRUFBYUMsU0FBUyxFQUFHakssRUFBTyxHQUNwQyxJQUFLLElBQUl6QixFQUFJLEVBQUd1RixFQUFJa0csRUFBVzVMLE9BQVFHLEVBQUlKLElBQUtJLElBQUt1RixFQUFHLENBQ3BELElBQUlvRyxFQUFlakosS0FBS3dJLFdBQWEzRixFQUNyQ2lHLEVBQU94TCxHQUFLeUwsRUFBV0csT0FBT0QsRUFBYyxHQUFHLEdBRW5ELE9BQU9ILEVBQU94SixLQUFLeUcsR0FBTXJILEVBQUVVLElBQUkyRyxLQUM1QixHQUFJckksTUFBTThDLFFBQVE5QixJQUFNQSxhQUFhMEIsYUFBYyxDQUN0RCxJQUFJckIsRUFBT0wsRUFBRXZCLE9BQ2IsR0FBSUQsRUFBSTZCLEVBQ0osTUFBTSxJQUFJMEIsTUFBTSxvQkFFcEIsSUFBSXFJLEVBQVMsSUFBSXBMLE1BQU1SLEdBQ25CNkwsRUFBYUMsU0FBUyxFQUFHakssRUFBTyxHQUNwQyxJQUFLLElBQUl6QixFQUFJLEVBQUd1RixFQUFJa0csRUFBVzVMLE9BQVFHLEVBQUlKLElBQUtJLElBQUt1RixFQUFHLENBQ3BELElBQUlvRyxFQUFlakosS0FBS3dJLFdBQWEzRixFQUNyQ2lHLEVBQU94TCxHQUFLeUwsRUFBV0csT0FBT0QsRUFBYyxHQUFHLEdBRW5ELE9BQU9ILEVBQU94SixLQUFLeUcsR0FBTXJILEVBQUVxSDs7Ozs7Ozs7T0FZbkMxRixjQUFjM0IsRUFBR3hCLEVBQUdpTCxFQUFPLE1BRXZCLE9BRFUsSUFBSXhDLFdBQVd3QyxHQUNoQlUsT0FBT25LLEVBQUd4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dDdElaLGFBQVUyRCxHQUNyQixJQUFJM0MsRUFDSixJQUFLLE1BQU02QixLQUFTYyxFQUNILE1BQVRkLElBQWtCN0IsRUFBTTZCLFFBQWtCb0osSUFBUmpMLEdBQXFCNkIsR0FBU0EsS0FDaEU3QixFQUFNNkIsR0FHZCxPQUFPN0I7Ozs7Ozs7R0NQSSxhQUFVMkMsR0FDckIsSUFBSXdFLEVBQ0osSUFBSyxNQUFNdEYsS0FBU2MsRUFDSCxNQUFUZCxJQUFrQnNGLEVBQU10RixRQUFrQm9KLElBQVI5RCxHQUFxQnRGLEdBQVNBLEtBQ2hFc0YsRUFBTXRGLEdBR2QsT0FBT3NGOzs7O0dDVkosTUFBTStEOzs7Ozs7Ozs7Ozs7QUFZVHZKLFlBQVl3SixFQUFXLEtBQU1DLEVBQVd2RCxDQUFBQSxHQUFLQSxHQUFHd0QsRUFBYSxPQUN6RCxPQUFJRixFQUNPRCxLQUFLSSxRQUFRSCxFQUFVQyxFQUFVQyxJQUV4Q3ZKLEtBQUt5SixVQUFZSCxFQUNqQnRKLEtBQUswSixXQUFhLEdBRWQxSixLQUFLMkosWUFEUyxPQUFkSixFQUNtQixDQUFDN00sRUFBR0MsSUFBTUQsRUFBSUMsRUFDWixPQUFkNE0sRUFDWSxDQUFDN00sRUFBR0MsSUFBTUQsRUFBSUMsRUFFZDRNLEVBRWhCdko7Ozs7Ozs7T0FXZkssZUFBZWdKLEVBQVVDLEVBQVd2RCxDQUFBQSxHQUFLQSxHQUFHd0QsRUFBYSxPQUNyRCxNQUFNSyxFQUFPLElBQUlSLEtBQUssS0FBTUUsRUFBVUMsR0FDaENNLEVBQVlELEVBQUtGLFdBQ3ZCLElBQUssTUFBTS9HLEtBQUswRyxFQUNaUSxFQUFVNUwsS0FBSyxDQUNYNkwsUUFBV25ILEVBQ1g1QyxNQUFTdUosRUFBUzNHLEtBRzFCLElBQUssSUFBSXJGLEVBQUlWLEtBQUttTixNQUFPVixFQUFTbE0sT0FBUyxFQUFLLEdBQUlHLEdBQUssSUFBS0EsRUFDMURzTSxFQUFLSSxjQUFjMU0sR0FFdkIsT0FBT3NNOzs7Ozs7T0FTWEssTUFBTUMsRUFBU0MsR0FDWCxNQUFNTixFQUFZN0osS0FBSzBKLFlBQ3RCRyxFQUFVTSxHQUFVTixFQUFVSyxJQUFZLENBQUNMLEVBQVVLLEdBQVVMLEVBQVVNOzs7T0FPOUVDLGNBQ0ksTUFBTVAsRUFBWTdKLEtBQUswSixXQUN2QixJQUFJVyxFQUFRUixFQUFVMU0sT0FBUyxFQUMvQixLQUFPa04sRUFBUSxHQUFHLENBQ2QsSUFBSUMsRUFBYzFOLEtBQUttTixPQUFPTSxFQUFRLEdBQUssR0FDM0MsSUFBS3JLLEtBQUsySixZQUFZRSxFQUFVUSxHQUFPdEssTUFBTzhKLEVBQVVTLEdBQWF2SyxPQUNqRSxNQUVKQyxLQUFLaUssTUFBTUssRUFBYUQsR0FDeEJBLEVBQVFDOzs7OztPQVVoQnJNLEtBQUs2TCxHQUNELE1BRU1TLEVBQU8sQ0FBQ1QsUUFBV0EsRUFBUy9KLE1BRnBCQyxLQUFLeUosVUFBVUs7d0NBSzdCO09BRkE5SixLQUFLMEosV0FBV3pMLEtBQUtzTSxHQUNyQnZLLEtBQUtvSyxjQUNFcEs7Ozs7T0FPWGdLLGNBQWNRLEVBQVksR0FDdEIsTUFBTVgsRUFBWTdKLEtBQUswSixXQUNqQkgsRUFBYXZKLEtBQUsySixZQUNsQnhNLEVBQVMwTSxFQUFVMU0sT0FDekIsSUFBSXNOLEVBQU8sRUFBSUQsRUFBYyxFQUN6QkUsRUFBUSxFQUFJRixFQUFjLEVBQzFCSCxFQUFRRyxFQUNaLEdBQUlILEVBQVFsTixFQUFRLEtBQU0sMkJBQ3RCc04sRUFBT3ROLEdBQVVvTSxFQUFXTSxFQUFVWSxHQUFNMUssTUFBTzhKLEVBQVVRLEdBQU90SyxTQUNwRXNLLEVBQVFJLEdBRVJDLEVBQVF2TixHQUFVb00sRUFBV00sRUFBVWEsR0FBTzNLLE1BQU84SixFQUFVUSxHQUFPdEssU0FDdEVzSyxFQUFRSyxHQUVSTCxJQUFVRyxJQUNWeEssS0FBS2lLLE1BQU1PLEVBQWFILEdBQ3hCckssS0FBS2dLLGNBQWNLOzs7O09BUTNCTSxNQUNJLE1BQU1kLEVBQVk3SixLQUFLMEosV0FDdkIsR0FBeUIsSUFBckJHLEVBQVUxTSxPQUNWLE9BQU8sS0FDSixHQUF5QixJQUFyQjBNLEVBQVUxTSxPQUNqQixPQUFPME0sRUFBVWMsTUFFckIzSyxLQUFLaUssTUFBTSxFQUFHSixFQUFVMU0sT0FBUyxHQUNqQyxNQUFNeU4sRUFBT2YsRUFBVWMsTUFFdkIsT0FEQTNLLEtBQUtnSyxnQkFDRVk7Ozs7T0FPUEMsWUFDQSxPQUFPN0ssS0FBSzBKLFdBQVd2TSxPQUFTLEVBQUk2QyxLQUFLMEosV0FBVyxHQUFLOzs7O09BUTdEb0IsV0FDSSxJQUFLLElBQUl4TixFQUFJLEVBQUdKLEVBQUk4QyxLQUFLMEosV0FBV3ZNLE9BQVFHLEVBQUlKLElBQUtJLFFBQzNDMEMsS0FBSzBKLFdBQVdwTSxHQUFHd007Ozs7T0FRakNpQixVQUNJLE9BQU8vSyxLQUFLWSxPQUNQbEIsTUFBSyxDQUFDaEQsRUFBRUMsSUFBTXFELEtBQUsySixZQUFZak4sRUFBR0MsSUFBTSxFQUFJOzs7O09BT3JEaUUsT0FDSSxPQUFPWixLQUFLMEosV0FDUHBLLEtBQUl5RyxHQUFLQSxFQUFFK0Q7Ozs7T0FPcEJrQixXQUNJLE9BQU9oTCxLQUFLMEo7Ozs7T0FPWnZNLGFBQ0EsT0FBTzZDLEtBQUswSixXQUFXdk07Ozs7T0FPdkI4TixZQUNBLE9BQXVCLElBQWhCakwsS0FBSzdDOzs7OztHQ2hNYixNQUFNK047Ozs7Ozs7O0FBUVRyTCxZQUFZd0osRUFBVyxNQUVuQixHQURBckosS0FBS21MLE1BQVEsSUFBSUMsSUFDYi9CLEVBQ0EsSUFBSyxNQUFNMUcsS0FBSzBHLEVBQ1pySixLQUFLcUwsU0FBUzFJLEdBR3RCLE9BQU8zQyxLQUdYcUwsU0FBUzFOLEdBQ0wsTUFBTTJOLEVBQU90TCxLQUFLbUwsTUFRbEIsT0FQS0csRUFBS0MsSUFBSTVOLEtBQ1YyTixFQUFLeEcsSUFBSW5ILEdBQ1RBLEVBQUU2TixlQUFpQixHQUNuQjdOLEVBQUU2TixlQUFlQyxPQUFTOU4sRUFDMUJBLEVBQUU2TixlQUFlRSxTQUFXLElBQUlOLElBQUksQ0FBQ3pOLElBQ3JDQSxFQUFFNk4sZUFBZUcsS0FBTyxHQUVyQjNMLEtBR1g0TCxLQUFLak8sR0FFRCxPQURhcUMsS0FBS21MLE1BQ1RJLElBQUk1TixHQUNMQSxFQUFFNk4sZUFBZUMsU0FBVzlOLEdBQzVCQSxFQUFFNk4sZUFBZUUsU0FBUzVHLE9BQU9uSCxHQUNqQ0EsRUFBRTZOLGVBQWVDLE9BQVN6TCxLQUFLNEwsS0FBS2pPLEVBQUU2TixlQUFlQyxRQUM5QzlOLEVBQUU2TixlQUFlQyxRQUVqQjlOLEVBR0osS0FJZmtPLE1BQU1sTyxFQUFHWCxHQUNMLElBQUk4TyxFQUFTOUwsS0FBSzRMLEtBQUtqTyxHQUNuQm9PLEVBQVMvTCxLQUFLNEwsS0FBSzVPLEdBRXZCLE9BQUk4TyxJQUFXQyxJQUNYRCxFQUFPTixlQUFlRyxLQUFPSSxFQUFPUCxlQUFlRyxRQUFPRyxFQUFRQyxHQUFVLENBQUNBLEVBQVFELElBRXpGQyxFQUFPUCxlQUFlQyxPQUFTSzs7QUFFL0JDLEVBQU9QLGVBQWVFLFNBQVNNLFFBQVFGLEVBQU9OLGVBQWVFLFNBQVM1RyxJQUFLZ0gsRUFBT04sZUFBZUUsVUFDakdJLEVBQU9OLGVBQWVHLE1BQVFJLEVBQU9QLGVBQWVHLE1BTnRCM0w7Ozs7R0NoRC9CLE1BQU1pTTs7Ozs7Ozs7Ozs7O0FBWVRwTSxZQUFZd0osRUFBVyxLQUFNeEssRUFBU0MsV0FrQmxDLE9BakJBa0IsS0FBS2tNLE1BQVEsTUFDVHJNLFlBQVlzTSxFQUFPQyxFQUFPLEtBQU1DLEVBQU8sS0FBTUMsRUFBTyxNQUNoRHRNLEtBQUttTSxNQUFRQSxFQUNibk0sS0FBS29NLE9BQVNBLEVBQ2RwTSxLQUFLcU0sT0FBU0EsRUFDZHJNLEtBQUtzTSxPQUFTQSxJQUd0QnRNLEtBQUt1TSxNQUFRLE1BQ1QxTSxZQUFZMk0sR0FDUnhNLEtBQUt3TSxPQUFTQSxJQUd0QnhNLEtBQUt5TSxRQUFVNU4sRUFDWHdLLEdBQ0FySixLQUFLOEUsSUFBSXVFLEdBRU5ySjs7Ozs7T0FRWDhFLElBQUl1RSxHQUtBLE9BSkFBLEVBQVdBLEVBQVMvSixLQUFJLENBQUN3SyxFQUFTTyxLQUN2QixDQUFDQSxNQUFPQSxFQUFPUCxRQUFTQSxNQUVuQzlKLEtBQUswTSxNQUFRMU0sS0FBSzJNLFdBQVd0RCxHQUN0QnJKOzs7OztPQVFYMk0sV0FBV3RELEdBQ1AsR0FBd0IsSUFBcEJBLEVBQVNsTSxPQUNULE9BQU8sSUFBSTZDLEtBQUt1TSxNQUFNbEQsR0FDbkIsQ0FDSCxJQVFJM0gsRUFSQWtMLEVBQUk1TSxLQUFLNk0saUJBQWlCeEQsR0FDMUJ5RCxFQUFrQnpELEVBQVMzSixNQUFLLENBQUNoRCxFQUFHQyxJQUFNRCxFQUFFb04sUUFBUThDLEdBQUtqUSxFQUFFbU4sUUFBUThDLEtBQ25FMVAsRUFBSTRQLEVBQWdCM1AsT0FDcEI0UCxFQUFVblEsS0FBS21OLE1BQU03TSxFQUFJLEdBQ3pCOFAsRUFBSTNELEVBQVMwRCxHQUNiM0csRUFBSTBHLEVBQWdCbk4sTUFBTSxFQUFHb04sR0FDN0I3SSxFQUFJNEksRUFBZ0JuTixNQUFNb04sRUFBUzdQLEdBQ25Db1AsRUFBUzFQLEtBQUtzQixPQUFPbUwsRUFBUy9KLEtBQUl5RyxHQUFLL0YsS0FBS3lNLFFBQVFPLEVBQUVsRCxRQUFTL0QsRUFBRStELFlBT3JFLE9BSklwSSxFQURBMEUsRUFBRWpKLE9BQVMsR0FBSytHLEVBQUUvRyxPQUFTLEVBQ3ZCLElBQUk2QyxLQUFLa00sTUFBTWMsRUFBR2hOLEtBQUsyTSxXQUFXdkcsR0FBSXBHLEtBQUsyTSxXQUFXekksR0FBSW9JLEdBRTFELElBQUl0TSxLQUFLdU0sTUFBTWxELEdBRWhCM0g7Ozs7O09BU2ZtTCxpQkFBaUJuTCxHQUNiLElBQUlxRSxFQUFJckUsRUFBRSxHQUFHb0ksUUFBUTNNLE9BQ2pCa0ssRUFBUSxJQUFJM0osTUFBTXFJLEdBRXRCLElBQUssSUFBSXpJLEVBQUksRUFBR0EsRUFBSXlJLElBQUt6SSxFQUNyQitKLEVBQU0vSixHQUFLLENBQUN3RSxFQUFBQSxHQUFXQSxFQUFBQSxHQUczQixJQUFJbUwsRUFBU3ZMLEVBQUV3TCxRQUFPLENBQUNDLEVBQUtDLEtBQ3hCLElBQUssSUFBSTlQLEVBQUksRUFBR0EsRUFBSXlJLElBQUt6SSxFQUNyQjZQLEVBQUk3UCxHQUFHLEdBQUtWLEtBQUt5SSxJQUFJOEgsRUFBSTdQLEdBQUcsR0FBSThQLEVBQVF0RCxRQUFReE0sSUFDaEQ2UCxFQUFJN1AsR0FBRyxHQUFLVixLQUFLc0IsSUFBSWlQLEVBQUk3UCxHQUFHLEdBQUk4UCxFQUFRdEQsUUFBUXhNLElBRXBELE9BQU82UCxJQUNSOUYsR0FDSDRGLEVBQVNBLEVBQU8zTixLQUFJeUcsR0FBS0EsRUFBRSxHQUFLQSxFQUFFLEtBRWxDLElBQUk2RyxFQUFJLEVBQ1IsSUFBSyxJQUFJdFAsRUFBSSxFQUFHQSxFQUFJeUksSUFBS3pJLEVBQ3JCc1AsRUFBSUssRUFBTzNQLEdBQUsyUCxFQUFPTCxHQUFLdFAsRUFBSXNQLEVBRXBDLE9BQU9BOzs7Ozs7T0FTWFMsT0FBT3BRLEVBQUcwQixFQUFJLEdBQ1YsT0FBT3FCLEtBQUtzTixRQUFRclEsRUFBRzBCLEVBQUcsSUFBSXlLLEtBQUssTUFBTXJELEdBQUsvRixLQUFLeU0sUUFBUTFHLEVBQUUrRCxRQUFTN00sSUFBSSxPQUFRK0MsS0FBSzBNOzs7Ozs7O09BVTNGWSxRQUFRclEsRUFBRzBCLEVBQUc0TyxFQUFHN0w7O0FBRWIsR0FBSTZMLEVBQUVwUSxRQUFVd0IsR0FBSytDLEVBQUV5SyxPQUFTekssRUFBRTRLLFFBQVV0TSxLQUFLeU0sUUFBUXhQLEVBQUd5RSxFQUFFeUssTUFBTXJDLFNBQVdwSSxFQUFFNEssUUFBVWlCLEVBQUUxQyxNQUFNOUssTUFDL0YsT0FBT3dOOztBQU1YLEdBSkk3TCxFQUFFMEssUUFBUXBNLEtBQUtzTixRQUFRclEsRUFBRzBCLEVBQUc0TyxFQUFHN0wsRUFBRTBLLFFBQ2xDMUssRUFBRTJLLFFBQVFyTSxLQUFLc04sUUFBUXJRLEVBQUcwQixFQUFHNE8sRUFBRzdMLEVBQUUySyxRQUdsQzNLLEVBQUU4SyxPQUNGLElBQUssSUFBSWxQLEVBQUksRUFBR0osRUFBSXdFLEVBQUU4SyxPQUFPclAsT0FBUUcsRUFBSUosSUFBS0ksRUFBRyxDQUM3QyxJQUFJMFAsRUFBSXRMLEVBQUU4SyxPQUFPbFAsR0FDYnFCLEVBQUk0TyxFQUFFcFEsT0FDTm9RLEVBQUV0UCxLQUFLK08sSUFFUE8sRUFBRXRQLEtBQUsrTyxHQUNQTyxFQUFFNUMsT0FJZCxPQUFPNEM7Ozs7R0N6SVIsTUFBTUM7Ozs7Ozs7Ozs7QUFVVDNOLFlBQVl3SixFQUFTLEtBQU14SyxFQUFPQyxXQUM5QmtCLEtBQUt5TSxRQUFVNU4sRUFDZm1CLEtBQUt5TixVQUFZcEUsYUFBb0J6SixPQUFTeUosRUFBV3pKLE9BQU9QLEtBQUtnSyxHQUNyRSxNQUFNcEYsRUFBSWpFLEtBQUt5TixVQUFVek8sTUFBTSxHQUUzQmdCLEtBQUswTixHQURNLGdCQUFYN08sRUFDVW1CLEtBQUt5TixVQUFVbE4sUUFFZjNCLGdCQUFnQm9CLEtBQUt5TixVQUFXNU8sR0FFOUNtQixLQUFLd04sSUFBTSxHQUNYLElBQUssSUFBSXBPLEVBQU0sRUFBR0EsRUFBTTZFLElBQUs3RSxFQUFLLENBQzlCLE1BQU11TyxFQUFZM04sS0FBSzBOLEdBQUd0TyxJQUFJQSxHQUN4QndPLEVBQUksSUFBSXhFLEtBQUssTUFBTXJELEdBQUtBLEVBQUVoRyxPQUFPLE9BQ3ZDLElBQUssSUFBSU4sRUFBSSxFQUFHQSxFQUFJd0UsSUFBS3hFLEVBQ3JCbU8sRUFBRTNQLEtBQUssQ0FDSDhCLE1BQU80TixFQUFVbE8sR0FDakI0SyxNQUFPNUssSUFHZk8sS0FBS3dOLElBQUl2UCxLQUFLMlA7Ozs7OztPQVV0QlAsT0FBT3BRLEVBQUcwQixFQUFJLEdBQ1YsTUFBTUUsRUFBU21CLEtBQUt5TSxRQUNkZSxFQUFNeE4sS0FBS3dOLElBQ2pCLElBQUlJLEVBQ0osR0FBSWxRLE1BQU04QyxRQUFRdkQsR0FBSSxDQUNsQixHQUFvQixlQUFoQitDLEtBQUt5TSxRQUNMLEtBQU0seUZBRVYsTUFBTXBELEVBQVdySixLQUFLeU4sVUFDaEJ4SixFQUFJdUosRUFBSXJRLE9BQ2QsSUFBSTBRLEVBQXdCLEtBQ3hCQyxFQUFlaE0sRUFBQUEsRUFDbkIsSUFBSyxJQUFJeEUsRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQUcsQ0FDeEIsTUFDTThKLEVBQU92SSxFQUFPNUIsRUFESm9NLEVBQVNqSyxJQUFJOUIsSUFFekI4SixFQUFPMEcsSUFDUEQsRUFBd0J2USxFQUN4QndRLEVBQWUxRyxHQUd2QndHLEVBQUlKLEVBQUlLLFFBQ0RFLE9BQU9DLFVBQVUvUSxLQUN4QjJRLEVBQUlKLEVBQUl2USxJQUdaLElBQUlnSSxFQUFTLEdBQ2IsSUFBSyxJQUFJM0gsRUFBSSxFQUFHQSxFQUFJcUIsSUFBS3JCLEVBQ3JCMkgsRUFBT2hILEtBQUsyUCxFQUFFakQsT0FHbEIsT0FEQTFGLEVBQU8rRyxTQUFRaE8sR0FBTzRQLEVBQUUzUCxLQUFLRCxFQUFJOEwsV0FDMUI3RTs7Ozs7Ozs7R0NqRUEsWUFBU3ZHLEdBQ3BCLE1BQU9LLEVBQU1lLEdBQVFwQixFQUFFTSxNQUNqQnVPLEVBQUksSUFBSTNOLE9BQU9iLEVBQU1lLEVBQU0sWUFDM0JvRSxFQUFJLElBQUl0RSxPQUFPRSxFQUFNQSxFQUFNLEdBRWpDLElBQUssSUFBSUwsRUFBSSxFQUFHQSxFQUFJSyxJQUFRTCxFQUFHLENBQzNCLElBQUk2RSxFQUFJNUYsRUFBRWMsSUFBSUMsR0FDZCxJQUFLLElBQUluQyxFQUFJLEVBQUdBLEVBQUltQyxJQUFLbkMsRUFBRyxDQUN4QixNQUFNMlEsRUFBSVYsRUFBRS9OLElBQUlsQyxHQUNWNFEsRUFBVXRRLFlBQVlxUSxFQUFFM08sS0FBSSxDQUFDNk8sRUFBSXhQLElBQU13UCxFQUFLN0osRUFBRTNGLE1BQ3BEdUYsRUFBRTVDLFVBQVVoRSxFQUFFbUMsRUFBR3lPLEdBQ2pCNUosRUFBSUEsRUFBRWhGLEtBQUksQ0FBQzhPLEVBQUl6UCxJQUFNeVAsRUFBS0YsRUFBVUQsRUFBRXRQLEtBRTFDLE1BQU0wUCxFQUFTQyxLQUFLaEssRUFBR3hGLFdBQ3ZCLElBQUssSUFBSUgsRUFBSSxFQUFHQSxFQUFJSSxJQUFRSixFQUN4QjRPLEVBQUVqTSxVQUFVM0MsRUFBR2MsRUFBRzZFLEVBQUUzRixHQUFLMFAsR0FFN0JuSyxFQUFFNUMsVUFBVTdCLEVBQUVBLEVBQUc0TyxHQUVyQixNQUFPLENBQUNuSyxFQUFLQSxFQUFHcUosRUFBS0E7Ozs7Ozs7O0dDbEJWLHVDQUFTN08sRUFBR0MsRUFBSSxFQUFHNFAsRUFBZSxJQUFLcEcsRUFBSyxNQUN2RCxNQUFNMUMsRUFBYTBDLGFBQWdCeEMsV0FBYXdDLEVBQU8sSUFBSXhDLFdBQVd3QyxHQUNoRXpKLGFBQWFrQixTQUFTbEIsRUFBSWtCLE9BQU9QLEtBQUtYLElBQzVDLE1BQU14QixFQUFJd0IsRUFBRU0sTUFBTSxHQUNsQixJQUFNdU8sRUFBR0EsRUFBR3JKLEVBQUdBLEdBQU1zSyxHQUFHLElBQUk1TyxPQUFPMUMsRUFBR3lCLEdBQUcsSUFBTThHLEVBQVdJLFVBQzFELEtBQU8wSSxLQUFrQixDQUNyQixNQUFNRSxFQUFPdkssRUFBRTNELFFBRVRtTyxFQUFLRixHQUREOVAsRUFBRTJELElBQUlrTCxJQUVoQkEsRUFBSW1CLEVBQUduQixFQUNQckosRUFBSXdLLEVBQUd4SyxFQUNIdEcsWUFBWXNHLEVBQUVhLElBQUkwSixHQUFNdEosTUFBUWpJLEVBQUksUUFDcENxUixFQUFpQixHQU16QixNQUFPLENBQ0h2SCxZQUhnQjlDLEVBQUVpQixLQUlsQjJCLGFBSGlCeUcsRUFBRWhNLFlBQVl5RDs7Ozs7O0dDcEJoQyxNQUFNMko7O0FBRUxDLHFCQUNBLE9BQU81TyxLQUFLNk8sZ0JBR1pELG1CQUFldEQsR0FFZixPQURBdEwsS0FBSzZPLGdCQUFrQnZELEVBQ2hCdEw7Ozs7Ozs7Ozs7O09BYVhILFlBQVlzRCxFQUFHNEMsRUFBSSxFQUFHbEgsRUFBU0MsVUFBV3FKLEVBQU8sTUFDN0MsR0FBSXpLLE1BQU04QyxRQUFRMkMsR0FDZG5ELEtBQUs4TyxNQUFRLFFBQ2I5TyxLQUFLbUQsRUFBSXZELE9BQU9QLEtBQUs4RCxPQUNsQixDQUFBLEtBQUlBLGFBQWF2RCxRQUlwQixNQUFNLElBQUlhLE1BQU0sdUJBSGhCVCxLQUFLOE8sTUFBUSxTQUNiOU8sS0FBS21ELEVBQUlBLEVBVWIsT0FOQ25ELEtBQUs0SCxHQUFJNUgsS0FBSzBOLElBQU0xTixLQUFLbUQsRUFBRW5FLE1BQzVCZ0IsS0FBSytPLEdBQUtoSixFQUNWL0YsS0FBS3lNLFFBQVU1TixFQUNmbUIsS0FBSzJILE1BQVFRLEVBQ2JuSSxLQUFLZ1AsWUFBYyxJQUFJckosV0FBV3dDLEdBQ2xDbkksS0FBS2lQLGlCQUFrQixFQUNoQmpQOzs7Ozs7T0FTWGtQLFVBQVVDLEVBQU1wUCxFQUFRLE1BQ3BCLEdBQUlDLEtBQUs0TyxlQUFlUSxTQUFTRCxHQUM3QixNQUFNLElBQUkxTyxNQUFNLEdBQUcwTywrQkFFdkIsT0FBSXBQLEdBQ0FDLEtBQUssSUFBSW1QLEtBQVVwUCxFQUNuQkMsS0FBS2lQLGlCQUFrQixFQUNoQmpQLE1BRUFBLEtBQUssSUFBSW1QLEtBSXhCRSxLQUFLRixFQUFNcFAsRUFBUSxNQUNmLE9BQU9DLEtBQUtrUCxVQUFVQyxFQUFNcFAsR0FHaENpTixFQUFFbUMsRUFBTXBQLEVBQVEsTUFDWixPQUFPQyxLQUFLa1AsVUFBVUMsRUFBTXBQOzs7O09BT2hDdVAsWUFFSSxPQURBdFAsS0FBS3VQLGFBQ0V2UCxLQUFLd1AsV0FHaEJDLGFBQ0ksT0FBT3pQLEtBQUtzUCxZQUdoQkMsYUFDU3ZQLEtBQUtpUCxpQkFBd0MsbUJBQWRqUCxLQUFLMFAsT0FDckMxUCxLQUFLMFAsT0FDTDFQLEtBQUtpUCxpQkFBa0I7OztPQU8zQk8saUJBQ0EsTUFBc0IsV0FBZnhQLEtBQUs4TyxNQUFxQjlPLEtBQUsyUCxFQUFJM1AsS0FBSzJQLEVBQUUzSyxVQUdyRDRLLHlCQUF5QkMsR0FFckIsT0FEVyxJQUFJN1AsUUFBUTZQLEdBQ2JQLFlBR2RqUCxvQkFBb0J3UCxHQUVoQixPQURTLElBQUk3UCxRQUFRNlAsR0FDWFAsWUFHZGpQLGdDQUFnQ3dQLEdBQzVCLE9BQU83UCxLQUFLc1AsYUFBYU8sR0FHN0J4UCxvQkFBcUJ3UCxHQUNqQixNQUNNQyxFQURLLElBQUk5UCxRQUFRNlAsR0FDUkosWUFDZixJQUFLLE1BQU16UixLQUFPOFIsUUFDUjlSOzs7OztHQ2pIWCxNQUFNK1IsWUFBWXBCOzs7Ozs7Ozs7QUFTckI5TyxZQUFZc0QsRUFBRzRDLEVBQUUsR0FFYixPQURBaUssTUFBTTdNLEVBQUc0QyxHQUNGL0Y7OztPQU1Yc1AsWUFDSSxNQUFNbk0sRUFBSW5ELEtBQUttRCxFQUNUNEQsRUFBSS9HLEtBQUtpUSx1QkFFZixPQURBalEsS0FBSzJQLEVBQUl4TSxFQUFFZCxJQUFJMEUsR0FDUi9HLEtBQUt3UDs7OztPQU9oQlMsdUJBQ0ksR0FBSWpRLEtBQUsrRyxFQUNMLE9BQU8vRyxLQUFLK0csRUFFaEIsTUFBTTVELEVBQUluRCxLQUFLbUQsRUFDVCtNLEVBQVF0USxPQUFPUCxLQUFLOEQsRUFBRXFDLFVBQ3RCMkssRUFBU2hOLEVBQUU0QixJQUFJbUwsR0FDZnhOLEVBQUl5TixFQUFPNU8sWUFBWWMsSUFBSThOLElBQ3pCckosYUFBY0MsR0FBTUcsOEJBQTRCeEUsRUFBRzFDLEtBQUsrTyxJQUVoRSxPQURBL08sS0FBSytHLEVBQUluSCxPQUFPUCxLQUFLMEgsR0FBR3hGLFlBQ2pCdkIsS0FBSytHOzs7OztHQ3JDYixNQUFNcUosWUFBWXpCOzs7Ozs7Ozs7OztBQVdyQjlPLFlBQVlzRCxFQUFHNEMsRUFBRSxFQUFHbEgsRUFBT0MsVUFBV3FKLEVBQUssTUFFdkMsT0FEQTZILE1BQU03TSxFQUFHNEMsRUFBR2xILEVBQVFzSixHQUNibkk7Ozs7T0FPWHNQLFlBQ0ksTUFBTW5NLEVBQUluRCxLQUFLbUQsRUFDVHBFLEVBQU9vRSxFQUFFbkUsTUFBTSxHQUNmSCxFQUFTbUIsS0FBS3lNLFFBQ2QvTixFQUFlLGdCQUFYRyxFQUEyQnNFLEVBQUl2RSxnQkFBZ0J1RSxFQUFHdEUsR0FDdER3UixFQUFNM1IsRUFBRThHLFNBQ1I4SyxFQUFNNVIsRUFBRTZHLFNBQ1JnTCxFQUFNN1IsRUFBRTRHLEtBRWR0RixLQUFLd1EsS0FBTzlSLEVBQ1osTUFBTWdELEVBQUksSUFBSTlCLE9BQU9iLEVBQU1BLEdBQU0sQ0FBQ3pCLEVBQUdtQyxJQUFPZixFQUFFMkMsTUFBTS9ELEVBQUdtQyxHQUFLNFEsRUFBSS9TLEdBQUtnVCxFQUFJN1EsR0FBSzhRLEtBRXRFekosYUFBY0MsR0FBTUcsOEJBQTRCeEYsRUFBRzFCLEtBQUsrTyxJQUdoRSxPQUZBL08sS0FBSzJQLEVBQUkvUCxPQUFPUCxLQUFLMEgsR0FBR3hGLFlBRWpCdkIsS0FBS3dQOzs7T0FNaEJpQixTQUNJLE1BQU14TSxFQUFJakUsS0FBS21ELEVBQUVuRSxNQUFNLEdBQ2pCMlEsRUFBSTNQLEtBQUsyUCxFQUNUZSxFQUFNMVEsS0FBS3dRLEtBSVhHLEVBQU0sSUFBSS9RLE9BQ2hCK1EsRUFBSTNSLE1BQVEsQ0FBQ2lGLEVBQUdBLEVBQUcsQ0FBQzNHLEVBQUdtQyxJQUNabkMsRUFBSW1DLEVBQUlYLFVBQVU2USxFQUFFdlEsSUFBSTlCLEdBQUlxUyxFQUFFdlEsSUFBSUssSUFBTWtSLEVBQUl0UCxNQUFNNUIsRUFBR25DLElBRWhFLElBQUlzVCxFQUFVLEVBQ1ZDLEVBQWEsRUFDakIsSUFBSyxJQUFJdlQsRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQ3JCLElBQUssSUFBSW1DLEVBQUluQyxFQUFJLEVBQUdtQyxFQUFJd0UsSUFBS3hFLEVBQ3pCbVIsR0FBV2hVLEtBQUtrVSxJQUFJSixFQUFJclAsTUFBTS9ELEVBQUdtQyxHQUFLa1IsRUFBSXRQLE1BQU0vRCxFQUFHbUMsR0FBSSxHQUN2RG9SLEdBQWNqVSxLQUFLa1UsSUFBSUosRUFBSXJQLE1BQU0vRCxFQUFHbUMsR0FBSSxHQUdoRCxPQUFPN0MsS0FBS0MsS0FBSytULEVBQVVDOzs7OztHQzNENUIsTUFBTUUsZUFBZXBDOzs7Ozs7Ozs7Ozs7QUFZeEI5TyxZQUFZc0QsRUFBRzZOLEVBQVdqTCxFQUFJLEVBQUdsSCxFQUFTQyxVQUFXcUosRUFBSyxNQUl0RCxPQUhBNkgsTUFBTTdNLEVBQUc0QyxFQUFHbEgsRUFBUXNKLEdBQ3BCNkgsTUFBTXBCLGVBQWlCLENBQUMsS0FDeEI1TyxLQUFLa1AsVUFBVSxJQUFLdFMsS0FBS3lJLElBQUkyTCxHQUFhcFUsS0FBS3NCLElBQUl0QixLQUFLbU4sTUFBTS9KLEtBQUttRCxFQUFFbkUsTUFBTSxHQUFLLElBQUssR0FBSWdCLEtBQUs0SCxHQUFJLElBQzNGNUg7Ozs7T0FPWHNQLFlBQ0l0UCxLQUFLdVAsYUFDTCxNQUFNcE0sRUFBSW5ELEtBQUttRCxFQUNUcEUsRUFBT2lCLEtBQUs0SCxHQUNaL0ksRUFBU21CLEtBQUt5TSxRQUVkeE4sRUFBSSxJQUFJVyxPQUNkWCxFQUFFRCxNQUFRLENBQUNELEVBQU1BLEVBQU0sQ0FBQ3pCLEVBQUVtQyxJQUFNbkMsR0FBS21DLEVBQUlaLEVBQU9zRSxFQUFFL0QsSUFBSTlCLEdBQUk2RixFQUFFL0QsSUFBSUssSUFBTVIsRUFBRW9DLE1BQU01QixFQUFFbkMsSUFDaEYsTUFBTTJULEVBQW9CLEdBQzFCLElBQUssSUFBSTNULEVBQUksRUFBR0EsRUFBSXlCLElBQVF6QixFQUFHLENBQzNCLE1BQU04QixFQUFNLEdBQ1osSUFBSyxJQUFJSyxFQUFJLEVBQUdBLEVBQUlWLElBQVFVLEVBQ3hCTCxFQUFJbkIsS0FBSyxDQUNMb00sTUFBUzVLLEVBQ1RGLFNBQVlOLEVBQUVvQyxNQUFNL0QsRUFBR21DLEtBRy9CLE1BQU1tTyxFQUFJLElBQUl4RSxLQUFLaEssR0FBSzJHLEdBQUtBLEVBQUV4RyxVQUFVLE9BQ3pDMFIsRUFBa0JoVCxLQUFLMlAsRUFBRTdDLFVBQVVwTCxNQUFNLEVBQUdLLEtBQUtrUixHQUFLOzs7O2tGQU8xRCxNQUFNQyxFQUFJLElBQUl2UixPQUFPYixFQUFNQSxHQUFNLENBQUN6QixFQUFFbUMsS0FDaEMsTUFBTTJSLEVBQVFILEVBQWtCM1QsR0FBR3NPLE1BQUsxTyxHQUFLQSxFQUFFbU4sUUFBVTVLLElBQ3pELE9BQU8yUixFQUFRQSxFQUFNN1IsU0FBV3VDLEVBQUFBLEtBR3BDLElBQUssSUFBSXhFLEVBQUksRUFBR0EsRUFBSXlCLElBQVF6QixFQUN4QixJQUFLLElBQUltQyxFQUFJLEVBQUdBLEVBQUlWLElBQVFVLEVBQ3hCLElBQUssSUFBSWQsRUFBSSxFQUFHQSxFQUFJSSxJQUFRSixFQUN4QndTLEVBQUU3UCxVQUFVaEUsRUFBR21DLEVBQUc3QyxLQUFLeUksSUFBSThMLEVBQUU5UCxNQUFNL0QsRUFBR21DLEdBQUkwUixFQUFFOVAsTUFBTS9ELEVBQUdxQixHQUFLd1MsRUFBRTlQLE1BQU0xQyxFQUFHYyxLQUtqRixJQUFJNFEsRUFBTSxJQUFJalEsYUFBYXJCLEdBQ3ZCdVIsRUFBTSxJQUFJbFEsYUFBYXJCLEdBQ3ZCd1IsRUFBTSxFQUNON1IsRUFBSSxJQUFJa0IsT0FBT2IsRUFBTUEsR0FBTSxDQUFDekIsRUFBRW1DLEtBQzlCLElBQUlzQyxFQUFNb1AsRUFBRTlQLE1BQU0vRCxFQUFHbUMsR0FLckIsT0FKQXNDLEVBQU1BLElBQVFELEVBQUFBLEVBQVcsRUFBSUMsRUFDN0JzTyxFQUFJL1MsSUFBTXlFLEVBQ1Z1TyxFQUFJN1EsSUFBTXNDLEVBQ1Z3TyxHQUFPeE8sRUFDQUEsS0FHWHNPLEVBQU1BLEVBQUkvUSxLQUFJZ0YsR0FBS0EsRUFBSXZGLElBQ3ZCdVIsRUFBTUEsRUFBSWhSLEtBQUlnRixHQUFLQSxFQUFJdkYsSUFDdkJ3UixHQUFReFIsR0FBUSxFQUNoQixNQUFNMkMsRUFBSSxJQUFJOUIsT0FBT2IsRUFBTUEsR0FBTSxDQUFDekIsRUFBRW1DLElBQU9mLEVBQUUyQyxNQUFNL0QsRUFBRW1DLEdBQUs0USxFQUFJL1MsR0FBS2dULEVBQUk3USxHQUFLOFEsS0FHcEV6SixhQUFjQyxHQUFNRyw4QkFBNEJ4RixFQUFHMUIsS0FBSytPOzs7QUFHaEUsT0FGQS9PLEtBQUsyUCxFQUFJL1AsT0FBT1AsS0FBSzBILEdBQUd4RixZQUVqQnZCLEtBQUt3UDs7Ozs7R0NyRmIsTUFBTTZCLGdCQUFnQjFDOzs7Ozs7Ozs7Ozs7O0FBYXpCOU8sWUFBWXNELEVBQUc0QyxFQUFFLEVBQUdsSCxFQUFPQyxVQUFXcUosRUFBSyxNQUV2QyxPQURBNkgsTUFBTTdNLEVBQUc0QyxFQUFHbEgsRUFBUXNKLEdBQ2JuSTs7Ozs7O09BU1hzUix3QkFBd0JsSyxHQUNwQixNQUNNbkQsRUFESWpFLEtBQUttRCxFQUNIbkUsTUFBTSxHQUNsQixJQUFJdVMsRUFBVXZSLEtBQUtnUCxZQUFZeEcsV0FBYXZFLEVBQUksRUFDNUN1TixFQUFVLEtBQ1ZDLEdBQVkzUCxFQUFBQSxFQUNoQixJQUFLLElBQUl4RSxFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFBRyxDQUN4QixNQUFNb1UsRUFBT3RLLEVBQUttSyxFQUFTalUsR0FDdkJvVSxFQUFPRCxJQUNQQSxFQUFXQyxFQUNYRixFQUFVbFUsR0FHbEJtVSxHQUFZM1AsRUFBQUEsRUFDWixJQUFLLElBQUl4RSxFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFBRyxDQUN4QixNQUFNcVUsRUFBT3ZLLEVBQUtvSyxFQUFTbFUsR0FDdkJxVSxFQUFPRixJQUNQQSxFQUFXRSxFQUNYSixFQUFValUsR0FHbEIsTUFBTyxDQUFDaVUsRUFBU0MsRUFBU0M7Ozs7T0FPOUJuQyxZQUNJLE1BQU1uTSxFQUFJbkQsS0FBS21ELEVBQ1RjLEVBQUlkLEVBQUVuRSxNQUFNLEdBQ1orRyxFQUFJL0YsS0FBSytPLEdBQ1RsUSxFQUFTbUIsS0FBS3lNLFFBQ2RrRCxFQUFJLElBQUkvUCxPQUFPcUUsRUFBRzhCLEVBQUcsR0FDM0IsSUFBSXFCLEtBQU8sQ0FBQzFLLEVBQUdDLElBQU1rQyxFQUFPc0UsRUFBRS9ELElBQUkxQyxHQUFJeUcsRUFBRS9ELElBQUl6QyxJQUU1QyxJQUFLLElBQUlpVixFQUFPLEVBQUdBLEVBQU83TCxJQUFLNkwsRUFBTSxDQUNqQyxJQUFJQyxFQUFXeks7dUJBRWY7TUFBT21LLEVBQVNDLEVBQVNNLEdBQVE5UixLQUFLc1Isd0JBQXdCbEs7Ozs7Ozs7Ozt1QkFVOUQsR0FBYSxJQUFUMEssRUFBWTs7QUFFWixJQUFLLElBQUl4VSxFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFBRyxDQUN4QixNQUVNeVUsR0FGTzNLLEtBQUttSyxFQUFTalUsSUFFTixFQUFJd1UsR0FBUSxFQURwQjFLLEtBQUtvSyxFQUFTbFUsSUFDa0IsSUFBTSxFQUFJd1UsR0FDdkRuQyxFQUFFck8sVUFBVWhFLEVBQUdzVSxFQUFNRzs7OzsrQkFNekIzSztLQUFPLENBQUMxSyxFQUFHQyxJQUFNQyxLQUFLQyxLQUFLZ1YsRUFBU25WLEVBQUdDLElBQU0sR0FBS2dULEVBQUV0TyxNQUFNM0UsRUFBR2tWLEdBQVFqQyxFQUFFdE8sTUFBTTFFLEVBQUdpVixLQUFVO21CQUtsRztPQURBNVIsS0FBSzJQLEVBQUlBLEVBQ0YzUCxLQUFLd1A7Ozs7O0dDeEZiLE1BQU13QyxZQUFZckQ7Ozs7Ozs7Ozs7OztBQVlyQjlPLFlBQVlzRCxFQUFHOE8sRUFBUWxNLEVBQUksRUFBR2xILEVBQVNDLFVBQVdxSixFQUFLLE1BSW5ELE9BSEE2SCxNQUFNN00sRUFBRzRDLEVBQUdsSCxFQUFRc0osR0FDcEI2SCxNQUFNcEIsZUFBaUIsQ0FBQyxVQUN4QjVPLEtBQUtrUCxVQUFVLFNBQVUrQyxHQUNsQmpTOzs7T0FNWHNQLFlBQ0ksSUFBSW5NLEVBQUluRCxLQUFLbUQsR0FDUHBFLEVBQU1lLEdBQVNxRCxFQUFFbkUsTUFDbkJpVCxFQUFTalMsS0FBS2tTLFFBQ2RDLEVBQWdCLEdBQ2hCQyxFQUFXLEVBQ2ZILEVBQU9qRyxTQUFRLENBQUNuSixFQUFHdkYsS0FDWHVGLEtBQUtzUCxHQUNMQSxFQUFjdFAsR0FBR3dQLFFBQ2pCRixFQUFjdFAsR0FBRzlELEtBQUtkLEtBQUtrRixFQUFFL0QsSUFBSTlCLEtBRWpDNlUsRUFBY3RQLEdBQUssQ0FDZnlQLEdBQU1GLElBQ05DLE1BQVMsRUFDVHRULEtBQVEsQ0FBQ29FLEVBQUUvRCxJQUFJOUI7O0FBTTNCLElBQUlpVixFQUFTcFAsRUFBRW1DLEtBQ1hrTixFQUFTLElBQUk1UyxPQUFPd1MsRUFBVXRTLEdBQ2xDLElBQUssSUFBSTJTLEtBQVNOLEVBQWUsQ0FDN0IsSUFDSU8sRUFESTlTLE9BQU9QLEtBQUs4UyxFQUFjTSxHQUFPMVQsTUFDMUJ5RyxTQUNmLElBQUssSUFBSS9GLEVBQUksRUFBR0EsRUFBSUssSUFBUUwsRUFDeEIrUyxFQUFPbFIsVUFBVTZRLEVBQWNNLEdBQU9ILEdBQUk3UyxFQUFHaVQsRUFBT2pUO2tCQUk1RDtJQUFJa1QsRUFBTSxJQUFJL1MsT0FBT0UsRUFBTUEsR0FDM0IsSUFBSyxJQUFJMlMsS0FBU04sRUFBZSxDQUM3QixJQUFJN04sRUFBSWtPLEVBQU9wVCxJQUFJK1MsRUFBY00sR0FBT0gsSUFDcEM1UixFQUFJLElBQUlkLE9BQU9FLEVBQU0sR0FBSUwsR0FBTTZFLEVBQUU3RSxHQUFLOFMsSUFDdEN0TyxFQUFJa08sRUFBY00sR0FBT0osTUFDN0JNLEVBQU1BLEVBQUk3TixJQUFJcEUsRUFBRTJCLElBQUkzQixFQUFFYSxhQUFhcUQsS0FBS1g7aUJBSTVDO0lBQUkyTyxFQUFNLElBQUloVCxPQUFPRSxFQUFNQSxHQUMzQixJQUFLLElBQUkyUyxLQUFTTixFQUFlLENBQzdCLElBQUk3TixFQUFJa08sRUFBT3BULElBQUkrUyxFQUFjTSxHQUFPSCxJQUNwQzVSLEVBQUksSUFBSWQsT0FBT0UsRUFBTSxHQUFJTCxHQUFNNkUsRUFBRTdFLEtBQ2pDeUUsRUFBSWlPLEVBQWNNLEdBQU8xVCxLQUM3QixJQUFLLElBQUl6QixFQUFJLEVBQUdKLEVBQUlpVixFQUFjTSxHQUFPSixNQUFPL1UsRUFBSUosSUFBS0ksRUFBRyxDQUN4RCxJQUFJdVYsRUFBUSxJQUFJalQsT0FBT0UsRUFBTSxHQUFHLENBQUNMLEVBQUVrQixJQUFNdUQsRUFBRTVHLEdBQUdtQyxHQUFLaUIsRUFBRVcsTUFBTTVCLEVBQUcsS0FDOURtVCxFQUFNQSxFQUFJOU4sSUFBSStOLEVBQU14USxJQUFJd1EsRUFBTXRSLGVBSXRDLElBQU11RixhQUFjQyxHQUFNRyw4QkFBNEIwTCxFQUFJblIsVUFBVVksSUFBSXNRLEdBQU0zUyxLQUFLK087O0FBS25GLE9BSkFoSSxFQUFJbkgsT0FBT1AsS0FBSzBILEdBQUd4RixZQUNuQnZCLEtBQUsyUCxFQUFJeE0sRUFBRWQsSUFBSTBFLEdBR1IvRyxLQUFLd1A7Ozs7O0dDM0ViLE1BQU1zRCxZQUFZbkU7Ozs7Ozs7Ozs7OztBQVlyQjlPLFlBQVlzRCxFQUFHNk4sRUFBV2pMLEVBQUUsRUFBR2xILEVBQU9DLFVBQVdxSixFQUFLLE1BSWxELE9BSEE2SCxNQUFNN00sRUFBRzRDLEVBQUdsSCxFQUFRc0osR0FDcEI2SCxNQUFNcEIsZUFBaUIsQ0FBQyxLQUN4QjVPLEtBQUtrUCxVQUFVLElBQUt0UyxLQUFLeUksSUFBSTJMLEdBQWFwVSxLQUFLc0IsSUFBSXRCLEtBQUttTixNQUFNL0osS0FBSzRILEdBQUssSUFBSyxHQUFJNUgsS0FBSzRILEdBQUssSUFDcEY1SDs7O09BTVhzUCxZQUNJLE1BQU1uTSxFQUFJbkQsS0FBS21ELEVBQ1Q0QyxFQUFJL0YsS0FBSytPLEdBQ1RoUSxFQUFPaUIsS0FBSzRILEdBQ1o5SCxFQUFPRSxLQUFLME4sR0FDWi9PLEVBQUlxQixLQUFLa1AsVUFBVSxLQUNuQi9QLEVBQUs0VCxvQkFBb0I1UCxFQUFHeEUsRUFBRyxLQUFNcUIsS0FBS3lNLFNBQzFDdUcsRUFBSSxJQUFJcFQsT0FBT2pCLEVBQUcsRUFBRyxHQUNyQnNVLEVBQUksSUFBSXJULE9BQU9iLEVBQU1BLEdBRTNCLElBQUssSUFBSUssRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxFQUFLLENBQ2pDLE1BQU04VCxFQUFTL1QsRUFBR0MsR0FDWitULEVBQUksSUFBSXZULE9BQU9qQixFQUFHbUIsR0FBTSxDQUFDeEMsRUFBR21DLElBQU0wRCxFQUFFOUIsTUFBTTZSLEVBQU81VixHQUFHbUMsRUFBR0EsR0FBSzBELEVBQUU5QixNQUFNakMsRUFBS0ssS0FDekVpRCxFQUFJeVEsRUFBRTlRLElBQUk4USxFQUFFM1IsR0FDbEIsR0FBSzdDLEVBQUltQixFQUFPLENBQ1osTUFBTXNULEVBQVV4VixZQUFZOEUsRUFBRXlDLE1BQVEsSUFDdEMsSUFBSyxJQUFJMUYsRUFBSSxFQUFHQSxFQUFJZCxJQUFLYyxFQUNyQmlELEVBQUVwQixVQUFVN0IsRUFBR0EsRUFBR2lELEVBQUVyQixNQUFNNUIsRUFBR0EsR0FBSzJUO2VBSTFDO0lBQUlDLEVBQUl6VCxPQUFPMFQsU0FBUzVRLEVBQUdzUSxFQUFHaFQsS0FBS2dQLGFBQ25DcUUsRUFBSUEsRUFBRXhPLE9BQU93TyxFQUFFalcsS0FDZixJQUFLLElBQUlxQyxFQUFJLEVBQUdBLEVBQUlkLElBQUtjLEVBQ3JCd1QsRUFBRTNSLFVBQVVsQyxFQUFLOFQsRUFBT3pULEdBQUdBLEVBQUc0VCxFQUFFaFMsTUFBTTVCLEVBQUc7aUJBSWpEO01BQ004VCxFQURJLElBQUkzVCxPQUFPYixFQUFNQSxFQUFNLFlBQ3BCZ0csSUFBSWtPLEdBQ1h2TSxFQUFJNk0sRUFBRy9SLEVBQUVhLElBQUlrUixJQUNYek0sYUFBY0MsR0FBTUcsOEJBQTRCUixFQUFFbEYsRUFBRUMsVUFBV3NFLEVBQUk7O0FBSTNFLE9BSEEvRixLQUFLMlAsRUFBSS9QLE9BQU9QLEtBQUswSCxFQUFFcEgsTUFBTSxFQUFHLEVBQUlvRyxJQUFJdkUsRUFHakN4QixLQUFLd1A7Ozs7O0dDM0RiLE1BQU1nRSxhQUFhN0U7Ozs7Ozs7Ozs7Ozs7QUFhdEI5TyxZQUFZc0QsRUFBRzZOLEVBQVdqTCxFQUFFLEVBQUdsSCxFQUFPQyxVQUFXcUosRUFBSyxNQUlsRCxHQUhBNkgsTUFBTTdNLEVBQUc0QyxFQUFHbEgsRUFBUXNKLEdBQ3BCNkgsTUFBTXBCLGVBQWlCLENBQUMsS0FDeEI1TyxLQUFLa1AsVUFBVSxJQUFLdFMsS0FBS3lJLElBQUkyTCxHQUFhcFUsS0FBS3NCLElBQUl0QixLQUFLbU4sTUFBTS9KLEtBQUs0SCxHQUFLLElBQUssR0FBSTVILEtBQUs0SCxHQUFLLElBQ3ZGNUgsS0FBSzBOLElBQU0zSCxFQUFHLEtBQU0sNEJBQTRCL0YsS0FBSzBOLDJFQUEyRTNILE1BQ3BJLE9BQU8vRjs7O09BTVhzUCxZQUNJLE1BQU1uTSxFQUFJbkQsS0FBS21ELEVBQ1Q0QyxFQUFJL0YsS0FBSytPLElBQ1BoUSxFQUFNRSxHQUFNa0UsRUFBRW5FLE1BQ2hCTCxFQUFJcUIsS0FBS2tQLFVBQVUsS0FFbkIvUCxFQUFLNFQsb0JBQW9CNVAsRUFBR3hFLEVBQUcsS0FBTXFCLEtBQUt5TSxTQUUxQ3VHLEVBQUksSUFBSXBULE9BQU9YLEVBQUdBLEVBQUcsVUFDckJ5QyxFQUFJLElBQUk5QixPQUFPYixFQUFNQSxFQUFNLEdBRWpDLElBQUssSUFBSUssRUFBTSxFQUFHQSxFQUFNTCxJQUFRSyxFQUFLOztBQUVqQyxNQUFNcVUsRUFBTSxDQUFDclUsS0FBUUQsRUFBR0MsR0FBS0UsS0FBSXBDLEdBQUtBLEVBQUV1QyxLQUN4QyxJQUFJaVUsRUFBTTlULE9BQU9QLEtBQUtvVSxFQUFJblUsS0FBSXBDLEdBQUtpRyxFQUFFL0QsSUFBSWxDO2FBRXpDd1c7RUFBTUEsRUFBSXJSLElBQUkyUTs7QUFFZCxNQUFNdFEsRUFBSWdSLEVBQUlyUixJQUFJcVIsRUFBSW5TLGNBQ2R1RixhQUFjNk0sR0FBTXpNLDhCQUE0QnhFLEVBQUdxRCxHQUVyRDZOLEVBQVFoVSxPQUFPUCxLQUFLc1UsR0FFcEJFLEVBQU1ELEVBQU1yUyxZQUFZYyxJQUFJdVIsR0FBTzlPLElBQUksRUFBSWxJLEtBQUtDLEtBQUs4QixFQUFJLElBQy9ELElBQUssSUFBSXJCLEVBQUksRUFBR0EsRUFBSXFCLEVBQUksSUFBS3JCLEVBQ3pCLElBQUssSUFBSW1DLEVBQUksRUFBR0EsRUFBSWQsRUFBSSxJQUFLYyxFQUN6QmlDLEVBQUVKLFVBQVVtUyxFQUFJblcsR0FBSW1XLEVBQUloVSxHQUFJaUMsRUFBRUwsTUFBTW9TLEVBQUluVyxHQUFJbVcsRUFBSWhVLEtBQU9uQyxJQUFNbUMsRUFBSSxFQUFJLEdBQU1vVSxFQUFJeFMsTUFBTS9ELEVBQUdtQztpQ0FNcEc7TUFBUXFILGFBQWM2SSxHQUFNekksOEJBQTRCeEYsRUFBR3FFLEVBQUk7O0FBSS9ELE9BSEEvRixLQUFLMlAsRUFBSS9QLE9BQU9QLEtBQUtzUSxFQUFFaFEsTUFBTSxJQUFJNEIsWUFHMUJ2QixLQUFLd1A7Ozs7O0dDN0RiLE1BQU1zRSxhQUFhbkY7Ozs7Ozs7Ozs7Ozs7O0FBY3RCOU8sWUFBWXNELEVBQUc0USxFQUFXLEdBQUlDLEVBQVEsR0FBSWpPLEVBQUUsRUFBR2xILEVBQU9DLFVBQVdxSixFQUFLLE1BUWxFLE9BUEE2SCxNQUFNN00sRUFBRzRDLEVBQUdsSCxFQUFRc0osR0FDcEI2SCxNQUFNcEIsZUFBaUIsQ0FBQyxhQUFjLFlBQ3BDNU8sS0FBSzRILEdBQUk1SCxLQUFLME4sSUFBTzFOLEtBQUttRCxFQUFFbkUsTUFDOUJnQixLQUFLa1AsVUFBVSxhQUFjdFMsS0FBS3lJLElBQUkwTyxFQUFZL1QsS0FBSzRILEdBQUssSUFDNUQ1SCxLQUFLa1AsVUFBVSxVQUFXOEUsR0FDMUJoVSxLQUFLaVUsTUFBUSxFQUNialUsS0FBSzJQLEVBQUksSUFBSS9QLE9BQU9JLEtBQUs0SCxHQUFJNUgsS0FBSytPLElBQUksSUFBTS9PLEtBQUtnUCxZQUFZbkosU0FDdEQ3Rjs7Ozs7T0FRWDBQLEtBQUs5USxFQUFnQjs7QUFFakIsTUFBTXNWLEVBQVV0WCxLQUFLdVgsSUFBSW5VLEtBQUtvVSxhQUN4Qm5RLEVBQUlqRSxLQUFLNEgsR0FDVDNJLEVBQUllLEtBQUswTixHQUNUN08sRUFBU21CLEtBQUt5TSxRQUNkdEosRUFBSW5ELEtBQUttRCxFQUNmLElBQUlrUixFQUNKLEdBQUl6VixFQUNBeVYsRUFBUXpWLE1BQ0wsQ0FDSHlWLEVBQVEsSUFBSXpVLE9BQU9xRSxFQUFHQSxHQUN0QixJQUFLLElBQUkzRyxFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFBRyxDQUN4QixNQUFNb1csRUFBTXZRLEVBQUUvRCxJQUFJOUIsR0FDbEIsSUFBSyxJQUFJbUMsRUFBSW5DLEVBQUksRUFBR21DLEVBQUl3RSxJQUFLeEUsRUFBRyxDQUM1QixNQUFNRixFQUFXVixFQUFPNlUsRUFBS3ZRLEVBQUUvRCxJQUFJSyxJQUNuQzRVLEVBQU0vUyxVQUFVaEUsRUFBR21DLEVBQUdGLEdBQ3RCOFUsRUFBTS9TLFVBQVU3QixFQUFHbkMsRUFBR2lDLEtBTWxDLE1BQU0rVSxFQUFJLElBQUkxVSxPQUFPcUUsRUFBR0EsRUFBRyxTQUUzQmpFLEtBQUt1VSxPQUFTLElBQUkzVSxPQUFPcUUsRUFBR2hGLEVBQUcsU0FDL0JlLEtBQUt3VSxPQUFTLElBQUk1VSxPQUFPcUUsRUFBR2hGLEVBQUc7O0FBRy9CLElBQUl3VixFQUFPLElBQUkvVyxNQUFNdUcsR0FBR3lELEtBQUssR0FHN0IsSUFBSyxJQUFJcEssRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQUcsQ0FDeEIsSUFBSW9YLEdBQVc1UyxFQUFBQSxFQUNYNlMsRUFBVTdTLEVBQUFBLEVBQ1ZxRSxFQUFPLEVBQ1B5TyxHQUFPLEVBRVBDLEVBQU0sRUFDVixNQUFPRCxHQUFNLENBQ1QsSUFBSUUsRUFBTyxFQUNYLElBQUssSUFBSXJWLEVBQUksRUFBR0EsRUFBSXdFLElBQUt4RSxFQUFHLENBQ3hCLElBQUlzVixFQUFLblksS0FBS29ZLEtBQUtYLEVBQU1oVCxNQUFNL0QsRUFBR21DLEdBQUswRyxHQUNuQzdJLElBQU1tQyxJQUFHc1YsRUFBSyxHQUNsQk4sRUFBS2hWLEdBQUtzVixFQUNWRCxHQUFRQyxFQUVaLElBQUlFLEVBQVEsRUFDWixJQUFLLElBQUl4VixFQUFJLEVBQUdBLEVBQUl3RSxJQUFLeEUsRUFBRyxDQUN4QixJQUFJc1YsRUFBZSxJQUFURCxFQUFjLEVBQUlMLEVBQUtoVixHQUFLcVYsRUFDdENMLEVBQUtoVixHQUFLc1YsRUFDTkEsRUFBSyxPQUNMRSxHQUFTRixFQUFLblksS0FBS3VYLElBQUlZLElBRzNCRSxFQUFRZixHQUNSUSxFQUFVdk8sRUFDVkEsRUFBUXdPLElBQVk3UyxFQUFBQSxFQUFvQixFQUFQcUUsR0FBY0EsRUFBT3dPLEdBQVcsSUFFakVBLEVBQVV4TyxFQUNWQSxFQUFRdU8sS0FBYTVTLEVBQUFBLEVBQWFxRSxFQUFPLEdBQU9BLEVBQU91TyxHQUFXLEtBRXBFRyxFQUNFalksS0FBS1ksSUFBSXlYLEVBQVFmLEdBakNqQixPQWlDaUNVLEdBQU8sR0FDeENDLEdBakNLLEtBaUNZRCxHQUFPLEdBR2hDLElBQUssSUFBSW5WLEVBQUksRUFBR0EsRUFBSXdFLElBQUt4RSxFQUNyQjZVLEVBQUVoVCxVQUFVaEUsRUFBR21DLEVBQUdnVixFQUFLaFY7dUJBSy9CO01BQU15VixFQUFPLElBQUl0VixPQUFPcUUsRUFBR0EsRUFBRyxTQUN4QmtSLEVBQVMsRUFBSmxSLEVBQ1gsSUFBSyxJQUFJM0csRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQ3JCLElBQUssSUFBSW1DLEVBQUluQyxFQUFHbUMsRUFBSXdFLElBQUt4RSxFQUFHLENBQ3hCLE1BQU11TixFQUFJcFEsS0FBS3NCLEtBQUtvVyxFQUFFalQsTUFBTS9ELEVBQUdtQyxHQUFLNlUsRUFBRWpULE1BQU01QixFQUFHbkMsSUFBTTZYLEVBQUksUUFDekRELEVBQUs1VCxVQUFVaEUsRUFBR21DLEVBQUd1TixHQUNyQmtJLEVBQUs1VCxVQUFVN0IsRUFBR25DLEVBQUcwUCxHQUk3QixPQURBaE4sS0FBS29WLEdBQUtGLEVBQ0hsVjs7Ozs7T0FRWHNQLFVBQVUrRixFQUFXLEtBQ2pCclYsS0FBS3VQLGFBQ0wsSUFBSyxJQUFJalMsRUFBSSxFQUFHQSxFQUFJK1gsSUFBYy9YLEVBQzlCMEMsS0FBS3NWLE9BRVQsT0FBT3RWLEtBQUt3UDs7Ozs7T0FRaEJDLFdBQVk0RixFQUFXLEtBQ25CclYsS0FBS3VQLGFBQ0wsSUFBSyxJQUFJalMsRUFBSSxFQUFHQSxFQUFJK1gsSUFBYy9YLEVBQzlCMEMsS0FBS3NWLGFBQ0N0VixLQUFLd1AsV0FFZixPQUFPeFAsS0FBS3dQOzs7OztPQVFoQjhGLE9BQ0ksTUFBTUMsSUFBU3ZWLEtBQUtpVSxNQUNkSyxFQUFJdFUsS0FBS29WLEdBQ1RJLEVBQVF4VixLQUFLdVUsT0FDYmtCLEVBQVF6VixLQUFLd1UsT0FDYnZRLEVBQUlqRSxLQUFLNEgsR0FDVG9NLEVBQVVoVSxLQUFLMFYsU0FDZkMsRUFBTTNWLEtBQUsrTyxHQUNqQixJQUFJWSxFQUFJM1AsS0FBSzJQO3FCQUdiO01BQU1pRyxFQUFPTCxFQUFPLElBQU0sRUFBSSxFQUd4Qk0sRUFBSyxJQUFJalcsT0FBT3FFLEVBQUdBLEVBQUc7Z0NBQzVCO0lBQUk2UixFQUFPLEVBQ1gsSUFBSyxJQUFJeFksRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQ3JCLElBQUssSUFBSW1DLEVBQUluQyxFQUFJLEVBQUdtQyxFQUFJd0UsSUFBS3hFLEVBQUcsQ0FDNUIsSUFBSXNXLEVBQU8sRUFDWCxJQUFLLElBQUloUSxFQUFJLEVBQUdBLEVBQUk0UCxJQUFPNVAsRUFBRyxDQUMxQixNQUFNaVEsRUFBUXJHLEVBQUV0TyxNQUFNL0QsRUFBR3lJLEdBQUs0SixFQUFFdE8sTUFBTTVCLEVBQUdzRyxHQUN6Q2dRLEdBQVFDLEVBQVFBLEVBRXBCLE1BQU1DLEVBQUssR0FBSyxFQUFJRixHQUNwQkYsRUFBR3ZVLFVBQVVoRSxFQUFHbUMsRUFBR3dXLEdBQ25CSixFQUFHdlUsVUFBVTdCLEVBQUduQyxFQUFHMlksR0FDbkJILEdBQVEsRUFBSUc7bUJBS3BCO01BQU0xSSxFQUFJLElBQUkzTixPQUFPcUUsRUFBR0EsRUFBRyxHQUMzQixJQUFLLElBQUkzRyxFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFDckIsSUFBSyxJQUFJbUMsRUFBSW5DLEVBQUksRUFBR21DLEVBQUl3RSxJQUFLeEUsRUFBRyxDQUM1QixNQUFNc0MsRUFBTW5GLEtBQUtzQixJQUFJMlgsRUFBR3hVLE1BQU0vRCxFQUFHbUMsR0FBS3FXLEVBQU0sUUFDNUN2SSxFQUFFak0sVUFBVWhFLEVBQUdtQyxFQUFHc0MsR0FDbEJ3TCxFQUFFak0sVUFBVTdCLEVBQUduQyxFQUFHeUUsR0FJMUIsTUFBTW1VLEVBQU8sSUFBSXRXLE9BQU9xRSxFQUFHMFIsRUFBSyxTQUNoQyxJQUFLLElBQUlyWSxFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFDckIsSUFBSyxJQUFJbUMsRUFBSSxFQUFHQSxFQUFJd0UsSUFBS3hFLEVBQUcsQ0FDeEIsTUFBTTBXLEVBQVUsR0FBS1AsRUFBT3RCLEVBQUVqVCxNQUFNL0QsRUFBR21DLEdBQUs4TixFQUFFbE0sTUFBTS9ELEVBQUdtQyxJQUFNb1csRUFBR3hVLE1BQU0vRCxFQUFHbUMsR0FDekUsSUFBSyxJQUFJc0csRUFBSSxFQUFHQSxFQUFJNFAsSUFBTzVQLEVBQ3ZCbVEsRUFBSzVVLFVBQVVoRSxFQUFHeUksRUFBR21RLEVBQUs3VSxNQUFNL0QsRUFBR3lJLEdBQUtvUSxHQUFXeEcsRUFBRXRPLE1BQU0vRCxFQUFHeUksR0FBSzRKLEVBQUV0TyxNQUFNNUIsRUFBR3NHO3dCQU0xRjtJQUFJcVEsRUFBUSxJQUFJaFcsYUFBYXVWLEdBQzdCLElBQUssSUFBSXJZLEVBQUksRUFBR0EsRUFBSTJHLElBQUszRyxFQUNyQixJQUFLLElBQUl5SSxFQUFJLEVBQUdBLEVBQUk0UCxJQUFPNVAsRUFBRyxDQUMxQixNQUFNc1EsRUFBTUgsRUFBSzdVLE1BQU0vRCxFQUFHeUksR0FDcEJ1USxFQUFNZCxFQUFNblUsTUFBTS9ELEVBQUd5SSxHQUNyQndRLEVBQVNkLEVBQU1wVSxNQUFNL0QsRUFBR3lJLEdBRTlCLElBQUl5USxFQUFVNVosS0FBSzZaLEtBQUtKLEtBQVN6WixLQUFLNlosS0FBS0gsR0FBZ0IsR0FBVEMsRUFBY0EsRUFBUyxHQUNyRUMsRUFBVSxNQUFLQSxFQUFVLEtBQzdCZixFQUFNblUsVUFBVWhFLEVBQUd5SSxFQUFHeVEsR0FFdEIsTUFDTUUsR0FEU25CLEVBQU8sSUFBTSxHQUFLLElBQ1RlLEVBQU10QyxFQUFVd0MsRUFBVUgsRUFDbERiLEVBQU1sVSxVQUFVaEUsRUFBR3lJLEVBQUcyUSxHQUV0Qi9HLEVBQUVyTyxVQUFVaEUsRUFBR3lJLEVBQUc0SixFQUFFdE8sTUFBTS9ELEVBQUd5SSxHQUFLMlEsR0FDbENOLEVBQU1yUSxJQUFNNEosRUFBRXRPLE1BQU0vRCxFQUFHeUksR0FJL0IsSUFBSyxJQUFJekksRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQ3JCLElBQUssSUFBSXlJLEVBQUksRUFBR0EsRUFBSSxJQUFLQSxFQUNyQjRKLEVBQUVyTyxVQUFVaEUsRUFBR3lJLEVBQUc0SixFQUFFdE8sTUFBTS9ELEVBQUd5SSxHQUFLcVEsRUFBTXJRLEdBQUs5QixHQUlyRCxPQUFPakUsS0FBSzJQOzs7Ozs7Ozs7O0dDaE9MLGdCQUFVek4sRUFBR3lVLEVBQUlDLEVBQVcsS0FDdkMsTUFDTTFaLEVBQUl5WixFQUFHeFosT0FDYixJQUFJOEksRUFBUSxLQUNSNFEsRUFBTSxJQUNObFosRUFBSWdaLEVBQUdoWCxRQUNQbVgsRUFBSzVVLEVBQUV2RSxHQUNQb1osR0FBYyxFQUVsQixLQUFPSCxNQUFjLElBQU1HLEdBQWEsQ0FDcENBLEdBQWMsRUFDZCxJQUFLLElBQUl6WixFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQUcsQ0FDeEJLLEVBQUVMLElBQU0sS0FDUixJQUFJMFosRUFBTTlVLEVBQUV2RSxHQUNaQSxFQUFFTCxJQUFNLEtBQ1IsSUFBSTJaLEdBQU1ELEVBQU1GLEdBQU0sS0FDbEJsYSxLQUFLWSxJQUFJeVosR0FmTCxNQWdCSkYsR0FBYyxHQUVsQnBaLEVBQUVMLElBQU0ySSxFQUFRZ1IsRUFDaEJILEVBQUs1VSxFQUFFdkUsR0FFWHNJLEdBQVM0USxHQUFPQyxFQUFLLEtBQU8sR0FDNUJELEVBQU1DLEVBRVYsT0FBT25aOzs7OztHQ3BCSixNQUFNdVosYUFBYXZJOzs7Ozs7Ozs7Ozs7Ozs7QUFnQnRCOU8sWUFBWXNELEVBQUdnVSxFQUFZLEdBQUlDLEVBQW1CLEVBQUdDLEVBQVMsRUFBR3RSLEVBQUUsRUFBR2xILEVBQU9DLFVBQVdxSixFQUFLLE1BZ0J6RixPQWZBNkgsTUFBTTdNLEVBQUc0QyxFQUFHbEgsRUFBUXNKLEdBQ3BCNkgsTUFBTXBCLGVBQWlCLENBQUMsY0FBZSxxQkFBc0IsYUFDM0Q1TyxLQUFLNEgsR0FBSTVILEtBQUswTixJQUFPMU4sS0FBS21ELEVBQUVuRSxNQUM5Qm1ZLEVBQWN2YSxLQUFLeUksSUFBSXJGLEtBQUs0SCxHQUFLLEVBQUd1UCxHQUNwQ25YLEtBQUtrUCxVQUFVLGNBQWVpSSxHQUM5Qm5YLEtBQUtrUCxVQUFVLHFCQUFzQnRTLEtBQUt5SSxJQUFJK1IsRUFBb0JELEVBQWMsSUFDaEZuWCxLQUFLa1AsVUFBVSxXQUFZbUksR0FDM0JyWCxLQUFLaVUsTUFBUSxFQUNialUsS0FBS3NYLFFBQVUsRUFDZnRYLEtBQUt1WCxrQkFBb0IsRUFDekJ2WCxLQUFLd1gsb0JBQXNCLEVBQzNCeFgsS0FBS3lYLHNCQUF3QixFQUM3QnpYLEtBQUswWCxVQUFZLElBQ2pCMVgsS0FBSzJYLGVBQWlCLEVBQ3RCM1gsS0FBSzJQLEVBQUksSUFBSS9QLE9BQU9JLEtBQUs0SCxHQUFJNUgsS0FBSytPLElBQUksSUFBTS9PLEtBQUtnUCxZQUFZbkosU0FDdEQ3Rjs7Ozs7O09BU1g0WCxnQkFBZ0IzSyxFQUFRb0ssR0FDcEIsTUFDTVEsRUFBSzdPLFNBQVMsRUFBWSxFQUFUaUUsRUFBWSxLQUM3QjZLLEVBQUs5TyxTQUFTLEVBQVksRUFBVGlFLEVBQVksS0FFbkMsSUFBSyxJQUFJM1AsRUFBSSxFQUFHSixFQUFJMmEsRUFBRzFhLE9BQVFHLEVBQUlKLElBQUtJLEVBQUcsQ0FDdkMsTUFBTXlhLEVBQU9GLEVBQUd2YSxHQUNoQndhLEVBQUd4YSxHQUFNeWEsRUFBT1YsRUFBVyxFQUFJemEsS0FBS29ZLE1BQU0rQyxFQUFPVixHQUFZcEssR0FRakUsT0FBTytLLFFBTE1oTCxJQUNULE1BQU1pTCxFQUFRalAsU0FBUyxFQUFHLEtBQUsxSixLQUFJLENBQUNxQixFQUFHckQsS0FBTXdhLE9BQUFBLEVBQUd4YSxJQVZyQ0ssRUFVZ0RrYSxFQUFHdmEsR0FWaERaLEVBVW9Ec1EsRUFBRSxHQVZuRHJRLEVBVXVEcVEsRUFBRSxHQVZuRCxHQUFLLEVBQUl0USxFQUFJRSxLQUFLa1UsSUFBSW5ULEVBQUcsRUFBSWhCLEtBQTFDLElBQUNnQixFQUFHakIsRUFBR0MsS0FXakIsT0FBT0MsS0FBS0MsS0FBS2UsWUFBWXFhLEVBQU0zWSxLQUFJcUQsR0FBS0EsRUFBSUEsUUFHakMsQ0FBQyxFQUFHOzs7Ozs7O09BVTNCdVYsOEJBQThCdkssRUFBV3dLLEVBQVFDLEdBQzdDLElBQUssSUFBSTlhLEVBQUksRUFBR0osRUFBSXlRLEVBQVV4USxPQUFRRyxFQUFJSixJQUFLSSxFQUMzQyxJQUFLLElBQUltQyxFQUFJLEVBQUdpQixFQUFJaU4sRUFBVXJRLEdBQUdILE9BQVFzQyxFQUFJaUIsSUFBS2pCLEVBQUcsQ0FDakQsTUFBTTZFLEVBQUlxSixFQUFVclEsR0FBR21DLEdBQUdNLE1BQVFxWSxFQUFLOWEsR0FDdkNxUSxFQUFVclEsR0FBR21DLEdBQUdNLE1BQVF1RSxFQUFJLEVBQUkxSCxLQUFLb1ksS0FBSzFRLEVBQUk2VCxFQUFPN2EsSUFBTSxFQUduRSxPQUFPcVE7Ozs7OztPQVNYMEssaUJBQWlCQyxFQUFLM1osR0FDbEIsTUFBTTRaLEVBQXFCLEtBQ3JCQyxFQUFtQixLQUVuQnBCLEVBQXFCcFgsS0FBS3lZLG9CQUMxQkMsRUFBUzliLEtBQUsrYixLQUFLaGEsR0FDbkJ5WixFQUFPLEdBQ1BELEVBQVMsR0FDVGhWLEVBQUluRCxLQUFLbUQsRUFDVGMsRUFBSWQsRUFBRW5FLE1BQU0sR0FHWjJPLEVBQVksR0FDbEIsR0FBcUIsZ0JBQWpCM04sS0FBS3lNLFFBQ0wsSUFBSyxJQUFJblAsRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQ3JCcVEsRUFBVTFQLEtBQUtxYSxFQUFJakwsT0FBTy9QLEVBQUdxQixHQUFHaWEsZ0JBR3JDLElBQUssTUFBTUMsS0FBTzFWLEVBQ2J3SyxFQUFVMVAsS0FBS3FhLEVBQUlqTCxPQUFPd0wsRUFBS2xhLEdBQUdxTSxXQUFXNE4sV0FJckQsSUFBSyxJQUFJdGIsRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQUcsQ0FDeEIsSUFBSXdiLEVBQUssRUFDTEMsRUFBS2pYLEVBQUFBLEVBQ0xrWCxFQUFNLEVBRVYsTUFBTUMsRUFBZ0J0TCxFQUFVclEsR0FDMUI0YixFQUFnQkQsRUFBY0UsUUFBT3BULEdBQUtBLEVBQUVoRyxNQUFRLElBQ3BEcVosRUFBdUJGLEVBQWMvYixPQUMzQyxHQUFJaWMsR0FBd0JoQyxFQUFvQixDQUM1QyxNQUFNL00sRUFBUXpOLEtBQUttTixNQUFNcU4sR0FDbkJpQyxFQUFnQmpDLEVBQXFCL00sRUFDdkNBLEVBQVEsR0FDUitOLEVBQUtuYSxLQUFLaWIsRUFBYzdPLEVBQVEsSUFDNUJnUCxFQUFnQmQsSUFDaEJILEVBQUs5YSxHQUFHeUMsT0FBU3NaLEdBQWlCSCxFQUFjN08sR0FBT3RLLE1BQVFtWixFQUFjN08sRUFBUSxNQUd6RitOLEVBQUs5YSxHQUFHeUMsTUFBUXNaLEVBQWdCSCxFQUFjLEdBQUduWixXQUU5Q3FaLEVBQXVCLElBQzlCaEIsRUFBSzlhLEdBQUs0YixFQUFjRSxFQUF1QixHQUFHclosT0FFdEQsSUFBSyxJQUFJcEMsRUFBSSxFQUFHQSxFQTFDTCxLQTBDbUJBLEVBQUcsQ0FDN0IsSUFBSW1YLEVBQU8sRUFDWCxJQUFLLElBQUlyVixFQUFJLEVBQUdBLEVBQUlkLElBQUtjLEVBQUcsQ0FDeEIsTUFBTXNHLEVBQUlrVCxFQUFjeFosR0FBR00sTUFBUXFZLEVBQUs5YSxHQUN4Q3dYLEdBQVMvTyxFQUFJLEVBQUluSixLQUFLb1ksS0FBTWpQLEVBQUlpVCxHQUFRLEVBRTVDLEdBQUlwYyxLQUFLWSxJQUFJc1gsRUFBTzRELEdBQVVILEVBQzFCLE1BRUF6RCxFQUFPNEQsR0FDTkssRUFBSUMsR0FBTyxDQUFDQSxHQUFNRixFQUFLQyxHQUFNLElBR3pCRCxFQUFJRSxHQURMRCxJQUFPalgsRUFBQUEsRUFDSyxDQUFDa1gsRUFBVyxFQUFOQSxHQUVOLENBQUNBLEdBQU1GLEVBQUtDLEdBQU0sR0FJMUNaLEVBQU83YSxHQUFLMGIsRUFFWixNQUFNTSxFQUFZTCxFQUFjL0wsUUFBTyxDQUFDeFEsRUFBR0MsSUFBTUQsRUFBSUMsRUFBRW9ELE9BQU8sR0FBS2taLEVBQWM5YjtvQkFFakY7R0FBSWliLEVBQUs5YSxHQUFLLEVBQ042YSxFQUFPN2EsR0FBS2tiLEVBQW1CYyxJQUMvQm5CLEVBQU83YSxHQUFLa2IsRUFBbUJjLE9BRWhDLENBQ0gsTUFBTUMsRUFBUzVMLEVBQVVULFFBQU8sQ0FBQ0MsRUFBS25QLElBQVFtUCxFQUFNblAsRUFBSWtQLFFBQU8sQ0FBQ3hRLEVBQUdDLElBQU1ELEVBQUlDLEVBQUVvRCxPQUFPLEdBQUsvQixFQUFJYixTQUMzRmdiLEVBQU83YSxHQUFLa2IsRUFBbUJlLElBQy9CcEIsRUFBTzdhLEdBQUtrYixFQUFtQmUsSUFLM0MsTUFBTyxDQUNINUwsVUFBYUEsRUFDYndLLE9BQVVBLEVBQ1ZDLEtBQVFBOzs7Ozs7T0FVaEJvQixzQkFBc0JyVyxFQUFHZ1UsR0FDckIsTUFBTWxULEVBQUlkLEVBQUVuRSxNQUFNLEdBQ1pILEVBQVNtQixLQUFLeU0sUUFDZDZMLEVBQWlCLGdCQUFYelosRUFBMkIsSUFBSTJPLElBQUlySyxFQUFHLGVBQWlCLElBQUk4SSxTQUFTOUksRUFBRTZCLFVBQVduRyxHQUM3RixJQUFJOE8sVUFBRUEsRUFBU3dLLE9BQUVBLEVBQU1DLEtBQUVBLEdBQVNwWSxLQUFLcVksaUJBQWlCQyxFQUFLbkIsR0FDN0R4SixFQUFZM04sS0FBS2tZLDhCQUE4QnZLLEVBQVd3SyxFQUFRQyxHQUNsRSxNQUFNblQsRUFBUyxJQUFJckYsT0FBT3FFLEVBQUdBLEVBQUcsU0FDaEMsSUFBSyxJQUFJM0csRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQUcsQ0FDeEIsTUFBTW1jLEVBQWM5TCxFQUFVclEsR0FDOUIsSUFBSyxJQUFJbUMsRUFBSSxFQUFHQSxFQUFJZ2EsRUFBWXRjLFNBQVVzQyxFQUN0Q3dGLEVBQU8zRCxVQUFVaEUsRUFBR21jLEVBQVloYSxHQUFHcUssUUFBUU8sTUFBT29QLEVBQVloYSxHQUFHTSxPQUd6RSxNQUFNMlosRUFBb0J6VSxFQUFPekQsRUFDM0JtWSxFQUFjMVUsRUFBT0wsS0FBSzhVLEdBQ2hDLE9BQU96VSxFQUNGSCxJQUFJNFUsR0FDSjNVLElBQUk0VSxHQUNKL1UsS0FBSzVFLEtBQUt1WCxtQkFDVnpTLElBQUk2VSxFQUFZL1UsS0FBSyxFQUFJNUUsS0FBS3VYOzs7OztPQVF2Q3FDLHdCQUF3QkMsR0FDcEIsTUFBTUMsRUFBVTlaLEtBQUsrWixTQUNmOVUsRUFBUyxJQUFJK1UsYUFBYUYsRUFBUTNjLFFBQVF1SyxNQUFNLEdBQ2hEdVMsRUFBYy9iLElBQUk0YixHQUNsQkksRUFBWUosRUFBUXhhLEtBQUkrVCxHQUFLd0csR0FBWXhHLEVBQUk0RyxLQUNuRCxJQUFLLElBQUkzYyxFQUFJLEVBQUdBLEVBQUkySCxFQUFPOUgsU0FBVUcsRUFDL0I0YyxFQUFVNWMsR0FBSyxJQUFHMkgsRUFBTzNILEdBQUtWLEtBQUs0SyxNQUFNcVMsRUFBV0ssRUFBVTVjLEtBQ3BFLE9BQU8ySDs7Ozs7T0FRWGtWLE9BQU9DLEdBQ0gsTUFBTXJiLEVBQU8sR0FDUGUsRUFBTyxHQUNQYyxFQUFPLElBQ0x5WixFQUFRQyxHQUFXRixFQUFNcGIsTUFDakMsSUFBSyxJQUFJSSxFQUFNLEVBQUdBLEVBQU1pYixJQUFVamIsRUFDOUIsSUFBSyxJQUFJSSxFQUFNLEVBQUdBLEVBQU04YSxJQUFVOWEsRUFBSyxDQUNuQyxNQUFNNkIsRUFBUStZLEVBQU0vWSxNQUFNakMsRUFBS0ksR0FDakIsSUFBVjZCLElBQ0F0QyxFQUFLZCxLQUFLbUIsR0FDVlUsRUFBSzdCLEtBQUt1QixHQUNWb0IsRUFBSzNDLEtBQUtvRCxJQUl0QixNQUFPLENBQ0h0QyxLQUFRQSxFQUNSZSxLQUFRQSxFQUNSYyxLQUFRQTs7OztPQVFoQjhPLE9BQ0ksTUFBUWhULEVBQUdDLEdBQU1xRCxLQUFLNFgsZ0JBQWdCNVgsS0FBS3NYLFFBQVN0WCxLQUFLdWEsV0FDekR2YSxLQUFLd2EsR0FBSzlkLEVBQ1ZzRCxLQUFLeWEsR0FBSzlkLEVBQ1ZxRCxLQUFLMGEsT0FBUzFhLEtBQUt3WixzQkFBc0J4WixLQUFLbUQsRUFBR25ELEtBQUsyYSxjQUN0RCxNQUFNNWIsS0FBRUEsRUFBSWUsS0FBRUEsRUFBTWMsS0FBTWtaLEdBQVk5WixLQUFLbWEsT0FBT25hLEtBQUswYSxRQVF2RCxPQVBBMWEsS0FBSzRhLE1BQVE3YixFQUNiaUIsS0FBSzZhLE1BQVEvYSxFQUNiRSxLQUFLK1osU0FBV0QsRUFDaEI5WixLQUFLOGEsbUJBQXFCOWEsS0FBSzRaLHdCQUF3QjVaLEtBQUswWCxXQUM1RDFYLEtBQUsrYSw0QkFBOEIvYSxLQUFLOGEsbUJBQW1CeGIsS0FBSXlHLEdBQUtBLEVBQUkvRixLQUFLeVgsd0JBQzdFelgsS0FBS2diLHNCQUF3QmhiLEtBQUs4YSxtQkFBbUJuYixRQUNyREssS0FBS2liLCtCQUFpQ2piLEtBQUsrYSw0QkFBNEJwYixRQUNoRUssS0FHUG9YLHVCQUFtQnJYLEdBQ25CQyxLQUFLeVksb0JBQXNCMVksRUFHM0JxWCx5QkFDQSxPQUFPcFgsS0FBS3lZLG9CQUdacEIsYUFBU3RYLEdBQ1RDLEtBQUt1YSxVQUFZeGEsRUFHakJzWCxlQUNBLE9BQU9yWCxLQUFLdWEsVUFHaEJILFFBRUksT0FEQXBhLEtBQUt1UCxhQUNFLENBQUV6UCxLQUFNRSxLQUFLNGEsTUFBTzdiLEtBQU1pQixLQUFLNmEsTUFBT2YsUUFBUzlaLEtBQUsrWjs7Ozs7T0FRL0R6SyxVQUFVK0YsRUFBVyxLQUNiclYsS0FBSzBYLFdBQWFyQyxJQUNsQnJWLEtBQUswWCxVQUFZckMsRUFDakJyVixLQUFLMFAsUUFFVDFQLEtBQUt1UCxhQUNMLElBQUssSUFBSWpTLEVBQUksRUFBR0EsRUFBSStYLElBQWMvWCxFQUM5QjBDLEtBQUtzVixPQUVULE9BQU90VixLQUFLd1A7Ozs7O09BU2hCQyxXQUFZNEYsRUFBVyxLQUNmclYsS0FBSzBYLFdBQWFyQyxJQUNsQnJWLEtBQUswWCxVQUFZckMsRUFDakJyVixLQUFLMFAsUUFFVDFQLEtBQUt1UCxhQUNMLElBQUssSUFBSWpTLEVBQUksRUFBR0EsRUFBSStYLElBQWMvWCxFQUM5QjBDLEtBQUtzVixhQUNDdFYsS0FBS3dQLFdBRWYsT0FBT3hQLEtBQUt3UDs7Ozs7T0FRaEIwTCxNQUFNdmQsR0FDRixPQUFJQSxFQUFJLEVBQVUsRUFDZEEsR0FBSyxHQUFXLEVBQ2JBOzs7Ozs7Ozs7T0FZWHdkLGlCQUFpQkMsRUFBZ0JDLEVBQWdCQyxFQUFNQyxHQUNuRCxNQUNJeE0sR0FBSTRHLEVBQ0o2RixPQUFRdlYsRUFDUnVSLG9CQUFxQmlFLEVBQ3JCakIsR0FBSTlkLEVBQ0orZCxHQUFJOWQsRUFDSm1lLG1CQUFvQlksRUFDcEJYLDRCQUE2QlksRUFDN0JWLCtCQUFnQ1csRUFDaENaLHNCQUF1QmEsRUFDdkJYLE1BQU9ZLEdBQ1A5YixLQUNFK2IsRUFBY1IsRUFBS3BlLE9BRXpCLElBQUssSUFBSUcsRUFBSSxFQUFHSixFQUFJd2UsRUFBa0J2ZSxPQUFRRyxFQUFJSixJQUFLSSxFQUNuRCxHQUFJdWUsRUFBcUJ2ZSxJQUFNMEMsS0FBS2lVLE1BQU8sQ0FDdkMsTUFBTXhVLEVBQUk2YixFQUFLaGUsR0FDVHFCLEVBQUk0YyxFQUFLamUsR0FDVDhQLEVBQVVnTyxFQUFlaGMsSUFBSUssR0FDN0IyUixFQUFRaUssRUFBZWpjLElBQUlULEdBQzNCeUksRUFBT3RLLGtCQUFrQnNRLEVBQVNnRSxHQUN4QyxJQUFJNEssRUFBYSxFQUNiNVUsRUFBTyxJQUNQNFUsR0FBZSxFQUFJdGYsRUFBSUMsRUFBSUMsS0FBS2tVLElBQUkxSixFQUFNekssRUFBSSxJQUFPRCxFQUFJRSxLQUFLa1UsSUFBSTFKLEVBQU16SyxHQUFLLElBRWpGLElBQUssSUFBSW9KLEVBQUksRUFBR0EsRUFBSTRQLElBQU81UCxFQUFHLENBQzFCLE1BQU1rVyxFQUFTSCxFQUFLRSxHQUFjNU8sRUFBUXJILEdBQUtxTCxFQUFNckwsS0FBT0UsRUFDdEQyRyxFQUFJUSxFQUFRckgsR0FBS2tXLEVBQ2pCQyxFQUFJOUssRUFBTXJMLEdBQUtrVyxFQUNyQjdPLEVBQVFySCxHQUFLNkcsRUFDYndFLEVBQU1yTCxHQUFLbVcsRUFDWGQsRUFBZTlaLFVBQVU3QixFQUFHc0csRUFBRzZHLEdBQy9CeU8sRUFBZS9aLFVBQVUzQyxFQUFHb0gsRUFBR21XLEdBRW5DTCxFQUFxQnZlLElBQU1vZSxFQUFrQnBlLEdBQzdDLE1BQU02ZSxHQUFpQm5jLEtBQUtpVSxNQUFRMkgsRUFBOEJ0ZSxJQUFNcWUsRUFBMkJyZSxHQUNuRyxJQUFLLElBQUkwUCxFQUFJLEVBQUdBLEVBQUltUCxJQUFpQm5QLEVBQUcsQ0FDcEMsTUFBTXJPLEVBQUkvQixLQUFLbU4sTUFBTS9KLEtBQUtnUCxZQUFZbkosT0FBU2tXLEdBQ3pDM0ssRUFBUWlLLEVBQWVqYyxJQUFJbWMsRUFBSzVjLElBQ2hDeUksRUFBT3RLLGtCQUFrQnNRLEVBQVNnRSxHQUN4QyxJQUFJNEssRUFBYSxFQUNqQixHQUFJNVUsRUFBTyxFQUNQNFUsRUFBYyxFQUFJUCxFQUFxQjllLElBQU8sSUFBTXlLLElBQVMxSyxFQUFJRSxLQUFLa1UsSUFBSTFKLEVBQU16SyxHQUFLLFNBQ2xGLEdBQUk4QyxJQUFNZCxFQUNiLFNBRUosSUFBSyxJQUFJb0gsRUFBSSxFQUFHQSxFQUFJNFAsSUFBTzVQLEVBQUcsQ0FDMUIsTUFBTWtXLEVBQVNILEVBQUtFLEdBQWM1TyxFQUFRckgsR0FBS3FMLEVBQU1yTCxLQUFPRSxFQUN0RDJHLEVBQUlRLEVBQVFySCxHQUFLa1csRUFDakJDLEVBQUk5SyxFQUFNckwsR0FBS2tXLEVBQ3JCN08sRUFBUXJILEdBQUs2RyxFQUNid0UsRUFBTXJMLEdBQUttVyxFQUNYZCxFQUFlOVosVUFBVTdCLEVBQUdzRyxFQUFHNkcsR0FDL0J5TyxFQUFlL1osVUFBVWlhLEVBQUs1YyxHQUFJb0gsRUFBR21XLElBRzdDTixFQUE4QnRlLElBQU82ZSxFQUFnQlIsRUFBMkJyZSxHQUd4RixPQUFPOGQ7Ozs7T0FPWDlGLE9BQ0ksSUFBSUMsSUFBU3ZWLEtBQUtpVSxNQUNkdEUsRUFBSTNQLEtBQUsyUCxFQUtiLE9BSEEzUCxLQUFLd2IsT0FBVXhiLEtBQUsyWCxnQkFBa0IsRUFBSXBDLEVBQU92VixLQUFLMFgsV0FDdEQxWCxLQUFLMlAsRUFBSTNQLEtBQUttYixpQkFBaUJ4TCxFQUFHQSxFQUFHM1AsS0FBSzRhLE1BQU81YSxLQUFLNmEsT0FFL0M3YSxLQUFLMlA7Ozs7O0dDOVpiLE1BQU15TSxlQUFlek47Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQnhCOU8sWUFBWXNELEVBQUdrWixFQUFhLElBQUt6UCxFQUFJLEVBQUc3RyxFQUFJLEVBQUdsSCxFQUFTQyxVQUFXcUosRUFBSyxNQUtwRSxPQUpBNkgsTUFBTTdNLEVBQUc0QyxFQUFHbEgsRUFBUXNKLEdBQ3BCNkgsTUFBTXBCLGVBQWlCLENBQUMsYUFBYyxLQUN0QzVPLEtBQUtrUCxVQUFVLGFBQWNtTixHQUM3QnJjLEtBQUtrUCxVQUFVLElBQUt0QyxHQUNiNU07Ozs7O09BUVgwUCxLQUFLNE0sRUFBTSxLQUFNaEUsRUFBTSxNQUNuQixNQUFNblYsRUFBSW5ELEtBQUttRCxFQUNUYyxFQUFJZCxFQUFFbkUsTUFBTSxHQUNaK0csRUFBSS9GLEtBQUsrTyxHQUNUbFEsRUFBU21CLEtBQUt5TSxRQUNkRyxFQUFJNU0sS0FBS3VjLEdBQ2Z2YyxLQUFLd2MsVUFBWSxFQUFJNVAsRUFDckI1TSxLQUFLeWMsV0FBYSxFQUFJN1AsRUFDdEI1TSxLQUFLMGMsU0FBVyxFQUFJOVAsRUFDcEI1TSxLQUFLMlAsRUFBSTJNLEdBQU8sSUFBSXZNLElBQUk1TSxFQUFHNEMsR0FBR3VKO0FBQzlCdFAsS0FBS3NZLElBQU1BLEdBQU8sSUFBSXJNLFNBQVM5SSxFQUFFNkIsVUFBV25HLEdBQzVDLE1BQU04ZCxTQUFDQSxFQUFRN0MsUUFBRUEsR0FBVzlaLEtBQUs0YyxtQkFBbUI1YyxLQUFLd2MsVUFBV3hjLEtBQUt5YyxXQUFZemMsS0FBSzBjLFVBUTFGLE9BUEExYyxLQUFLMmMsU0FBV0EsRUFDaEIzYyxLQUFLOFosUUFBVUEsRUFDZjlaLEtBQUs2YyxHQUFLLElBQU81WSxFQUFJMFksRUFBUzNkLE1BQU0sR0FDcENnQixLQUFLMEMsRUFBSVosRUFBQUEsRUFDVDlCLEtBQUswRixJQUFNLEtBQ1gxRixLQUFLOGMsSUFBTSxJQUFJbGQsT0FBT3FFLEVBQUc4QixFQUFHLEdBQzVCL0YsS0FBSytjLEtBQU8sSUFBSW5kLE9BQU9xRSxFQUFHOEIsRUFBRyxHQUN0Qi9GOzs7Ozs7T0FTWDRjLG1CQUFtQkosRUFBV0MsRUFBWUMsR0FDdEMsTUFBTTdkLEVBQVNtQixLQUFLeU0sUUFDZDRQLEVBQWFyYyxLQUFLZ2QsWUFDbEI3WixFQUFJbkQsS0FBS21ELEVBQ1RjLEVBQUlkLEVBQUVuRSxNQUFNLEdBQ1pzWixFQUFNdFksS0FBS3NZLElBQ1gyRSxFQUFVcmdCLEtBQUt5SSxJQUFJbVgsRUFBWSxHQUFJdlksR0FDbkNpWixFQUFPLElBQUl0ZCxPQUFPcUUsRUFBR2daLEdBQ3JCRSxFQUFnQixJQUFJdmQsT0FBT3FFLEVBQUdnWixHQUNwQyxJQUFLLElBQUkzZixFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFDckJnYixFQUFJakwsT0FBT2xLLEVBQUUvRCxJQUFJOUIsR0FBSTJmLEVBQVUsR0FDMUJqUyxXQUNBbU8sUUFBT3BULEdBQWdCLEdBQVhBLEVBQUVoRyxRQUNkTCxNQUFLLENBQUNoRCxFQUFHQyxJQUFNRCxFQUFFcUQsTUFBUXBELEVBQUVvRCxRQUMzQmlNLFNBQVEsQ0FBQ2pHLEVBQUd0RyxLQUNUeWQsRUFBSzViLFVBQVVoRSxFQUFHbUMsRUFBR3NHLEVBQUUrRCxRQUFRTyxPQUMvQjhTLEVBQWM3YixVQUFVaEUsRUFBR21DLEVBQUdzRyxFQUFFaEc7a0JBSTVDO01BQU1xZCxFQUFNLElBQUloZCxhQUFhNkQsR0FDN0IsSUFBSyxJQUFJM0csRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQ3JCOGYsRUFBSTlmLEdBQUtWLEtBQUtzQixLQUNOaWYsRUFBYzliLE1BQU0vRCxFQUFHLEdBQ3ZCNmYsRUFBYzliLE1BQU0vRCxFQUFHLEdBQ3ZCNmYsRUFBYzliLE1BQU0vRCxFQUFHLEdBQ3ZCNmYsRUFBYzliLE1BQU0vRCxFQUFHLElBQU0sRUFDN0IsT0FHWixNQUFNZ1gsRUFBSXRVLEtBQUtxZCxRQUFRRixFQUFlQyxFQUFLRixHQUUzQyxJQUFJUCxFQUFXM2MsS0FBS3NkLHFCQUFxQmhKLEVBQUc0SSxFQUFNVixFQUFXQyxHQUN6RGMsRUFBYVosRUFBUzNkLE1BQU0sR0FDaEMsTUFBTXdlLEVBQW9CLElBQUlwZCxhQUFhbWQsR0FDM0MsSUFBSyxJQUFJamdCLEVBQUksRUFBR0EsRUFBSWlnQixJQUFjamdCLEVBQUcsQ0FDakMsTUFBTW1DLEVBQUlrZCxFQUFTdGIsTUFBTS9ELEVBQUcsR0FDdEJxQixFQUFJZ2UsRUFBU3RiLE1BQU0vRCxFQUFHLEdBQzVCa2dCLEVBQWtCbGdCLEdBQUt1QixFQUFPc0UsRUFBRS9ELElBQUlLLEdBQUkwRCxFQUFFL0QsSUFBSVQsSUFFbEQsSUFBSW1iLEVBQVU5WixLQUFLeWQsY0FBY2QsRUFBVXJJLEVBQUc0SSxFQUFNTSxFQUFtQkosR0FFdkUsR0FBSVYsRUFBVyxFQUFHLENBQ2QsTUFBTWdCLGdCQUFDQSxFQUFlQyxlQUFFQSxHQUFrQjNkLEtBQUs0ZCx3QkFBd0J6YSxFQUFHdVosRUFBVVUsR0FDcEZULEVBQVdBLEVBQVM3WixPQUFPNGEsRUFBaUIsWUFDNUM1RCxFQUFVMVosYUFBYWYsS0FBSyxJQUFJeWEsS0FBWTZELElBRWhESixFQUFhWixFQUFTM2QsTUFBTSxHQUM1QixJQUFJNmUsR0FBYy9iLEVBQUFBLEVBQ2xCLElBQUssSUFBSXhFLEVBQUksRUFBR0EsRUFBSWlnQixJQUFjamdCLEVBQzFCd2dCLE1BQU1oRSxFQUFReGMsTUFBTXdjLEVBQVF4YyxHQUFLLEdBQ2pDdWdCLEVBQWEvRCxFQUFReGMsS0FBSXVnQixFQUFhL0QsRUFBUXhjLElBRXRELElBQUl5Z0IsR0FBZ0JqYyxFQUFBQSxFQUNwQixJQUFLLElBQUl4RSxFQUFJLEVBQUdBLEVBQUlpZ0IsSUFBY2pnQixFQUM5QndjLEVBQVF4YyxJQUFNdWdCLEVBQ2QvRCxFQUFReGMsSUFBTSxLQUNkd2MsRUFBUXhjLEdBQUtWLEtBQUt1WCxJQUFJLEVBQUlrSSxFQUFhdkMsRUFBUXhjLElBQzNDeWdCLEVBQWVqRSxFQUFReGMsS0FBSXlnQixFQUFlakUsRUFBUXhjLElBRTFELElBQUssSUFBSUEsRUFBSSxFQUFHQSxFQUFJaWdCLElBQWNqZ0IsRUFDOUJ3YyxFQUFReGMsSUFBTXlnQixFQUVsQixNQUFPLENBQ0hwQixTQUFZQSxFQUNaN0MsUUFBV0E7Ozs7Ozs7O09BWW5CdUQsUUFBUUYsRUFBZUMsRUFBS0YsR0FDeEIsTUFBT2paLEVBQUdrVCxHQUFlZ0csRUFBY25lLE1BQ3ZDLE9BQU8sSUFBSVksT0FBT3FFLEVBQUdrVCxHQUFhLENBQUM3WixFQUFHbUMsSUFDM0I3QyxLQUFLb1ksTUFBT21JLEVBQWM5YixNQUFNL0QsRUFBR21DLElBQU0sR0FBSzJkLEVBQUk5ZixHQUFLOGYsRUFBSUYsRUFBSzdiLE1BQU0vRCxFQUFHbUM7Ozs7Ozs7OztPQWF4RjZkLHFCQUFxQmhKLEVBQUc0SSxFQUFNVixFQUFXQyxHQUNyQyxNQUFNeFksRUFBSWlaLEVBQUtsZSxNQUFNLEdBQ2YyZCxFQUFXLElBQUkvYyxPQUFPcUUsRUFBSXVZLEVBQVlDLEVBQVksR0FDeEQsSUFBSyxJQUFJbmYsRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQUcsQ0FDeEIsSUFBSTBnQixFQUFNMWdCLEVBQUlrZixFQUFZQyxFQUMxQixNQUFNd0IsRUFBZWplLEtBQUtrZSxVQUFVNUosRUFBRWxWLElBQUk5QixHQUFHZ0MsS0FBSXlHLElBQU1BLEtBQ3ZELElBQUssSUFBSXRHLEVBQUksRUFBR0EsRUFBSStjLElBQWEvYyxFQUFHLENBQ2hDLElBQUkwZSxFQUFNMWUsRUFBSWdkLEVBQ2QsTUFBTTJCLEVBQU1sQixFQUFLN2IsTUFBTS9ELEVBQUcyZ0IsRUFBYXhlLElBQ2pDNGUsRUFBVXJlLEtBQUtzZSxrQkFBa0I3QixFQUFZeFksRUFBR2dhLEVBQWF0ZSxNQUFNLEVBQUdGLEVBQUksSUFDaEYsSUFBSyxJQUFJZCxFQUFJLEVBQUdBLEVBQUk4ZCxJQUFjOWQsRUFBRyxDQUNqQyxNQUFNMEwsRUFBUTJULEVBQU1HLEVBQU14ZixFQUNwQjRmLEVBQU1GLEVBQVExZixHQUNwQmdlLEVBQVNyYixVQUFVK0ksRUFBTyxFQUFHL00sR0FDN0JxZixFQUFTcmIsVUFBVStJLEVBQU8sRUFBRytULEdBQzdCekIsRUFBU3JiLFVBQVUrSSxFQUFPLEVBQUdrVSxLQUl6QyxPQUFPNUI7Ozs7O09BUVh1QixVQUFVeGYsR0FDTixPQUFPQSxFQUNGWSxLQUFJLENBQUN5RyxFQUFHekksS0FBYyxDQUFDeUksRUFBR0EsRUFBR3pJLEVBQUdBLE1BQ2hDb0MsTUFBSyxDQUFDaEQsRUFBR0MsSUFBTUQsRUFBRXFKLEVBQUlwSixFQUFFb0osSUFDdkJ6RyxLQUFLeUcsR0FBTUEsRUFBRXpJOzs7Ozs7O09BVXRCZ2hCLGtCQUFrQnBFLEVBQVdzRSxFQUFTQyxHQUNsQyxNQUFNaFosRUFBYXpGLEtBQUtnUCxZQUNsQjBQLEVBQVcxVixTQUFTLEVBQUd3VixFQUFVLEdBQUdyRixRQUFPcFQsR0FBSzBZLEVBQVFFLFFBQVE1WSxHQUFLLElBQzNFLE9BQU9OLEVBQVdvRCxPQUFPNlYsRUFBVTloQixLQUFLeUksSUFBSTZVLEVBQVd3RSxFQUFTdmhCLE9BQVM7Ozs7Ozs7OztPQVk3RXNnQixjQUFjZCxFQUFVckksRUFBRzRJLEVBQU1NLEVBQW1CSixHQUNoRCxNQUFNRyxFQUFhWixFQUFTM2QsTUFBTSxHQUM1QjhhLEVBQVUsSUFBSTFaLGFBQWFtZCxHQUNqQyxJQUFLLElBQUl0Z0IsRUFBSSxFQUFHQSxFQUFJc2dCLElBQWN0Z0IsRUFBRyxDQUNqQyxNQUFNSyxFQUFJcWYsRUFBU3RiLE1BQU1wRSxFQUFHLEdBQ3RCbWhCLEVBQU1sQixFQUFLOWQsSUFBSTlCLEdBQUdxaEIsUUFBUWhDLEVBQVN0YixNQUFNcEUsRUFBRyxJQUM1QzJoQixFQUFRdEssRUFBRWpULE1BQU0vRCxFQUFHOGdCLEdBQ3pCLElBQUlTLEVBQVFqaUIsS0FBS29ZLE1BQU13SSxFQUFrQnZnQixJQUFNLElBQUttZ0IsRUFBSTlmLEdBQUs4ZixFQUFJVCxFQUFTdGIsTUFBTXBFLEVBQUcsTUFDL0U0aEIsRUFBUSxRQUFPQSxFQUFRLE9BQzNCL0UsRUFBUTdjLEdBQUsyaEIsRUFBUUMsRUFFekIsT0FBTy9FOzs7Ozs7O09BVVg4RCx3QkFBd0J6YSxFQUFHdVosRUFBVVUsR0FDakMsTUFBTXZlLEVBQVNtQixLQUFLeU0sUUFDZGhILEVBQWF6RixLQUFLZ1AsWUFDbEIvSyxFQUFJZCxFQUFFbkUsTUFBTSxHQUNaMGUsRUFBa0IsSUFBSTlkLE9BQU9xRSxFQUFJeVksRUFBVSxHQUMzQ2lCLEVBQWlCLElBQUl2ZCxhQUFhNkQsRUFBSXlZLEdBQzVDLElBQUssSUFBSXBmLEVBQUksRUFBR0EsRUFBSTJHLElBQUszRyxFQUFHLENBQ3hCLE1BQU0wZ0IsRUFBTTFnQixFQUFJb2YsRUFDVm9DLEVBQVUsSUFBSTlWLFNBQVMsRUFBRzFMLEVBQUksTUFBTzBMLFNBQVMxTCxFQUFJLEVBQUcyRyxFQUFJLElBQy9ELElBQUssSUFBSXhFLEVBQUksRUFBR0EsRUFBSWlkLElBQVlqZCxFQUFHLENBQy9CLElBQUsyZSxFQUFLRyxHQUFPOVksRUFBV29ELE9BQU9pVyxFQUFTLEdBQ3hDRixFQUFRaGlCLEtBQUtvWSxNQUFPblcsRUFBT3NFLEVBQUUvRCxJQUFJOUIsR0FBSTZGLEVBQUUvRCxJQUFJZ2YsS0FBUyxJQUFNaEIsRUFBSTlmLEdBQUs4ZixFQUFJZ0IsS0FDdkVRLEVBQVEsUUFBT0EsRUFBUSxPQUMzQixJQUFJQyxFQUFRamlCLEtBQUtvWSxNQUFPblcsRUFBT3NFLEVBQUUvRCxJQUFJOUIsR0FBSTZGLEVBQUUvRCxJQUFJbWYsS0FBUyxJQUFNbkIsRUFBSTlmLEdBQUs4ZixFQUFJbUIsS0FDdkVNLEVBQVEsUUFBT0EsRUFBUSxPQUV2QkQsRUFBUUMsS0FDUFQsRUFBS0csR0FBTyxDQUFDQSxFQUFLSCxJQUNsQlEsRUFBT0MsR0FBUyxDQUFDQSxFQUFPRCxJQUU3QixNQUFNdlUsRUFBUTJULEVBQU12ZSxFQUNwQmllLEVBQWdCcGMsVUFBVStJLEVBQU8sRUFBRy9NLEdBQ3BDb2dCLEVBQWdCcGMsVUFBVStJLEVBQU8sRUFBRytULEdBQ3BDVixFQUFnQnBjLFVBQVUrSSxFQUFPLEVBQUdrVSxHQUNwQ1osRUFBZXRULEdBQVN1VSxFQUFRQyxHQUd4QyxNQUFPLENBQ0huQixnQkFBbUJBLEVBQ25CQyxlQUFrQkE7Ozs7T0FRMUJvQixNQUFNcFAsR0FDRixNQUFNNk0sRUFBWXhjLEtBQUt3YyxVQUNqQkMsRUFBYXpjLEtBQUt5YyxXQUNsQkUsRUFBVzNjLEtBQUsyYyxTQUNoQjdDLEVBQVU5WixLQUFLOFosU0FDZDdWLEVBQUcwUixHQUFPaEcsRUFBRTNRLE1BQ2J1ZSxFQUFhWixFQUFTM2QsTUFBTSxHQUM1QmtYLEVBQU8sSUFBSXRXLE9BQU9xRSxFQUFHMFIsRUFBSyxHQUNoQyxJQUFJcUosRUFBTyxJQUFJdGhCLE1BQU1pWSxHQUFLak8sS0FBSyxHQUMzQnVYLEVBQU8sSUFBSXZoQixNQUFNaVksR0FBS2pPLEtBQUssR0FDM0J3WCxFQUFPLEVBQ1BDLEVBQU8sRUFDUEMsRUFBUyxFQUNUQyxFQUFPLEVBQ1gsTUFBTUMsRUFBaUJyYixFQUFJdVksRUFBWUMsRUFFdkMsSUFBSyxJQUFJeGYsRUFBSSxFQUFHQSxFQUFJc2dCLElBQWN0Z0IsRUFBRyxDQUNqQyxNQUFPSyxFQUFHbUMsRUFBR2QsR0FBS2dlLEVBQVN2ZCxJQUFJbkM7Z0NBRS9CO0dBQUlBLEVBQUl3ZixHQUFjLEdBQUt4ZixHQUFLcWlCLEVBQWdCLENBQzVDSixFQUFPLEVBQ1BDLEVBQU8sRUFDUCxJQUFLLElBQUlwWixFQUFJLEVBQUdBLEVBQUk0UCxJQUFPNVAsRUFBRyxDQUMxQixNQUFNd1osRUFBTzVQLEVBQUV0TyxNQUFNL0QsRUFBR3lJLEdBQ2xCeVosRUFBTzdQLEVBQUV0TyxNQUFNNUIsRUFBR3NHLEdBQ2xCMFosRUFBTzlQLEVBQUV0TyxNQUFNMUMsRUFBR29ILEdBQ3hCaVosRUFBS2paLEdBQUt3WixFQUFPQyxFQUNqQlAsRUFBS2xaLEdBQUt3WixFQUFPRSxFQUNqQlAsR0FBU0YsRUFBS2paLElBQU0sRUFDcEJvWixHQUFTRixFQUFLbFosSUFBTTs7S0FHckIsQ0FDSG9aLEVBQU8sRUFDUCxJQUFLLElBQUlwWixFQUFJLEVBQUdBLEVBQUk0UCxJQUFPNVAsRUFBRyxDQUMxQixNQUFNd1osRUFBTzVQLEVBQUV0TyxNQUFNL0QsRUFBR3lJLEdBQ2xCMFosRUFBTzlQLEVBQUV0TyxNQUFNMUMsRUFBR29ILEdBQ3hCa1osRUFBS2xaLEdBQUt3WixFQUFPRSxFQUNqQk4sR0FBU0YsRUFBS2xaLElBQU0sR0FJeEJtWixFQUFPQyxLQUFRQyxFQUNuQkMsR0FBUXZGLEVBQVE3YyxJQUFNLEVBQUlraUIsRUFBT0QsR0FDakMsTUFBTTdMLEdBQUt5RyxFQUFRN2MsSUFBTWlpQixFQUFPQyxLQUFVLEVBQzFDLElBQUssSUFBSXBaLEVBQUksRUFBR0EsRUFBSTRQLElBQU81UCxFQUFHLENBQzFCLE1BQU0yWixFQUFLVixFQUFLalosR0FBS29aLEVBQU85TCxFQUN0QnNNLEVBQUtWLEVBQUtsWixHQUFLbVosRUFBTzdMLEVBQzVCNkMsRUFBSzVVLFVBQVVoRSxFQUFHeUksRUFBR21RLEVBQUs3VSxNQUFNL0QsRUFBR3lJLEdBQUsyWixFQUFLQyxHQUM3Q3pKLEVBQUs1VSxVQUFVN0IsRUFBR3NHLEVBQUdtUSxFQUFLN1UsTUFBTTVCLEVBQUdzRyxHQUFLMlosR0FDeEN4SixFQUFLNVUsVUFBVTNDLEVBQUdvSCxFQUFHbVEsRUFBSzdVLE1BQU0xQyxFQUFHb0gsR0FBSzRaLElBR2hELE1BQU8sQ0FDSHpKLEtBQVFBLEVBQ1JtSixLQUFRQSxFQUNSRCxPQUFVQTs7OztPQVFsQjlQLFVBQVVzUSxFQUFnQixLQUN0QjVmLEtBQUt1UCxhQUNMLElBQUssSUFBSWdHLEVBQU8sRUFBR0EsRUFBT3FLLElBQWlCckssRUFDdkN2VixLQUFLNmYsTUFBTXRLLEdBRWYsT0FBT3ZWLEtBQUt3UDs7OztPQU9oQkMsYUFDSXpQLEtBQUt1UCxhQUNMLElBQUssSUFBSWdHLEVBQU8sRUFBR0EsRUFBTyxNQUFPQSxFQUM3QnZWLEtBQUs2ZixNQUFNdEssU0FDTHZWLEtBQUt3UCxXQUVmLE9BQU94UCxLQUFLd1A7Ozs7O09BUWhCcVEsTUFBTXRLLEdBQ0YsTUFBTXVLLEVBQVF2SyxFQUFPLElBQU0sR0FBSyxHQUMxQndLLEVBQVEvZixLQUFLMEMsRUFDYm9hLEVBQU05YyxLQUFLOGMsSUFDWG5OLEVBQUkzUCxLQUFLMlAsRUFBRTdLLElBQUlnWSxFQUFJbFksS0FBS2tiLEtBQ3hCNUosS0FBQ0EsRUFBSW1KLEtBQUVBLEVBQUlELE9BQUVBLEdBQVVwZixLQUFLK2UsTUFBTXBQLEdBSXhDLE9BSEEzUCxLQUFLMEMsRUFBSTJjLEVBQ1RyZixLQUFLMlAsRUFBSTNQLEtBQUtnZ0Isa0JBQWtCclEsRUFBRzRGLEVBQU1XLEdBQ3pDbFcsS0FBSzZjLElBQU9rRCxFQUFRVixFQUFPcmYsS0FBSzBGLElBQVEsS0FBTyxHQUN4QzFGLEtBQUsyUDs7Ozs7OztPQVVoQnFRLGtCQUFrQnJRLEVBQUc0RixFQUFNVyxHQUN2QixNQUFPalMsRUFBRzBSLEdBQU9oRyxFQUFFM1EsTUFDYjhnQixFQUFRdkssRUFBTyxJQUFNLEdBQUssR0FFMUJ3SCxFQUFPL2MsS0FBSytjLEtBQ1pELEVBQU05YyxLQUFLOGMsSUFDWEQsRUFBSzdjLEtBQUs2YyxHQUNoQixJQUFLLElBQUl2ZixFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFDckIsSUFBSyxJQUFJeUksRUFBSSxFQUFHQSxFQUFJNFAsSUFBTzVQLEVBQUcsQ0FDMUIsTUFBTWthLEVBQVlyakIsS0FBSzZaLEtBQUtxRyxFQUFJemIsTUFBTS9ELEVBQUd5SSxLQUFPbkosS0FBSzZaLEtBQUtQLEVBQUs3VSxNQUFNL0QsRUFBR3lJLElBQU9nWCxFQUFLMWIsTUFBTS9ELEVBQUd5SSxHQUFLLEdBQUtuSixLQUFLc0IsSUFBdUIsR0FBbkI2ZSxFQUFLMWIsTUFBTS9ELEVBQUd5SSxHQU5ySCxLQU9UZ1gsRUFBS3piLFVBQVVoRSxFQUFHeUksRUFBR2thLEdBQ3JCbkQsRUFBSXhiLFVBQVVoRSxFQUFHeUksRUFBRytaLEVBQVFoRCxFQUFJemIsTUFBTS9ELEVBQUd5SSxHQUFLOFcsRUFBS0UsRUFBSzFiLE1BQU0vRCxFQUFHeUksR0FBS21RLEVBQUs3VSxNQUFNL0QsRUFBR3lJLElBQ3BGNEosRUFBRXJPLFVBQVVoRSxFQUFHeUksRUFBRzRKLEVBQUV0TyxNQUFNL0QsRUFBR3lJLEdBQUsrVyxFQUFJemIsTUFBTS9ELEVBQUd5SSxJQUd2RCxPQUFPNEo7Ozs7R0N6WVIsTUFBTXVROzs7Ozs7Ozs7OztBQVdUcmdCLFlBQVlzZ0IsRUFBUUMsRUFBVSxXQUFZdmhCLEVBQVNDLFdBSy9DLEdBSkFrQixLQUFLcWdCLElBQU0sRUFDWHJnQixLQUFLc2dCLFFBQVVILGFBQWtCdmdCLE9BQVN1Z0IsRUFBU3ZnQixPQUFPUCxLQUFLOGdCLEdBQy9EbmdCLEtBQUt5TSxRQUFVNU4sRUFDZm1CLEtBQUt1Z0IsU0FBV0gsRUFDRCxnQkFBWHZoQixHQUE0Qm1CLEtBQUtzZ0IsUUFBUXRoQixNQUFNLEtBQU9nQixLQUFLc2dCLFFBQVF0aEIsTUFBTSxHQUN6RSxNQUFNLElBQUl5QixNQUFNLDZEQUlwQixPQUZBVCxLQUFLMFAsT0FDTDFQLEtBQUt3Z0IsS0FBT3hnQixLQUFLeWdCLEtBQ1Z6Z0I7Ozs7OztPQVNYMGdCLGFBQWEzZ0IsRUFBT08sRUFBTyxZQUN2QixJQUNJZ0osRUFEQXFYLEVBQVcsR0FFZixPQUFRcmdCLEdBQ0osSUFBSyxXQUNEZ0osRUFBWXZELEdBQU1BLEVBQUVxQixLQUNwQixNQUNKLElBQUssUUFDRGtDLEVBQVl2RCxHQUFNQSxFQUFFNmEsTUFDcEIsTUFDSixRQUNJLE1BQU0sSUFBSW5nQixNQUFNLGdCQUd4QixPQURBVCxLQUFLNmdCLFVBQVU3Z0IsS0FBS3dnQixLQUFNbFgsRUFBVXZKLEVBQU80Z0IsR0FDcENBOzs7Ozs7O09BVVhFLFVBQVV0VyxFQUFNckksRUFBR25DLEVBQU9rRixHQUNsQi9DLEVBQUVxSSxJQUFTeEssRUFDWGtGLEVBQU9oSCxLQUFLc00sRUFBS3VXLFdBRWpCOWdCLEtBQUs2Z0IsVUFBVXRXLEVBQUtFLEtBQU12SSxFQUFHbkMsRUFBT2tGLEdBQ3BDakYsS0FBSzZnQixVQUFVdFcsRUFBS0csTUFBT3hJLEVBQUduQyxFQUFPa0Y7OztPQU83Q3lLLE9BQ0ksTUFBTTdRLEVBQVNtQixLQUFLeU0sUUFDZC9OLEVBQUlzQixLQUFLc2dCLFFBQ1RwakIsRUFBSzhDLEtBQUsrZ0IsR0FBS3JpQixFQUFFTSxNQUFNLEdBQ3ZCZ2lCLEVBQVNoaEIsS0FBS2loQixPQUFTLElBQUk3Z0IsYUFBYWxELEdBQzlDLElBQUkwQixFQUNKLEdBQWUsZ0JBQVhDLEVBQTBCLENBQzFCRCxFQUFrQixJQUFJZ0IsT0FBTzFDLEVBQUdBLEVBQUc7QUFDbkMsSUFBSyxJQUFJSSxFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQUcsQ0FDeEIwakIsRUFBTTFqQixHQUFLOztBQUVYLElBQUssSUFBSW1DLEVBQUksRUFBR0EsRUFBSXZDLElBQUt1QyxFQUNyQmIsRUFBZ0IwQyxVQUFVaEUsRUFBR21DLEVBQUduQyxJQUFNbUMsRUFBSXFDLEVBQUFBLEVBQVdqRCxFQUFPSCxFQUFFVSxJQUFJOUIsR0FBSW9CLEVBQUVVLElBQUlLLEtBQ3hFYixFQUFnQnlDLE1BQU0vRCxFQUFHMGpCLEVBQU0xakIsSUFBTXNCLEVBQWdCeUMsTUFBTS9ELEVBQUdtQyxLQUM5RHVoQixFQUFNMWpCLEdBQUttQyxRQUlwQixDQUNIYixFQUFrQm9CLEtBQUtzZ0IsUUFBUS9mLFFBQy9CLElBQUssSUFBSWpELEVBQUksRUFBR0EsRUFBSUosSUFBS0ksRUFDckIsSUFBSyxJQUFJbUMsRUFBSSxFQUFHQSxFQUFJdkMsSUFBS3VDLEVBQ2pCbkMsSUFBTW1DLEVBQ05iLEVBQWdCMEMsVUFBVWhFLEVBQUdtQyxFQUFHcUMsRUFBQUEsR0FDekJsRCxFQUFnQnlDLE1BQU0vRCxFQUFHMGpCLEVBQU0xakIsSUFBTXNCLEVBQWdCeUMsTUFBTS9ELEVBQUdtQyxLQUNyRXVoQixFQUFNMWpCLEdBQUttQyxHQUszQk8sS0FBS2toQixpQkFBbUJ0aUIsRUFDeEIsTUFBTStoQixFQUFZM2dCLEtBQUttaEIsVUFBWSxJQUFJempCLE1BQU1SLEdBQ3ZDa2tCLEVBQVVwaEIsS0FBS3FoQixRQUFVLElBQUlDLFlBQVlwa0IsR0FDL0MsSUFBSyxJQUFJSSxFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQ3JCcWpCLEVBQVNyakIsR0FBSyxHQUNkcWpCLEVBQVNyakIsR0FBRyxHQUFLLElBQUlpa0IsUUFBUXZoQixLQUFLcWdCLE1BQU8sS0FBTSxLQUFNLEVBQUczaEIsRUFBRVUsSUFBSTlCLEdBQUlBLEVBQUcsRUFBRyxHQUN4RThqQixFQUFPOWpCLEdBQUssRUFFaEIsT0FBTzBDOzs7T0FNWHlnQixLQUNJLE1BQU12akIsRUFBSThDLEtBQUsrZ0IsR0FDVEMsRUFBUWhoQixLQUFLaWhCLE9BQ2JoaUIsRUFBSWUsS0FBS2toQixpQkFDVFAsRUFBVzNnQixLQUFLbWhCLFVBQ2hCQyxFQUFTcGhCLEtBQUtxaEIsUUFDZGpCLEVBQVVwZ0IsS0FBS3VnQixTQUNyQixJQUFJQyxFQUFPLEtBQ1gsSUFBSyxJQUFJeFQsRUFBSSxFQUFHd1UsRUFBUXRrQixFQUFJLEVBQUc4UCxFQUFJd1UsSUFBU3hVLEVBQUcsQ0FDM0MsSUFBSXlVLEVBQUssRUFDVCxJQUFLLElBQUlua0IsRUFBSSxFQUFHQSxFQUFJSixJQUFLSSxFQUFHLENBQ3hCLElBQUlva0IsRUFBVXppQixFQUFFb0MsTUFBTS9ELEVBQUcwakIsRUFBTTFqQixJQUMvQixJQUFLLElBQUltQyxFQUFJbkMsRUFBSSxFQUFHbUMsRUFBSXZDLElBQUt1QyxFQUNyQmlpQixFQUFVemlCLEVBQUVvQyxNQUFNL0QsRUFBR21DLEtBQ3JCdWhCLEVBQU0xakIsR0FBS21DLEVBQ1hpaUIsRUFBVXppQixFQUFFb0MsTUFBTS9ELEVBQUcwakIsRUFBTTFqQixLQUl2QyxJQUFLLElBQUlBLEVBQUksRUFBR0EsRUFBSUosSUFBS0ksRUFDakIyQixFQUFFb0MsTUFBTS9ELEVBQUcwakIsRUFBTTFqQixJQUFNMkIsRUFBRW9DLE1BQU1vZ0IsRUFBSVQsRUFBTVMsTUFDekNBLEVBQUtua0IsR0FHYixJQUFJcWtCLEVBQUtYLEVBQU1TLEdBQ1hHLEVBQWFqQixFQUFTYyxHQUFJLEdBQzFCSSxFQUFhbEIsRUFBU2dCLEdBQUksR0FDMUJHLEVBQXFCRixFQUFXRyxPQUFTLENBQUNILEVBQVd2WCxPQUFTdVgsRUFBV3ZYLE1BQ3pFMlgsRUFBcUJILEVBQVdFLE9BQVMsQ0FBQ0YsRUFBV3hYLE9BQVN3WCxFQUFXeFgsTUFDekV5VSxFQUFVZ0QsRUFBbUJoZixPQUFPa2YsR0FDcENDLEVBQWMsSUFBSVYsUUFBUXZoQixLQUFLcWdCLE1BQU91QixFQUFZQyxFQUFZNWlCLEVBQUVvQyxNQUFNb2dCLEVBQUlFLEdBQUssS0FBTTdDLEdBQ3pGOEMsRUFBV25XLE9BQVN3VyxFQUNwQkosRUFBV3BXLE9BQVN3VyxFQUNwQnRCLEVBQVNjLEdBQUlTLFFBQVFELEdBQ3JCYixFQUFPSyxJQUFPTCxFQUFPTyxHQUNyQixJQUFLLElBQUlsaUIsRUFBSSxFQUFHQSxFQUFJdkMsSUFBS3VDLEVBQUcsQ0FDeEIsTUFBTTBpQixFQUFTbGpCLEVBQUVvQyxNQUFNb2dCLEVBQUloaUIsR0FDckIyaUIsRUFBU25qQixFQUFFb0MsTUFBTXNnQixFQUFJbGlCLEdBQzNCLElBQUlNLEVBQ0osT0FBUXFnQixHQUNKLElBQUssU0FDRHJnQixFQUFRbkQsS0FBS3lJLElBQUk4YyxFQUFRQyxHQUN6QixNQUNKLElBQUssV0FDRHJpQixFQUFRbkQsS0FBS3NCLElBQUlpa0IsRUFBUUMsR0FDekIsTUFDSixJQUFLLFVBQ0RyaUIsR0FBU3FoQixFQUFPSyxHQUFNVSxFQUFTZixFQUFPTyxHQUFNUyxJQUFXaEIsRUFBT0ssR0FBTUwsRUFBTzNoQixJQUduRlIsRUFBRXFDLFVBQVU3QixFQUFHZ2lCLEVBQUkxaEIsR0FDbkJkLEVBQUVxQyxVQUFVbWdCLEVBQUloaUIsRUFBR00sR0FHdkJkLEVBQUVxQyxVQUFVbWdCLEVBQUlBLEVBQUkzZixFQUFBQSxHQUNwQixJQUFLLElBQUl4RSxFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQ3JCMkIsRUFBRXFDLFVBQVVoRSxFQUFHcWtCLEVBQUk3ZixFQUFBQSxHQUNuQjdDLEVBQUVxQyxVQUFVcWdCLEVBQUlya0IsRUFBR3dFLEVBQUFBOzs7Ozs7OztnQkFXdkIwZSxFQUFPeUIsRUFFWCxPQUFPekIsR0FJZixNQUFNZSxRQUNGMWhCLFlBQVl5UyxFQUFJN0gsRUFBTUMsRUFBT3RELEVBQU1pYixFQUFVaFksRUFBT3NCLEVBQU1pVixHQVV0RCxPQVRBNWdCLEtBQUtzUyxHQUFLQSxFQUNWdFMsS0FBS3lLLEtBQU9BLEVBQ1p6SyxLQUFLMEssTUFBUUEsRUFDYjFLLEtBQUtvSCxLQUFPQSxFQUNacEgsS0FBS3FLLE1BQVFBLEVBQ2JySyxLQUFLMkwsS0FBT0EsR0FBUWxCLEVBQUtrQixLQUFPakIsRUFBTWlCLEtBQ3RDM0wsS0FBSzRnQixNQUFRQSxHQUFTLEVBQUloa0IsS0FBS3NCLElBQUl1TSxFQUFLbVcsTUFBT2xXLEVBQU1rVyxPQUNyRDVnQixLQUFLcWlCLFNBQVdBLEdBQVlyaUIsS0FBS3NpQixvQkFBb0I3WCxFQUFNQyxHQUMzRDFLLEtBQUt5TCxPQUFTLEtBQ1B6TCxLQUdYc2lCLG9CQUFvQjdYLEVBQU1DLEdBQ3RCLE1BQU02WCxFQUFTOVgsRUFBS2tCLEtBQ2Q2VyxFQUFTOVgsRUFBTWlCLEtBQ2Y4VyxFQUFhaFksRUFBSzRYLFNBQ2xCSyxFQUFhaFksRUFBTTJYLFNBQ25CMVcsRUFBTzNMLEtBQUsyTCxLQUNaek8sRUFBSXVOLEVBQUs0WCxTQUFTbGxCLE9BQ2xCd2xCLEVBQWUsSUFBSXZpQixhQUFhbEQsR0FDdEMsSUFBSyxJQUFJSSxFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQ3JCcWxCLEVBQWFybEIsSUFBTWlsQixFQUFTRSxFQUFXbmxCLEdBQUtrbEIsRUFBU0UsRUFBV3BsQixJQUFNcU8sRUFFMUUsT0FBT2dYLEVBR1BaLGFBQ0EsT0FBc0IsSUFBZi9oQixLQUFLNGdCLE1BR2hCRSxTQUNJLEdBQUk5Z0IsS0FBSytoQixPQUFRLE1BQU8sQ0FBQy9oQixNQUN6QixNQUFNeUssRUFBT3pLLEtBQUt5SyxLQUNaQyxFQUFRMUssS0FBSzBLLE1BQ25CLE9BQVFELEVBQUtzWCxPQUFTLENBQUN0WCxHQUFRQSxFQUFLcVcsVUFBVWhlLE9BQU80SCxFQUFNcVgsT0FBUyxDQUFDclgsR0FBU0EsRUFBTW9XLFVBR3hGOEIsY0FDSSxHQUFJNWlCLEtBQUsraEIsT0FBUSxNQUFPLENBQUMvaEIsTUFDekIsTUFBTTZpQixFQUFtQjdpQixLQUFLeUssS0FBS21ZLGNBQzdCRSxFQUFvQjlpQixLQUFLMEssTUFBTWtZLGNBQ3JDLE9BQU9DLEVBQWlCL2YsT0FBT2dnQixHQUFtQmhnQixPQUFPLENBQUM5Qzs7OztHQ2hPM0QsTUFBTStpQjs7Ozs7Ozs7Ozs7OztBQWFUbGpCLFlBQVlzZ0IsRUFBUTZDLEVBQUdua0IsRUFBU0MsVUFBV3FKLEVBQUssS0FBTXVILEdBQU8sR0FDekQxUCxLQUFLeU0sUUFBVTVOLEVBQ2ZtQixLQUFLc2dCLFFBQVVILEVBQ2ZuZ0IsS0FBS2lqQixHQUFLRCxFQUNWLE1BQU8vZSxFQUFHaEYsR0FBS2toQixFQUFPbmhCLE1BUXRCLE9BUEFnQixLQUFLNEgsR0FBSzNELEVBQ1ZqRSxLQUFLME4sR0FBS3pPLEVBQ04rakIsRUFBSS9lLElBQUcrZSxFQUFJL2UsR0FDZmpFLEtBQUtnUCxZQUFjLElBQUlySixXQUFXd0MsR0FDbENuSSxLQUFLbWhCLFVBQVksSUFBSXpqQixNQUFNdUcsR0FBR3lELFVBQUt5QixHQUNuQ25KLEtBQUtrakIsbUJBQXFCbGpCLEtBQUttakIsc0JBQXNCSCxHQUNqRHRULEdBQU0xUCxLQUFLMFAsS0FBS3NULEVBQUdoakIsS0FBS2tqQixvQkFDckJsakI7OztPQU1YMGdCLGVBQ0ksTUFBTXNDLEVBQUloakIsS0FBS2lqQixHQUNUdEMsRUFBVzNnQixLQUFLbWhCLFVBQ2hCbGMsRUFBUyxJQUFJdkgsTUFBTXNsQixHQUFHdGIsT0FBT3BJLEtBQUksSUFBTSxJQUFJNUIsUUFFakQsT0FEQWlqQixFQUFTM1UsU0FBUSxDQUFDWSxFQUFHdFAsSUFBTTJILEVBQU8ySCxHQUFHM08sS0FBS1gsS0FDbkMySDs7Ozs7T0FRWG1lLGdCQUFnQjVXLEVBQVE2VyxHQUNwQixNQUFNM2tCLEVBQUlzQixLQUFLc2dCLFFBQ1R6aEIsRUFBU21CLEtBQUt5TSxRQUNwQixJQUFJblAsRUFBSWtQLEVBQU9yUCxPQWFmLE9BWlFpTSxLQUFLSSxRQUNUNlosR0FDQ3RkLElBQ0csTUFBTXVkLEVBQUs1a0IsRUFBRVUsSUFBSTJHLEdBQ2pCLElBQUkzSSxFQUFNLEVBQ1YsSUFBSyxJQUFJcUMsRUFBSSxFQUFHQSxFQUFJbkMsSUFBS21DLEVBQ3JCckMsR0FBT3lCLEVBQU95a0IsRUFBSTlXLEVBQU8vTSxJQUU3QixPQUFPckMsSUFFWCxPQUVLdU4sTUFBTWIsUUFHbkJxWixzQkFBc0JILEdBQ2xCLE1BQU0vZSxFQUFJakUsS0FBSzRILEdBQ1RuQyxFQUFhekYsS0FBS2dQLFlBQ2xCdFEsRUFBSXNCLEtBQUtzZ0IsUUFDVGlELEVBQW9CLElBQUk3bEIsTUFBTXNsQixHQUFHdGIsT0FDakNvWCxFQUFVOVYsU0FBUyxFQUFHL0UsRUFBSSxHQUMxQnVmLEVBQWUvZCxFQUFXK0MsWUFBY3ZFLEVBQUksR0FDbERzZixFQUFrQixHQUFLN2tCLEVBQUVVLElBQUlva0IsR0FDN0IsTUFBTUMsRUFBYyxDQUFDRCxHQUNmRSxFQUFjOW1CLEtBQUttTixPQUFPOUYsRUFBSStlLEdBQUtBO0FBQ3pDLElBQUssSUFBSTFsQixFQUFJLEVBQUdBLEVBQUkwbEIsSUFBSzFsQixFQUFHOztBQUV4QixNQUFNd0wsRUFBU3JELEVBQVdvRCxPQUFPaVcsRUFBUTNGLFFBQU9wVCxJQUFnQyxHQUEzQjBkLEVBQVk5RSxRQUFRNVksS0FBVzJkLEdBQzlFQyxFQUFpQjNqQixLQUFLb2pCLGdCQUFnQkcsRUFBa0I1akIsTUFBTSxFQUFHckMsR0FBSXdMLEdBQzNFMmEsRUFBWXhsQixLQUFLMGxCLEdBQ2pCSixFQUFrQmptQixHQUFLb0IsRUFBRVUsSUFBSXVrQixHQUVqQyxPQUFPSixFQUdYSyxXQUFXTCxHQUNQLE1BQU1QLEVBQUlPLEVBQWtCcG1CLE9BQ3RCOEcsRUFBSWpFLEtBQUs0SCxHQUNUM0ksRUFBSWUsS0FBSzBOLEdBQ1RoUCxFQUFJc0IsS0FBS3NnQixRQUNUemhCLEVBQVNtQixLQUFLeU0sUUFDZGtVLEVBQVczZ0IsS0FBS21oQixVQUN0QixJQUFJMEMsR0FBbUI7aUNBRXZCO0lBQUssSUFBSXZtQixFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFBRyxDQUN4QixNQUFNd21CLEVBQUtwbEIsRUFBRVUsSUFBSTlCLEdBQ2pCLElBQUkrWixFQUFXdlYsRUFBQUEsRUFDWGlpQixFQUFjLEtBQ2xCLElBQUssSUFBSXRrQixFQUFJLEVBQUdBLEVBQUl1akIsSUFBS3ZqQixFQUFHLENBQ3hCLElBQUlzRyxFQUFJbEgsRUFBTzBrQixFQUFrQjlqQixHQUFJcWtCLEdBQ2pDL2QsRUFBSXNSLElBQ0pBLEVBQVd0UixFQUNYZ2UsRUFBY3RrQixHQUdsQmtoQixFQUFTcmpCLEtBQU95bUIsSUFDaEJGLEdBQW1CLEdBRXZCbEQsRUFBU3JqQixHQUFLeW1COzsrQkFJbEI7SUFBSyxJQUFJem1CLEVBQUksRUFBR0EsRUFBSTBsQixJQUFLMWxCLEVBQUcsQ0FDeEIsTUFBTStrQixFQUFXa0IsRUFBa0JqbUIsR0FDbkMsSUFBSyxJQUFJbUMsRUFBSSxFQUFHQSxFQUFJUixJQUFLUSxFQUNyQjRpQixFQUFTNWlCLEdBQUs7bUJBTXRCO09BRkFPLEtBQUtna0Isa0JBQWtCVCxHQUVoQixDQUNITSxpQkFBb0JBLEVBQ3BCTixrQkFBcUJBLEdBSTdCUyxrQkFBa0JULEdBQ2QsTUFBTVAsRUFBSU8sRUFBa0JwbUIsT0FDdEI4RyxFQUFJakUsS0FBSzRILEdBQ1QzSSxFQUFJZSxLQUFLME4sR0FDVGhQLEVBQUlzQixLQUFLc2dCLFFBQ1RLLEVBQVczZ0IsS0FBS21oQixVQUNoQjhDLEVBQWtCLElBQUl2bUIsTUFBTXNsQixHQUFHdGIsS0FBSyxHQUUxQyxJQUFLLElBQUlwSyxFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFBRyxDQUN4QixNQUFNd21CLEVBQUtwbEIsRUFBRVUsSUFBSTlCLEdBQ1g0bUIsRUFBS3ZELEVBQVNyakIsR0FDcEIybUIsRUFBZ0JDLEtBQ2hCLE1BQU03QixFQUFXa0IsRUFBa0JXLEdBQ25DLElBQUssSUFBSXprQixFQUFJLEVBQUdBLEVBQUlSLElBQUtRLEVBQ3JCNGlCLEVBQVM1aUIsSUFBTXFrQixFQUFHcmtCLEdBRzFCLElBQUssSUFBSW5DLEVBQUksRUFBR0EsRUFBSTBsQixJQUFLMWxCLEVBQUcsQ0FDeEIsTUFBTUosRUFBSSttQixFQUFnQjNtQixHQUMxQmltQixFQUFrQmptQixHQUFLaW1CLEVBQWtCam1CLEdBQUdnQyxLQUFJc04sR0FBS0EsRUFBSTFQOzs7O09BU2pFd1MsS0FBS3NULEVBQUdPLEdBQ0NQLElBQUdBLEVBQUloakIsS0FBS2lqQixJQUNaTSxJQUFtQkEsRUFBb0J2akIsS0FBS21qQixzQkFBc0JILElBQ3ZFLElBQUlhLEdBQW1CLEVBQ3ZCLEVBQUcsQ0FDQyxNQUFNTSxFQUFtQm5rQixLQUFLNGpCLFdBQVdMLEdBQ3pDQSxFQUFvQlksRUFBaUJaLGtCQUNyQ00sRUFBbUJNLEVBQWlCTix1QkFDL0JBOzs7O0dDbEtWLE1BQU1POzs7Ozs7Ozs7Ozs7OztBQWNUdmtCLFlBQVlzZ0IsRUFBUTZDLEVBQUdwTSxFQUFTLEtBQU0vWCxFQUFTQyxVQUFXcUosRUFBSyxNQUMzRG5JLEtBQUt5TSxRQUFVNU4sRUFDZm1CLEtBQUtzZ0IsUUFBVUgsRUFDZm5nQixLQUFLcWtCLEdBQUtya0IsS0FBS3NnQixRQUFRdGIsVUFDdkJoRixLQUFLaWpCLEdBQUtELEVBQ1YsTUFBTy9lLEVBQUdoRixHQUFLa2hCLEVBQU9uaEIsTUFrQnRCLE9BakJBZ0IsS0FBSzRILEdBQUszRCxFQUNWakUsS0FBSzBOLEdBQUt6TyxFQUNWZSxLQUFLc2tCLFVBQVkxTixHQUFZLEdBQUtoYSxLQUFLMm5CLE1BQU10Z0IsR0FDN0NqRSxLQUFLa2hCLGlCQUFtQixJQUFJdGhCLE9BQU9xRSxFQUFHQSxFQUFHOzs7Ozs7OztBQVFyQytlLEVBQUkvZSxJQUFHK2UsRUFBSS9lLEdBQ2ZqRSxLQUFLZ1AsWUFBYyxJQUFJckosV0FBV3dDLEdBQ2xDbkksS0FBS21oQixVQUFZLElBQUl6akIsTUFBTXVHLEdBQUd5RCxVQUFLeUIsR0FDbkNuSixLQUFLd2tCLGlCQUFtQnhrQixLQUFLeWtCLG9CQUFvQnpCOztBQUVqRGhqQixLQUFLaVAsaUJBQWtCLEVBQ2hCalA7OztPQU1YMGdCLGVBQ0ksTUFBTXNDLEVBQUloakIsS0FBS2lqQixHQUNUdmtCLEVBQUlzQixLQUFLcWtCLEdBQ1Zya0IsS0FBS2lQLGlCQUNOalAsS0FBSzBQLEtBQUtzVCxFQUFHaGpCLEtBQUt3a0Isa0JBRXRCLE1BQU12ZixFQUFTLElBQUl2SCxNQUFNc2xCLEdBQUd0YixPQUFPcEksS0FBSSxJQUFNLElBQUk1QixRQUtqRCxPQUpBZ0IsRUFBRXNOLFNBQVEsQ0FBQzBZLEVBQUtqbEIsS0FDWndGLEVBQU9qRixLQUFLMmtCLGdCQUFnQkQsRUFBS2psQixHQUFHbWxCLGVBQWUzbUIsS0FBS3dCLE1BRTVEd0YsRUFBTzRmLFFBQVU3a0IsS0FBS3drQixpQkFDZnZmLEVBR1gySyxrQkFDSSxNQUFNZ0gsRUFBVzVXLEtBQUtza0IsZ0JBQ2hCdGtCLEtBQUswZ0IsZUFDWCxJQUFJb0UsR0FBUyxFQUNUeG5CLEVBQUksRUFDUixHQUNJd25CLEVBQVM5a0IsS0FBSzRqQixtQkFDUjVqQixLQUFLMGdCLHNCQUNMb0UsS0FBWXhuQixFQUFJc1o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BK0Q5QmdOLGFBQ0ksTUFBTWxsQixFQUFJc0IsS0FBS3FrQixHQUNUckIsRUFBSWhqQixLQUFLaWpCLEdBQ1Q0QixFQUFVN2tCLEtBQUt3a0IsaUJBQ2ZPLEVBQVFybUIsRUFBRVksS0FBSSxDQUFDMGxCLEVBQUs5SSxJQUFNbGMsS0FBSzJrQixnQkFBZ0JLLEVBQUs5SSxLQUVwRCtJLEVBQVUsSUFBSXZuQixNQUFNc2xCLEdBQUd0YixLQUFLLEdBQzVCd2QsRUFBSyxJQUFJeG5CLE1BQU1zbEIsR0FBR3RiLEtBQUs7O0FBK0I3QixHQTlCQWhKLEVBQUVzTixTQUFRLENBQUMwWSxFQUFLamxCLEtBQ1osR0FBSW9sQixFQUFRTSxXQUFVemtCLEdBQUtBLElBQU1qQixJQUFLLEVBQUcsQ0FDckMsTUFBTTJsQixFQUFNTCxFQUFNdGxCLEdBQUc0bEIsaUJBQ2ZDLEVBQVUsSUFBSTVuQixNQUFNc2xCLEdBQUd0YixNQUFNMGQ7O0FBQ25DMW1CLEVBQUVzTixTQUFRLENBQUNnWixFQUFLOUksS0FDWixHQUFJemMsSUFBTXljLEVBQUcsT0FDYixNQUFNcUosRUFBT3ZsQixLQUFLd2xCLGNBQWN0SixFQUFHemMsRUFBR3VsQixFQUFLTixJQUNwQ0UsY0FBaUIxbkIsRUFBR21vQixpQkFBb0JJLEVBQUtDLGdCQUFtQkMsR0FBT1osRUFBTTdJOzs7QUFHcEY7QUFGQW9KLEVBQVFwb0IsSUFBTU4sS0FBS3lJLElBQUlrZ0IsRUFBTUksR0FBT0YsRUFFaENGLEVBQU9FOztBQUVQLElBQUssSUFBSW5vQixFQUFJLEVBQUdBLEVBQUkwbEIsSUFBSzFsQixFQUNqQkEsSUFBTUosSUFBR29vQixFQUFRaG9CLElBQU1pb0IsRUFBT0U7O0FBSzlDSCxFQUNLaG1CLEtBQUksQ0FBQ3lHLEVBQUd6SSxJQUFNLENBQUN5SSxFQUFHekksS0FDbEI2YixRQUFPLEVBQUVwVCxFQUFHekksS0FBT3lJLEVBQUlrZixFQUFRM25CLEtBQy9CME8sU0FBUSxFQUFFakcsRUFBR3pJLE1BQ055SSxFQUFJa2YsRUFBUTNuQixLQUNaMm5CLEVBQVEzbkIsR0FBS3lJLEVBQ2JtZixFQUFHNW5CLEdBQUttQyxVQU14QjRGLElBQUk0ZixJQUFZLEVBQUcsT0FBTzsyQkFHOUI7S0FBTzVmLElBQUk0ZixHQUFXLEdBQUc7O0FBRXJCLE1BQU0zbkIsRUFBSTJuQixFQUNMM2xCLEtBQUksQ0FBQ3lHLEVBQUd6SSxJQUFNLENBQUN5SSxFQUFHekksS0FDbEJvQyxNQUFLLEVBQUVoRCxJQUFLQyxLQUFPRCxFQUFJQyxJQUFHLEdBQUcsR0FDWSxHQUExQ2tvQixFQUFRMUwsUUFBT3pZLEdBQUtBLEdBQUt3a0IsRUFBRzVuQixLQUFJSCxTQUNoQzBuQixFQUFRdm5CLEdBQUs0bkIsRUFBRzVuQjs7QUFHcEIybkIsRUFBUTNuQixHQUFLOztBQUViMm5CLEVBQ0szbEIsS0FBSSxDQUFDOGxCLEVBQUszbEIsSUFBTSxDQUFDMmxCLEVBQUszbEIsS0FDdEIwWixRQUFPLEVBQUVpTSxLQUFTQSxFQUFNLElBQ3hCcFosU0FBUSxFQUFFckwsRUFBR2xCLE1BQ1YsTUFBTWlsQixFQUFNaG1CLEVBQUVlLEdBQ2QsSUFBSXJDLEVBQU0sRUFDVnNCLEVBQUVzTixTQUFRLENBQUNnWixFQUFLOUksS0FDUjJJLEVBQVFNLFdBQVV6a0IsR0FBS0EsR0FBS2pCLEdBQUtpQixHQUFLd2IsS0FBTSxHQUM1QzVlLEdBQUttQyxJQUNMc2xCLEVBQU03SSxHQUFHMEksZ0JBQWtCQyxFQUFRcGxCLEdBQ25DckMsR0FBUVIsS0FBS3lJLElBQUlyRixLQUFLd2xCLGNBQWN0SixFQUFHemMsRUFBR3VsQixFQUFLTixHQUFNSyxFQUFNN0ksR0FBR3dKLGlCQUFtQlgsRUFBTTdJLEdBQUdtSixpQkFFMUZqb0IsR0FBUVIsS0FBS3lJLElBQUlyRixLQUFLd2xCLGNBQWN0SixFQUFHemMsRUFBR3VsQixFQUFLTixHQUFPSyxFQUFNN0ksR0FBR21KLGlCQUFrQixPQUd6RkosRUFBUXhsQixHQUFLckMsS0FJekIsT0FEQTRDLEtBQUt3a0IsaUJBQW1CSyxHQUNqQixFQUdYVyxjQUFjbG9CLEVBQUdtQyxFQUFHb1osRUFBSSxLQUFNNkwsRUFBSSxNQUM5QixHQUFJcG5CLElBQU1tQyxFQUFHLE9BQU8sRUFDcEIsTUFBTVIsRUFBSWUsS0FBS2toQixpQkFDVHhpQixFQUFJc0IsS0FBS3FrQixHQUNUeGxCLEVBQVNtQixLQUFLeU0sUUFDcEIsSUFBSXlTLEVBQU9qZ0IsRUFBRW9DLE1BQU0vRCxFQUFHbUMsR0FNdEIsT0FMYSxJQUFUeWYsSUFDQUEsRUFBT3JnQixFQUFPZ2EsR0FBT25hLEVBQUVwQixHQUFJb25CLEdBQU9obUIsRUFBRWUsSUFDcENSLEVBQUVxQyxVQUFVaEUsRUFBR21DLEVBQUd5ZixHQUNsQmpnQixFQUFFcUMsVUFBVTdCLEVBQUduQyxFQUFHNGhCLElBRWZBLEVBR1h5RixnQkFBZ0JELEVBQUtqbEIsR0FDakIsTUFBTW9sQixFQUFVN2tCLEtBQUt3a0IsaUJBQ2Y5bEIsRUFBSXNCLEtBQUtxa0IsSUFDUnVCLEVBQVNDLEdBQVVoQixFQUNyQnZsQixLQUFJLENBQUNvQixFQUFHcEQsS0FDTCxNQUFNd29CLEVBQU1wbkIsRUFBRWdDLEdBQ2QsTUFBTyxDQUFDVixLQUFLd2xCLGNBQWMvbEIsRUFBR2lCLEVBQUdna0IsRUFBS29CLEdBQU14b0IsTUFFL0NvQyxNQUFLLENBQUNxbUIsRUFBSUMsSUFBT0QsRUFBRyxHQUFLQyxFQUFHLEtBRWpDLE1BQU8sQ0FDSFgsaUJBQW9CTyxFQUFRLEdBQzVCaEIsY0FBaUJnQixFQUFRLEdBQ3pCRixnQkFBbUJHLEVBQU8sR0FDMUJJLGFBQWdCSixFQUFPOzs7O09BUS9CblcsS0FBS3NULEVBQUdrRCxHQUNDbEQsSUFBR0EsRUFBSWhqQixLQUFLaWpCLElBQ1ppRCxJQUFpQkEsRUFBa0JsbUIsS0FBS3lrQixvQkFBb0J6QixJQUNqRSxNQUFNcE0sRUFBVzVXLEtBQUtza0IsVUFDdEIsSUFBSVEsR0FBUyxFQUNUeG5CLEVBQUksRUFDUixHQUNJd25CLEVBQVM5a0IsS0FBSzRqQixvQkFDUmtCLEtBQVl4bkIsRUFBSXNaLEdBQzFCLE9BQU81Vzs7Ozs7T0FRWHlrQixvQkFBb0J6QixHQUNoQixNQUFNL2UsRUFBSWpFLEtBQUs0SCxHQUNUbEosRUFBSXNCLEtBQUtxa0IsR0FDVHZGLEVBQVU5VixTQUFTLEVBQUcvRSxFQUFJLEdBQzFCd0IsRUFBYXpGLEtBQUtnUCxZQUNsQjlSLEVBQUlOLEtBQUt5SSxJQUFJcEIsRUFBRyxHQUFLckgsS0FBS3VwQixLQUFLdnBCLEtBQUtDLEtBQUtvSCxLQUN6Q21pQixFQUFLLElBQUkxb0IsTUFBTVIsR0FBR3dLLEtBQUs1RixFQUFBQSxHQUN2QitpQixFQUFVOztBQUVoQixJQUFJd0IsRUFBTXZrQixFQUFBQSxFQUNOd2tCLEVBQUk3Z0IsRUFBV29ELE9BQU9pVyxFQUFTNWhCLEdBQ25DLElBQUssSUFBSXVDLEVBQUksRUFBR0EsRUFBSXZDLElBQUt1QyxFQUFHLENBQ3hCLE1BQU04bUIsRUFBTUQsRUFBRTdtQixHQUNSaWxCLEVBQU1obUIsRUFBRTZuQixHQUNkLElBQUssSUFBSXJLLEVBQUksRUFBR0EsRUFBSWhmLElBQUtnZixFQUFHLENBQ3hCLEdBQUlBLElBQU16YyxFQUFHLFNBQ2IsTUFBTXVsQixFQUFNdG1CLEVBQUU0bkIsRUFBRXBLLElBQ2hCa0ssRUFBRzNtQixJQUFNTyxLQUFLd2xCLGNBQWMvbEIsRUFBR3ljLEVBQUd3SSxFQUFLTSxHQUV2Q29CLEVBQUczbUIsR0FBSzRtQixJQUNSQSxFQUFNRCxFQUFHM21CO0FBQ1RvbEIsRUFBUTVtQixLQUFLc29CO2dCQUlyQjtJQUFLLElBQUlqcEIsRUFBSSxFQUFHQSxFQUFJMGxCLElBQUsxbEIsRUFBRyxDQUN4QixJQUFJMm5CLEVBQVVuakIsRUFBQUEsRUFDZHdrQixFQUFJN2dCLEVBQVdvRCxPQUFPaVcsRUFBUTNGLFFBQU85TyxHQUFTd2EsRUFBUU0sV0FBVXBmLEdBQUtBLElBQU1zRSxJQUFTLElBQUluTixHQUN4RixJQUFLLElBQUl1QyxFQUFJLEVBQUdBLEVBQUl2QyxJQUFLdUMsRUFBRyxDQUN4QixJQUFJNmxCLEVBQVUsRUFDZCxNQUFNaUIsRUFBTUQsRUFBRTdtQixHQUNSaWxCLEVBQU1obUIsRUFBRTZuQixHQUNkLElBQUssSUFBSXJLLEVBQUksRUFBR0EsRUFBSWhmLElBQUtnZixFQUFHLENBQ3hCLEdBQUlBLElBQU16YyxFQUFHLFNBQ2IsTUFBTSttQixFQUFNRixFQUFFcEssR0FDUjhJLEVBQU10bUIsRUFBRThuQixHQUNkLElBQUlDLEVBQVF6bUIsS0FBS3dsQixjQUFjZSxFQUFLQyxFQUFLOUIsRUFBS00sR0FBTzNmLElBQUl3ZixFQUFRdmxCLEtBQUlvQixHQUFLVixLQUFLd2xCLGNBQWNnQixFQUFLOWxCLEVBQUdza0IsTUFDakd5QixFQUFRLElBQ1JuQixHQUFvQm1CO2lCQUl4Qm5CO0VBQVVMLElBQ1ZBLEVBQVVLLEVBQ1ZULEVBQVE1bUIsS0FBS3NvQixJQUdyQkYsR0FBT3BCLEVBRVgsT0FBT0osRUFBUWxsQixNQUFNLEVBQUdxakI7Ozs7R0NqVHpCLE1BQU0wRDs7Ozs7Ozs7Ozs7Ozs7O0FBZVQ3bUIsWUFBWXNnQixFQUFRbk0sRUFBUzJTLEVBQVk5bkIsRUFBU0MsV0FVOUMsT0FUQWtCLEtBQUtzZ0IsUUFBVUgsRUFDZm5nQixLQUFLMFYsU0FBVzFCLEVBQ2hCaFUsS0FBSzRtQixZQUFjRCxFQUNuQjNtQixLQUFLeU0sUUFBVTVOLEVBRWZtQixLQUFLNm1CLGNBQWdCLEdBQ3JCN21CLEtBQUttaEIsVUFBWSxHQUNqQm5oQixLQUFLOG1CLElBQU0sSUFBSXBwQixNQUFNeWlCLEVBQU9uaEIsTUFBTSxJQUFJMEksT0FDdEMxSCxLQUFLMFAsT0FDRTFQOzs7T0FNWDBQLE9BQ0ksTUFBTXFYLEVBQWUvbUIsS0FBSzZtQixjQUNwQjFHLEVBQVNuZ0IsS0FBS3NnQixRQUNkcmMsRUFBSWtjLEVBQU9uaEIsTUFBTSxHQUNqQmdvQixFQUFLaG5CLEtBQUs4bUIsSUFDVm5HLEVBQVczZ0IsS0FBS21oQixVQUN0QixJQUFJOEYsRUFBZ0JqbkIsS0FBS2tuQixlQUFpQixFQUUxQyxJQUFLLElBQUk1cEIsRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQ3JCMHBCLEVBQUcxcEIsR0FBSyxDQUNKd00sUUFBV3FXLEVBQU8vZ0IsSUFBSTlCLEdBQ3RCK00sTUFBUy9NLEVBQ1Q2cEIsMkJBQXlCaGUsRUFDekJpZSxXQUFhLEdBR3JCLElBQUssTUFBTXBhLEtBQUtnYSxFQUNaLElBQUloYSxFQUFFb2EsWUFDTnBhLEVBQUVnRSxVQUFZaFIsS0FBS3FuQixlQUFlcmEsR0FDbENBLEVBQUVvYSxXQUFZLEVBQ2R6RyxFQUFTMWlCLEtBQUssQ0FBQytPLEVBQUUzQyxRQUNqQjRjLEVBQWdCdEcsRUFBU3hqQixPQUFTLEVBQ2xDNHBCLEVBQWE5b0IsS0FBSytPLEdBQ1k3RCxNQUExQm5KLEtBQUtzbkIsZUFBZXRhLElBQWlCLENBQ3JDLE1BQU11YSxFQUFRLElBQUluZSxLQUFLLE1BQU1yRCxHQUFLQSxFQUFFb2hCLHVCQUF1QixPQUMzRG5uQixLQUFLd25CLFFBQVF4YSxFQUFHdWEsR0FDaEJ2bkIsS0FBS3luQixnQkFBZ0JGLEVBQU81RyxFQUFTc0csSUFHN0MsT0FBT2puQjs7Ozs7O09BU1hxbkIsZUFBZXJhLEdBQ1gsR0FBSSxjQUFlQSxFQUFHLE9BQU9BLEVBQUVnRSxVQUMvQixNQUFNZ1csRUFBS2huQixLQUFLOG1CLElBQ1Zqb0IsRUFBU21CLEtBQUt5TSxRQUNkdUgsRUFBVWhVLEtBQUswVixTQUNmMUUsRUFBWSxHQUNsQixJQUFLLE1BQU0vQyxLQUFLK1ksRUFDUi9ZLEVBQUU1RCxPQUFTMkMsRUFBRTNDLE9BQ2J4TCxFQUFPbU8sRUFBRWxELFFBQVNtRSxFQUFFbkUsU0FBV2tLLEdBQy9CaEQsRUFBVS9TLEtBQUtnUSxHQUd2QixPQUFPK0M7Ozs7OztPQVNYc1csZUFBZXRhLEdBQ1gsTUFBTTJaLEVBQWEzbUIsS0FBSzRtQixZQUNsQi9uQixFQUFTbUIsS0FBS3lNLFFBQ3BCLEtBQUlPLEVBQUVnRSxXQUFhaEUsRUFBRWdFLFVBQVU3VCxRQUFVd3BCLEdBR3pDLE9BQU85bkIsRUFBT21PLEVBQUVsRCxRQUFTa0QsRUFBRWdFLFVBQVUyVixHQUFZN2M7Ozs7OztPQVNyRDBkLFFBQVF4YSxFQUFHdWEsR0FDUCxNQUFNMW9CLEVBQVNtQixLQUFLeU0sUUFDZGliLEVBQWdCMW5CLEtBQUtzbkIsZUFBZXRhLEdBQ3BDZ0UsRUFBWWhSLEtBQUtxbkIsZUFBZXJhO0FBQ3RDLElBQUssTUFBTWlCLEtBQUsrQyxFQUFXLENBQ3ZCLEdBQUkvQyxFQUFFbVosVUFBVyxTQUNqQixNQUFNTyxFQUE0Qi9xQixLQUFLc0IsSUFBSXdwQixFQUFlN29CLEVBQU9tTyxFQUFFbEQsUUFBU21FLEVBQUVuRTtrRUFFMUV5ZDtFQUFNdmMsV0FBV21hLFdBQVVwZixHQUFLQSxFQUFFK0QsU0FBV21FLElBQUssR0FDbERBLEVBQUVrWixzQkFBd0JRLEVBQzFCSixFQUFNdHBCLEtBQUtnUTtBQUVQMFosRUFBNEIxWixFQUFFa1osd0JBQzlCbFosRUFBRWtaLHNCQUF3QlEsRUFDMUJKLEVBQVFuZSxLQUFLSSxRQUFRK2QsRUFBTTNtQixRQUFRbUYsR0FBS0EsRUFBRW9oQix1QkFBdUI7Ozs7OztPQVlqRk0sZ0JBQWdCRixFQUFPSyxHQUNuQixNQUFNYixFQUFlL21CLEtBQUs2bUIsY0FDMUIsTUFBUVUsRUFBTXRjLE9BQU8sQ0FDakIsTUFBTWdELEVBQUlzWixFQUFNNWMsTUFBTWIsUUFDdEJtRSxFQUFFK0MsVUFBWWhSLEtBQUtxbkIsZUFBZXBaLEdBQ2xDQSxFQUFFbVosV0FBWSxFQUNkUSxFQUFRM3BCLEtBQUtnUSxFQUFFNUQsT0FDZjBjLEVBQWE5b0IsS0FBS2dRLEdBQ1k5RSxNQUExQm5KLEtBQUtzbkIsZUFBZXJaLEtBQ3BCak8sS0FBS3duQixRQUFRdlosRUFBR3NaLEdBQ2hCdm5CLEtBQUt5bkIsZ0JBQWdCRixFQUFPSzs7OztPQVN4Q2xILGVBQ0ksTUFBTUMsRUFBVyxHQUNYa0gsRUFBVyxHQUNYbEIsRUFBYTNtQixLQUFLNG1CLFlBQ3hCLElBQUssTUFBTWdCLEtBQVc1bkIsS0FBS21oQixVQUNuQnlHLEVBQVF6cUIsT0FBU3dwQixFQUNqQmtCLEVBQVM1cEIsUUFBUTJwQixHQUVqQmpILEVBQVMxaUIsS0FBSzJwQixHQUl0QixPQURBakgsRUFBUzFpQixLQUFLNHBCLEdBQ1BsSDs7O09BTVhtSCwwQkFDSSxNQUFNN2pCLEVBQUlqRSxLQUFLc2dCLFFBQVF0aEIsTUFBTSxHQUN2QmlHLEVBQVMsSUFBSXZILE1BQU11RyxHQUFHeUQsT0FDdEJpWixFQUFXM2dCLEtBQUswZ0IsZUFDdEIsSUFBSyxJQUFJcGpCLEVBQUksRUFBR0osRUFBSXlqQixFQUFTeGpCLE9BQVFHLEVBQUlKLElBQUtJLEVBQUcsQ0FDN0MsTUFBTXNxQixFQUFVakgsRUFBU3JqQixHQUN6QixJQUFLLE1BQU0rTSxLQUFTdWQsRUFDaEIzaUIsRUFBT29GLEdBQVUvTSxFQUFJSixFQUFJLEVBQUtJLEdBQUssRUFHM0MsT0FBTzJIOzs7OztHQzlLUixNQUFNOGlCLFlBQVlwWjs7Ozs7Ozs7Ozs7Ozs7QUFjckI5TyxZQUFZc0QsRUFBR3hFLEVBQUdxcEIsRUFBZ0JqaUIsRUFBRSxFQUFHbEgsRUFBT0MsVUFBV3FKLEVBQUssTUFNMUQsT0FMQTZILE1BQU03TSxFQUFHNEMsRUFBR2xILEVBQVFzSixHQUNwQjZILE1BQU1wQixlQUFpQixDQUFDLElBQUssa0JBQzdCNU8sS0FBS2tQLFVBQVUsSUFBS3RTLEtBQUt5SSxJQUFJMUcsR0FBSy9CLEtBQUtzQixJQUFJdEIsS0FBS21OLE1BQU0vSixLQUFLNEgsR0FBSyxJQUFLLEdBQUk1SCxLQUFLNEgsR0FBSyxJQUNuRjVILEtBQUtrUCxVQUFVLGlCQUFrQnRTLEtBQUt5SSxJQUFJMmlCLEdBQWtCcHJCLEtBQUt1cEIsS0FBS3ZwQixLQUFLQyxLQUFLbUQsS0FBSzRILEtBQU01SCxLQUFLNEgsR0FBSyxJQUNyRzVILEtBQUtpUCxpQkFBa0IsRUFDaEJqUDs7Ozs7O09BU1gwUCxLQUFLZixFQUFHeUIsSUFBSzZYLEVBQWMsR0FBSXphLEVBQUl2QixVQUMvQixHQUFJak0sS0FBS2lQLGdCQUFpQixPQUFPalAsS0FDakMsTUFBTW1ELEVBQUluRCxLQUFLbUQsRUFDVGMsRUFBSWpFLEtBQUs0SCxHQUNUb2IsRUFBSWhqQixLQUFLa1AsVUFBVSxLQUNuQm5KLEVBQUkvRixLQUFLK08sR0FDVGxRLEVBQVNtQixLQUFLeU0sUUFDZHliLEVBQUtsb0IsS0FBS2tQLFVBQVUsa0JBQ3BCOFksRUFBaUIsSUFBSTVELFNBQVNqaEIsRUFBRytrQixFQUFJLEtBQU1ycEIsR0FBUTZoQixlQUFlbUUsUUFDbEVuaUIsRUFBSSxJQUFJOUMsT0FBT3NvQixFQUFJamtCLEVBQUcsU0FDNUIrakIsRUFBZWhjLFNBQVEsQ0FBQ21jLEVBQUs3cUIsS0FDekJvRixFQUFFcEIsVUFBVWhFLEVBQUc2cUIsRUFBSyxNQUV4QixNQUFNQyxFQUFNLElBQUl6WixFQUFHL08sT0FBT1AsS0FBSzJvQixFQUFlMW9CLEtBQUk2b0IsR0FBT2hsQixFQUFFL0QsSUFBSStvQixTQUFXRixFQUFlbGlCLEdBQUd1SixZQUV0RitZLEVBQUtsbEIsRUFBRTZCLFVBQ1BzVCxFQUFNLElBQUk5SyxFQUFJNmEsRUFBSXhwQixHQUNsQnVILEVBQUksSUFBSXhHLE9BQU9xRSxFQUFHQSxFQUFHLEtBQ3JCZ0MsR0FBUyxFQUFFK2MsRUFDakJxRixFQUFHcmMsU0FBUSxDQUFDNk0sRUFBS3ZiLEtBQ2IsSUFBSyxNQUFPK00sTUFBUzVLLEtBQU02WSxFQUFJakwsT0FBT3dMLEVBQUttSyxHQUFHbFksVUFDdEN4TixJQUFNbUMsR0FDVjJHLEVBQUU5RSxVQUFVaEUsRUFBR21DLEVBQUd3RyxNQUcxQixNQUFNdkgsRUFBSTBILEVBQUV0RCxPQUFPSixFQUFHLFlBR2hCL0YsRUFESSxJQUFJaUQsT0FBT3FFLEVBQUc4QixFQUFHLFNBQ2ZqRCxPQUFPc2xCLEVBQUssWUFLeEIsT0FIQXBvQixLQUFLcWtCLEdBQUszbEIsRUFDVnNCLEtBQUt5YSxHQUFLOWQsRUFDVnFELEtBQUtpUCxpQkFBa0IsRUFDaEJqUDs7OztPQVFYc1AsWUFDSXRQLEtBQUt1UCxhQUNMLE1BQU03USxFQUFJc0IsS0FBS3FrQixHQUNUaUUsRUFBSzVwQixFQUFFOEMsRUFDUDdFLEVBQUlxRCxLQUFLeWEsR0FDVDhOLEVBQU1ELEVBQUdqbUIsSUFBSTNELEdBQ2I4cEIsRUFBTUYsRUFBR2ptQixJQUFJMUYsR0FFbkIsT0FEQXFELEtBQUsyUCxFQUFJL1AsT0FBTzBULFNBQVNpVixFQUFLQyxFQUFLeG9CLEtBQUtnUCxhQUNqQ2hQLEtBQUt3UDs7Ozs7O0dDOUViLE1BQU1pWixnQkFBZ0I5Wjs7Ozs7Ozs7Ozs7OztBQWF6QjlPLFlBQVlzRCxFQUFHNEMsRUFBSSxFQUFHbEgsRUFBU0MsVUFBV3FKLEVBQU8sTUFLN0MsT0FKQTZILE1BQU03TSxFQUFHNEMsRUFBR2xILEVBQVFzSixHQUNwQjZILE1BQU1wQixlQUFpQixJQUN0QjVPLEtBQUs0SCxHQUFJNUgsS0FBSzBOLElBQU0xTixLQUFLbUQsRUFBRW5FLE1BQzVCZ0IsS0FBS2toQixpQkFBbUIsSUFBSXRoQixPQUFPSSxLQUFLNEgsR0FBSTVILEtBQUs0SCxHQUFJLEdBQzlDNUg7OztPQU1YMG9CLHVCQUF1QnByQixFQUFHbUMsRUFBR1osR0FDekIsTUFBTUksRUFBSWUsS0FBS2toQixpQkFDVC9kLEVBQUluRCxLQUFLbUQsRUFDVHdsQixFQUFPMXBCLEVBQUVvQyxNQUFNL0QsRUFBR21DLEdBQ3hCLEdBQWEsSUFBVGtwQixFQUFZLENBQ1osSUFBSXZoQixFQUFPdkksRUFBT3NFLEVBQUUvRCxJQUFJOUIsR0FBSTZGLEVBQUUvRCxJQUFJSyxJQUdsQyxPQUZBUixFQUFFcUMsVUFBVWhFLEVBQUdtQyxFQUFHMkgsR0FDbEJuSSxFQUFFcUMsVUFBVTdCLEVBQUduQyxFQUFHOEosR0FDWEEsRUFFWCxPQUFPdWhCOzs7Ozs7T0FTWEMsNEJBQTRCL3BCLEVBQVNDLFdBQ2pDLE1BQU1tRixFQUFJakUsS0FBSzRILEdBQ1R6RSxFQUFJLElBQUluRCxLQUFLbUQsR0FFbkIsSUFBSTBsQixFQUFlLElBQUkzZCxZQUFZL0gsR0FDbkMsTUFBTTJsQixFQUFJLEdBQ1YsSUFBSUMsRUFBSSxHQUNSLElBQUssSUFBSXpyQixFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFDckIsSUFBSyxJQUFJbUMsRUFBSW5DLEVBQUksRUFBR21DLEVBQUl3RSxJQUFLeEUsRUFDekJzcEIsRUFBRTlxQixLQUFLLENBQUNYLEVBQUdtQyxFQUFHTyxLQUFLMG9CLHVCQUF1QnByQixFQUFHbUMsRUFBR1osS0FHeERrcUIsRUFBSUEsRUFBRXJwQixNQUFLLENBQUNoRCxFQUFHQyxJQUFNRCxFQUFFLEdBQUtDLEVBQUUsS0FFOUIsSUFBSyxNQUFPcXNCLEVBQUcxa0IsRUFBRytPLEtBQU0wVixFQUFHLENBQ3ZCLE1BQU1FLEVBQVFKLEVBQWFqZCxLQUFLekksRUFBRTZsQixJQUM1QkUsRUFBUUwsRUFBYWpkLEtBQUt6SSxFQUFFbUIsSUFDOUIya0IsSUFBVUMsSUFDVkosRUFBRTdxQixLQUFLLENBQUMrcUIsRUFBRzFrQixFQUFHK08sSUFDZHdWLEVBQWFoZCxNQUFNb2QsRUFBT0MsSUFJbEMsT0FBT0osRUFBRXBwQixNQUFLLENBQUNoRCxFQUFHQyxJQUFNRCxFQUFFLEdBQUtDLEVBQUU7OztPQU1yQytTLE9BSUksT0FIQTFQLEtBQUsyUCxFQUFJLElBQUkvUCxPQUFPSSxLQUFLNEgsR0FBSTVILEtBQUsrTyxHQUFJLEdBQ3RDL08sS0FBS21wQixNQUFRbnBCLEtBQUs0b0IsNEJBQTRCNW9CLEtBQUt5TSxTQUNuRHpNLEtBQUtpUCxpQkFBa0IsRUFDaEJqUDs7Ozs7Ozs7T0FXWG9wQixjQUFjQyxFQUFJQyxJQUFNQyxFQUFJQyxJQUFNQyxFQUFJQyxJQUNsQyxPQUFRSCxFQUFLRixJQUFPSyxFQUFLSixJQUFPRSxFQUFLRixJQUFPRyxFQUFLSixJQUFPOzs7Ozs7O09BVTVETSxPQUFPckQsR0FDSCxNQUFNOVosRUFBUzhaLEVBQUU1bUIsTUFBSyxFQUFFa3FCLEVBQUlDLElBQU1DLEVBQUlDLEtBQVFGLEVBQUtFLEdBQU1ILEVBQUtFLElBQ3hEN2xCLEVBQUl1SSxFQUFPclAsT0FDakIsR0FBSThHLEdBQUssRUFBRyxPQUFPdUksRUFFbkIsTUFBTXdkLEVBQVEsR0FDZCxJQUFLLElBQUkxc0IsRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQUcsQ0FDeEIsS0FBTzBzQixFQUFNN3NCLFFBQVUsR0FBSzZDLEtBQUtvcEIsYUFBYVksRUFBTUEsRUFBTTdzQixPQUFTLEdBQUk2c0IsRUFBTUEsRUFBTTdzQixPQUFTLEdBQUlxUCxFQUFPbFAsS0FDbkcwc0IsRUFBTXJmLE1BRVZxZixFQUFNL3JCLEtBQUt1TyxFQUFPbFAsSUFFdEIsTUFBTTJzQixFQUFRLEdBQ2QsSUFBSyxJQUFJM3NCLEVBQUkyRyxFQUFJLEVBQUczRyxHQUFLLElBQUtBLEVBQUcsQ0FDN0IsS0FBTzJzQixFQUFNOXNCLFFBQVUsR0FBSzZDLEtBQUtvcEIsYUFBYWEsRUFBTUEsRUFBTTlzQixPQUFTLEdBQUk4c0IsRUFBTUEsRUFBTTlzQixPQUFTLEdBQUlxUCxFQUFPbFAsS0FDbkcyc0IsRUFBTXRmLE1BRVZzZixFQUFNaHNCLEtBQUt1TyxFQUFPbFAsSUFJdEIsT0FGQTJzQixFQUFNdGYsTUFDTnFmLEVBQU1yZixNQUNDcWYsRUFBTWxuQixPQUFPbW5COzs7Ozs7O09BVXhCQyxhQUFhQyxFQUFLQyxJQUFPQyxFQUFLQyxJQUMxQixNQUFNcHRCLEVBQUk0QixVQUFVLENBQUNxckIsRUFBS0MsR0FBTSxDQUFDQyxFQUFLQyxJQUN0QyxHQUFVLElBQU5wdEIsRUFDQSxNQUFPLENBQ0hxdEIsSUFBSyxFQUNMQyxJQUFLLEdBRWIsTUFBTUMsRUFBTSxFQUFFSixFQUFNRixHQUFPanRCLEdBQUlvdEIsRUFBTUYsR0FBT2x0QixHQUN0Q3N0QixFQUFNQyxFQUFJLEdBQ2hCLElBQUlGLEVBQU0zdEIsS0FBS0MsS0FBSyxFQUFJMnRCLEVBQU1BLEdBRTlCLE9BREFELEVBQU1FLEVBQUksSUFBTSxHQUFLRixFQUFNQSxFQUNwQixDQUNIQSxJQUFLQSxFQUNMQyxJQUFLQTs7Ozs7O09BVWJFLGFBQWFDLEVBQU0zZCxFQUFHNGQsR0FDbEIsSUFDSUMsRUFjQUMsRUFDQUMsRUFoQkF6bUIsR0FBSyxFQUVULElBQUssSUFBSWhILEVBQUksRUFBR0EsRUFBSXF0QixFQUFLeHRCLFNBQVVHLEVBQUcsQ0FDbEMsTUFBTXlJLEVBQUlqSCxVQUFVNnJCLEVBQUtydEIsR0FBSTBQLEtBQ2xCLElBQVAxSSxHQUlJdW1CLEVBQUs5a0IsS0FIVDhrQixFQUFLOWtCLEVBQ0x6QixFQUFJaEgsR0FXUnN0QixHQUNBRSxFQUFLSCxFQUFLcm1CLEdBQ1Z5bUIsRUFBS0osR0FBTXJtQixFQUFJLEdBQUtxbUIsRUFBS3h0QixVQUVoQixHQUFMbUgsSUFBUUEsRUFBSXFtQixFQUFLeHRCLE9BQVMsR0FDOUIydEIsRUFBS0gsRUFBS3JtQixHQUNWeW1CLEVBQUtKLEdBQU1ybUIsRUFBSSxHQUFLcW1CLEVBQUt4dEIsU0FHN0IsTUFBTTZ0QixFQUFpQixDQUNuQkMsSUFBS04sRUFBS3JtQixHQUFHLEdBQ2I0bUIsSUFBS1AsRUFBS3JtQixHQUFHLElBR2pCLEdBQUlxbUIsRUFBS3h0QixRQUFVLEVBQUcsQ0FDbEIsTUFBTW90QixJQUFFQSxFQUFHQyxJQUFFQSxHQUFReHFCLEtBQUtrcUIsWUFBWVksRUFBSUMsR0FDMUNDLEVBQWVULElBQU1BLEVBQ3JCUyxFQUFlUixJQUFNQSxPQUVyQlEsRUFBZVQsSUFBTSxFQUNyQlMsRUFBZVIsSUFBTSxFQUd6QixPQUFPUTs7Ozs7T0FRWEcsYUFBYUMsRUFBSUMsSUFBS0osR0FBRUEsRUFBRUMsR0FBRUEsRUFBRVgsSUFBRUEsRUFBR0MsSUFBRUEsSUFDakMsSUFBSTdzQixFQUFJeXRCLEVBQUtILEVBQ1RqdUIsRUFBSXF1QixFQUFLSCxFQUdiLE1BQU8sQ0FGRXZ0QixFQUFJNnNCLEVBQU14dEIsRUFBSXV0QixFQUNkNXNCLEVBQUk0c0IsRUFBTXZ0QixFQUFJd3RCOzs7Ozs7O09BVzNCYyxzQkFBc0I1b0IsRUFBR3pGLEVBQUdzdUIsR0FDeEIsTUFBTXRuQixFQUFJdkIsRUFBRXZGLE9BQ1osSUFBSyxJQUFJRyxFQUFJLEVBQUdBLEVBQUkyRyxJQUFLM0csRUFBRyxDQUN4QixNQUFNc1AsRUFBSWxLLEVBQUVwRixJQUNMa3VCLEVBQUlDLEdBQU16ckIsS0FBS21yQixZQUFZdmUsRUFBRzNQLEdBQ3JDMlAsRUFBRSxHQUFLNGUsRUFDUDVlLEVBQUUsR0FBSzZlLEVBQUtGOzs7Ozs7T0FVcEJHLG1CQUFtQjFDLEVBQUcxa0IsRUFBRytPLEdBQ3JCLE1BQU1zWSxFQUFXLElBQUkzQyxFQUFFeGQsZUFBZUUsVUFDaENrZ0IsRUFBVyxJQUFJdG5CLEVBQUVrSCxlQUFlRSxVQUVoQ21nQixFQUFTN3JCLEtBQUsycEIsT0FBT2dDLEdBQ3JCRyxFQUFTOXJCLEtBQUsycEIsT0FBT2lDLEdBRXJCRyxFQUFNL3JCLEtBQUswcUIsYUFBYW1CLEVBQVE3QyxHQUFHLEdBQ25DZ0QsRUFBTWhzQixLQUFLMHFCLGFBQWFvQixFQUFReG5CLEdBQUcsR0FFekN0RSxLQUFLc3JCLHNCQUFzQkssRUFBVUksRUFBSyxHQUMxQy9yQixLQUFLc3JCLHNCQUFzQk0sRUFBVUksRUFBSzNZOzs7T0FNOUMvRCxZQUNTdFAsS0FBS2lQLGlCQUFpQmpQLEtBQUswUCxPQUNoQyxNQUFNdWMsRUFBT2pzQixLQUFLbXBCLE1BQ1p4WixFQUFJLElBQUkzUCxLQUFLMlAsR0FDYnVjLEVBQWEsSUFBSWhoQixZQUNuQnlFLEVBQUVyUSxLQUFJLENBQUN0QyxFQUFHTSxLQUNOTixFQUFFTSxFQUFJQSxFQUNDTixNQUlmLElBQUssTUFBT2dzQixFQUFHMWtCLEVBQUcrTyxLQUFNNFksRUFBTSxDQUMxQixNQUFNRSxFQUFjRCxFQUFXdGdCLEtBQUsrRCxFQUFFcVosSUFDaENvRCxFQUFjRixFQUFXdGdCLEtBQUsrRCxFQUFFckwsSUFDbEM2bkIsSUFBZ0JDLElBQ3BCcHNCLEtBQUswckIsbUJBQW1CUyxFQUFhQyxFQUFhL1ksR0FDbEQ2WSxFQUFXcmdCLE1BQU1zZ0IsRUFBYUMsSUFFbEMsT0FBT3BzQixLQUFLd1AsV0FHaEJDLGFBQ1N6UCxLQUFLaVAsaUJBQWlCalAsS0FBSzBQLE9BQ2hDLE1BQU11YyxFQUFPanNCLEtBQUttcEIsTUFDWnhaLEVBQUksSUFBSTNQLEtBQUsyUCxHQUNidWMsRUFBYSxJQUFJaGhCLFlBQ25CeUUsRUFBRXJRLEtBQUksQ0FBQ3RDLEVBQUdNLEtBQ05OLEVBQUVNLEVBQUlBLEVBQ0NOLE1BSWYsSUFBSyxNQUFPZ3NCLEVBQUcxa0IsRUFBRytPLEtBQU00WSxFQUFNLENBQzFCLE1BQU1FLEVBQWNELEVBQVd0Z0IsS0FBSytELEVBQUVxWixJQUNoQ29ELEVBQWNGLEVBQVd0Z0IsS0FBSytELEVBQUVyTCxJQUNsQzZuQixJQUFnQkMsSUFDcEJwc0IsS0FBSzByQixtQkFBbUJTLEVBQWFDLEVBQWEvWSxHQUNsRDZZLEVBQVdyZ0IsTUFBTXNnQixFQUFhQyxTQU94QnBzQixLQUFLd1AsWUFFZixPQUFPeFAsS0FBS3dQOzs7OztHQ3pTYixNQUFNNmMsZUFBZUM7Ozs7Ozs7Ozs7Ozs7QUFheEJ6c0IsWUFBWXNELEVBQUdvcEIsRUFBTSxHQUFLeG1CLEVBQUUsRUFBR2xILEVBQU9DLFVBQVdxSixFQUFLLE1BS2xELE9BSkE2SCxNQUFNN00sRUFBRzRDLEVBQUdsSCxFQUFRc0osR0FDcEI2SCxNQUFNcEIsZUFBaUIsQ0FBQyxTQUN4QjVPLEtBQUtrUCxVQUFVLFFBQVNxZCxJQUN0QnZzQixLQUFLNEgsR0FBSTVILEtBQUswTixJQUFPMU4sS0FBS21ELEVBQUVuRSxNQUN2QmdCOzs7T0FNWDBQLEtBQUtmLEVBQUcsU0FBVS9QLEVBQWdCLE1BQzlCLE1BQU1xRixFQUFJakUsS0FBSzRILEdBQ1Q3QixFQUFJL0YsS0FBSytPLEdBRWYsR0FBVyxXQUFQSixFQUFpQixDQUNqQixNQUFNbEosRUFBYXpGLEtBQUtnUCxZQUN4QmhQLEtBQUsyUCxFQUFJLElBQUkvUCxPQUFPcUUsRUFBRzhCLEdBQUcsSUFBTU4sRUFBV0ksY0FDcEM4SSxhQUFjMmQsS0FDckJ0c0IsS0FBSzJQLEVBQUloQixFQUFHVyxVQUFVdFAsS0FBS21ELElBRy9CLE9BREFuRCxLQUFLcEIsZ0JBQWtCQSxHQUFtQm9CLEtBQUt3c0Isa0JBQWtCeHNCLEtBQUttRCxHQUMvRG5EOzs7OztPQVFYd3NCLGtCQUFrQjl0QixHQUNkLE1BQU1HLEVBQVNtQixLQUFLeU0sUUFDZHhJLEVBQUl2RixFQUFFTSxNQUFNLEdBQ1pDLEVBQUksSUFBSVcsT0FBT3FFLEVBQUdBLEdBQ3hCLElBQUssSUFBSTNHLEVBQUksRUFBR0EsRUFBSTJHLElBQUszRyxFQUFHLENBQ3hCLE1BQU1rRixFQUFNOUQsRUFBRVUsSUFBSTlCLEdBQ2xCLElBQUssSUFBSW1DLEVBQUluQyxFQUFHbUMsRUFBSXdFLElBQUt4RSxFQUFHLENBQ3hCLElBQUlGLEVBQVlqQyxJQUFNbUMsRUFBSSxFQUFJWixFQUFPMkQsRUFBSzlELEVBQUVVLElBQUlLLElBQ2hEUixFQUFFcUMsVUFBVWhFLEVBQUdtQyxFQUFHRixHQUNsQk4sRUFBRXFDLFVBQVU3QixFQUFHbkMsRUFBR2lDLElBRzFCLE9BQU9OOzs7T0FNWHFRLFVBQVVzSCxFQUFTLEtBQ1Y1VyxLQUFLaVAsaUJBQWlCalAsS0FBSzBQLE9BQ2hDLElBQUssSUFBSWpRLEVBQUksRUFBR0EsRUFBSW1YLElBQVluWCxFQUM1Qk8sS0FBS3lzQixRQUVULE9BQU96c0IsS0FBS3dQLFdBR2hCQyxXQUFZbUgsRUFBUyxLQUNaNVcsS0FBS2lQLGlCQUFpQmpQLEtBQUswUCxPQUVoQyxJQUFLLElBQUlqUSxFQUFJLEVBQUdBLEVBQUltWCxJQUFZblgsRUFDNUJPLEtBQUt5c0IsY0FDQ3pzQixLQUFLd1AsV0FHZixPQUFPeFAsS0FBS3dQLFdBR2hCaWQsUUFDSSxNQUFNQyxFQUFRMXNCLEtBQUtrUCxVQUFVLFNBQ3ZCalEsRUFBSWUsS0FBS3BCLGdCQUNUcUYsRUFBSWpFLEtBQUs0SCxHQUNUN0IsRUFBSS9GLEtBQUsrTyxHQUNUbFEsRUFBU21CLEtBQUt5TSxRQUNwQixJQUFJa0QsRUFBSTNQLEtBQUsyUCxFQUVUd0IsRUFBSSxJQUFJdlIsT0FBT3FFLEVBQUc4QixFQUFHLEdBRXJCM0ksRUFBTSxJQUFJZ0QsYUFBYTJGLEdBQzNCLElBQUssSUFBSXpJLEVBQUksRUFBR0EsRUFBSTJHLElBQUszRyxFQUFHLENBQ3hCLElBQUlxdkIsRUFBSyxJQUFJdnNCLGFBQWEyRixHQUN0QjZtQixFQUFLLElBQUl4c0IsYUFBYTJGLEdBQzFCLE1BQU04bUIsRUFBS2xkLEVBQUV2USxJQUFJOUIsR0FDakIsSUFBSyxJQUFJbUMsRUFBSSxFQUFHQSxFQUFJd0UsSUFBS3hFLEVBQUcsQ0FDeEIsR0FBSW5DLElBQU1tQyxFQUFHLFNBQ2IsTUFBTXF0QixFQUFLbmQsRUFBRXZRLElBQUlLLEdBQ1hnbkIsRUFBUSxJQUFJcm1CLGFBQWEyRixHQUMvQixJQUFLLElBQUlwSCxFQUFJLEVBQUdBLEVBQUlvSCxJQUFLcEgsRUFDckI4bkIsRUFBTTluQixHQUFLa3VCLEVBQUdsdUIsR0FBS211QixFQUFHbnVCLEdBRTFCLE1BQU1vdUIsRUFBS2x1QixFQUFPZ3VCLEVBQUlDLEdBQ2hCRSxFQUFLL3RCLEVBQUVvQyxNQUFNL0QsRUFBR21DLEdBQ2hCd3RCLEVBQUtELEVBQUtELEVBQ1ZHLEVBQUt0d0IsS0FBS3NCLElBQUk4dUIsRUFBS0QsRUFBSSxLQUM3QixJQUFLLElBQUlwdUIsRUFBSSxFQUFHQSxFQUFJb0gsSUFBS3BILEVBQ3JCZ3VCLEVBQUdodUIsSUFBTThuQixFQUFNOW5CLEdBQUtzdUIsRUFBS0MsRUFDekJOLEVBQUdqdUIsS0FBT3N1QixFQUFLcndCLEtBQUtrVSxJQUFJMlYsRUFBTTluQixHQUFJLElBQU0sRUFBSXN1QixFQUFLRixHQUFNQSxHQUFNRyxFQUdyRSxJQUFLLElBQUl2dUIsRUFBSSxFQUFHQSxFQUFJb0gsSUFBS3BILEVBQUcsQ0FDeEIsTUFBTW9ELEVBQU00TixFQUFFdE8sTUFBTS9ELEVBQUdxQixJQUFNK3RCLEVBQVFDLEVBQUdodUIsR0FBSy9CLEtBQUtZLElBQUlvdkIsRUFBR2p1QixLQUFPLEdBQ2hFd1MsRUFBRTdQLFVBQVVoRSxFQUFHcUIsRUFBR29ELEdBQ2xCM0UsRUFBSXVCLElBQU1vRCxHQUdsQixJQUFLLElBQUlwRCxFQUFJLEVBQUdBLEVBQUlvSCxJQUFLcEgsRUFDckJ2QixFQUFJdUIsSUFBTXNGLEVBR2QsSUFBSyxJQUFJM0csRUFBSSxFQUFHQSxFQUFJMkcsSUFBSzNHLEVBQ3JCLElBQUssSUFBSXFCLEVBQUksRUFBR0EsRUFBSW9ILElBQUtwSCxFQUNyQmdSLEVBQUVyTyxVQUFVaEUsRUFBR3FCLEVBQUd3UyxFQUFFOVAsTUFBTS9ELEVBQUdxQixHQUFLdkIsRUFBSXVCLElBRzlDLE9BQU9nUiJ9
