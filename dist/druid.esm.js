// https://renecutura.eu v0.5.1 Copyright 2022 Rene Cutura
/**
 * Computes the euclidean distance (l<sub>2</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias euclidean
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the euclidean distance between {@link a} and {@link b}.
 */
function euclidean(t,e){return Math.sqrt(euclidean_squared(t,e))}
/**
 * Numerical stable summation with the Kahan summation algorithm.
 * @memberof module:numerical
 * @alias kahan_sum
 * @param {Array} summands - Array of values to sum up.
 * @returns {number} The sum.
 * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm}
 */function kahan_sum(t){let e,r,s=t.length,i=0,n=0;for(let o=0;o<s;++o)e=t[o]-n,r=i+e,n=r-i-e,i=r;return i}
/**
 * Numerical stable summation with the Neumair summation algorithm.
 * @memberof module:numerical
 * @alias neumair_sum
 * @param {Array} summands - Array of values to sum up.
 * @returns {number} The sum.
 * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements}
 */function neumair_sum(t){let e=t.length,r=0,s=0;for(let i=0;i<e;++i){let e=t[i],n=r+e;Math.abs(r)>=Math.abs(e)?s+=r-n+e:s+=e-n+r,r=n}return r+s}
/**
 * Computes the squared euclidean distance (l<sub>2</sub><sup>2</sup>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias euclidean_squared
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the squared euclidean distance between {@link a} and {@link b}.
 */function euclidean_squared(t,e){if(t.length!=e.length)return;let r=t.length,s=new Array(r);for(let i=0;i<r;++i){let r=t[i],n=e[i];s[i]=(r-n)*(r-n)}return neumair_sum(s)}
/**
 * Computes the cosine distance (not similarity) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias cosine
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @example
 * druid.cosine([1,0],[1,1]) == 0.7853981633974484 == π/4
 * @returns {Number} The cosine distance between {@link a} and {@link b}.
 */function cosine(t,e){if(t.length!==e.length)return;let r=t.length,s=0,i=0,n=0;for(let o=0;o<r;++o)s+=t[o]*e[o],i+=t[o]*t[o],n+=e[o]*e[o];return Math.acos(s/(Math.sqrt(i)*Math.sqrt(n)))}
/**
 * Computes the manhattan distance (l<sub>1</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias manhattan
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the manhattan distance between {@link a} and {@link b}.
 */function manhattan(t,e){if(t.length!=e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i]);return s}
/**
 * Computes the chebyshev distance (L<sub>∞</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias chebyshev
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the chebyshev distance between {@link a} and {@link b}.
 */function chebyshev(t,e){if(t.length!=e.length)return;let r=t.length,s=[];for(let i=0;i<r;++i)s.push(Math.abs(t[i]-e[i]));return Math.max(...s)}
/**
 * Computes the canberra distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias canberra
 * @param {Array<Number>} a 
 * @param {Array<Number>} b 
 * @returns {Number} The canberra distance between {@link a} and {@link b}.
 * @see {@link https://en.wikipedia.org/wiki/Canberra_distance}
 */function canberra(t,e){if(t.length!==e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i])/(Math.abs(t[i])+Math.abs(e[i]));return s}
/**
 * Computes the jaccard distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias jaccard
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the jaccard distance between {@link a} and {@link b}.
 */function jaccard(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,i=0;for(let n=0;n<r;++n){const r=0!=t[n],o=0!=e[n];s+=r||o,i+=r&&o}return(s-i)/s}
/**
 * Computes the hamming distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias hamming
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the hamming distance between {@link a} and {@link b}.
 */function hamming(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let i=0;i<r;++i){s+=t[i]!=e[i]}return s/r}
/**
 * Computes the Sokal-Michener distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias sokal_michener
 * @param {Array<Number>} a 
 * @param {Array<Number>} b 
 * @returns {Number} the Sokal-Michener distance between {@link a} and {@link b}.  
 */function sokal_michener(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let i=0;i<r;++i){s+=0!=t[i]!=(0!=e[i])}return 2*s/(r+s)}
/**
 * Computes the yule distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias yule
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the yule distance between {@link a} and {@link b}.
 */function yule(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,i=0,n=0;for(let o=0;o<r;++o){const r=0!=t[o],a=0!=e[o];s+=r&&a,i+=r&&!a,n+=!r&&r}return 0==i||0==n?0:2*i*n/(s*(r-s-i-n)+i*n)}
/**
 * Computes the k-nearest neighbors of each row of {@link A}.
 * @memberof module:matrix
 * @alias k_nearest_neigbhors
 * @param {Matrix} A - Either the data matrix, or a distance matrix.
 * @param {Number} k - The number of neighbors to compute.
 * @param {Function|"precomputed"} [metric=euclidean]
 * @returns {Array<Object>} -
 */function k_nearest_neighbors(t,e,r=euclidean){const s=t.shape[0];let i="precomputed"==r?t:distance_matrix(t,r),n=new Array(s);for(let t=0;t<s;++t)n[t]=Array.from(i.row(t)).map(((e,r)=>({i:t,j:r,distance:e}))).sort(((t,e)=>t.distance-e.distance)).slice(1,e+1);return n}
/**
 * Computes the distance matrix of datamatrix {@link A}.
 * @memberof module:matrix
 * @alias distance_matrix
 * @param {Matrix} A - Matrix.
 * @param {Function} [metric=euclidean] - The diistance metric.
 * @returns {Matrix} D - The distance matrix of {@link A}.
 */function distance_matrix(t,e=euclidean){let r=t.shape[0];const s=new Matrix(r,r);for(let i=0;i<r;++i){const n=t.row(i);for(let o=i+1;o<r;++o){const r=e(n,t.row(o));s.set_entry(i,o,r),s.set_entry(o,i,r)}}return s}
/**
 * Creates an Array containing {@link number} numbers from {@link start} to {@link end}.
 * If <code>{@link number} = null</null>.
 * @memberof module:matrix
 * @alias linspace
 * @param {Number} start - Start value.
 * @param {Number} end - End value.
 * @param {Number} [number = null] - Number of number between {@link start} and {@link end}.
 * @returns {Array} - An array with {@link number} entries, beginning at {@link start} ending at {@link end}.
 */function linspace(t,e,r=null){if(r||(r=Math.max(Math.round(e-t)+1,1)),r<2)return 1===r?[t]:[];let s=new Array(r);for(let i=r-=1;i>=0;--i)s[i]=(i*e+(r-i)*t)/r;return s}
//import { neumair_sum } from "../numerical/index";
/**
 * Computes the norm of a vector, by computing its distance to **0**.
 * @memberof module:matrix
 * @alias norm
 * @param {Matrix|Array<Number>|Float64Array} v - Vector. 
 * @param {Function} [metric = euclidean] - Which metric should be used to compute the norm.
 * @returns {Number} - The norm of {@link v}.
 */function norm(t,e=euclidean){let r=null;if(t instanceof Matrix){let[e,s]=t.shape;if(1===e)r=t.row(0);else{if(1!==s)throw new Error("Matrix must be 1d!");r=t.col(0)}}else r=t;const s=r.length;return e(r,Float64Array.from({length:s},(()=>0)))}
/**
 * Normalizes Vector {@link v}.
 * @memberof module:matrix
 * @alias normalize
 * @param {Array<Number>|Float64Array} v - Vector
 * @param {Function} metric 
 * @returns {Array<Number>|Float64Array} - The normalized vector with length 1.
 */function normalize(t,e=euclidean){const r=norm(t,e);return t.map((t=>t/r))}
/**
 * Computes the QR Decomposition of the Matrix {@link A} using Gram-Schmidt process.
 * @memberof module:linear_algebra
 * @alias qr
 * @param {Matrix} A
 * @returns {{R: Matrix, Q: Matrix}}
 * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_the_Gram%E2%80%93Schmidt_process}
 */function qr_gramschmidt(t){const[e,r]=t.shape,s=new Matrix(e,r,"identity"),i=new Matrix(r,r,0);for(let n=0;n<r;++n){let r=t.col(n);for(let t=0;t<n;++t){const e=s.col(t),o=neumair_sum(e.map(((t,e)=>t*r[e])));i.set_entry(t,n,o),r=r.map(((t,r)=>t-o*e[r]))}const o=norm(r,euclidean);for(let t=0;t<e;++t)s.set_entry(t,n,r[t]/o);i.set_entry(n,n,o)}return{R:i,Q:s}}
/**
 * Computes the QR Decomposition of the Matrix {@link A} with householder transformations.
 * @memberof module:linear_algebra
 * @alias qr_householder
 * @param {Matrix} A
 * @returns {{R: Matrix, Q: Matrix}}
 * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections}
 * @see {@link http://mlwiki.org/index.php/Householder_Transformation}
 */function qr_householder(t){const[e,r]=t.shape,s=new Matrix(e,e,"I"),i=t.clone();for(let t=0;t<r;++t){const e=Matrix.from(i.col(t).slice(t)),r=norm(e),n=e.entry(0,0),o=-Math.sign(n),a=n-o*r,h=e.divide(a).set_entry(0,0,1),l=-o*a/r,_=h.outer(h),c=i.get_block(t,0),u=c.sub(_.dot(c).mult(l)),d=s.get_block(0,t),m=d.sub(d.dot(_).mult(l));i.set_block(t,0,u),s.set_block(0,t,m)}return{R:i,Q:s}}
/**
 * Computes the {@link k} biggest Eigenvectors and Eigenvalues from Matrix {@link A} with the QR-Algorithm.
 * @memberof module:linear_algebra
 * @alias simultaneous_poweriteration
 * @param {Matrix} A - The Matrix
 * @param {Number} k - The number of eigenvectors and eigenvalues to compute.
 * @param {Object} parameters - Object containing parameterization of the simultanious poweriteration method.
 * @param {Number} [parameters.max_iterations=100] - The number of maxiumum iterations the algorithm should run.
 * @param {Number|Randomizer} [parameters.seed=1212] - The seed value or a randomizer used in the algorithm.
 * @param {Function} [parameters.qr=qr_gramschmidt] - The QR technique to use.
 * @param {Number} [parameters.tol=1e-8] - Allowed error for stopping criteria
 * @returns {{eigenvalues: Array, eigenvectors: Array}} - The {@link k} biggest eigenvectors and eigenvalues of Matrix {@link A}.
 */function simultaneous_poweriteration(t,e=2,{seed:r=1212,max_iterations:s=100,qr:i=qr_gramschmidt,tol:n=1e-8}={}){const o=r instanceof Randomizer?r:new Randomizer(r);t instanceof Matrix||(t=Matrix.from(t));const a=t.shape[0];let{Q:h,R:l}=i(new Matrix(a,e,(()=>2*(o.random-.5))));for(;s--;){const e=h.clone(),r=i(t.dot(h));h=r.Q,l=r.R;if(euclidean_squared(h.values,e.values)<n)break}return{eigenvalues:l.diag,eigenvectors:h.transpose().to2dArray}}
/**
 * Computes the inner product between two arrays of the same length.
 * @memberof module:linear_algebra
 * @alias inner_product
 * @param {Array|Float64Array} a - Array a
 * @param {Array|Float64Array} b - Array b
 * @returns The inner product between {@link a} and {@link b}
 */function inner_product(t,e){const r=t.length;if(r!=e.length)throw new Error("Array a and b must have the same length!");let s=0;for(let i=0;i<r;++i)s+=t*e;return s}
/**
 * @class
 * @alias Matrix
 * @requires module:numerical/neumair_sum
 */class Matrix{
/**
     * creates a new Matrix. Entries are stored in a Float64Array.
     * @constructor
     * @memberof module:matrix
     * @alias Matrix
     * @param {number} rows - The amount of rows of the matrix.
     * @param {number} cols - The amount of columns of the matrix.
     * @param {(function|string|number)} value=0 - Can be a function with row and col as parameters, a number, or "zeros", "identity" or "I", or "center".
     *  - **function**: for each entry the function gets called with the parameters for the actual row and column.
     *  - **string**: allowed are
     *      - "zero", creates a zero matrix.
     *      - "identity" or "I", creates an identity matrix.
     *      - "center", creates an center matrix.
     *  - **number**: create a matrix filled with the given value.
     * @example
     *
     * let A = new Matrix(10, 10, () => Math.random()); //creates a 10 times 10 random matrix.
     * let B = new Matrix(3, 3, "I"); // creates a 3 times 3 identity matrix.
     * @returns {Matrix} returns a {@link rows} times {@link cols} Matrix filled with {@link value}.
     */
constructor(t=null,e=null,r=null){if(this._rows=t,this._cols=e,this._data=null,t&&e){if(!r)return this._data=new Float64Array(t*e),this;if("function"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}if("string"==typeof r){if("zeros"===r)return new Matrix(t,e,0);if("identity"===r||"I"===r){this._data=new Float64Array(t*e);for(let r=0;r<t;++r)this._data[r*e+r]=1;return this}if("center"===r&&t==e){this._data=new Float64Array(t*e),r=(e,r)=>(e===r?1:0)-1/t;for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}}if("number"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r;return this}}return this}
/**
     * Creates a Matrix out of {@link A}.
     * @param {(Matrix|Array|Float64Array|number)} A - The matrix, array, or number, which should converted to a Matrix.
     * @param {"row"|"col"|"diag"} [type = "row"] - If {@link A} is a Array or Float64Array, then type defines if it is a row- or a column vector.
     * @returns {Matrix}
     *
     * @example
     * let A = Matrix.from([[1, 0], [0, 1]]); //creates a two by two identity matrix.
     * let S = Matrix.from([1, 2, 3], "diag"); // creates a 3 by 3 matrix with 1, 2, 3 on its diagonal. [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
     */static from(t,e="row"){if(t instanceof Matrix)return t.clone();if(!(Array.isArray(t)||t instanceof Float64Array)){if("number"==typeof t)return new Matrix(1,1,t);throw new Error("error")}{let r=t.length;if(0===r)throw new Error("Array is empty");
// 1d
if(!(Array.isArray(t[0])||t[0]instanceof Float64Array)){if("row"===e)return new Matrix(1,r,((e,r)=>t[r]));
// 2d
if("col"===e)return new Matrix(r,1,(e=>t[e]));if("diag"===e)return new Matrix(r,r,((e,r)=>e==r?t[e]:0));throw new Error("1d array has NaN entries")}if(Array.isArray(t[0])||t[0]instanceof Float64Array){let e=t[0].length;for(let s=0;s<r;++s)if(t[s].length!==e)throw new Error("various array lengths");return new Matrix(r,e,((e,r)=>t[e][r]))}}}
/**
     * Returns the {@link row}<sup>th</sup> row from the Matrix.
     * @param {Number} row
     * @returns {Float64Array}
     */row(t){const e=this.values,r=this._cols;return e.subarray(t*r,(t+1)*r)}
/**
     * Returns an generator yielding each row of the Matrix.
     * @yields {Float64Array}
     */*iterate_rows(){const t=this._cols,e=this._rows,r=this.values;for(let s=0;s<e;++s)yield r.subarray(s*t,(s+1)*t)}
/**
     * Makes a {@link Matrix} object an iterable object.
     * @yields {Float64Array}
     */*[Symbol.iterator](){for(const t of this.iterate_rows())yield t}
/**
     * Sets the entries of {@link row}<sup>th</sup> row from the Matrix to the entries from {@link values}.
     * @param {int} row
     * @param {Array} values
     * @returns {Matrix}
     */set_row(t,e){let r=this._cols;if(Array.isArray(e)&&e.length===r){let s=t*r;for(let t=0;t<r;++t)this.values[s+t]=e[t]}else if(e instanceof Matrix&&e.shape[1]===r&&1===e.shape[0]){let s=t*r;for(let t=0;t<r;++t)this.values[s+t]=e._data[t]}return this}
/**
     * Returns the {@link col}<sup>th</sup> column from the Matrix.
     * @param {int} col
     * @returns {Array}
     */col(t){let e=new Float64Array(this._rows);for(let r=0;r<this._rows;++r)e[r]=this.values[r*this._cols+t];return e}
/**
     * Returns the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix.
     * @param {int} row
     * @param {int} col
     * @returns {float64}
     */entry(t,e){return this.values[t*this._cols+e]}
/**
     * Sets the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix to the given {@link value}.
     * @param {int} row
     * @param {int} col
     * @param {float64} value
     * @returns {Matrix}
     */set_entry(t,e,r){return this.values[t*this._cols+e]=r,this}
/**
     * Returns a new transposed Matrix.
     * @returns {Matrix}
     */transpose(){return new Matrix(this._cols,this._rows,((t,e)=>this.entry(e,t)))}
/**
     * Returns a new transposed Matrix. Short-form of {@function transpose}.
     * @returns {Matrix}
     */get T(){return this.transpose()}
/**
     * Returns the inverse of the Matrix.
     * @returns {Matrix}
     */inverse(){const t=this._rows,e=this._cols;let r=new Matrix(t,2*e,((t,r)=>r>=e?t===r-e?1:0:this.entry(t,r))),s=0,i=0;for(;s<t&&i<e;){var n=0;let o=-1/0;for(let e=s;e<t;++e){let t=Math.abs(r.entry(e,i));o<t&&(n=e,o=t)}if(0==r.entry(n,i))i++;else{
// swap rows
for(let t=0;t<2*e;++t){let e=r.entry(s,t),i=r.entry(n,t);r.set_entry(s,t,e),r.set_entry(n,t,i)}for(let n=s+1;n<t;++n){let t=r.entry(n,i)/r.entry(s,i);r.set_entry(n,i,0);for(let o=i+1;o<2*e;++o)r.set_entry(n,o,r.entry(n,o)-r.entry(s,o)*t)}s++,i++}}for(let s=0;s<t;++s){let t=r.entry(s,s);for(let i=s;i<2*e;++i)r.set_entry(s,i,r.entry(s,i)/t)}for(let s=t-1;s>=0;--s){let t=r.entry(s,s);for(let i=0;i<s;i++){let n=r.entry(i,s)/t;for(let t=i;t<2*e;++t){let e=r.entry(i,t);e-=r.entry(s,t)*n,r.set_entry(i,t,e)}}}return new Matrix(t,e,((t,s)=>r.entry(t,s+e)))}
/**
     * Returns the dot product. If {@link B} is an Array or Float64Array then an Array gets returned. If {@link B} is a Matrix then a Matrix gets returned.
     * @param {(Matrix|Array|Float64Array)} B the right side
     * @returns {(Matrix|Array)}
     */dot(t){if(t instanceof Matrix){let e=this;if(e.shape[1]!==t.shape[0])throw new Error(`A.dot(B): A is a ${e.shape.join(" ⨯ ")}-Matrix, B is a ${t.shape.join(" ⨯ ")}-Matrix: \n                A has ${e.shape[1]} cols and B ${t.shape[0]} rows. \n                Must be equal!`);let r=e.shape[1];return new Matrix(e.shape[0],t.shape[1],((s,i)=>{const n=e.row(s),o=t.col(i);let a=0;for(let t=0;t<r;++t)a+=n[t]*o[t];return a}))}if(Array.isArray(t)||t instanceof Float64Array){let e=this._rows;if(t.length!==e)throw new Error(`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`);let r=new Array(e);for(let s=0;s<e;++s)r[s]=neumair_sum(this.row(s).map((e=>e*t[s])));return r}throw new Error("B must be Matrix or Array")}
/**
     * Computes the outer product from {@link this} and {@link B}.
     * @param {Matrix} B
     * @returns {Matrix}
     */outer(t){let e=this,r=e._data.length;if(r!=t._data.length)return;let s=new Matrix;return s.shape=[r,r,(r,i)=>r<=i?e._data[r]*t._data[i]:s.entry(i,r)],s}
/**
     * Appends matrix {@link B} to the matrix.
     * @param {Matrix} B - matrix to append.
     * @param {"horizontal"|"vertical"|"diag"} [type = "horizontal"] - type of concatenation.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 1], [1, 1]]); // 2 by 2 matrix filled with ones.
     * let B = Matrix.from([[2, 2], [2, 2]]); // 2 by 2 matrix filled with twos.
     *
     * A.concat(B, "horizontal"); // 2 by 4 matrix. [[1, 1, 2, 2], [1, 1, 2, 2]]
     * A.concat(B, "vertical"); // 4 by 2 matrix. [[1, 1], [1, 1], [2, 2], [2, 2]]
     * A.concat(B, "diag"); // 4 by 4 matrix. [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 2, 2], [0, 0, 2, 2]]
     */concat(t,e="horizontal"){const r=this,[s,i]=r.shape,[n,o]=t.shape;if("horizontal"==e){if(s!=n)throw new Error(`A.concat(B, "horizontal"): A and B need same number of rows, A has ${s} rows, B has ${n} rows.`);const e=new Matrix(s,i+o,"zeros");return e.set_block(0,0,r),e.set_block(0,i,t),e}if("vertical"==e){if(i!=o)throw new Error(`A.concat(B, "vertical"): A and B need same number of columns, A has ${i} columns, B has ${o} columns.`);const e=new Matrix(s+n,i,"zeros");return e.set_block(0,0,r),e.set_block(s,0,t),e}if("diag"==e){const e=new Matrix(s+n,i+o,"zeros");return e.set_block(0,0,r),e.set_block(s,i,t),e}throw new Error(`type must be "horizontal" or "vertical", but type is ${e}!`)}
/**
     * Writes the entries of B in A at an offset position given by {@link offset_row} and {@link offset_col}.
     * @param {int} offset_row
     * @param {int} offset_col
     * @param {Matrix} B
     * @returns {Matrix}
     */set_block(t,e,r){let[s,i]=r.shape;for(let n=0;n<s;++n)if(!(n>this._rows))for(let s=0;s<i;++s)s>this._cols||this.set_entry(n+t,s+e,r.entry(n,s));return this}
/**
     * Extracts the entries from the {@link start_row}<sup>th</sup> row to the {@link end_row}<sup>th</sup> row, the {@link start_col}<sup>th</sup> column to the {@link end_col}<sup>th</sup> column of the matrix.
     * If {@link end_row} or {@link end_col} is empty, the respective value is set to {@link this.rows} or {@link this.cols}.
     * @param {Number} start_row
     * @param {Number} start_col
     * @param {Number} [end_row = null]
     * @param {Number} [end_col = null]
     * @returns {Matrix} Returns a end_row - start_row times end_col - start_col matrix, with respective entries from the matrix.
     * @example
     *
     * let A = Matrix.from([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); // a 3 by 3 matrix.
     *
     * A.get_block(1, 1); // [[5, 6], [8, 9]]
     * A.get_block(0, 0, 1, 1); // [[1]]
     * A.get_block(1, 1, 2, 2); // [[5]]
     * A.get_block(0, 0, 2, 2); // [[1, 2], [4, 5]]
     */get_block(t,e,r=null,s=null){const[i,n]=this.shape;if(s=s??n,(r=r??i)<=t||s<=e)throw new Error(`\n                end_row must be greater than start_row, and \n                end_col must be greater than start_col, but\n                end_row = ${r}, start_row = ${t}, end_col = ${s}, and start_col = ${e}!`);const o=new Matrix(r-t,s-e,"zeros");for(let i=t,n=0;i<r;++i,++n)for(let t=e,r=0;t<s;++t,++r)o.set_entry(n,r,this.entry(i,t));return o;
//return new Matrix(end_row - start_row, end_col - start_col, (i, j) => this.entry(i + start_row, j + start_col));
}
/**
     * Returns a new array gathering entries defined by the indices given by argument.
     * @param {Array<Number>} row_indices - Array consists of indices of rows for gathering entries of this matrix
     * @param {Array<Number>} col_indices  - Array consists of indices of cols for gathering entries of this matrix
     * @returns {Matrix}
     */gather(t,e){const r=t.length,s=e.length,i=new Matrix(r,s);for(let s=0;s<r;++s){const n=t[s];for(let t=0;t<r;++t){const r=e[t];i.set_entry(s,t,this.entry(n,r))}}return i}
/**
     * Applies a function to each entry of the matrix.
     * @private
     * @param {function} f function takes 2 parameters, the value of the actual entry and a value given by the function {@link v}. The result of {@link f} gets writen to the Matrix.
     * @param {function} v function takes 2 parameters for row and col, and returns a value witch should be applied to the colth entry of the rowth row of the matrix.
     */_apply_array(t,e){const r=this.values,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o;r[i]=t(r[i],e(n,o))}}return this}_apply_rowwise_array(t,e){return this._apply_array(e,((e,r)=>t[r]))}_apply_colwise_array(t,e){const r=this.values,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o;r[i]=e(r[i],t[n])}}return this}_apply(t,e){let r=this.values;if(t instanceof Matrix){let[s,i]=t.shape,[n,o]=this.shape;if(1===s){if(o!==i)throw new Error("cols !== value_cols");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(0,i))}else if(1===i){if(n!==s)throw new Error("rows !== value_rows");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,0))}else{if(n!=s||o!=i)throw new Error("error");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,i))}}else if(Array.isArray(t)){let s=this._rows,i=this._cols;if(t.length===s)for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[n]);else{if(t.length!==i)throw new Error("error");for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[s])}}else for(let s=0,i=this._rows*this._cols;s<i;++s)r[s]=e(r[s],t);return this}
/**
     * Clones the Matrix.
     * @returns {Matrix}
     */clone(){let t=new Matrix;return t._rows=this._rows,t._cols=this._cols,t._data=this.values.slice(0),t}
/**
     * Entrywise multiplication with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.mult(2); // [[2, 4], [6, 8]];
     * A.mult(B); // [[1, 4], [9, 16]];
     */mult(t){return this.clone()._apply(t,((t,e)=>t*e))}
/**
     * Entrywise division with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.divide(2); // [[0.5, 1], [1.5, 2]];
     * A.divide(B); // [[1, 1], [1, 1]];
     */divide(t){return this.clone()._apply(t,((t,e)=>t/e))}
/**
     * Entrywise addition with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.add(2); // [[3, 4], [5, 6]];
     * A.add(B); // [[2, 4], [6, 8]];
     */add(t){return this.clone()._apply(t,((t,e)=>t+e))}
/**
     * Entrywise subtraction with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.sub(2); // [[-1, 0], [1, 2]];
     * A.sub(B); // [[0, 0], [0, 0]];
     */sub(t){return this.clone()._apply(t,((t,e)=>t-e))}
/**
     * Returns the number of rows and columns of the Matrix.
     * @returns {Array} An Array in the form [rows, columns].
     */get shape(){return[this._rows,this._cols]}
/**
     * Returns the matrix in the given shape with the given function which returns values for the entries of the matrix.
     * @param {Array} parameter - takes an Array in the form [rows, cols, value], where rows and cols are the number of rows and columns of the matrix, and value is a function which takes two parameters (row and col) which has to return a value for the colth entry of the rowth row.
     * @returns {Matrix}
     */set shape([t,e,r=(()=>0)]){this._rows=t,this._cols=e,this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}
/**
     * Returns the Matrix as a Array of Float64Arrays.
     * @returns {Array<Float64Array>}
     */get to2dArray(){const t=[];for(const e of this.iterate_rows())t.push(e);return t}
/**
     * Returns the Matrix as a Array of Arrays.
     * @returns {Array<Array>}
     */get asArray(){const t=[];for(const e of this.iterate_rows())t.push(Array.from(e));return t}
/**
     * Returns the diagonal of the Matrix.
     * @returns {Float64Array}
     */get diag(){const t=this._rows,e=this._cols,r=Math.min(t,e);let s=new Float64Array(r);for(let t=0;t<r;++t)s[t]=this.entry(t,t);return s}
/**
     * Returns the mean of all entries of the Matrix.
     * @returns {Number}
     */get mean(){return this.sum/(this._rows*this._cols)}
/**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Number}
     */get sum(){return neumair_sum(this.values)}
/**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Float64Array}
     */get values(){return this._data}
/**
     * Returns the mean of each row of the matrix.
     * @returns {Float64Array}
     */get meanRows(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:e});for(let i=0;i<e;++i){s[i]=0;for(let e=0;e<r;++e)s[i]+=t[i*r+e];s[i]/=r}return s}
/** Returns the mean of each column of the matrix.
     * @returns {Float64Array}
     */get meanCols(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:r});for(let i=0;i<r;++i){s[i]=0;for(let n=0;n<e;++n)s[i]+=t[n*r+i];s[i]/=e}return s}
/**
     * Solves the equation {@link A}x = {@link b} using the conjugate gradient method. Returns the result x.
     * @param {Matrix} A - Matrix
     * @param {Matrix} b - Matrix
     * @param {Randomizer} [randomizer=null]
     * @param {Number} [tol=1e-3]
     * @returns {Matrix}
     */static solve_CG(t,e,r,s=.001){null===r&&(r=new Randomizer);const i=t.shape[0],n=e.shape[1];let o=new Matrix(i,0);for(let a=0;a<n;++a){const n=Matrix.from(e.col(a)).T;let h=new Matrix(i,1,(()=>r.random)),l=n.sub(t.dot(h)),_=l.clone();do{const e=t.dot(_),r=l.T.dot(l).entry(0,0)/_.T.dot(e).entry(0,0);h=h.add(_.mult(r));const s=l.sub(e.mult(r)),i=s.T.dot(s).entry(0,0)/l.T.dot(l).entry(0,0);_=s.add(_.mult(i)),l=s}while(Math.abs(l.mean)>s);o=o.concat(h,"horizontal")}return o}
/**
     * Solves the equation {@link A}x = {@link b}. Returns the result x.
     * @param {Matrix} A - Matrix or LU Decomposition
     * @param {Matrix} b - Matrix
     * @returns {Matrix}
     */static solve(t,e){let{L:r,U:s}="L"in t&&"U"in t?t:Matrix.LU(t),i=r.shape[0],n=e.clone();
// forward
for(let t=0;t<i;++t){for(let e=0;e<t-1;++e)n.set_entry(0,t,n.entry(0,t)-r.entry(t,e)*n.entry(1,e));n.set_entry(0,t,n.entry(0,t)/r.entry(t,t))}
// backward
for(let t=i-1;t>=0;--t){for(let e=i-1;e>t;--e)n.set_entry(0,t,n.entry(0,t)-s.entry(t,e)*n.entry(0,e));n.set_entry(0,t,n.entry(0,t)/s.entry(t,t))}return n}
/**
     * {@link L}{@link U} decomposition of the Matrix {@link A}. Creates two matrices, so that the dot product LU equals A.
     * @param {Matrix} A
     * @returns {{L: Matrix, U: Matrix}} result - Returns the left triangle matrix {@link L} and the upper triangle matrix {@link U}.
     */static LU(t){const e=t.shape[0],r=new Matrix(e,e,"zeros"),s=new Matrix(e,e,"identity");for(let i=0;i<e;++i){for(let n=i;n<e;++n){let e=0;for(let t=0;t<i;++t)e+=r.entry(n,t)*s.entry(t,i);r.set_entry(n,i,t.entry(n,i)-e)}for(let n=i;n<e;++n){if(0===r.entry(i,i))return;let e=0;for(let t=0;t<i;++t)e+=r.entry(i,t)*s.entry(t,n);s.set_entry(i,n,(t.entry(i,n)-e)/r.entry(i,i))}}return{L:r,U:s}}
/**
     * Computes the determinante of {@link A}, by using the LU decomposition of {@link A}.
     * @param {Matrix} A
     * @returns {Number} det - Returns the determinate of the Matrix {@link A}.
     */static det(t){const e=t.shape[0],{L:r,U:s}=Matrix.LU(t),i=r.diag,n=s.diag;let o=i[0]*n[0];for(let t=1;t<e;++t)o*=i[t]*n[t];return o}
/**
     * Computes the {@link k} components of the SVD decomposition of the matrix {@link M}
     * @param {Matrix} M
     * @param {int} [k=2]
     * @returns {{U: Matrix, Sigma: Matrix, V: Matrix}}
     */static SVD(t,e=2){const r=t.T;let s=r.dot(t),i=t.dot(r),{eigenvectors:n,eigenvalues:o}=simultaneous_poweriteration(s,e),{eigenvectors:a}=simultaneous_poweriteration(i,e);return{U:a,Sigma:o.map((t=>Math.sqrt(t))),V:n};
//Algorithm 1a: Householder reduction to bidiagonal form:
/* const [m, n] = A.shape;
        let U = new Matrix(m, n, (i, j) => i == j ? 1 : 0);
        console.log(U.to2dArray)
        let V = new Matrix(n, m, (i, j) => i == j ? 1 : 0);
        console.log(V.to2dArray)
        let B = Matrix.bidiagonal(A.clone(), U, V);
        console.log(U,V,B)
        return { U: U, "Sigma": B, V: V }; */}}
/**
 * @class
 * @memberof module:utils
 * @alias Randomizer
 */class Randomizer{
/**
     * Mersenne Twister random number generator.
     * @constructor
     * @param {Number} [_seed=new Date().getTime()] - The seed for the random number generator. If <code>_seed == null</code> then the actual time gets used as seed.
     * @see https://github.com/bmurray7/mersenne-twister-examples/blob/master/javascript-mersenne-twister.js
     */
constructor(t){return this._N=624,this._M=397,this._MATRIX_A=2567483615,this._UPPER_MASK=2147483648,this._LOWER_MASK=2147483647,this._mt=new Array(this._N),this._mti=this.N+1,this.seed=t||(new Date).getTime(),this}set seed(t){this._seed=t;let e=this._mt;for(e[0]=t>>>0,this._mti=1;this._mti<this._N;this._mti+=1){let t=this._mti,r=e[t-1]^e[t-1]>>>30;e[t]=(1812433253*((4294901760&r)>>>16)<<16)+1812433253*(65535&r)+t,e[t]>>>=0}}
/**
     * Returns the seed of the random number generator.
     * @returns {Number} - The seed.
     */get seed(){return this._seed}
/**
     * Returns a float between 0 and 1.
     * @returns {Number} - A random number between [0, 1]
     */get random(){return this.random_int*(1/4294967296)}
/**
     * Returns an integer between 0 and MAX_INTEGER.
     * @returns {Integer} - A random integer.
     */get random_int(){let t,e=new Array(0,this._MATRIX_A);if(this._mti>=this._N){let r,s=this._N-this._M,i=this._M-this._N;
/* if (this._mti == this._N + 1) {
                this.seed = 5489;
            } */for(r=0;r<s;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+this._M]^t>>>1^e[1&t];for(;r<this._N-1;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+i]^t>>>1^e[1&t];t=this._mt[this._N-1]&this._UPPER_MASK|this._mt[0]&this._LOWER_MASK,this._mt[this._N-1]=this._mt[this._M-1]^t>>>1^e[1&t],this._mti=0}return t=this._mt[this._mti+=1],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,t^=t>>>18,t>>>0}
/**
     * Returns samples from an input Matrix or Array.
     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.
     * @param {Number} n - The number of samples.
     * @returns {Array} - A random selection form {@link A} of {@link n} samples.
     */choice(t,e){if(t instanceof Matrix){let r=t.shape[0];if(e>r)throw new Error("n bigger than A!");let s=new Array(e),i=linspace(0,r-1);for(let t=0,r=i.length;t<e;++t,--r){let e=this.random_int%r;s[t]=i.splice(e,1)[0]}return s.map((e=>t.row(e)))}if(Array.isArray(t)||t instanceof Float64Array){let r=t.length;if(e>r)throw new Error("n bigger than A!");let s=new Array(e),i=linspace(0,r-1);for(let t=0,r=i.length;t<e;++t,--r){let e=this.random_int%r;s[t]=i.splice(e,1)[0]}return s.map((e=>t[e]))}}
/**
     * @static
     * Returns samples from an input Matrix or Array.
     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.
     * @param {Number} n - The number of samples.
     * @param {Number} seed - The seed for the random number generator.
     * @returns {Array} - A random selection form {@link A} of {@link n} samples.
     */static choice(t,e,r=1212){return new Randomizer(r).choice(t,e);
/* let rows = A.shape[0];
        if (n > rows) {
            throw new Error("n bigger than A!");
        }
        let rand = new Randomizer(seed);
        let sample = new Array(n);
        let index_list = linspace(0, rows - 1);
        for (let i = 0, l = index_list.length; i < n; ++i, --l) {
            let random_index = rand.random_int % l;
            sample[i] = index_list.splice(random_index, 1)[0];
        }
        //return result;
        //return new Matrix(n, cols, (row, col) => A.entry(sample[row], col))
        return sample.map((d) => A.row(d)); */}}
/**
 * Returns maximum in Array {@link values}.
 * @memberof module:utils
 * @alias max
 * @param {Array} values 
 * @returns {Number}
 */function max(t){let e;for(const r of t)null!=r&&(e<r||void 0===e&&r>=r)&&(e=r);return e}
/**
 * Returns maximum in Array {@link values}.
 * @memberof module:utils
 * @alias min
 * @param {Array} values
 * @returns {Number}
 */function min(t){let e;for(const r of t)null!=r&&(e>r||void 0===e&&r<=r)&&(e=r);return e}
/**
 * @class
 * @alias Heap
 */class Heap{
/**
     * A heap is a datastructure holding its elements in a specific way, so that the top element would be the first entry of an ordered list.
     * @constructor
     * @memberof module:datastructure
     * @alias Heap
     * @param {Array=} elements - Contains the elements for the Heap. {@link elements} can be null.
     * @param {Function} [accessor = (d) => d] - Function returns the value of the element.
     * @param {("min"|"max"|Function)} [comparator = "min"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. ("min" for a Min-Heap, "max" for a Max_heap)
     * @returns {Heap}
     * @see {@link https://en.wikipedia.org/wiki/Binary_heap}
     */
constructor(t=null,e=(t=>t),r="min"){return t?Heap.heapify(t,e,r):(this._accessor=e,this._container=[],this._comparator="min"==r?(t,e)=>t<e:"max"==r?(t,e)=>t>e:r,this)}
/**
     * Creates a Heap from an Array
     * @param {Array|Set} elements - Contains the elements for the Heap.
     * @param {Function=} [accessor = (d) => d] - Function returns the value of the element.
     * @param {(String=|Function)} [comparator = "min"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. ("min" for a Min-Heap, "max" for a Max_heap)
     * @returns {Heap}
     */static heapify(t,e=(t=>t),r="min"){const s=new Heap(null,e,r),i=s._container;for(const r of t)i.push({element:r,value:e(r)});for(let e=Math.floor(t.length/2-1);e>=0;--e)s._heapify_down(e);return s}
/**
     * Swaps elements of container array.
     * @private
     * @param {Number} index_a 
     * @param {Number} index_b 
     */_swap(t,e){const r=this._container;[r[e],r[t]]=[r[t],r[e]]}
/**
     * @private
     */_heapify_up(){const t=this._container;let e=t.length-1;for(;e>0;){let r=Math.floor((e-1)/2);if(!this._comparator(t[e].value,t[r].value))break;this._swap(r,e),e=r}}
/**
     * Pushes the element to the heap.
     * @param {} element
     * @returns {Heap}
     */push(t){const e={element:t,value:this._accessor(t)};
//const node = new Node(element, value);
return this._container.push(e),this._heapify_up(),this}
/**
     * @private
     * @param {Number} [start_index = 0] 
     */_heapify_down(t=0){const e=this._container,r=this._comparator,s=e.length;let i=2*t+1,n=2*t+2,o=t;if(o>s)throw"index higher than length";i<s&&r(e[i].value,e[o].value)&&(o=i),n<s&&r(e[n].value,e[o].value)&&(o=n),o!==t&&(this._swap(t,o),this._heapify_down(o))}
/**
     * Removes and returns the top entry of the heap.
     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).
     */pop(){const t=this._container;if(0===t.length)return null;if(1===t.length)return t.pop();this._swap(0,t.length-1);const e=t.pop();return this._heapify_down(),e}
/**
     * Returns the top entry of the heap without removing it.
     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).
     */get first(){return this._container.length>0?this._container[0]:null}
/**
     * Yields the raw data
     * @yields {Object} Object consists of the element and its value (computed by {@link accessor}).
     */*iterate(){for(let t=0,e=this._container.length;t<e;++t)yield this._container[t].element}
/**
     * Returns the heap as ordered array.
     * @returns {Array} Array consisting the elements ordered by {@link comparator}.
     */toArray(){return this.data().sort(((t,e)=>this._comparator(t,e)?-1:0))}
/**
     * Returns elements of container array.
     * @returns {Array} Array consisting the elements.
     */data(){return this._container.map((t=>t.element))}
/**
     * Returns the container array.
     * @returns {Array} The container array.
     */raw_data(){return this._container}
/**
     * The size of the heap.
     * @returns {Number}
     */get length(){return this._container.length}
/**
     * Returns false if the the heap has entries, true if the heap has no entries.
     * @returns {Boolean}
     */get empty(){return 0===this.length}}
/**
 * @class
 * @alias DisjointSet
 * @see {@link https://en.wikipedia.org/wiki/Disjoint-set_data_structure}
 */class DisjointSet{
/**
     * @constructor
     * @alias DisjointSet
     * @memberof module:datastructure
     * @param {Array=} elements 
     * @returns {DisjointSet}
     */
constructor(t=null){if(this._list=new Set,t)for(const e of t)this.make_set(e);return this}make_set(t){const e=this._list;return e.has(t)||(e.add(t),t.__disjoint_set={},t.__disjoint_set.parent=t,t.__disjoint_set.children=new Set([t]),t.__disjoint_set.size=1),this}find(t){return this._list.has(t)?t.__disjoint_set.parent!==t?(t.__disjoint_set.children.add(...t),t.__disjoint_set.parent=this.find(t.__disjoint_set.parent),t.__disjoint_set.parent):t:null}union(t,e){let r=this.find(t),s=this.find(e);return r===s||(r.__disjoint_set.size<s.__disjoint_set.size&&([r,s]=[s,r]),s.__disjoint_set.parent=r,
// keep track of children?
s.__disjoint_set.children.forEach(r.__disjoint_set.children.add,r.__disjoint_set.children),r.__disjoint_set.size+=s.__disjoint_set.size),this}}
/**
 * @class
 * @alias BallTree
 */class BallTree{
/**
     * Generates a BallTree with given {@link elements}.
     * @constructor
     * @memberof module:knn
     * @alias BallTree
     * @param {Array=} elements - Elements which should be added to the BallTree
     * @param {Function} [metric = euclidean] metric to use: (a, b) => distance
     * @see {@link https://en.wikipedia.org/wiki/Ball_tree}
     * @see {@link https://github.com/invisal/noobjs/blob/master/src/tree/BallTree.js}
     * @returns {BallTree}
     */
constructor(t=null,e=euclidean){return this._Node=class{constructor(t,e=null,r=null,s=null){this.pivot=t,this.child1=e,this.child2=r,this.radius=s}},this._Leaf=class{constructor(t){this.points=t}},this._metric=e,t&&this.add(t),this}
/**
     * 
     * @param {Array<*>} elements - new elements.
     * @returns {BallTree}
     */add(t){return t=t.map(((t,e)=>({index:e,element:t}))),this._root=this._construct(t),this}
/**
     * @private
     * @param {Array<*>} elements 
     * @returns {Node} root of balltree.
     */_construct(t){if(1===t.length)return new this._Leaf(t);{let e,r=this._greatest_spread(t),s=t.sort(((t,e)=>t.element[r]-e.element[r])),i=s.length,n=Math.floor(i/2),o=t[n],a=s.slice(0,n),h=s.slice(n,i),l=Math.max(...t.map((t=>this._metric(o.element,t.element))));return e=a.length>0&&h.length>0?new this._Node(o,this._construct(a),this._construct(h),l):new this._Leaf(t),e}}
/**
     * @private
     * @param {Node} B 
     * @returns {Number}
     */_greatest_spread(t){let e=t[0].element.length,r=new Array(e);for(let t=0;t<e;++t)r[t]=[1/0,-1/0];let s=t.reduce(((t,r)=>{for(let s=0;s<e;++s)t[s][0]=Math.min(t[s][0],r.element[s]),t[s][1]=Math.max(t[s][1],r.element[s]);return t}),r);s=s.map((t=>t[1]-t[0]));let i=0;for(let t=0;t<e;++t)i=s[t]>s[i]?t:i;return i}
/**
     * 
     * @param {*} t - query element.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.
     */search(t,e=5){return this._search(t,e,new Heap(null,(e=>this._metric(e.element,t)),"max"),this._root)}
/**
     * @private
     * @param {*} t - query element.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @param {Heap} Q - Heap consists of the currently found {@link k} nearest neighbors.
     * @param {Node|Leaf} B 
     */_search(t,e,r,s){
// B is Node
if(r.length>=e&&s.pivot&&s.radius&&this._metric(t,s.pivot.element)-s.radius>=r.first.value)return r;
// B is leaf
if(s.child1&&this._search(t,e,r,s.child1),s.child2&&this._search(t,e,r,s.child2),s.points)for(let t=0,i=s.points.length;t<i;++t){let i=s.points[t];e>r.length?r.push(i):(r.push(i),r.pop())}return r}}
/**
 * @class
 * @alias KNN
 */class KNN{
/**
     * Generates a KNN list with given {@link elements}.
     * @constructor
     * @memberof module:knn
     * @alias KNN
     * @param {Array=} elements - Elements which should be added to the KNN list
     * @param {Function|"precomputed"} [metric = euclidean] metric is either precomputed or a function to use: (a, b) => distance
     * @returns {KNN}
     */
constructor(t=null,e=euclidean){this._metric=e,this._elements=t instanceof Matrix?t:Matrix.from(t);const r=this._elements.shape[0];this._D="precomputed"===e?this._elements.clone():distance_matrix(this._elements,e),this.KNN=[];for(let t=0;t<r;++t){const e=this._D.row(t),s=new Heap(null,(t=>t.value),"min");for(let t=0;t<r;++t)s.push({value:e[t],index:t});this.KNN.push(s)}}
/**
     * 
     * @param {Array|Number} t - query element or index.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.
     */search(t,e=5){const r=this._metric,s=this.KNN;let i;if(Array.isArray(t)){if("precomputed"==this._metric)throw"Search by query element is only possible when not using a precomputed distance matrix!";const e=this._elements,n=s.length;let o=null,a=1/0;for(let s=0;s<n;++s){const i=r(t,e.row(s));i<a&&(o=s,a=i)}i=s[o]}else Number.isInteger(t)&&(i=s[t]);let n=[];for(let t=0;t<e;++t)n.push(i.pop());return n.forEach((t=>i.push(t.element))),n}}
/**
 * @class
 * @alias DR
 * @borrows DR#parameter as DR#para
 * @borrows DR#parameter as DR#p
 */class DR{
/**
     * Takes the default parameters and seals them, remembers the type of input {@link X}, and initializes the random number generator.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias DR
     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed value for the random number generator.
     * @returns {DR}
     */
constructor(t,e,r){if(this._parameters=Object.assign(Object.seal(e),r),Array.isArray(t))this._type="array",this.X=Matrix.from(t);else{if(!(t instanceof Matrix))throw new Error("No valid type for X!");this._type="matrix",this.X=t}return[this._N,this._D]=this.X.shape,this._randomizer=new Randomizer(this._parameters.seed),this._is_initialized=!1,this}
/**
     * Set and get parameters
     * @param {String} name - name of the parameter.
     * @param {any} [value = null] - value of the parameter to set.
     * @returns {DR|any} - On setting a parameter, this function returns the DR object. If <code>value == null</code> then return actual parameter value.
     * @example
     * const DR = new druid.TSNE(X, {d: 3}); // creates a new DR object, with parameter for <code>d</code> = 3.
     * DR.parameter("d"); // returns 3,
     * DR.parameter("d", 2); // sets parameter <code>d</code> to 2 and returns <code>DR</code>.
     */parameter(t,e=null){if(!this._parameters.hasOwnProperty(t))throw new Error(`${t} is not a valid parameter!`);return e?(this._parameters[t]=e,this._is_initialized=!1,this):this._parameters[t]}para(t,e=null){return this.parameter(t,e)}p(t,e=null){return this.parameter(t,e)}
/**
     * Computes the projection.
     * @returns {Matrix} - Returns the projection.
     */transform(){return this.check_init(),this.projection}
/**
     * Computes the projection.
     * @returns {Generator} - A generator yielding the intermediate steps of the dimensionality reduction method.
     */*generator(){return this.transform()}
/**
     * If the respective DR method has an <code>init</code> function, call it before <code>transform</code>.
     * @returns {DR}
     */check_init(){return this._is_initialized||"function"!=typeof this.init||(this.init(),this._is_initialized=!0),this}
/**
     * @returns {Matrix|Array} Returns the projection.
     */get projection(){if(this.hasOwnProperty("Y"))return this.check_init(),"matrix"===this._type?this.Y:this.Y.to2dArray;throw new Error("The dataset is not transformed yet!")}
/**
     *
     * @param  {...any} args - Arguments the transform method of the respective DR method takes.
     * @returns {Promise} - A promise yielding the dimensionality reduced dataset.
     */async transform_async(...t){return this.transform(...t)}
/**
     * @static
     * @param  {...any} args - Takes the same arguments of the constructor of the respective DR method.
     * @returns {Matrix|Array} - The dimensionality reduced dataset.
     */static transform(...t){return new this(...t).transform()}
/**
     * @static
     * @param  {...any} args - Takes the same arguments of the constructor of the respective DR method.
     * @returns {Promise} - A promise yielding the dimensionality reduced dataset.
     */static async transform_async(...t){return this.transform(...t)}
/**
     * @static
     * @param  {...any} args - Takes the same arguments of the constructor of the respective DR method.
     * @returns {Generator} - A generator yielding the intermediate steps of the dimensionality reduction method.
     */static*generator(...t){const e=new this(...t).generator();for(const t of e)yield t}}
/**
 * @class
 * @alias PCA
 * @augments DR
 */class PCA extends DR{
/**
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias PCA
     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @returns {PCA}
     */
constructor(t,e){return super(t,{d:2,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Transforms the inputdata {@link X} to dimensionality {@link d}. If parameter {@link A} is given, then project {@link A} with the principal components of {@link X}.
     * @param {null|Matrix|Array} [A = null] - If given, the data to project.
     * @returns {Matrix|Array} - The projected data.
     */transform(t=null){const e=this.principal_components();if(null==t){const t=this.X;return this.Y=t.dot(e),this.projection}if(Array.isArray(t))return Matrix.from(t).dot(e).asArray;if(t instanceof Matrix)return t.dot(e);throw new Error("No valid type for A!")}
/**
     * Computes the {@link d} principal components of Matrix {@link X}.
     * @returns {Matrix}
     */principal_components(){if(this.V)return this.V;const{d:t,eig_args:e}=this._parameters,r=this.X,s=Matrix.from(r.meanCols),i=r.sub(s),n=i.transpose().dot(i),{eigenvectors:o}=simultaneous_poweriteration(n,t,e);return this.V=Matrix.from(o).transpose(),this.V}static principal_components(t,e){return new this(t,e).principal_components()}}
/**
 * @class
 * @alias MDS
 * @extends DR
 */class MDS extends DR{
/**
     * Classical MDS.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias MDS
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     */
constructor(t,e){return super(t,{d:2,metric:euclidean,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Transforms the inputdata {@link X} to dimensionality {@link d}.
     * @returns {Matrix|Array}
     */transform(){const t=this.X,e=t.shape[0],{d:r,metric:s,eig_args:i}=this._parameters,n="precomputed"===s?t:distance_matrix(t,s),o=n.meanCols,a=n.meanRows,h=n.mean;this._d_X=n;const l=new Matrix(e,e,((t,e)=>n.entry(t,e)-o[t]-a[e]+h)),{eigenvectors:_}=simultaneous_poweriteration(l,r,i);return this.Y=Matrix.from(_).transpose(),this.projection}
/**
     * @returns {Number} - the stress of the projection.
     */stress(){const t=this.X.shape[0],e=this.Y,r=this._d_X,s=new Matrix;s.shape=[t,t,(t,r)=>t<r?euclidean(e.row(t),e.row(r)):s.entry(r,t)];let i=0,n=0;for(let e=0;e<t;++e)for(let o=e+1;o<t;++o)i+=Math.pow(r.entry(e,o)-s.entry(e,o),2),n+=Math.pow(r.entry(e,o),2);return Math.sqrt(i/n)}}
/**
 * @class
 * @alias ISOMAP
 * @extends DR
 */class ISOMAP extends DR{
/**
     * Isometric feature mapping (ISOMAP).
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias ISOMAP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} parameters.neighbors - the number of neighbors {@link ISOMAP} should use to project the data.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://doi.org/10.1126/science.290.5500.2319}
     */
constructor(t,e){return super(t,{neighbors:void 0,d:2,metric:euclidean,seed:1212,eig_args:{}},e),this.parameter("neighbors",Math.min(this._parameters.neighbors??Math.max(Math.floor(this.X.shape[0]/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */transform(){this.check_init();const t=this.X,e=this._N,{d:r,metric:s,eig_args:i,neighbors:n}=this._parameters,o=new Matrix;o.shape=[e,e,(e,r)=>e<=r?s(t.row(e),t.row(r)):o.entry(r,e)];const a=[];for(let t=0;t<e;++t){const r=[];for(let s=0;s<e;++s)r.push({index:s,distance:o.entry(t,s)});const s=new Heap(r,(t=>t.distance),"min");a.push(s.toArray().slice(1,n+1))}
/*D = dijkstra(kNearestNeighbors);*/
// compute shortest paths
// TODO: make extern
/** @see {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm} */const h=new Matrix(e,e,((t,e)=>{const r=a[t].find((t=>t.index===e));return r?r.distance:1/0}));for(let t=0;t<e;++t)for(let r=0;r<e;++r)for(let s=0;s<e;++s)h.set_entry(t,r,Math.min(h.entry(t,r),h.entry(t,s)+h.entry(s,r)));let l=new Float64Array(e),_=new Float64Array(e),c=0;const u=new Matrix(e,e,((t,e)=>{let r=h.entry(t,e);return r=r===1/0?0:r,l[t]+=r,_[e]+=r,c+=r,r}));l=l.map((t=>t/e)),_=_.map((t=>t/e)),c/=e**2;const d=new Matrix(e,e,((t,e)=>u.entry(t,e)-l[t]-_[e]+c)),{eigenvectors:m}=simultaneous_poweriteration(d,r,i);
// compute d eigenvectors
// return embedding
return this.Y=Matrix.from(m).transpose(),this.projection}}
/**
 * @class
 * @alias FASTMAP
 * @extends DR
 */class FASTMAP extends DR{
/**
     * FastMap: a fast algorithm for indexing, data-mining and visualization of traditional and multimedia datasets
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias FASTMAP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the dimensionality of the projection.
     * @returns {FASTMAP}
     * @see {@link https://doi.org/10.1145/223784.223812}
     */
constructor(t,e){return super(t,{d:2,metric:euclidean,seed:1212},e),this}
/**
     * Chooses two points which are the most distant in the actual projection.
     * @private
     * @param {Function} dist
     * @returns {Array} An array consisting of first index, second index, and distance between the two points.
     */_choose_distant_objects(t){const e=this.X.shape[0];let r=this._randomizer.random_int%e-1,s=null,i=-1/0;for(let n=0;n<e;++n){const e=t(r,n);e>i&&(i=e,s=n)}i=-1/0;for(let n=0;n<e;++n){const e=t(s,n);e>i&&(i=e,r=n)}return[r,s,i]}
/**
     * Computes the projection.
     * @returns {Matrix} The {@link d}-dimensional projection of the data matrix {@link X}.
     */transform(){const t=this.X,e=t.shape[0],{d:r,metric:s}=this._parameters,i=new Matrix(e,r,0);let dist=(e,r)=>s(t.row(e),t.row(r));for(let t=0;t<r;++t){let r=dist;
// choose pivot objects
const[s,n,o]=this._choose_distant_objects(dist);if(0!==o){
// project the objects on the line (O_a, O_b)
for(let r=0;r<e;++r){const e=(dist(s,r)**2+o**2-dist(n,r)**2)/(2*o);i.set_entry(r,t,e)}
// consider the projections of the objects on a
// hyperplane perpendicluar to the line (a, b);
// the distance function D'() between two
// projections is given by Eq.4
dist=(e,s)=>Math.sqrt(r(e,s)**2-(i.entry(e,t)-i.entry(s,t))**2)}}
// return embedding.
return this.Y=i,this.projection}}
/**
 * @class
 * @alias LDA
 * @extends DR
 */class LDA extends DR{
/**
     * Linear Discriminant Analysis.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LDA
     * @param {Matrix} X - The high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Array} parameters.labels - The labels / classes for each data point.
     * @param {number} [parameters.d = 2] - The dimensionality of the projection.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://onlinelibrary.wiley.com/doi/10.1111/j.1469-1809.1936.tb02137.x}
     */
constructor(t,e){return super(t,{labels:null,d:2,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,[e,r]=t.shape,{d:s,labels:i,eig_args:n}=this._parameters;if(null===i||i.length!=e)throw new Error("LDA needs parameter label to every datapoint to work!");const o={};let a=0;i.forEach(((e,r)=>{e in o?(o[e].count++,o[e].rows.push(t.row(r))):o[e]={id:a++,count:1,rows:[t.row(r)]}}));
// create X_mean and vector means;
const h=t.mean,l=new Matrix(a,r);for(const t in o){const e=Matrix.from(o[t].rows).meanCols;for(let s=0;s<r;++s)l.set_entry(o[t].id,s,e[s])}
// scatter_between
let _=new Matrix(r,r);for(const t in o){const e=l.row(o[t].id),s=new Matrix(r,1,(t=>e[t]-h)),i=o[t].count;_=_.add(s.dot(s.transpose()).mult(i))}
// scatter_within
let c=new Matrix(r,r);for(const t in o){const e=l.row(o[t].id),s=new Matrix(r,1,(t=>e[t])),i=o[t].rows;for(let e=0,n=o[t].count;e<n;++e){const t=new Matrix(r,1,((t,r)=>i[e][t]-s.entry(t,0)));c=c.add(t.dot(t.transpose()))}}let{eigenvectors:u}=simultaneous_poweriteration(c.inverse().dot(_),s,n);
// return embedding
return u=Matrix.from(u).transpose(),this.Y=t.dot(u),this.projection}}
/**
 * @class
 * @alias LLE
 * @extends DR
 */class LLE extends DR{
/**
     * Locally Linear Embedding.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LLE
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} neighbors - the label / class of each data point.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://doi.org/10.1126/science.290.5500.2323}
     */
constructor(t,e){return super(t,{neighbors:void 0,d:2,metric:euclidean,seed:1212,eig_args:{}},e),this.parameter("neighbors",Math.min(e.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,e=this._N,r=this._D,{neighbors:s,d:i,eig_args:n,metric:o}=this._parameters,a=k_nearest_neighbors(t,s,o),h=new Matrix(s,1,1),l=new Matrix(e,e);for(let i=0;i<e;++i){const e=a[i],n=new Matrix(s,r,((r,s)=>t.entry(e[r].j,s)-t.entry(i,s))),o=n.dot(n.T);if(s>r){const t=neumair_sum(o.diag)/1e3;for(let e=0;e<s;++e)o.set_entry(e,e,o.entry(e,e)+t)}
// reconstruct;
let _=Matrix.solve_CG(o,h,this._randomizer);_=_.divide(_.sum);for(let t=0;t<s;++t)l.set_entry(i,e[t].j,_.entry(t,0))}
// comp embedding
const _=new Matrix(e,e,"identity").sub(l),c=_.T.dot(_),{eigenvectors:u}=simultaneous_poweriteration(c.T.inverse(),i+1,n);
// return embedding
return this.Y=Matrix.from(u.slice(1,1+i)).T,this.projection}}
/**
 * @class
 * @alias LTSA
 * @extends DR
 */class LTSA extends DR{
/**
     * Local Tangent Space Alignment
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LTSA
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} parameters.neighbors - the number of neighbors {@link LTSA} should use to project the data.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://epubs.siam.org/doi/abs/10.1137/S1064827502419154}
     */
constructor(t,e){if(super(t,{neighbors:void 0,d:2,metric:euclidean,seed:1212,eig_args:{}},e),this.parameter("neighbors",Math.min(e.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this._D<=this.parameter("d"))throw new Error(`Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${this.parameter("d")})!`);return this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,[e,r]=t.shape,{d:s,neighbors:i,metric:n,eig_args:o}=this._parameters,a=k_nearest_neighbors(t,i,n),h=new Matrix(r,r,"center"),l=new Matrix(e,e,0);for(let r=0;r<e;++r){
// 1.2 compute the d largest eigenvectors of the correlation matrix
const e=[r,...a[r].map((t=>t.j))];let n=Matrix.from(e.map((e=>t.row(e))));
// center X_i
n=n.dot(h);
// correlation matrix
const _=n.dot(n.transpose()),{eigenvectors:c}=simultaneous_poweriteration(_,s,o),u=Matrix.from(c),d=u.transpose().dot(u).add(1/Math.sqrt(i+1));for(let t=0;t<i+1;++t)for(let r=0;r<i+1;++r)l.set_entry(e[t],e[r],l.entry(e[t],e[r])-(t===r?1:0)+d.entry(t,r))}
// 3. Aligning global coordinates
const{eigenvectors:_}=simultaneous_poweriteration(l,s+1,o);
// return embedding
return this.Y=Matrix.from(_.slice(1)).transpose(),this.projection}}
/**
 * @class
 * @alias TSNE
 * @extends DR
 */class TSNE extends DR{
/**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TSNE
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.perplexity = 50] - perplexity.
     * @param {Number} [parameters.epsilon = 10] - learning parameter.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {TSNE}
     */
constructor(t,e){return super(t,{perplexity:50,epsilon:10,d:2,metric:euclidean,seed:1212},e),[this._N,this._D]=this.X.shape,this._iter=0,this.Y=new Matrix(this._N,this.parameter("d"),(()=>this._randomizer.random)),this}
/**
     *
     * @param {Matrix} distance_matrix - accepts a precomputed distance matrix
     * @returns {TSNE}
     */init(){
// init
const t=Math.log(this.parameter("perplexity")),e=this._N,r=this._D,{metric:s}=this._parameters,i=this.X;let n;if("precomputed"==s)n=druid.Matrix.from(i);else{n=new Matrix(e,e);for(let t=0;t<e;++t){const r=i.row(t);for(let o=t+1;o<e;++o){const e=s(r,i.row(o));n.set_entry(t,o,e),n.set_entry(o,t,e)}}}const o=new Matrix(e,e,"zeros");this._ystep=new Matrix(e,r,"zeros"),this._gains=new Matrix(e,r,1);
// search for fitting sigma
let a=new Float64Array(e);for(let r=0;r<e;++r){let s=-1/0,i=1/0,h=1,l=!1,_=0;for(;!l;){let o=0;for(let t=0;t<e;++t){let e=Math.exp(-n.entry(r,t)*h);r===t&&(e=0),a[t]=e,o+=e}let c=0;for(let t=0;t<e;++t){let e=0===o?0:a[t]/o;a[t]=e,e>1e-7&&(c-=e*Math.log(e))}c>t?(s=h,h=i===1/0?2*h:(h+i)/2):(i=h,h=s===-1/0?h/2:(h+s)/2),++_,Math.abs(c-t)<1e-4&&(l=!0),_>=50&&(l=!0)}for(let t=0;t<e;++t)o.set_entry(r,t,a[t])}
//compute probabilities
const h=new Matrix(e,e,"zeros"),l=2*e;for(let t=0;t<e;++t)for(let r=t;r<e;++r){const e=Math.max((o.entry(t,r)+o.entry(r,t))/l,1e-100);h.set_entry(t,r,e),h.set_entry(r,t,e)}return this._P=h,this}
/**
     *
     * @param {Number} [iterations=500] - number of iterations.
     * @yields {Matrix|Array<Array>} - the projection.
     */transform(t=500){this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}
/**
     *
     * @param {Number} [iterations=500] - number of iterations.
     * @yields {Matrix|Array<Array>} - the projection.
     */*generator(t=500){this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}
/**
     * performs a optimization step
     * @private
     * @returns {Matrix}
     */next(){const t=++this._iter,e=this._P,r=this._ystep,s=this._gains,i=this._N,{d:n,epsilon:o}=this._parameters;let a=this.Y;
//calc cost gradient;
const h=t<100?4:1,l=new Matrix(i,i,"zeros");
// compute Q dist (unnormalized)
let _=0;for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){let r=0;for(let s=0;s<n;++s){const i=a.entry(t,s)-a.entry(e,s);r+=i*i}const s=1/(1+r);l.set_entry(t,e,s),l.set_entry(e,t,s),_+=2*s}
// normalize Q dist
const c=new Matrix(i,i,0);for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){const r=Math.max(l.entry(t,e)/_,1e-100);c.set_entry(t,e,r),c.set_entry(e,t,r)}const u=new Matrix(i,n,"zeros");for(let t=0;t<i;++t)for(let r=0;r<i;++r){const s=4*(h*e.entry(t,r)-c.entry(t,r))*l.entry(t,r);for(let e=0;e<n;++e)u.set_entry(t,e,u.entry(t,e)+s*(a.entry(t,e)-a.entry(r,e)))}
// perform gradient step
let d=new Float64Array(n);for(let e=0;e<i;++e)for(let i=0;i<n;++i){const n=u.entry(e,i),h=r.entry(e,i),l=s.entry(e,i);let _=Math.sign(n)===Math.sign(h)?.8*l:l+.2;_<.01&&(_=.01),s.set_entry(e,i,_);const c=(t<250?.5:.8)*h-o*_*n;r.set_entry(e,i,c),a.set_entry(e,i,a.entry(e,i)+c),d[i]+=a.entry(e,i)}for(let t=0;t<i;++t)for(let e=0;e<2;++e)a.set_entry(t,e,a.entry(t,e)-d[e]/i);return this.Y}}
/**
 *
 * @memberof module:optimization
 * @alias powell
 * @param {Function} f
 * @param {Array} x0
 * @param {Number} [max_iter = 300]
 * @returns {Array}
 * @see http://optimization-js.github.io/optimization-js/optimization.js.html#line438
 */function powell(t,e,r=300){const s=e.length;let i=.001,n=1e4,o=e.slice(),a=t(o),h=!1;for(;r-- >=0&&!h;){h=!0;for(let e=0;e<s;++e){o[e]+=1e-6;let r=t(o);o[e]-=1e-6;let s=(r-a)/1e-6;Math.abs(s)>.01&&(h=!1),o[e]-=i*s,a=t(o)}i*=n>=a?1.05:.4,n=a}return o}
/**
 * @class
 * @alias UMAP
 * @extends DR
 */class UMAP extends DR{
/**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias UMAP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.n_neighbors = 15] - size of the local neighborhood.
     * @param {Number} [parameters.local_connectivity = 1] - number of nearest neighbors connected in the local neighborhood.
     * @param {Number} [parameters.min_dist = 1] - controls how tightly points get packed together.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points in the high-dimensional space.
     * @param {Number} [parameters._spread = 1] - The effective scale of embedded points. (In combination with {@link parameters.min_dist})
     * @param {Number} [parameters._set_op_mix_ratio = 1] - Interpolate between union and intersection.
     * @param {Number} [parameters._repulsion_strength = 1]  - Weighting applied to negative samples.
     * @param {Number} [parameters._negative_sample_rate = 5] - The number of negative samples per positive sample.
     * @param {Number} [parameters._n_epochs = 350] - The number of training epochs.
     * @param {Number} [parameter._initial_alpha = 1] - The initial learning rate for the optimization.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {UMAP}
     */
constructor(t,e){
/* let n_neighbors = Math.min(this._N - 1, parameters.n_neighbors);
        this.parameter("n_neighbors", n_neighbors);
        this.parameter("local_connectivity", Math.min(this.parameter("local_connectivity"), n_neighbors - 1)); */
if(super(t,{n_neighbors:15,local_connectivity:1,min_dist:1,d:2,metric:euclidean,seed:1212,_spread:1,_set_op_mix_ratio:1,_repulsion_strength:1,_negative_sample_rate:5,_n_epochs:350,_initial_alpha:1},e),[this._N,this._D]=this.X.shape,this.parameter("n_neighbors")>this._N)throw new Error(`Parameter n_neighbors (=${this.parameter("n_neighbors")}) needs to be smaller than dataset size (N=${this._N})!`);if(this.parameter("local_connectivity")>this.parameter("n_neighbors"))throw new Error(`Parameter local_connectivity (=${this.parameter("local_connectivity")}) needs to be smaller than parameter n_neighbors (=${this.parameter("n_neighbors")})`);this._iter=0;const r=this._randomizer;return this.Y=new Matrix(this._N,this.parameter("d"),(()=>r.random)),this}
/**
     * @private
     * @param {Number} spread
     * @param {Number} min_dist
     * @returns {Array}
     */_find_ab_params(t,e){const r=linspace(0,3*t,300),s=linspace(0,3*t,300);for(let i=0,n=r.length;i<n;++i){const n=r[i];s[i]=n<e?1:Math.exp(-(n-e)/t)}return powell((t=>{const e=linspace(1,300).map(((e,i)=>{return s[i]-(n=r[i],o=t[0],a=t[1],1/(1+o*Math.pow(n,2*a)));var n,o,a}));return Math.sqrt(neumair_sum(e.map((t=>t*t))))}),[1,1])}
/**
     * @private
     * @param {Array<Array>} distances
     * @param {Array<Number>} sigmas
     * @param {Array<Number>} rhos
     * @returns {Array}
     */_compute_membership_strengths(t,e,r){for(let s=0,i=t.length;s<i;++s)for(let i=0,n=t[s].length;i<n;++i){const n=t[s][i].value-r[s];t[s][i].value=n>0?Math.exp(-n/e[s]):1}return t}
/**
     * @private
     * @param {KNN|BallTree} knn
     * @param {Number} k
     * @returns {Object}
     */_smooth_knn_dist(t,e){const r=1e-5,s=.001,{local_connectivity:i,metric:n}=this._parameters,o=Math.log2(e),a=[],h=[],l=this.X,_=l.shape[0],c=[];if("precomputed"===n)for(let r=0;r<_;++r)c.push(t.search(r,e).reverse());else for(const r of l)c.push(t.search(r,e).raw_data().reverse());for(let t=0;t<_;++t){let n=0,l=1/0,_=1;const u=c[t],d=u.filter((t=>t.value>0)),m=d.length;if(m>=i){const e=Math.floor(i),s=i-e;e>0?(a.push(d[e-1]),s>r&&(a[t].value+=s*(d[e].value-d[e-1]))):a[t].value=s*d[0].value}else m>0&&(a[t]=d[m-1].value);for(let s=0;s<64;++s){let s=0;for(let r=0;r<e;++r){const e=u[r].value-a[t];s+=e>0?Math.exp(-e/_):1}if(Math.abs(s-o)<r)break;s>o?[l,_]=[_,(n+l)/2]:[n,_]=l===1/0?[_,2*_]:[_,(n+l)/2]}h[t]=_;const p=u.reduce(((t,e)=>t+e.value),0)/u.length;
//let mean_d = null;
if(a[t]>0)h[t]<s*p&&(h[t]=s*p);else{const e=c.reduce(((t,e)=>t+e.reduce(((t,e)=>t+e.value),0)/e.length));h[t]>s*e&&(h[t]=s*e)}}return{distances:c,sigmas:h,rhos:a}}
/**
     * @private
     * @param {Matrix} X
     * @param {Number} n_neighbors
     * @returns {Matrix}
     */_fuzzy_simplicial_set(t,e){const r=t.shape[0],{metric:s,_set_op_mix_ratio:i}=this._parameters,n="precomputed"===s?new KNN(t,"precomputed"):new BallTree(t.to2dArray,s);let{distances:o,sigmas:a,rhos:h}=this._smooth_knn_dist(n,e);o=this._compute_membership_strengths(o,a,h);const l=new Matrix(r,r,"zeros");for(let t=0;t<r;++t){const e=o[t];for(let r=0;r<e.length;++r)l.set_entry(t,e[r].element.index,e[r].value)}const _=l.T,c=l.mult(_);return l.add(_).sub(c).mult(i).add(c.mult(1-i))}
/**
     * @private
     * @param {Number} n_epochs
     * @returns {Array}
     */_make_epochs_per_sample(t){const e=this._weights,r=new Float32Array(e.length).fill(-1),s=max(e),i=e.map((e=>t*(e/s)));for(let e=0;e<r.length;++e)i[e]>0&&(r[e]=Math.round(t/i[e]));return r}
/**
     * @private
     * @param {Matrix} graph
     * @returns {Object}
     */_tocoo(t){const e=[],r=[],s=[],[i,n]=t.shape;for(let o=0;o<i;++o)for(let i=0;i<n;++i){const n=t.entry(o,i);0!==n&&(e.push(o),r.push(i),s.push(n))}return{rows:e,cols:r,data:s}}
/**
     * Computes all necessary
     * @returns {UMAP}
     */init(){const{_spread:t,min_dist:e,n_neighbors:r,_n_epochs:s,_negative_sample_rate:i}=this._parameters,[n,o]=this._find_ab_params(t,e);this._a=n,this._b=o,this._graph=this._fuzzy_simplicial_set(this.X,r);const{rows:a,cols:h,data:l}=this._tocoo(this._graph);return this._head=a,this._tail=h,this._weights=l,this._epochs_per_sample=this._make_epochs_per_sample(s),this._epochs_per_negative_sample=this._epochs_per_sample.map((t=>t*i)),this._epoch_of_next_sample=this._epochs_per_sample.slice(),this._epoch_of_next_negative_sample=this._epochs_per_negative_sample.slice(),this}graph(){return this.check_init(),{cols:this._head,rows:this._tail,weights:this._weights}}
/**
     *
     * @param {Number} [iterations=350] - number of iterations.
     * @returns {Matrix|Array}
     */transform(t=350){this.parameter("_n_epochs")!=t&&(this.parameter("_n_epochs",t),this.init()),this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}
/**
     *
     * @param {Number} [iterations=350] - number of iterations.
     * @returns {Matrix|Array}
     */*generator(t=350){this.parameter("_n_epochs")!=t&&(this.parameter("_n_epochs",t),this.init()),this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}
/**
     * @private
     * @param {Number} x
     * @returns {Number}
     */_clip(t){return t>4?4:t<-4?-4:t}
/**
     * performs the optimization step.
     * @private
     * @param {Matrix} head_embedding
     * @param {Matrix} tail_embedding
     * @param {Matrix} head
     * @param {Matrix} tail
     * @returns {Matrix}
     */_optimize_layout(t,e,r,s){const i=this._randomizer,{_repulsion_strength:n,d:o}=this._parameters,{_alpha:a,_a:h,_b:l,_epochs_per_sample:_,_epochs_per_negative_sample:c,_epoch_of_next_negative_sample:u,_epoch_of_next_sample:d,_clip:m}=this,p=s.length;for(let f=0,y=_.length;f<y;++f)if(d[f]<=this._iter){const y=r[f],w=s[f],g=t.row(y),x=e.row(w),M=euclidean_squared(g,x);let A=0;M>0&&(A=-2*h*l*Math.pow(M,l-1)/(h*Math.pow(M,l)+1));for(let r=0;r<o;++r){const s=m(A*(g[r]-x[r]))*a,i=g[r]+s,n=x[r]-s;g[r]=i,x[r]=n,t.set_entry(y,r,i),e.set_entry(w,r,n)}d[f]+=_[f];const b=(this._iter-u[f])/c[f];for(let r=0;r<b;++r){const r=i.random_int%p,_=e.row(s[r]),c=euclidean_squared(g,_);let u=0;if(c>0)u=2*n*l/((.01+c)*(h*Math.pow(c,l)+1));else if(y===r)continue;for(let i=0;i<o;++i){const n=m(u*(g[i]-_[i]))*a,o=g[i]+n,h=_[i]-n;g[i]=o,_[i]=h,t.set_entry(y,i,o),e.set_entry(s[r],i,h)}}u[f]+=b*c[f]}return t}
/**
     * @private
     * @returns {Matrix}
     */next(){const t=++this._iter,e=this.Y,{_initial_alpha:r,_n_epochs:s}=this._parameters;return this._alpha=r*(1-t/s),this.Y=this._optimize_layout(e,e,this._head,this._tail),this.Y}}
/**
 * @class
 * @alias TriMap
 * @extends DR
 */class TriMap extends DR{
/**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TriMap
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.weight_adj = 500] - scaling factor.
     * @param {Number} [parameters.c = 5] - number of triplets multiplier.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Number} [parameters.tol = 1e-8] -
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {TriMap}
     * @see {@link https://arxiv.org/pdf/1910.00204v1.pdf}
     * @see {@link https://github.com/eamid/trimap}
     */
constructor(t,e){return super(t,{weight_adj:500,c:5,d:2,metric:euclidean,tol:1e-8,seed:1212},e),this}
/**
     *
     * @param {Matrix} [pca = null] - Initial Embedding (if null then PCA gets used).
     * @param {KNN} [knn = null] - KNN Object (if null then BallTree gets used).
     */init(t=null,e=null){const r=this.X,s=r.shape[0],{d:i,metric:n,c:o}=this._parameters;this.n_inliers=2*o,this.n_outliers=1*o,this.n_random=1*o,this.Y=t||new PCA(r,i).transform(),this.knn=e||new BallTree(r.to2dArray,n);const{triplets:a,weights:h}=this._generate_triplets(this.n_inliers,this.n_outliers,this.n_random);return this.triplets=a,this.weights=h,this.lr=1e3*s/a.shape[0],this.C=1/0,this.vel=new Matrix(s,i,0),this.gain=new Matrix(s,i,1),this}
/**
     * Generates {@link n_inliers} x {@link n_outliers} x {@link n_random} triplets.
     * @param {Number} n_inliers
     * @param {Number} n_outliers
     * @param {Number} n_random
     */_generate_triplets(t,e,r){const{metric:s,weight_adj:i}=this._parameters,n=this.X,o=n.shape[0],a=this.knn,h=Math.min(t+20,o),l=new Matrix(o,h),_=new Matrix(o,h);for(let t=0;t<o;++t)a.search(n.row(t),h+1).raw_data().filter((t=>0!=t.value)).sort(((t,e)=>t.value-e.value)).forEach(((e,r)=>{l.set_entry(t,r,e.element.index),_.set_entry(t,r,e.value)}));
// scale parameter
const c=new Float64Array(o);for(let t=0;t<o;++t)c[t]=Math.max((_.entry(t,3)+_.entry(t,4)+_.entry(t,5)+_.entry(t,6))/4,1e-10);const u=this._find_p(_,c,l);let d=this._sample_knn_triplets(u,l,t,e),m=d.shape[0];const p=new Float64Array(m);for(let t=0;t<m;++t){const e=d.entry(t,0),r=d.entry(t,2);p[t]=s(n.row(e),n.row(r))}let f=this._find_weights(d,u,l,p,c);if(r>0){const{random_triplets:t,random_weights:e}=this._sample_random_triplets(n,r,c);d=d.concat(t,"vertical"),f=Float64Array.from([...f,...e])}m=d.shape[0];let y=-1/0;for(let t=0;t<m;++t)isNaN(f[t])&&(f[t]=0),y<f[t]&&(y=f[t]);let w=-1/0;for(let t=0;t<m;++t)f[t]/=y,f[t]+=1e-4,f[t]=Math.log(1+i*f[t]),w<f[t]&&(w=f[t]);for(let t=0;t<m;++t)f[t]/=w;return{triplets:d,weights:f}}
/**
     * Calculates the similarity matrix P
     * @private
     * @param {Matrix} knn_distances - matrix of pairwise knn distances
     * @param {Float64Array} sig - scaling factor for the distances
     * @param {Matrix} nbrs - nearest neighbors
     * @returns {Matrix} pairwise similarity matrix
     */_find_p(t,e,r){const[s,i]=t.shape;return new Matrix(s,i,((s,i)=>Math.exp(-(t.entry(s,i)**2)/e[s]/e[r.entry(s,i)])))}
/**
     * Sample nearest neighbors triplets based on the similarity values given in P.
     * @private
     * @param {Matrix} P - Matrix of pairwise similarities between each point and its neighbors given in matrix nbrs.
     * @param {Matrix} nbrs - Nearest neighbors indices for each point. The similarity values are given in matrix {@link P}. Row i corresponds to the i-th point.
     * @param {Number} n_inliers - Number of inlier points.
     * @param {Number} n_outliers - Number of outlier points.
     *
     */_sample_knn_triplets(t,e,r,s){const i=e.shape[0],n=new Matrix(i*r*s,3);for(let o=0;o<i;++o){let a=o*r*s;const h=this.__argsort(t.row(o).map((t=>-t)));for(let t=0;t<r;++t){let r=t*s;const l=e.entry(o,h[t]),_=this._rejection_sample(s,i,h.slice(0,t+1));for(let t=0;t<s;++t){const e=a+r+t,s=_[t];n.set_entry(e,0,o),n.set_entry(e,1,l),n.set_entry(e,2,s)}}}return n}
/**
     * Should do the same as np.argsort()
     * @private
     * @param {Array} A
     */__argsort(t){return t.map(((t,e)=>({d:t,i:e}))).sort(((t,e)=>t.d-e.d)).map((t=>t.i))}
/**
     * Samples {@link n_samples} integers from a given interval [0, {@link max_int}] while rejection the values that are in the {@link rejects}.
     * @private
     * @param {*} n_samples
     * @param {*} max_int
     * @param {*} rejects
     */_rejection_sample(t,e,r){const s=this._randomizer,i=linspace(0,e-1).filter((t=>r.indexOf(t)<0));return s.choice(i,Math.min(t,i.length-2))}
/**
     * Calculates the weights for the sampled nearest neighbors triplets
     * @private
     * @param {Matrix} triplets - Sampled Triplets.
     * @param {Matrix} P - Pairwise similarity matrix.
     * @param {Matrix} nbrs - nearest Neighbors
     * @param {Float64Array} outlier_distances - Matrix of pairwise outlier distances
     * @param {Float64Array} sig - scaling factor for the distances.
     */_find_weights(t,e,r,s,i){const n=t.shape[0],o=new Float64Array(n);for(let a=0;a<n;++a){const n=t.entry(a,0),h=r.row(n).indexOf(t.entry(a,1)),l=e.entry(n,h);let _=Math.exp(-(s[a]**2)/(i[n]*i[t.entry(a,2)]));_<1e-20&&(_=1e-20),o[a]=l/_}return o}
/**
     * Sample uniformly ranom triplets
     * @private
     * @param {Matrix} X - Data matrix.
     * @param {Number} n_random - Number of random triplets per point
     * @param {Float64Array} sig - Scaling factor for the distances
     */_sample_random_triplets(t,e,r){const s=this.parameter("metric"),i=this._randomizer,n=t.shape[0],o=new Matrix(n*e,3),a=new Float64Array(n*e);for(let h=0;h<n;++h){const l=h*e,_=[...linspace(0,h-1),...linspace(h+1,n-1)];for(let n=0;n<e;++n){let[e,c]=i.choice(_,2),u=Math.exp(-(s(t.row(h),t.row(e))**2)/(r[h]*r[e]));u<1e-20&&(u=1e-20);let d=Math.exp(-(s(t.row(h),t.row(c))**2)/(r[h]*r[c]));d<1e-20&&(d=1e-20),u<d&&([e,c]=[c,e],[u,d]=[d,u]);const m=l+n;o.set_entry(m,0,h),o.set_entry(m,1,e),o.set_entry(m,2,c),a[m]=u/d}}return{random_triplets:o,random_weights:a}}
/**
     * Computes the gradient for updating the embedding.
     * @param {Matrix} Y - The embedding
     */_grad(t){const e=this.n_inliers,r=this.n_outliers,s=this.triplets,i=this.weights,[n,o]=t.shape,a=s.shape[0],h=new Matrix(n,o,0);let l=new Float64Array(o),_=new Float64Array(o),c=1,u=1,d=0,m=0;const p=n*e*r;for(let e=0;e<a;++e){const[n,a,f]=s.row(e);
// update y_ij, y_ik, d_ij, d_ik
if(e%r==0||e>=p){c=1,u=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(a,e),i=t.entry(f,e);l[e]=r-s,_[e]=r-i,c+=l[e]**2,u+=_[e]**2}
// update y_ik and d_ik only
}else{u=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(f,e);_[e]=r-s,u+=_[e]**2}}c>u&&++d,m+=i[e]/(1+u/c);const y=(i[e]/(c+u))**2;for(let t=0;t<o;++t){const e=l[t]*u*y,r=_[t]*c*y;h.set_entry(n,t,h.entry(n,t)+e-r),h.set_entry(a,t,h.entry(a,t)-e),h.set_entry(f,t,h.entry(f,t)+r)}}return{grad:h,loss:m,n_viol:d}}
/**
     *
     * @param {Number} max_iteration
     */transform(t=400){this.check_init();for(let e=0;e<t;++e)this._next(e);return this.projection}
/**
     * @param {Number} max_iteration
     * @yields {Matrix}
     * @returns {Matrix}
     */*generator(t=800){this.check_init();for(let e=0;e<t;++e)this._next(e),yield this.projection;return this.projection}
/**
     * Does the iteration step.
     * @private
     * @param {Number} iter
     */_next(t){const e=t>150?.5:.3,r=this.C,s=this.vel,i=this.Y.add(s.mult(e)),{grad:n,loss:o,n_viol:a}=this._grad(i);return this.C=o,this.Y=this._update_embedding(i,t,n),this.lr*=r>o+this._parameters.tol?1.01:.9,this.Y}
/**
     * Updates the embedding.
     * @private
     * @param {Matrix} Y
     * @param {Number} iter
     * @param {Matrix} grad
     */_update_embedding(t,e,r){const[s,i]=t.shape,n=e>150?.9:.5,o=this.gain,a=this.vel,h=this.lr;for(let e=0;e<s;++e)for(let s=0;s<i;++s){const i=Math.sign(a.entry(e,s))!=Math.sign(r.entry(e,s))?o.entry(e,s)+.2:Math.max(.8*o.entry(e,s),.01);o.set_entry(e,s,i),a.set_entry(e,s,n*a.entry(e,s)-h*o.entry(e,s)*r.entry(e,s)),t.set_entry(e,s,t.entry(e,s)+a.entry(e,s))}return t}}
/**
 * @class
 * @alias Hierarchical_Clustering
 */class Hierarchical_Clustering{
/**
     * @constructor
     * @memberof module:clustering
     * @alias Hierarchical_Clustering
     * @todo needs restructuring.
     * @param {Matrix} - Data or distance matrix if metric is 'precomputed'
     * @param {("single"|"complete"|"average")} [linkage = "complete"]
     * @param {Function|"precomputed"} [metric = euclidean]
     * @returns {Hierarchical_Clustering}
     */
constructor(t,e="complete",r=euclidean){if(this._id=0,this._matrix=t instanceof Matrix?t:Matrix.from(t),this._metric=r,this._linkage=e,"precomputed"===r&&this._matrix.shape[0]!==this._matrix.shape[1])throw new Error("If metric is 'precomputed', then matrix has to be square!");return this.init(),this.root=this.do(),this}
/**
     *
     * @param {Number} value - value where to cut the tree.
     * @param {("distance"|"depth")} [type = "distance"] - type of value.
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}.
     */get_clusters(t,e="distance"){let r,s=[];switch(e){case"distance":r=t=>t.dist;break;case"depth":r=t=>t.depth;break;default:throw new Error("invalid type")}return this._traverse(this.root,r,t,s),s}
/**
     * @private
     * @param {} node
     * @param {*} f
     * @param {*} value
     * @param {*} result
     */_traverse(t,e,r,s){e(t)<=r?s.push(t.leaves()):(this._traverse(t.left,e,r,s),this._traverse(t.right,e,r,s))}
/**
     * computes the tree.
     */init(){const t=this._metric,e=this._matrix,r=this._n=e.shape[0],s=this._d_min=new Float64Array(r);let i;if("precomputed"!==t){i=new Matrix(r,r,0);//new Array(n);
for(let n=0;n<r;++n){s[n]=0;
//distance_matrix[i] = new Float64Array(n);
for(let o=0;o<r;++o)i.set_entry(n,o,n===o?1/0:t(e.row(n),e.row(o))),i.entry(n,s[n])>i.entry(n,o)&&(s[n]=o)}}else{i=this._matrix.clone();for(let t=0;t<r;++t)for(let e=0;e<r;++e)t===e?i.set_entry(t,e,1/0):i.entry(t,s[t])>i.entry(t,e)&&(s[t]=e)}this._distance_matrix=i;const n=this._clusters=new Array(r),o=this._c_size=new Uint16Array(r);for(let t=0;t<r;++t)n[t]=[],n[t][0]=new Cluster(this._id++,null,null,0,e.row(t),t,1,0),o[t]=1;return this}
/**
     * computes the tree.
     */do(){const t=this._n,e=this._d_min,r=this._distance_matrix,s=this._clusters,i=this._c_size,n=this._linkage;let o=null;for(let a=0,h=t-1;a<h;++a){let a=0;for(let s=0;s<t;++s){let i=r.entry(s,e[s]);for(let n=s+1;n<t;++n)i>r.entry(s,n)&&(e[s]=n,i=r.entry(s,e[s]))}for(let s=0;s<t;++s)r.entry(s,e[s])<r.entry(a,e[a])&&(a=s);let h=e[a],l=s[a][0],_=s[h][0],c=l.isLeaf?[l.index]:l.index,u=_.isLeaf?[_.index]:_.index,d=c.concat(u),m=new Cluster(this._id++,l,_,r.entry(a,h),null,d);l.parent=m,_.parent=m,s[a].unshift(m),i[a]+=i[h];for(let e=0;e<t;++e){const t=r.entry(a,e),s=r.entry(h,e);let o;switch(n){case"single":o=Math.min(t,s);break;case"complete":o=Math.max(t,s);break;case"average":o=(i[a]*t+i[h]*s)/(i[a]+i[e])}r.set_entry(e,a,o),r.set_entry(a,e,o)}r.set_entry(a,a,1/0);for(let e=0;e<t;++e)r.set_entry(e,h,1/0),r.set_entry(h,e,1/0);
/* for (let j = 0; j < n; ++j) {
                if (d_min[j] === c2) {
                    d_min[j] = c1;
                }
                if (D.entry(c1, j) < D.entry(c1, d_min[c1])) {
                    d_min[c1] = j;
                }
            } */o=m}return o}}class Cluster{constructor(t,e,r,s,i,n,o,a){return this.id=t,this.left=e,this.right=r,this.dist=s,this.index=n,this.size=o??e.size+r.size,this.depth=a??1+Math.max(e.depth,r.depth),this.centroid=i??this._calculate_centroid(e,r),this.parent=null,this}_calculate_centroid(t,e){const r=t.size,s=e.size,i=t.centroid,n=e.centroid,o=this.size,a=t.centroid.length,h=new Float64Array(a);for(let t=0;t<a;++t)h[t]=(r*i[t]+s*n[t])/o;return h}get isLeaf(){return 0===this.depth}leaves(){if(this.isLeaf)return[this];const t=this.left,e=this.right;return(t.isLeaf?[t]:t.leaves()).concat(e.isLeaf?[e]:e.leaves())}descendants(){if(this.isLeaf)return[this];const t=this.left.descendants(),e=this.right.descendants();return t.concat(e).concat([this])}}
/**
 * @class
 * @alias KMeans
 */class KMeans{
/**
     * @constructor
     * @memberof module:clustering
     * @alias KMeans
     * @todo needs restructuring. 
     * @param {Matrix} matrix 
     * @param {Numbers} K 
     * @param {Function} [metric = euclidean] 
     * @param {Number} [seed = 1987]
     * @param {Boolean} [init = true]
     * @returns {KMeans}
     */
constructor(t,e,r=euclidean,s=1987,i=!0){this._metric=r,this._matrix=t,this._K=e;const[n,o]=t.shape;return this._N=n,this._D=o,e>n&&(e=n),this._randomizer=new Randomizer(s),this._clusters=new Array(n).fill(void 0),this._cluster_centroids=this._get_random_centroids(e),i&&this.init(e,this._cluster_centroids),this}
/**
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. 
     */get_clusters(){const t=this._K,e=this._clusters,r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>r[t].push(e))),r}
/**
     * @private
     * @param {Array} points 
     * @param {Array} candidates 
     */_furthest_point(t,e){const r=this._matrix,s=this._metric;let i=t.length;return Heap.heapify(e,(e=>{const n=r.row(e);let o=0;for(let e=0;e<i;++e)o+=s(n,t[e]);return o}),"max").pop().element}_get_random_centroids(t){const e=this._N,r=this._randomizer,s=this._matrix,i=new Array(t).fill(),n=linspace(0,e-1),o=r.random_int%(e-1);i[0]=s.row(o);const a=[o],h=Math.floor((e-t)/t);// / K
for(let e=1;e<t;++e){
// sampling + kmeans++ improvement?
const t=r.choice(n.filter((t=>-1==a.indexOf(t))),h),o=this._furthest_point(i.slice(0,e),t);a.push(o),i[e]=s.row(o)}return i}_iteration(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._metric,o=this._clusters;let a=!1;
// find nearest cluster centroid.
for(let s=0;s<r;++s){const r=i.row(s);let h=1/0,l=null;for(let s=0;s<e;++s){let e=n(t[s],r);e<h&&(h=e,l=s)}o[s]!==l&&(a=!0),o[s]=l}
// update cluster centroid
// reset cluster centroids to 0
for(let r=0;r<e;++r){const e=t[r];for(let t=0;t<s;++t)e[t]=0}
// compute centroid
return this._compute_centroid(t),{clusters_changed:a,cluster_centroids:t}}_compute_centroid(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._clusters,o=new Array(e).fill(0);for(let e=0;e<r;++e){const r=i.row(e),a=n[e];o[a]++;const h=t[a];for(let t=0;t<s;++t)h[t]+=r[t]}for(let r=0;r<e;++r){const e=o[r];t[r]=t[r].map((t=>t/e))}}
/**
     * Computes {@link K} clusters out of the {@link matrix}.
     * @param {Number} K - number of clusters.
     */init(t,e){t||(t=this._K),e||(e=this._get_random_centroids(t));let r=!1;do{const t=this._iteration(e);e=t.cluster_centroids,r=t.clusters_changed}while(r)}}
/**
 * @class
 * @alias KMedoids
 */class KMedoids{
/**
     * @constructor
     * @memberof module:clustering
     * @alias KMedoids
     * @todo needs restructuring. 
     * @param {Matrix} matrix - data matrix
     * @param {Numbers} K - number of clusters
     * @param {number} [max_iter=null] - maximum number of iterations. Default is 10 * Math.log10(N)
     * @param {Function} [metric = euclidean] - metric defining the dissimilarity 
     * @param {Number} [seed = 1212] - seed value for random number generator
     * @returns {KMedoids}
     * @see {@link https://link.springer.com/chapter/10.1007/978-3-030-32047-8_16} Faster k-Medoids Clustering: Improving the PAM, CLARA, and CLARANS Algorithms
     */
constructor(t,e,r=null,s=euclidean,i=1212){this._metric=s,this._matrix=t,this._A=this._matrix.to2dArray,this._K=e;const[n,o]=t.shape;return this._N=n,this._D=o,this._max_iter=r||10*Math.log10(n),this._distance_matrix=new Matrix(n,n,"zeros"),
/* for (let i = 1; i < N; ++i) {
            for (let j = i + 1; j < N; ++j) {
                let dist = metric(this._A[i], this._A[j]);
                this._distance_matrix.set_entry(i, j, dist);
                this._distance_matrix.set_entry(j, i, dist)
            }
        } */
e>n&&(e=n),this._randomizer=new Randomizer(i),this._clusters=new Array(n).fill(void 0),this._cluster_medoids=this._get_random_medoids(e),
//if (init) this.init(K, this._cluster_medoids);
this._is_initialized=!1,this}
/**
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. 
     */get_clusters(){const t=this._K,e=this._A;this._is_initialized||this.init(t,this._cluster_medoids);const r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>{r[this._nearest_medoid(t,e).index_nearest].push(e)})),r.medoids=this._cluster_medoids,r}async*generator(){const t=this._max_iter;yield this.get_clusters();let e=!1,r=0;do{e=this._iteration(),yield this.get_clusters()}while(!e&&++r<t)}
/**
     * Algorithm 1. FastPAM1: Improved SWAP algorithm
     */
/* _iteration_1() {
        const A = this._A;
        const N = this._N;
        const K = this._K;
        const medoids = this._cluster_medoids;
        let DeltaTD = 0;
        let m0 = null;
        let x0 = null;
        A.forEach((x_j, j) => {
            if (medoids.findIndex(m => m === j) < 0) {
                const nearest_medoid = this._nearest_medoid(x_j, j);
                const d_j = nearest_medoid.distance_nearest; // distance to current medoid
                const deltaTD = new Array(K).fill(-d_j); // change if making j a medoid
                A.forEach((x_o, o) => {
                    // disance to new medoid
                    const d_oj = this._get_distance(o, j, x_o, x_j);
                    const {
                        "index_nearest": n,
                        "distance_nearest": d_n,
                        "distance_second": d_s,
                    } = this._nearest_medoid(x_o, o); 
                    this._clusters[o] = n; // cached values
                    deltaTD[n] += Math.min(d_oj, d_s) - d_n; // loss change
                    if (d_oj < d_n) { // reassignment check
                        deltaTD.forEach((d_i, i) => {
                            if (n !== i) {
                                deltaTD[i] = d_i + d_oj - d_n; // update loss change
                            }
                        });
                    }
                });
                // choose best medoid i;
                const i = deltaTD
                    .map((d, i) => [d, i])
                    .sort((d1, d2) => d1[0] - d2[0])[0][1];
                const deltaTD_i = deltaTD[i];
                // store
                if (deltaTD_i < DeltaTD) {
                    DeltaTD = deltaTD_i;
                    m0 = i;
                    x0 = j;
                }
            }
        });

        if (DeltaTD >= 0) {
            return true // break loop if DeltaTD >= 0
        }
        // swap roles of medoid m and non-medoid x;
        medoids[m0] = x0;
        this._cluster_medoids = medoids;
        return false
    } */
/** Algorithm 2. FastPAM2: SWAP with multiple candidates
     * 
     */_iteration(){const t=this._A,e=this._K,r=this._cluster_medoids,s=t.map(((t,e)=>this._nearest_medoid(t,e))),i=new Array(e).fill(0),n=new Array(e).fill(null);
// stop if no improvements were found
if(t.forEach(((o,a)=>{if(r.findIndex((t=>t===a))<0){const r=s[a].distance_nearest,h=new Array(e).fill(-r);// distance to current medoid
// change if making j a medoid
t.forEach(((t,r)=>{if(a===r)return;const i=this._get_distance(r,a,t,o),{index_nearest:n,distance_nearest:l,distance_second:_}=s[r];// distance to new medoid
// loss change for x_o
// Reassignment check
if(// cached
h[n]+=Math.min(i,_)-l,i<l)
// update loss change
for(let t=0;t<e;++t)t!==n&&(h[t]+=i-l)})),
// remember best swap for i;
h.map(((t,e)=>[t,e])).filter((([t,e])=>t<i[e])).forEach((([t,e])=>{t<i[e]&&(i[e]=t,n[e]=a)}))}})),min(i)>=0)return!0;
// execute all improvements
for(;min(i)<0;){
// swap roles of medoid m_i and non_medoid xs_i
const e=i.map(((t,e)=>[t,e])).sort((([t],[e])=>t-e))[0][1];0==r.filter((t=>t==n[e])).length&&(r[e]=n[e]),
// disable the swap just performed
i[e]=0,
// recompute TD for remaining swap candidates
i.map(((t,e)=>[t,e])).filter((([t])=>t<0)).forEach((([n,o])=>{const a=t[o];let h=0;t.forEach(((t,i)=>{r.findIndex((t=>t!=o&&t==i))>=0||e!=o&&(s[i].index_nearest===r[o]?h+=Math.min(this._get_distance(i,o,t,a),s[i].distance_second)-s[i].distance_nearest:h+=Math.min(this._get_distance(i,o,t,a)-s[i].distance_nearest,0))})),i[o]=h}))}return this._cluster_medoids=r,!1}_get_distance(t,e,r=null,s=null){if(t===e)return 0;const i=this._distance_matrix,n=this._A,o=this._metric;let a=i.entry(t,e);return 0===a&&(a=o(r||n[t],s||n[e]),i.set_entry(t,e,a),i.set_entry(e,t,a)),a}_nearest_medoid(t,e){const r=this._cluster_medoids,s=this._A,[i,n]=r.map(((r,i)=>{const n=s[r];return[this._get_distance(e,r,t,n),i]})).sort(((t,e)=>t[0]-e[0]));return{distance_nearest:i[0],index_nearest:i[1],distance_second:n[0],index_second:n[1]}}
/**
     * Computes {@link K} clusters out of the {@link matrix}.
     * @param {Number} K - number of clusters.
     */init(t,e){t||(t=this._K),e||(e=this._get_random_medoids(t));const r=this._max_iter;let s=!1,i=0;do{s=this._iteration()}while(!s&&++i<r);return this}
/**
     * Algorithm 3. FastPAM LAB: Linear Approximate BUILD initialization.
     * @param {number} K - number of clusters
     * 
     */_get_random_medoids(t){const e=this._N,r=this._A,s=linspace(0,e-1),i=this._randomizer,n=Math.min(e,10+Math.ceil(Math.sqrt(e))),o=new Array(n).fill(1/0),a=[];
// first medoid
let h=1/0,l=i.choice(s,n);for(let t=0;t<n;++t){const e=l[t],s=r[e];for(let e=0;e<n;++e){if(e===t)continue;const i=r[l[e]];o[t]+=this._get_distance(t,e,s,i)}o[t]<h&&(h=o[t],// smallest distance sum
a.push(e))}
// other medoids
for(let e=1;e<t;++e){let t=1/0;l=i.choice(s.filter((t=>a.findIndex((e=>e===t))<0)),n);for(let e=0;e<n;++e){let s=0;const i=l[e],o=r[i];for(let t=0;t<n;++t){if(t===e)continue;const n=l[t],h=r[n];let _=this._get_distance(i,n,o,h)-min(a.map((t=>this._get_distance(n,t,h))));_<0&&(s+=_)}
// best reduction
s<t&&(t=s,a.push(i))}h+=t}return a.slice(0,t)}}
/**
 * @class
 * @alias OPTICS
 */class OPTICS{
/**
     * **O**rdering **P**oints **T**o **I**dentify the **C**lustering **S**tructure.
     * @constructor
     * @memberof module:clustering
     * @alias OPTICS
     * @todo needs restructuring. 
     * @param {Matrix} matrix - the data.
     * @param {Number} epsilon - the minimum distance which defines whether a point is a neighbor or not.
     * @param {Number} min_points - the minimum number of points which a point needs to create a cluster. (Should be higher than 1, else each point creates a cluster.)
     * @param {Function} [metric = euclidean] - the distance metric which defines the distance between two points of the {@link matrix}.
     * @returns {OPTICS}
     * @see {@link https://www.dbs.ifi.lmu.de/Publikationen/Papers/OPTICS.pdf}
     * @see {@link https://en.wikipedia.org/wiki/OPTICS_algorithm}
     */
constructor(t,e,r,s=euclidean){return this._matrix=t,this._epsilon=e,this._min_points=r,this._metric=s,this._ordered_list=[],this._clusters=[],this._DB=new Array(t.shape[0]).fill(),this.init(),this}
/**
     * Computes the clustering.
     */init(){const t=this._ordered_list,e=this._matrix,r=e.shape[0],s=this._DB,i=this._clusters;let n=this._cluster_index=0;for(let t=0;t<r;++t)s[t]={element:e.row(t),index:t,reachability_distance:void 0,processed:!1};for(const e of s)if(!e.processed&&(e.neighbors=this._get_neighbors(e),e.processed=!0,i.push([e.index]),n=i.length-1,t.push(e),null!=this._core_distance(e))){const t=new Heap(null,(t=>t.reachability_distance),"min");this._update(e,t),this._expand_cluster(t,i[n])}return this}
/**
     * 
     * @private
     * @param {Object} p - a point of {@link matrix}.
     * @returns {Array} An array consisting of the {@link epsilon}-neighborhood of {@link p}.
     */_get_neighbors(t){if("neighbors"in t)return t.neighbors;const e=this._DB,r=this._metric,s=this._epsilon,i=[];for(const n of e)n.index!=t.index&&r(t.element,n.element)<s&&i.push(n);return i}
/**
     * 
     * @private
     * @param {Object} p - a point of {@link matrix}.
     * @returns {Number} The distance to the {@link min_points}-th nearest point of {@link p}, or undefined if the {@link epsilon}-neighborhood has fewer elements than {@link min_points}.
     */_core_distance(t){const e=this._min_points,r=this._metric;if(!(t.neighbors&&t.neighbors.length<=e))return r(t.element,t.neighbors[e].element)}
/**
     * Updates the reachability distance of the points.
     * @private
     * @param {Object} p 
     * @param {Heap} seeds 
     */_update(t,e){const r=this._metric,s=this._core_distance(t),i=this._get_neighbors(t);//p.neighbors;
for(const n of i){if(n.processed)continue;const i=Math.max(s,r(t.element,n.element));
//if (q.reachability_distance == undefined) { // q is not in seeds
e.raw_data().findIndex((t=>t.element==n))<0?(n.reachability_distance=i,e.push(n)):// q is in seeds
i<n.reachability_distance&&(n.reachability_distance=i,e=Heap.heapify(e.data(),(t=>t.reachability_distance),"min"))}}
/**
     * Expands the {@link cluster} with points in {@link seeds}.
     * @private
     * @param {Heap} seeds 
     * @param {Array} cluster 
     */_expand_cluster(t,e){const r=this._ordered_list;for(;!t.empty;){const s=t.pop().element;s.neighbors=this._get_neighbors(s),s.processed=!0,e.push(s.index),r.push(s),null!=this._core_distance(s)&&(this._update(s,t),this._expand_cluster(t,e))}}
/**
     * Returns an array of clusters.
     * @returns {Array<Array>} Array of clusters with the indices of the rows in given {@link matrix}.
     */get_clusters(){const t=[],e=[],r=this._min_points;for(const s of this._clusters)s.length<r?e.push(...s):t.push(s);return t.push(e),t}
/**
     * @returns {Array} Returns an array, where the ith entry defines the cluster affirmation of the ith point of {@link matrix}. (-1 stands for outlier)
     */get_cluster_affirmation(){const t=this._matrix.shape[0],e=new Array(t).fill(),r=this.get_clusters();for(let t=0,s=r.length;t<s;++t){const i=r[t];for(const r of i)e[r]=t<s-1?t:-1}return e}}
/**
 * @class
 * @alias LSP
 * @extends DR
 */class LSP extends DR{
/**
     * Least Squares Projection.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LSP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.neighbors = Math.max(Math.floor(N / 10), 2)] - number of neighbors to consider.
     * @param {Number} [parameters.control_points = Math.ceil(Math.sqrt(N))] - number of controlpoints
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {LSP}
     * @see {@link https://ieeexplore.ieee.org/document/4378370}
     * @todo accept precomputed distance matrix.
     */
constructor(t,e){return super(t,{neighbors:void 0,control_points:void 0,d:2,metric:euclidean,seed:1212},e),this.parameter("neighbors",Math.min(e.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this.parameter("control_points",Math.min(e.control_points??Math.ceil(Math.sqrt(this._N)),this._N-1)),this._is_initialized=!1,this}
/**
     *
     * @param {DR} DR - method used for position control points.
     * @param {Object} DR_parameters - Object containing parameters for the DR method which projects the control points
     * @returns {LSP}
     */init(t=MDS,e={},r=BallTree){if(this._is_initialized)return this;const s=this.X,i=this._N,n=this.parameter("neighbors"),o=this.parameter("d"),a=this.parameter("seed"),h=this.parameter("metric");e=Object.assign({d:o,metric:h,seed:a},e);const l=this.parameter("control_points"),_=new KMedoids(s,l,null,h).get_clusters().medoids,c=new Matrix(l,i,"zeros");_.forEach(((t,e)=>{c.set_entry(e,t,1)}));const u=new t(Matrix.from(_.map((t=>s.row(t)))),e).transform(),d=s.to2dArray,m=new r(d,h),p=new Matrix(i,i,"I"),f=-1/n;d.forEach(((t,e)=>{for(const{index:r}of m.search(t,n).iterate())e!==r&&p.set_entry(e,r,f)}));const y=p.concat(c,"vertical"),w=new Matrix(i,o,"zeros").concat(u,"vertical");return this._A=y,this._b=w,this._is_initialized=!0,this}
/**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */transform(){this.check_init();const t=this._A,e=t.T,r=this._b,s=e.dot(t),i=e.dot(r);return this.Y=Matrix.solve_CG(s,i,this._randomizer),this.projection}}
/**
 * @class
 * @alias TopoMap
 * @memberof module:dimensionality_reduction
 * @extends DR
 */class TopoMap extends DR{
/**
     * TopoMap: A 0-dimensional Homology Preserving Projection of High-Dimensional Data.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TopoMap
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {TopoMap}
     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}
     */
constructor(t,e){return super(t,{metric:euclidean,seed:1212},e),[this._N,this._D]=this.X.shape,this._distance_matrix=new Matrix(this._N,this._N,0),this}
/**
     * @private
     */__lazy_distance_matrix(t,e,r){const s=this._distance_matrix,i=this.X,n=s.entry(t,e);if(0===n){let n=r(i.row(t),i.row(e));return s.set_entry(t,e,n),s.set_entry(e,t,n),n}return n}
/**
     * Computes the minimum spanning tree, using a given metric
     * @private
     * @param {Function} metric
     * @see {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}
     */_make_minimum_spanning_tree(t=euclidean){const e=this._N,r=[...this.X];let s=new DisjointSet(r);const i=[];let n=[];for(let r=0;r<e;++r)for(let s=r+1;s<e;++s)n.push([r,s,this.__lazy_distance_matrix(r,s,t)]);n=n.sort(((t,e)=>t[2]-e[2]));for(const[t,e,o]of n){const n=s.find(r[t]),a=s.find(r[e]);n!==a&&(i.push([t,e,o]),s.union(n,a))}return i.sort(((t,e)=>t[2]-e[2]))}
/**
     * initializes TopoMap. Sets all projcted points to zero, and computes a minimum spanning tree.
     */init(){const{metric:t}=this._parameters;return this.Y=new Matrix(this._N,2,0),this._Emst=this._make_minimum_spanning_tree(t),this._is_initialized=!0,this}
/**
     * Returns true if Point C is left of line AB.
     * @private
     * @param {Array} PointA - Point A of line AB
     * @param {Array} PointB - Point B of line AB
     * @param {Array} PointC - Point C
     * @returns {Boolean}
     */__hull_cross([t,e],[r,s],[i,n]){return(r-t)*(n-e)-(s-e)*(i-t)<=0}
/**
     * Computes the convex hull of the set of Points S
     * @private
     * @param {Array} S - Set of Points.
     * @see {@link https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript}
     * @returns {Array} convex hull of S. Starts at the bottom-most point and continues counter-clockwise.
     */__hull(t){const e=t.sort((([t,e],[r,s])=>e-s||t-r)),r=e.length;if(r<=2)return e;const s=[];for(let t=0;t<r;++t){for(;s.length>=2&&this.__hull_cross(s[s.length-2],s[s.length-1],e[t]);)s.pop();s.push(e[t])}const i=[];for(let t=r-1;t>=0;--t){for(;i.length>=2&&this.__hull_cross(i[i.length-2],i[i.length-1],e[t]);)i.pop();i.push(e[t])}return i.pop(),s.pop(),s.concat(i)}
/**
     * Finds the angle to rotate Point A and B to lie on a line parallel to the x-axis.
     * @private
     * @param {Array} PointA
     * @param {Array} PointB
     * @return {Object} Object containing the sinus- and cosinus-values for a rotation.
     */__findAngle([t,e],[r,s]){const i=euclidean([t,e],[r,s]);if(0===i)return{sin:0,cos:1};const n=[(r-t)/i,(s-e)/i],o=n[0];let a=Math.sqrt(1-o*o);return a=n[1]>=0?-a:a,{sin:a,cos:o}}
/**
     * @private
     * @param {Array} hull
     * @param {Array} p
     * @param {Bool} topEdge
     */__align_hull(t,e,r){let s,i,n,o=-1;for(let r=0;r<t.length;++r){const i=euclidean(t[r],e);(-1===o||s>i)&&(s=i,o=r)}r?(i=t[o],n=t[(o+1)%t.length]):(0==o&&(o=t.length-1),i=t[o],n=t[(o-1)%t.length]);const a={tx:-t[o][0],ty:-t[o][1]};if(t.length>=2){const{sin:t,cos:e}=this.__findAngle(i,n);a.sin=t,a.cos=e}else a.sin=0,a.cos=1;return a}
/**
     * @private
     * @param {Array} Point - The point which should get transformed.
     * @param {Object} Transformation - contains the values for translation and rotation.
     */__transform([t,e],{tx:r,ty:s,sin:i,cos:n}){let o=t+r,a=e+s;return[o*n-a*i,o*i+a*n]}
/**
     * Calls {@link __transform} for each point in Set C
     * @private
     * @param {Array} C - Set of points.
     * @param {Object} t - Transform object.
     * @param {Number} yOffset - value to offset set C.
     */__transform_component(t,e,r){const s=t.length;for(let i=0;i<s;++i){const s=t[i],[n,o]=this.__transform(s,e);s[0]=n,s[1]=o+r}}
/**
     * @private
     * @param {Array} u - point u
     * @param {Array} v - point v
     * @param {Number} w - edge weight w
     */__align_components(t,e,r){const s=[...t.__disjoint_set.children],i=[...e.__disjoint_set.children],n=this.__hull(s),o=this.__hull(i),a=this.__align_hull(n,t,!1),h=this.__align_hull(o,e,!0);this.__transform_component(s,a,0),this.__transform_component(i,h,r)}
/**
     * Transforms the inputdata {@link X} to dimensionality 2.
     */transform(){this._is_initialized||this.init();const t=this._Emst,e=this.Y.to2dArray,r=new DisjointSet(e.map(((t,e)=>(t.i=e,t))));for(const[s,i,n]of t){const t=r.find(e[s]),o=r.find(e[i]);t!==o&&(this.__align_components(t,o,n),r.union(t,o))}return this.projection}*generator(){this._is_initialized||this.init();const t=this._Emst,e=this.Y.to2dArray,r=new DisjointSet(e.map(((t,e)=>(t.i=e,t))));for(const[s,i,n]of t){const t=r.find(e[s]),o=r.find(e[i]);t!==o&&(this.__align_components(t,o,n),r.union(t,o),yield this.projection)}return this.projection}}
/**
 * @class
 * @alias SAMMON
 * @extends DR
 */class SAMMON extends DR{
/**
     * SAMMON's Mapping
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias SAMMON
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {"PCA"|"MDS"|"random"} [parameters.init = "random"] - Either "PCA" or "MDS", with which SAMMON initialiates the projection. With "random" a random matrix gets used as starting point.
     * @param {Object} [parameters.init_parameters] - Parameters for the {@link init}-DR method.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {SAMMON}
     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}
     */
constructor(t,e){return super(t,{magic:.1,d:2,metric:euclidean,seed:1212,init_DR:"random",init_parameters:{}},e),this}
/**
     * initializes the projection.
     * @private
     */init(){const t=this.X.shape[0],{d:e,metric:r,init_DR:s,init_parameters:i}=this._parameters;if("random"===s){const r=this._randomizer;this.Y=new Matrix(t,e,(()=>r.random))}else{if(!["PCA","MDS"].includes(s))throw new Error('init_DR needs to be either "random" or a DR method!');this.Y=Matrix.from("PCA"==s?PCA.transform(this.X,i):MDS.transform(this.X,i))}return this.distance_matrix="precomputed"==r?Matrix.from(this.X):distance_matrix(this.X,r),this}
/**
     * Transforms the inputdata {@link X} to dimenionality 2.
     * @param {Number} [max_iter=200] - Maximum number of iteration steps.
     * @returns {Matrix|Array} - The projection of {@link X}.
     */transform(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step();return this.projection}
/**
     * Transforms the inputdata {@link X} to dimenionality 2.
     * @param {Number} [max_iter=200] - Maximum number of iteration steps.
     * @returns {Generator} - A generator yielding the intermediate steps of the projection of {@link X}.
     */*generator(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step(),yield this.projection;return this.projection}_step(){const t=this.parameter("magic"),e=this.distance_matrix,r=this.X.shape[0],{d:s,metric:i}=this._parameters;let n=this.Y,o=new Matrix(r,s,0),a=new Float64Array(s);for(let h=0;h<r;++h){let l=new Float64Array(s),_=new Float64Array(s);const c=n.row(h);for(let t=0;t<r;++t){if(h===t)continue;const r=n.row(t),o=new Float64Array(s);for(let t=0;t<s;++t)o[t]=c[t]-r[t];const a=i(c,r),u=e.entry(h,t),d=u-a,m=Math.max(u*a,.01);for(let t=0;t<s;++t)l[t]+=o[t]*d/m,_[t]+=(d-Math.pow(o[t],2)*(1+d/a)/a)/m}for(let e=0;e<s;++e){const r=n.entry(h,e)+(t*l[e]/Math.abs(_[e])||0);o.set_entry(h,e,r),a[e]+=r}}for(let t=0;t<s;++t)a[t]/=r;for(let t=0;t<r;++t)for(let e=0;e<s;++e)n.set_entry(t,e,o.entry(t,e)-a[e]);return n}}var t="0.5.1";export{BallTree,DisjointSet,FASTMAP,Heap,Hierarchical_Clustering,ISOMAP,KMeans,KMedoids,KNN,LDA,LLE,LSP,LTSA,MDS,Matrix,OPTICS,PCA,Randomizer,SAMMON,TSNE,TopoMap,TriMap,UMAP,canberra,chebyshev,cosine,distance_matrix,euclidean,euclidean_squared,hamming,inner_product,jaccard,k_nearest_neighbors,kahan_sum,linspace,manhattan,max,min,neumair_sum,norm,normalize,powell,qr_gramschmidt as qr,qr_householder,simultaneous_poweriteration,sokal_michener,t as version,yule};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJ1aWQuZXNtLmpzIiwic291cmNlcyI6WyIuLi9tZXRyaWNzL2V1Y2xpZGVhbi5qcyIsIi4uL251bWVyaWNhbC9rYWhhbl9zdW0uanMiLCIuLi9udW1lcmljYWwvbmV1bWFpcl9zdW0uanMiLCIuLi9tZXRyaWNzL2V1Y2xpZGVhbl9zcXVhcmVkLmpzIiwiLi4vbWV0cmljcy9jb3NpbmUuanMiLCIuLi9tZXRyaWNzL21hbmhhdHRhbi5qcyIsIi4uL21ldHJpY3MvY2hlYnlzaGV2LmpzIiwiLi4vbWV0cmljcy9jYW5iZXJyYS5qcyIsIi4uL21ldHJpY3MvamFjY2FyZC5qcyIsIi4uL21ldHJpY3MvaGFtbWluZy5qcyIsIi4uL21ldHJpY3Mvc29rYWxfbWljaGVuZXIuanMiLCIuLi9tZXRyaWNzL3l1bGUuanMiLCIuLi9tYXRyaXgva19uZWFyZXN0X25laWdoYm9ycy5qcyIsIi4uL21hdHJpeC9kaXN0YW5jZV9tYXRyaXguanMiLCIuLi9tYXRyaXgvbGluc3BhY2UuanMiLCIuLi9tYXRyaXgvbm9ybS5qcyIsIi4uL21hdHJpeC9ub3JtYWxpemUuanMiLCIuLi9saW5lYXJfYWxnZWJyYS9xci5qcyIsIi4uL2xpbmVhcl9hbGdlYnJhL3FyX2hvdXNlaG9sZGVyLmpzIiwiLi4vbGluZWFyX2FsZ2VicmEvc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uLmpzIiwiLi4vbGluZWFyX2FsZ2VicmEvaW5uZXJfcHJvZHVjdC5qcyIsIi4uL21hdHJpeC9NYXRyaXguanMiLCIuLi91dGlsL3JhbmRvbWl6ZXIuanMiLCIuLi91dGlsL21heC5qcyIsIi4uL3V0aWwvbWluLmpzIiwiLi4vZGF0YXN0cnVjdHVyZS9IZWFwLmpzIiwiLi4vZGF0YXN0cnVjdHVyZS9EaXNqb2ludFNldC5qcyIsIi4uL2tubi9CYWxsVHJlZS5qcyIsIi4uL2tubi9LTk4uanMiLCIuLi9kaW1yZWQvRFIuanMiLCIuLi9kaW1yZWQvUENBLmpzIiwiLi4vZGltcmVkL01EUy5qcyIsIi4uL2RpbXJlZC9JU09NQVAuanMiLCIuLi9kaW1yZWQvRkFTVE1BUC5qcyIsIi4uL2RpbXJlZC9MREEuanMiLCIuLi9kaW1yZWQvTExFLmpzIiwiLi4vZGltcmVkL0xUU0EuanMiLCIuLi9kaW1yZWQvVFNORS5qcyIsIi4uL29wdGltaXphdGlvbi9wb3dlbGwuanMiLCIuLi9kaW1yZWQvVU1BUC5qcyIsIi4uL2RpbXJlZC9UcmlNYXAuanMiLCIuLi9jbHVzdGVyaW5nL0hpZXJhcmNoaWNhbF9DbHVzdGVyaW5nLmpzIiwiLi4vY2x1c3RlcmluZy9LTWVhbnMuanMiLCIuLi9jbHVzdGVyaW5nL0tNZWRvaWRzLmpzIiwiLi4vY2x1c3RlcmluZy9PUFRJQ1MuanMiLCIuLi9kaW1yZWQvTFNQLmpzIiwiLi4vZGltcmVkL1RvcG9NYXAuanMiLCIuLi9kaW1yZWQvU0FNTU9OLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV1Y2xpZGVhbl9zcXVhcmVkIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIGV1Y2xpZGVhbiBkaXN0YW5jZSAobDxzdWI+Mjwvc3ViPikgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGV1Y2xpZGVhblxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGV1Y2xpZGVhbl9zcXVhcmVkKGEsIGIpKTtcbn1cbiIsIi8qKlxuICogTnVtZXJpY2FsIHN0YWJsZSBzdW1tYXRpb24gd2l0aCB0aGUgS2FoYW4gc3VtbWF0aW9uIGFsZ29yaXRobS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bnVtZXJpY2FsXG4gKiBAYWxpYXMga2FoYW5fc3VtXG4gKiBAcGFyYW0ge0FycmF5fSBzdW1tYW5kcyAtIEFycmF5IG9mIHZhbHVlcyB0byBzdW0gdXAuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3VtLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2FoYW5fc3VtbWF0aW9uX2FsZ29yaXRobX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN1bW1hbmRzKSB7XG4gICAgbGV0IG4gPSBzdW1tYW5kcy5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IGNvbXBlbnNhdGlvbiA9IDA7XG4gICAgbGV0IHksIHQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICB5ID0gc3VtbWFuZHNbaV0gLSBjb21wZW5zYXRpb247XG4gICAgICAgIHQgPSBzdW0gKyB5O1xuICAgICAgICBjb21wZW5zYXRpb24gPSB0IC0gc3VtIC0geTtcbiAgICAgICAgc3VtID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cbiIsIi8qKlxuICogTnVtZXJpY2FsIHN0YWJsZSBzdW1tYXRpb24gd2l0aCB0aGUgTmV1bWFpciBzdW1tYXRpb24gYWxnb3JpdGhtLlxuICogQG1lbWJlcm9mIG1vZHVsZTpudW1lcmljYWxcbiAqIEBhbGlhcyBuZXVtYWlyX3N1bVxuICogQHBhcmFtIHtBcnJheX0gc3VtbWFuZHMgLSBBcnJheSBvZiB2YWx1ZXMgdG8gc3VtIHVwLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIHN1bS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0thaGFuX3N1bW1hdGlvbl9hbGdvcml0aG0jRnVydGhlcl9lbmhhbmNlbWVudHN9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzdW1tYW5kcykge1xuICAgIGxldCBuID0gc3VtbWFuZHMubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGxldCBjb21wZW5zYXRpb24gPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbGV0IHN1bW1hbmQgPSBzdW1tYW5kc1tpXTtcbiAgICAgICAgbGV0IHQgPSBzdW0gKyBzdW1tYW5kO1xuICAgICAgICBpZiAoTWF0aC5hYnMoc3VtKSA+PSBNYXRoLmFicyhzdW1tYW5kKSkge1xuICAgICAgICAgICAgY29tcGVuc2F0aW9uICs9IHN1bSAtIHQgKyBzdW1tYW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcGVuc2F0aW9uICs9IHN1bW1hbmQgLSB0ICsgc3VtO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHQ7XG4gICAgfVxuICAgIHJldHVybiBzdW0gKyBjb21wZW5zYXRpb247XG59XG4iLCJpbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkZWFuIGRpc3RhbmNlIChsPHN1Yj4yPC9zdWI+PHN1cD4yPC9zdXA+KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgZXVjbGlkZWFuX3NxdWFyZWRcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgc3F1YXJlZCBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgcyA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBsZXQgeCA9IGFbaV07XG4gICAgICAgIGxldCB5ID0gYltpXTtcbiAgICAgICAgc1tpXSA9ICh4IC0geSkgKiAoeCAtIHkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV1bWFpcl9zdW0ocyk7XG59XG4iLCIvKipcbiAqIENvbXB1dGVzIHRoZSBjb3NpbmUgZGlzdGFuY2UgKG5vdCBzaW1pbGFyaXR5KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgY29zaW5lXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYlxuICogQGV4YW1wbGVcbiAqIGRydWlkLmNvc2luZShbMSwwXSxbMSwxXSkgPT0gMC43ODUzOTgxNjMzOTc0NDg0ID09IM+ALzRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBjb3NpbmUgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IHN1bV9hID0gMDtcbiAgICBsZXQgc3VtX2IgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHN1bSArPSBhW2ldICogYltpXTtcbiAgICAgICAgc3VtX2EgKz0gYVtpXSAqIGFbaV07XG4gICAgICAgIHN1bV9iICs9IGJbaV0gKiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5hY29zKHN1bSAvIChNYXRoLnNxcnQoc3VtX2EpICogTWF0aC5zcXJ0KHN1bV9iKSkpO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgbWFuaGF0dGFuIGRpc3RhbmNlIChsPHN1Yj4xPC9zdWI+KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgbWFuaGF0dGFuXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYlxuICogQHJldHVybnMge051bWJlcn0gdGhlIG1hbmhhdHRhbiBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovIFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBzdW0gKz0gTWF0aC5hYnMoYVtpXSAtIGJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgY2hlYnlzaGV2IGRpc3RhbmNlIChMPHN1Yj7iiJ48L3N1Yj4pIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1ldHJpY3NcbiAqIEBhbGlhcyBjaGVieXNoZXZcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY2hlYnlzaGV2IGRpc3RhbmNlIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKE1hdGguYWJzKGFbaV0gLSBiW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCguLi5yZXMpO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgY2FuYmVycmEgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGNhbmJlcnJhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGEgXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGIgXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgY2FuYmVycmEgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbmJlcnJhX2Rpc3RhbmNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgbiA9IGEubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHN1bSArPSAoTWF0aC5hYnMoYVtpXSAtIGJbaV0pIC8gKE1hdGguYWJzKGFbaV0pICsgTWF0aC5hYnMoYltpXSkpKVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufSIsIi8qKlxuICogQ29tcHV0ZXMgdGhlIGphY2NhcmQgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGphY2NhcmRcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgamFjY2FyZCBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IG51bV9ub25femVybyA9IDA7XG4gICAgbGV0IG51bV9lcXVhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY29uc3QgeCA9IGFbaV0gIT0gMDtcbiAgICAgICAgY29uc3QgeSA9IGJbaV0gIT0gMDtcbiAgICAgICAgbnVtX25vbl96ZXJvICs9IHggfHwgeTtcbiAgICAgICAgbnVtX2VxdWFsICs9IHggJiYgeTtcbiAgICB9XG4gICAgcmV0dXJuIChudW1fbm9uX3plcm8gLSBudW1fZXF1YWwpIC8gbnVtX25vbl96ZXJvO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgaGFtbWluZyBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgaGFtbWluZ1xuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBoYW1taW5nIGRpc3RhbmNlIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgZGlzYWdyZWUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IHggPSBhW2ldO1xuICAgICAgICBjb25zdCB5ID0gYltpXTtcbiAgICAgICAgZGlzYWdyZWUgKz0geCAhPSB5O1xuICAgIH1cbiAgICByZXR1cm4gZGlzYWdyZWUgLyBuO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgU29rYWwtTWljaGVuZXIgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIHNva2FsX21pY2hlbmVyXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGEgXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGIgXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgU29rYWwtTWljaGVuZXIgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS4gIFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgY29uc3QgbiA9IGEubGVuZ3RoO1xuICAgIGxldCBudW1fbm90X2VxdWFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCB4ID0gYVtpXSAhPSAwO1xuICAgICAgICBjb25zdCB5ID0gYltpXSAhPSAwO1xuICAgICAgICBudW1fbm90X2VxdWFsICs9IHggIT0geTtcbiAgICB9XG4gICAgcmV0dXJuICgyICogbnVtX25vdF9lcXVhbCkgLyAobiArIG51bV9ub3RfZXF1YWwpO1xufSIsIi8qKlxuICogQ29tcHV0ZXMgdGhlIHl1bGUgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIHl1bGVcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgeXVsZSBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IG51bV90cnVlX3RydWUgPSAwO1xuICAgIGxldCBudW1fdHJ1ZV9mYWxzZSA9IDA7XG4gICAgbGV0IG51bV9mYWxzZV90cnVlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCB4ID0gYVtpXSAhPSAwO1xuICAgICAgICBjb25zdCB5ID0gYltpXSAhPSAwO1xuICAgICAgICBudW1fdHJ1ZV90cnVlICs9IHggJiYgeTtcbiAgICAgICAgbnVtX3RydWVfZmFsc2UgKz0geCAmJiAheTtcbiAgICAgICAgbnVtX2ZhbHNlX3RydWUgKz0gIXggJiYgeDtcbiAgICB9XG4gICAgY29uc3QgbnVtX2ZhbHNlX2ZhbHNlID0gbiAtIG51bV90cnVlX3RydWUgLSBudW1fdHJ1ZV9mYWxzZSAtIG51bV9mYWxzZV90cnVlO1xuICAgIHJldHVybiBudW1fdHJ1ZV9mYWxzZSA9PSAwIHx8IG51bV9mYWxzZV90cnVlID09IDAgPyAwIDogKDIgKiBudW1fdHJ1ZV9mYWxzZSAqIG51bV9mYWxzZV90cnVlKSAvIChudW1fdHJ1ZV90cnVlICogbnVtX2ZhbHNlX2ZhbHNlICsgbnVtX3RydWVfZmFsc2UgKiBudW1fZmFsc2VfdHJ1ZSk7XG59XG4iLCJpbXBvcnQgeyBkaXN0YW5jZV9tYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBrLW5lYXJlc3QgbmVpZ2hib3JzIG9mIGVhY2ggcm93IG9mIHtAbGluayBBfS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWF0cml4XG4gKiBAYWxpYXMga19uZWFyZXN0X25laWdiaG9yc1xuICogQHBhcmFtIHtNYXRyaXh9IEEgLSBFaXRoZXIgdGhlIGRhdGEgbWF0cml4LCBvciBhIGRpc3RhbmNlIG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBrIC0gVGhlIG51bWJlciBvZiBuZWlnaGJvcnMgdG8gY29tcHV0ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbbWV0cmljPWV1Y2xpZGVhbl1cbiAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSAtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChBLCBrLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICBjb25zdCByb3dzID0gQS5zaGFwZVswXTtcbiAgICBsZXQgRCA9IG1ldHJpYyA9PSBcInByZWNvbXB1dGVkXCIgPyBBIDogZGlzdGFuY2VfbWF0cml4KEEsIG1ldHJpYyk7XG4gICAgbGV0IG5OID0gbmV3IEFycmF5KHJvd3MpO1xuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgIG5OW3Jvd10gPSBBcnJheS5mcm9tKEQucm93KHJvdykpXG4gICAgICAgICAgICAubWFwKChkaXN0YW5jZSwgY29sKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaTogcm93LFxuICAgICAgICAgICAgICAgICAgICBqOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZSlcbiAgICAgICAgICAgIC5zbGljZSgxLCBrICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBuTjtcbn1cbiIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBtYXRyaXggb2YgZGF0YW1hdHJpeCB7QGxpbmsgQX0uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1hdHJpeFxuICogQGFsaWFzIGRpc3RhbmNlX21hdHJpeFxuICogQHBhcmFtIHtNYXRyaXh9IEEgLSBNYXRyaXguXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljPWV1Y2xpZGVhbl0gLSBUaGUgZGlpc3RhbmNlIG1ldHJpYy5cbiAqIEByZXR1cm5zIHtNYXRyaXh9IEQgLSBUaGUgZGlzdGFuY2UgbWF0cml4IG9mIHtAbGluayBBfS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKEEsIG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgIGxldCBuID0gQS5zaGFwZVswXTtcbiAgICBjb25zdCBEID0gbmV3IE1hdHJpeChuLCBuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCBBX2kgPSBBLnJvdyhpKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gbWV0cmljKEFfaSwgQS5yb3coaikpO1xuICAgICAgICAgICAgRC5zZXRfZW50cnkoaSwgaiwgZGlzdCk7XG4gICAgICAgICAgICBELnNldF9lbnRyeShqLCBpLCBkaXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRDtcbn1cbiIsIi8qKlxuICogQ3JlYXRlcyBhbiBBcnJheSBjb250YWluaW5nIHtAbGluayBudW1iZXJ9IG51bWJlcnMgZnJvbSB7QGxpbmsgc3RhcnR9IHRvIHtAbGluayBlbmR9LlxuICogSWYgPGNvZGU+e0BsaW5rIG51bWJlcn0gPSBudWxsPC9udWxsPi5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWF0cml4XG4gKiBAYWxpYXMgbGluc3BhY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCAtIFN0YXJ0IHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCAtIEVuZCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbnVtYmVyID0gbnVsbF0gLSBOdW1iZXIgb2YgbnVtYmVyIGJldHdlZW4ge0BsaW5rIHN0YXJ0fSBhbmQge0BsaW5rIGVuZH0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgd2l0aCB7QGxpbmsgbnVtYmVyfSBlbnRyaWVzLCBiZWdpbm5pbmcgYXQge0BsaW5rIHN0YXJ0fSBlbmRpbmcgYXQge0BsaW5rIGVuZH0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBudW1iZXIgPSBudWxsKSB7XG4gICAgaWYgKCFudW1iZXIpIHtcbiAgICAgICAgbnVtYmVyID0gTWF0aC5tYXgoTWF0aC5yb3VuZChlbmQgLSBzdGFydCkgKyAxLCAxKTtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDIpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlciA9PT0gMSA/IFtzdGFydF0gOiBbXTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBBcnJheShudW1iZXIpO1xuICAgIG51bWJlciAtPSAxO1xuICAgIGZvciAobGV0IGkgPSBudW1iZXI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IChpICogZW5kICsgKG51bWJlciAtIGkpICogc3RhcnQpIC8gbnVtYmVyO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbi8vaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4XCI7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG5vcm0gb2YgYSB2ZWN0b3IsIGJ5IGNvbXB1dGluZyBpdHMgZGlzdGFuY2UgdG8gKiowKiouXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1hdHJpeFxuICogQGFsaWFzIG5vcm1cbiAqIEBwYXJhbSB7TWF0cml4fEFycmF5PE51bWJlcj58RmxvYXQ2NEFycmF5fSB2IC0gVmVjdG9yLiBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gV2hpY2ggbWV0cmljIHNob3VsZCBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIG5vcm0uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBub3JtIG9mIHtAbGluayB2fS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHYsIG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgIGxldCB2ZWN0b3IgPSBudWxsO1xuICAgIGlmICh2IGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgIGxldCBbcm93cywgY29sc10gPSB2LnNoYXBlO1xuICAgICAgICBpZiAocm93cyA9PT0gMSkgdmVjdG9yID0gdi5yb3coMCk7XG4gICAgICAgIGVsc2UgaWYgKGNvbHMgPT09IDEpIHZlY3RvciA9IHYuY29sKDApO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIk1hdHJpeCBtdXN0IGJlIDFkIVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2ZWN0b3IgPSB2O1xuICAgIH1cbiAgICBjb25zdCBuID0gdmVjdG9yLmxlbmd0aDtcbiAgICBjb25zdCB6ZXJvcyA9IEZsb2F0NjRBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sICgpID0+IDApO1xuICAgIHJldHVybiBtZXRyaWModmVjdG9yLCB6ZXJvcyk7XG59XG4iLCJpbXBvcnQgeyBub3JtIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5cbi8qKlxuICogTm9ybWFsaXplcyBWZWN0b3Ige0BsaW5rIHZ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptYXRyaXhcbiAqIEBhbGlhcyBub3JtYWxpemVcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPnxGbG9hdDY0QXJyYXl9IHYgLSBWZWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldHJpYyBcbiAqIEByZXR1cm5zIHtBcnJheTxOdW1iZXI+fEZsb2F0NjRBcnJheX0gLSBUaGUgbm9ybWFsaXplZCB2ZWN0b3Igd2l0aCBsZW5ndGggMS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odiwgbWV0cmljID0gZXVjbGlkZWFuKSAge1xuICAgIGNvbnN0IHZfbm9ybSA9IG5vcm0odiwgbWV0cmljKTtcbiAgICByZXR1cm4gdi5tYXAodmFsdWUgPT4gdmFsdWUgLyB2X25vcm0pO1xufSIsImltcG9ydCB7IE1hdHJpeCwgbm9ybSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUVIgRGVjb21wb3NpdGlvbiBvZiB0aGUgTWF0cml4IHtAbGluayBBfSB1c2luZyBHcmFtLVNjaG1pZHQgcHJvY2Vzcy5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bGluZWFyX2FsZ2VicmFcbiAqIEBhbGlhcyBxclxuICogQHBhcmFtIHtNYXRyaXh9IEFcbiAqIEByZXR1cm5zIHt7UjogTWF0cml4LCBROiBNYXRyaXh9fVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUVJfZGVjb21wb3NpdGlvbiNVc2luZ190aGVfR3JhbSVFMiU4MCU5M1NjaG1pZHRfcHJvY2Vzc31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKEEpIHtcbiAgICBjb25zdCBbcm93cywgY29sc10gPSBBLnNoYXBlO1xuICAgIGNvbnN0IFEgPSBuZXcgTWF0cml4KHJvd3MsIGNvbHMsIFwiaWRlbnRpdHlcIik7XG4gICAgY29uc3QgUiA9IG5ldyBNYXRyaXgoY29scywgY29scywgMCk7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7ICsraikge1xuICAgICAgICBsZXQgdiA9IEEuY29sKGopO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGo7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcSA9IFEuY29sKGkpO1xuICAgICAgICAgICAgY29uc3QgcV9kb3RfdiA9IG5ldW1haXJfc3VtKHEubWFwKChxXywgaykgPT4gcV8gKiB2W2tdKSk7XG4gICAgICAgICAgICBSLnNldF9lbnRyeShpLCBqLCBxX2RvdF92KTtcbiAgICAgICAgICAgIHYgPSB2Lm1hcCgodl8sIGspID0+IHZfIC0gcV9kb3RfdiAqIHFba10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZfbm9ybSA9IG5vcm0odiwgZXVjbGlkZWFuKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3dzOyArK2spIHtcbiAgICAgICAgICAgIFEuc2V0X2VudHJ5KGssIGosIHZba10gLyB2X25vcm0pO1xuICAgICAgICB9XG4gICAgICAgIFIuc2V0X2VudHJ5KGosIGosIHZfbm9ybSk7XG4gICAgfVxuICAgIHJldHVybiB7IFIsIFEgfTtcbn1cbiIsImltcG9ydCB7IE1hdHJpeCwgbm9ybSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUVIgRGVjb21wb3NpdGlvbiBvZiB0aGUgTWF0cml4IHtAbGluayBBfSB3aXRoIGhvdXNlaG9sZGVyIHRyYW5zZm9ybWF0aW9ucy5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bGluZWFyX2FsZ2VicmFcbiAqIEBhbGlhcyBxcl9ob3VzZWhvbGRlclxuICogQHBhcmFtIHtNYXRyaXh9IEFcbiAqIEByZXR1cm5zIHt7UjogTWF0cml4LCBROiBNYXRyaXh9fVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUVJfZGVjb21wb3NpdGlvbiNVc2luZ19Ib3VzZWhvbGRlcl9yZWZsZWN0aW9uc31cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9tbHdpa2kub3JnL2luZGV4LnBocC9Ib3VzZWhvbGRlcl9UcmFuc2Zvcm1hdGlvbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKEEpIHtcbiAgICBjb25zdCBbcm93cywgY29sc10gPSBBLnNoYXBlO1xuICAgIGNvbnN0IFEgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIFwiSVwiKTtcbiAgICBjb25zdCBSID0gQS5jbG9uZSgpO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcbiAgICAgICAgY29uc3QgeCA9IE1hdHJpeC5mcm9tKFIuY29sKGopLnNsaWNlKGopKTtcbiAgICAgICAgY29uc3QgeF9ub3JtID0gbm9ybSh4KTtcbiAgICAgICAgY29uc3QgeDAgPSB4LmVudHJ5KDAsIDApO1xuICAgICAgICBjb25zdCByaG8gPSAtTWF0aC5zaWduKHgwKTtcbiAgICAgICAgY29uc3QgdTEgPSB4MCAtIHJobyAqIHhfbm9ybTtcbiAgICAgICAgY29uc3QgdSA9IHguZGl2aWRlKHUxKS5zZXRfZW50cnkoMCwgMCwgMSk7XG4gICAgICAgIGNvbnN0IGJldGEgPSAoLXJobyAqIHUxKSAvIHhfbm9ybTtcblxuICAgICAgICBjb25zdCB1X291dGVyX3UgPSB1Lm91dGVyKHUpO1xuICAgICAgICBjb25zdCBSX2Jsb2NrID0gUi5nZXRfYmxvY2soaiwgMCk7XG4gICAgICAgIGNvbnN0IG5ld19SID0gUl9ibG9jay5zdWIodV9vdXRlcl91LmRvdChSX2Jsb2NrKS5tdWx0KGJldGEpKTtcbiAgICAgICAgY29uc3QgUV9ibG9jayA9IFEuZ2V0X2Jsb2NrKDAsIGopO1xuICAgICAgICBjb25zdCBuZXdfUSA9IFFfYmxvY2suc3ViKFFfYmxvY2suZG90KHVfb3V0ZXJfdSkubXVsdChiZXRhKSk7XG4gICAgICAgIFIuc2V0X2Jsb2NrKGosIDAsIG5ld19SKTtcbiAgICAgICAgUS5zZXRfYmxvY2soMCwgaiwgbmV3X1EpO1xuICAgIH1cbiAgICByZXR1cm4geyBSLCBRIH07XG59XG4iLCJpbXBvcnQgeyBxciBhcyBxcl9ncmFtc2NobWlkdCB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBSYW5kb21pemVyIH0gZnJvbSBcIi4uL3V0aWwvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbl9zcXVhcmVkIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUge0BsaW5rIGt9IGJpZ2dlc3QgRWlnZW52ZWN0b3JzIGFuZCBFaWdlbnZhbHVlcyBmcm9tIE1hdHJpeCB7QGxpbmsgQX0gd2l0aCB0aGUgUVItQWxnb3JpdGhtLlxuICogQG1lbWJlcm9mIG1vZHVsZTpsaW5lYXJfYWxnZWJyYVxuICogQGFsaWFzIHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvblxuICogQHBhcmFtIHtNYXRyaXh9IEEgLSBUaGUgTWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gayAtIFRoZSBudW1iZXIgb2YgZWlnZW52ZWN0b3JzIGFuZCBlaWdlbnZhbHVlcyB0byBjb21wdXRlLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBzaW11bHRhbmlvdXMgcG93ZXJpdGVyYXRpb24gbWV0aG9kLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLm1heF9pdGVyYXRpb25zPTEwMF0gLSBUaGUgbnVtYmVyIG9mIG1heGl1bXVtIGl0ZXJhdGlvbnMgdGhlIGFsZ29yaXRobSBzaG91bGQgcnVuLlxuICogQHBhcmFtIHtOdW1iZXJ8UmFuZG9taXplcn0gW3BhcmFtZXRlcnMuc2VlZD0xMjEyXSAtIFRoZSBzZWVkIHZhbHVlIG9yIGEgcmFuZG9taXplciB1c2VkIGluIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1ldGVycy5xcj1xcl9ncmFtc2NobWlkdF0gLSBUaGUgUVIgdGVjaG5pcXVlIHRvIHVzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy50b2w9MWUtOF0gLSBBbGxvd2VkIGVycm9yIGZvciBzdG9wcGluZyBjcml0ZXJpYVxuICogQHJldHVybnMge3tlaWdlbnZhbHVlczogQXJyYXksIGVpZ2VudmVjdG9yczogQXJyYXl9fSAtIFRoZSB7QGxpbmsga30gYmlnZ2VzdCBlaWdlbnZlY3RvcnMgYW5kIGVpZ2VudmFsdWVzIG9mIE1hdHJpeCB7QGxpbmsgQX0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChBLCBrID0gMiwge3NlZWQgPSAxMjEyLCBtYXhfaXRlcmF0aW9ucyA9IDEwMCwgcXIgPSBxcl9ncmFtc2NobWlkdCwgdG9sID0gMWUtOH0gPSB7fSkge1xuICAgIGNvbnN0IHJhbmRvbWl6ZXIgPSBzZWVkIGluc3RhbmNlb2YgUmFuZG9taXplciA/IHNlZWQgOiBuZXcgUmFuZG9taXplcihzZWVkKTtcbiAgICBpZiAoIShBIGluc3RhbmNlb2YgTWF0cml4KSkgQSA9IE1hdHJpeC5mcm9tKEEpO1xuICAgIGNvbnN0IG4gPSBBLnNoYXBlWzBdO1xuICAgIGxldCB7IFEsIFIgfSA9IHFyKG5ldyBNYXRyaXgobiwgaywgKCkgPT4gKHJhbmRvbWl6ZXIucmFuZG9tIC0gLjUpICogMikpO1xuICAgIHdoaWxlIChtYXhfaXRlcmF0aW9ucy0tKSB7XG4gICAgICAgIGNvbnN0IG9sZFEgPSBRLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IFogPSBBLmRvdChRKTtcbiAgICAgICAgY29uc3QgUVIgPSBxcihaKTtcbiAgICAgICAgUSA9IFFSLlE7XG4gICAgICAgIFIgPSBRUi5SO1xuICAgICAgICBjb25zdCBlcnJvciA9IGV1Y2xpZGVhbl9zcXVhcmVkKFEudmFsdWVzLCBvbGRRLnZhbHVlcyk7XG4gICAgICAgIGlmIChlcnJvciA8IHRvbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlaWdlbnZhbHVlcyA9IFIuZGlhZztcbiAgICBjb25zdCBlaWdlbnZlY3RvcnMgPSBRLnRyYW5zcG9zZSgpLnRvMmRBcnJheTtcbiAgICByZXR1cm4geyBlaWdlbnZhbHVlcywgZWlnZW52ZWN0b3JzIH07XG59XG4iLCJpbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgaW5uZXIgcHJvZHVjdCBiZXR3ZWVuIHR3byBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoLlxuICogQG1lbWJlcm9mIG1vZHVsZTpsaW5lYXJfYWxnZWJyYVxuICogQGFsaWFzIGlubmVyX3Byb2R1Y3RcbiAqIEBwYXJhbSB7QXJyYXl8RmxvYXQ2NEFycmF5fSBhIC0gQXJyYXkgYVxuICogQHBhcmFtIHtBcnJheXxGbG9hdDY0QXJyYXl9IGIgLSBBcnJheSBiXG4gKiBAcmV0dXJucyBUaGUgaW5uZXIgcHJvZHVjdCBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgY29uc3QgTiA9IGEubGVuZ3RoO1xuICAgIGlmIChOICE9IGIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5IGEgYW5kIGIgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCFcIilcbiAgICB9XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgc3VtICs9IGEgKiBiO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuIiwiaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IFJhbmRvbWl6ZXIgfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBNYXRyaXhcbiAqIEByZXF1aXJlcyBtb2R1bGU6bnVtZXJpY2FsL25ldW1haXJfc3VtXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRyaXgge1xuICAgIC8qKlxuICAgICAqIGNyZWF0ZXMgYSBuZXcgTWF0cml4LiBFbnRyaWVzIGFyZSBzdG9yZWQgaW4gYSBGbG9hdDY0QXJyYXkuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTptYXRyaXhcbiAgICAgKiBAYWxpYXMgTWF0cml4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgLSBUaGUgYW1vdW50IG9mIHJvd3Mgb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29scyAtIFRoZSBhbW91bnQgb2YgY29sdW1ucyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9ufHN0cmluZ3xudW1iZXIpfSB2YWx1ZT0wIC0gQ2FuIGJlIGEgZnVuY3Rpb24gd2l0aCByb3cgYW5kIGNvbCBhcyBwYXJhbWV0ZXJzLCBhIG51bWJlciwgb3IgXCJ6ZXJvc1wiLCBcImlkZW50aXR5XCIgb3IgXCJJXCIsIG9yIFwiY2VudGVyXCIuXG4gICAgICogIC0gKipmdW5jdGlvbioqOiBmb3IgZWFjaCBlbnRyeSB0aGUgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgd2l0aCB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIGFjdHVhbCByb3cgYW5kIGNvbHVtbi5cbiAgICAgKiAgLSAqKnN0cmluZyoqOiBhbGxvd2VkIGFyZVxuICAgICAqICAgICAgLSBcInplcm9cIiwgY3JlYXRlcyBhIHplcm8gbWF0cml4LlxuICAgICAqICAgICAgLSBcImlkZW50aXR5XCIgb3IgXCJJXCIsIGNyZWF0ZXMgYW4gaWRlbnRpdHkgbWF0cml4LlxuICAgICAqICAgICAgLSBcImNlbnRlclwiLCBjcmVhdGVzIGFuIGNlbnRlciBtYXRyaXguXG4gICAgICogIC0gKipudW1iZXIqKjogY3JlYXRlIGEgbWF0cml4IGZpbGxlZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBuZXcgTWF0cml4KDEwLCAxMCwgKCkgPT4gTWF0aC5yYW5kb20oKSk7IC8vY3JlYXRlcyBhIDEwIHRpbWVzIDEwIHJhbmRvbSBtYXRyaXguXG4gICAgICogbGV0IEIgPSBuZXcgTWF0cml4KDMsIDMsIFwiSVwiKTsgLy8gY3JlYXRlcyBhIDMgdGltZXMgMyBpZGVudGl0eSBtYXRyaXguXG4gICAgICogQHJldHVybnMge01hdHJpeH0gcmV0dXJucyBhIHtAbGluayByb3dzfSB0aW1lcyB7QGxpbmsgY29sc30gTWF0cml4IGZpbGxlZCB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm93cyA9IG51bGwsIGNvbHMgPSBudWxsLCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuX2NvbHMgPSBjb2xzO1xuICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKHJvd3MgJiYgY29scykge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IHZhbHVlKHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiemVyb3NcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChyb3dzLCBjb2xzLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcImlkZW50aXR5XCIgfHwgdmFsdWUgPT09IFwiSVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbcm93ICogY29scyArIHJvd10gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiY2VudGVyXCIgJiYgcm93cyA9PSBjb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoaSwgaikgPT4gKGkgPT09IGogPyAxIDogMCkgLSAxIC8gcm93cztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IHZhbHVlKHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkocm93cyAqIGNvbHMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1hdHJpeCBvdXQgb2Yge0BsaW5rIEF9LlxuICAgICAqIEBwYXJhbSB7KE1hdHJpeHxBcnJheXxGbG9hdDY0QXJyYXl8bnVtYmVyKX0gQSAtIFRoZSBtYXRyaXgsIGFycmF5LCBvciBudW1iZXIsIHdoaWNoIHNob3VsZCBjb252ZXJ0ZWQgdG8gYSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtcInJvd1wifFwiY29sXCJ8XCJkaWFnXCJ9IFt0eXBlID0gXCJyb3dcIl0gLSBJZiB7QGxpbmsgQX0gaXMgYSBBcnJheSBvciBGbG9hdDY0QXJyYXksIHRoZW4gdHlwZSBkZWZpbmVzIGlmIGl0IGlzIGEgcm93LSBvciBhIGNvbHVtbiB2ZWN0b3IuXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDBdLCBbMCwgMV1dKTsgLy9jcmVhdGVzIGEgdHdvIGJ5IHR3byBpZGVudGl0eSBtYXRyaXguXG4gICAgICogbGV0IFMgPSBNYXRyaXguZnJvbShbMSwgMiwgM10sIFwiZGlhZ1wiKTsgLy8gY3JlYXRlcyBhIDMgYnkgMyBtYXRyaXggd2l0aCAxLCAyLCAzIG9uIGl0cyBkaWFnb25hbC4gW1sxLCAwLCAwXSwgWzAsIDIsIDBdLCBbMCwgMCwgM11dXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oQSwgdHlwZSA9IFwicm93XCIpIHtcbiAgICAgICAgaWYgKEEgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBBLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShBKSB8fCBBIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSB7XG4gICAgICAgICAgICBsZXQgbSA9IEEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG0gPT09IDApIHRocm93IG5ldyBFcnJvcihcIkFycmF5IGlzIGVtcHR5XCIpO1xuICAgICAgICAgICAgLy8gMWRcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShBWzBdKSAmJiAhKEFbMF0gaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicm93XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoMSwgbSwgKF8sIGopID0+IEFbal0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb2xcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtLCAxLCAoaSkgPT4gQVtpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRpYWdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtLCBtLCAoaSwgaikgPT4gKGkgPT0gaiA/IEFbaV0gOiAwKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiMWQgYXJyYXkgaGFzIE5hTiBlbnRyaWVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAyZFxuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEFbMF0pIHx8IEFbMF0gaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbiA9IEFbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG07ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBW3Jvd10ubGVuZ3RoICE9PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YXJpb3VzIGFycmF5IGxlbmd0aHNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgobSwgbiwgKGksIGopID0+IEFbaV1bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBBID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCgxLCAxLCBBKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVycm9yXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIHJvd308c3VwPnRoPC9zdXA+IHJvdyBmcm9tIHRoZSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgICAqIEByZXR1cm5zIHtGbG9hdDY0QXJyYXl9XG4gICAgICovXG4gICAgcm93KHJvdykge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICByZXR1cm4gZGF0YS5zdWJhcnJheShyb3cgKiBjb2xzLCAocm93ICsgMSkgKiBjb2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGdlbmVyYXRvciB5aWVsZGluZyBlYWNoIHJvdyBvZiB0aGUgTWF0cml4LlxuICAgICAqIEB5aWVsZHMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICAqaXRlcmF0ZV9yb3dzKCkge1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIHlpZWxkIGRhdGEuc3ViYXJyYXkocm93ICogY29scywgKHJvdyArIDEpICogY29scyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIHtAbGluayBNYXRyaXh9IG9iamVjdCBhbiBpdGVyYWJsZSBvYmplY3QuXG4gICAgICogQHlpZWxkcyB7RmxvYXQ2NEFycmF5fVxuICAgICAqL1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5pdGVyYXRlX3Jvd3MoKSkge1xuICAgICAgICAgICAgeWllbGQgcm93O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZW50cmllcyBvZiB7QGxpbmsgcm93fTxzdXA+dGg8L3N1cD4gcm93IGZyb20gdGhlIE1hdHJpeCB0byB0aGUgZW50cmllcyBmcm9tIHtAbGluayB2YWx1ZXN9LlxuICAgICAqIEBwYXJhbSB7aW50fSByb3dcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHNldF9yb3cocm93LCB2YWx1ZXMpIHtcbiAgICAgICAgbGV0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmIHZhbHVlcy5sZW5ndGggPT09IGNvbHMpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlc1tvZmZzZXQgKyBjb2xdID0gdmFsdWVzW2NvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWVzIGluc3RhbmNlb2YgTWF0cml4ICYmIHZhbHVlcy5zaGFwZVsxXSA9PT0gY29scyAmJiB2YWx1ZXMuc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlc1tvZmZzZXQgKyBjb2xdID0gdmFsdWVzLl9kYXRhW2NvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIGNvbH08c3VwPnRoPC9zdXA+IGNvbHVtbiBmcm9tIHRoZSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtpbnR9IGNvbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBjb2woY29sKSB7XG4gICAgICAgIGxldCByZXN1bHRfY29sID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLl9yb3dzKTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5fcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIHJlc3VsdF9jb2xbcm93XSA9IHRoaXMudmFsdWVzW3JvdyAqIHRoaXMuX2NvbHMgKyBjb2xdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRfY29sO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBjb2x9PHN1cD50aDwvc3VwPiBlbnRyeSBmcm9tIHRoZSB7QGxpbmsgcm93fTxzdXA+dGg8L3N1cD4gcm93IG9mIHRoZSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtpbnR9IHJvd1xuICAgICAqIEBwYXJhbSB7aW50fSBjb2xcbiAgICAgKiBAcmV0dXJucyB7ZmxvYXQ2NH1cbiAgICAgKi9cbiAgICBlbnRyeShyb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbcm93ICogdGhpcy5fY29scyArIGNvbF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUge0BsaW5rIGNvbH08c3VwPnRoPC9zdXA+IGVudHJ5IGZyb20gdGhlIHtAbGluayByb3d9PHN1cD50aDwvc3VwPiByb3cgb2YgdGhlIE1hdHJpeCB0byB0aGUgZ2l2ZW4ge0BsaW5rIHZhbHVlfS5cbiAgICAgKiBAcGFyYW0ge2ludH0gcm93XG4gICAgICogQHBhcmFtIHtpbnR9IGNvbFxuICAgICAqIEBwYXJhbSB7ZmxvYXQ2NH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHNldF9lbnRyeShyb3csIGNvbCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNbcm93ICogdGhpcy5fY29scyArIGNvbF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyB0cmFuc3Bvc2VkIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHRyYW5zcG9zZSgpIHtcbiAgICAgICAgbGV0IEIgPSBuZXcgTWF0cml4KHRoaXMuX2NvbHMsIHRoaXMuX3Jvd3MsIChyb3csIGNvbCkgPT4gdGhpcy5lbnRyeShjb2wsIHJvdykpO1xuICAgICAgICByZXR1cm4gQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHRyYW5zcG9zZWQgTWF0cml4LiBTaG9ydC1mb3JtIG9mIHtAZnVuY3Rpb24gdHJhbnNwb3NlfS5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIGdldCBUKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3Bvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBpbnZlcnNlKCkge1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgIGxldCBCID0gbmV3IE1hdHJpeChyb3dzLCAyICogY29scywgKGksIGopID0+IHtcbiAgICAgICAgICAgIGlmIChqID49IGNvbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA9PT0gaiAtIGNvbHMgPyAxIDogMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50cnkoaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaCA9IDA7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgd2hpbGUgKGggPCByb3dzICYmIGsgPCBjb2xzKSB7XG4gICAgICAgICAgICB2YXIgaV9tYXggPSAwO1xuICAgICAgICAgICAgbGV0IG1heF92YWwgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gaDsgaSA8IHJvd3M7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBNYXRoLmFicyhCLmVudHJ5KGksIGspKTtcbiAgICAgICAgICAgICAgICBpZiAobWF4X3ZhbCA8IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpX21heCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIG1heF92YWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEIuZW50cnkoaV9tYXgsIGspID09IDApIHtcbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgcm93c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMiAqIGNvbHM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaF92YWwgPSBCLmVudHJ5KGgsIGopO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaV92YWwgPSBCLmVudHJ5KGlfbWF4LCBqKTtcbiAgICAgICAgICAgICAgICAgICAgQi5zZXRfZW50cnkoaCwgaiwgaF92YWwpO1xuICAgICAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShpX21heCwgaiwgaV92YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaCArIDE7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGYgPSBCLmVudHJ5KGksIGspIC8gQi5lbnRyeShoLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgQi5zZXRfZW50cnkoaSwgaywgMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBrICsgMTsgaiA8IDIgKiBjb2xzOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEIuc2V0X2VudHJ5KGksIGosIEIuZW50cnkoaSwgaikgLSBCLmVudHJ5KGgsIGopICogZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaCsrO1xuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBsZXQgZiA9IEIuZW50cnkocm93LCByb3cpO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gcm93OyBjb2wgPCAyICogY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShyb3csIGNvbCwgQi5lbnRyeShyb3csIGNvbCkgLyBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IHJvd3MgLSAxOyByb3cgPj0gMDsgLS1yb3cpIHtcbiAgICAgICAgICAgIGxldCBCX3Jvd19yb3cgPSBCLmVudHJ5KHJvdywgcm93KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgQl9pX3JvdyA9IEIuZW50cnkoaSwgcm93KTtcbiAgICAgICAgICAgICAgICBsZXQgZiA9IEJfaV9yb3cgLyBCX3Jvd19yb3c7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCAyICogY29sczsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBCX2lfaiA9IEIuZW50cnkoaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBCX3Jvd19qID0gQi5lbnRyeShyb3csIGopO1xuICAgICAgICAgICAgICAgICAgICBCX2lfaiA9IEJfaV9qIC0gQl9yb3dfaiAqIGY7XG4gICAgICAgICAgICAgICAgICAgIEIuc2V0X2VudHJ5KGksIGosIEJfaV9qKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChyb3dzLCBjb2xzLCAoaSwgaikgPT4gQi5lbnRyeShpLCBqICsgY29scykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0LiBJZiB7QGxpbmsgQn0gaXMgYW4gQXJyYXkgb3IgRmxvYXQ2NEFycmF5IHRoZW4gYW4gQXJyYXkgZ2V0cyByZXR1cm5lZC4gSWYge0BsaW5rIEJ9IGlzIGEgTWF0cml4IHRoZW4gYSBNYXRyaXggZ2V0cyByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0geyhNYXRyaXh8QXJyYXl8RmxvYXQ2NEFycmF5KX0gQiB0aGUgcmlnaHQgc2lkZVxuICAgICAqIEByZXR1cm5zIHsoTWF0cml4fEFycmF5KX1cbiAgICAgKi9cbiAgICBkb3QoQikge1xuICAgICAgICBpZiAoQiBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IEEgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKEEuc2hhcGVbMV0gIT09IEIuc2hhcGVbMF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEuZG90KEIpOiBBIGlzIGEgJHtBLnNoYXBlLmpvaW4oXCIg4qivIFwiKX0tTWF0cml4LCBCIGlzIGEgJHtCLnNoYXBlLmpvaW4oXCIg4qivIFwiKX0tTWF0cml4OiBcbiAgICAgICAgICAgICAgICBBIGhhcyAke0Euc2hhcGVbMV19IGNvbHMgYW5kIEIgJHtCLnNoYXBlWzBdfSByb3dzLiBcbiAgICAgICAgICAgICAgICBNdXN0IGJlIGVxdWFsIWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IEkgPSBBLnNoYXBlWzFdO1xuICAgICAgICAgICAgbGV0IEMgPSBuZXcgTWF0cml4KEEuc2hhcGVbMF0sIEIuc2hhcGVbMV0sIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IEFfaSA9IEEucm93KHJvdyk7XG4gICAgICAgICAgICAgICAgY29uc3QgQl9pID0gQi5jb2woY29sKTtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gQV9pW2ldICogQl9pW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gQztcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEIpIHx8IEIgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgICAgIGlmIChCLmxlbmd0aCAhPT0gcm93cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQS5kb3QoQik6IEEgaGFzICR7cm93c30gY29scyBhbmQgQiBoYXMgJHtCLmxlbmd0aH0gcm93cy4gTXVzdCBiZSBlcXVhbCFgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBDID0gbmV3IEFycmF5KHJvd3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICBDW3Jvd10gPSBuZXVtYWlyX3N1bSh0aGlzLnJvdyhyb3cpLm1hcCgoZSkgPT4gZSAqIEJbcm93XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEIgbXVzdCBiZSBNYXRyaXggb3IgQXJyYXlgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBvdXRlciBwcm9kdWN0IGZyb20ge0BsaW5rIHRoaXN9IGFuZCB7QGxpbmsgQn0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEJcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIG91dGVyKEIpIHtcbiAgICAgICAgbGV0IEEgPSB0aGlzO1xuICAgICAgICBsZXQgbCA9IEEuX2RhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgciA9IEIuX2RhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobCAhPSByKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgQyA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgQy5zaGFwZSA9IFtcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgKGksIGopID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBLl9kYXRhW2ldICogQi5fZGF0YVtqXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQy5lbnRyeShqLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gQztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIG1hdHJpeCB7QGxpbmsgQn0gdG8gdGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQiAtIG1hdHJpeCB0byBhcHBlbmQuXG4gICAgICogQHBhcmFtIHtcImhvcml6b250YWxcInxcInZlcnRpY2FsXCJ8XCJkaWFnXCJ9IFt0eXBlID0gXCJob3Jpem9udGFsXCJdIC0gdHlwZSBvZiBjb25jYXRlbmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAxXSwgWzEsIDFdXSk7IC8vIDIgYnkgMiBtYXRyaXggZmlsbGVkIHdpdGggb25lcy5cbiAgICAgKiBsZXQgQiA9IE1hdHJpeC5mcm9tKFtbMiwgMl0sIFsyLCAyXV0pOyAvLyAyIGJ5IDIgbWF0cml4IGZpbGxlZCB3aXRoIHR3b3MuXG4gICAgICpcbiAgICAgKiBBLmNvbmNhdChCLCBcImhvcml6b250YWxcIik7IC8vIDIgYnkgNCBtYXRyaXguIFtbMSwgMSwgMiwgMl0sIFsxLCAxLCAyLCAyXV1cbiAgICAgKiBBLmNvbmNhdChCLCBcInZlcnRpY2FsXCIpOyAvLyA0IGJ5IDIgbWF0cml4LiBbWzEsIDFdLCBbMSwgMV0sIFsyLCAyXSwgWzIsIDJdXVxuICAgICAqIEEuY29uY2F0KEIsIFwiZGlhZ1wiKTsgLy8gNCBieSA0IG1hdHJpeC4gW1sxLCAxLCAwLCAwXSwgWzEsIDEsIDAsIDBdLCBbMCwgMCwgMiwgMl0sIFswLCAwLCAyLCAyXV1cbiAgICAgKi9cbiAgICBjb25jYXQoQiwgdHlwZSA9IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzO1xuICAgICAgICBjb25zdCBbcm93c19BLCBjb2xzX0FdID0gQS5zaGFwZTtcbiAgICAgICAgY29uc3QgW3Jvd3NfQiwgY29sc19CXSA9IEIuc2hhcGU7XG4gICAgICAgIGlmICh0eXBlID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICBpZiAocm93c19BICE9IHJvd3NfQikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQS5jb25jYXQoQiwgXCJob3Jpem9udGFsXCIpOiBBIGFuZCBCIG5lZWQgc2FtZSBudW1iZXIgb2Ygcm93cywgQSBoYXMgJHtyb3dzX0F9IHJvd3MsIEIgaGFzICR7cm93c19CfSByb3dzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgWCA9IG5ldyBNYXRyaXgocm93c19BLCBjb2xzX0EgKyBjb2xzX0IsIFwiemVyb3NcIik7XG4gICAgICAgICAgICBYLnNldF9ibG9jaygwLCAwLCBBKTtcbiAgICAgICAgICAgIFguc2V0X2Jsb2NrKDAsIGNvbHNfQSwgQik7XG4gICAgICAgICAgICByZXR1cm4gWDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgaWYgKGNvbHNfQSAhPSBjb2xzX0IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEuY29uY2F0KEIsIFwidmVydGljYWxcIik6IEEgYW5kIEIgbmVlZCBzYW1lIG51bWJlciBvZiBjb2x1bW5zLCBBIGhhcyAke2NvbHNfQX0gY29sdW1ucywgQiBoYXMgJHtjb2xzX0J9IGNvbHVtbnMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBYID0gbmV3IE1hdHJpeChyb3dzX0EgKyByb3dzX0IsIGNvbHNfQSwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgICAgIFguc2V0X2Jsb2NrKDAsIDAsIEEpO1xuICAgICAgICAgICAgWC5zZXRfYmxvY2socm93c19BLCAwLCBCKTtcbiAgICAgICAgICAgIHJldHVybiBYO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJkaWFnXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IFggPSBuZXcgTWF0cml4KHJvd3NfQSArIHJvd3NfQiwgY29sc19BICsgY29sc19CLCBcInplcm9zXCIpO1xuICAgICAgICAgICAgWC5zZXRfYmxvY2soMCwgMCwgQSk7XG4gICAgICAgICAgICBYLnNldF9ibG9jayhyb3dzX0EsIGNvbHNfQSwgQik7XG4gICAgICAgICAgICByZXR1cm4gWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdHlwZSBtdXN0IGJlIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIiwgYnV0IHR5cGUgaXMgJHt0eXBlfSFgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyaXRlcyB0aGUgZW50cmllcyBvZiBCIGluIEEgYXQgYW4gb2Zmc2V0IHBvc2l0aW9uIGdpdmVuIGJ5IHtAbGluayBvZmZzZXRfcm93fSBhbmQge0BsaW5rIG9mZnNldF9jb2x9LlxuICAgICAqIEBwYXJhbSB7aW50fSBvZmZzZXRfcm93XG4gICAgICogQHBhcmFtIHtpbnR9IG9mZnNldF9jb2xcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc2V0X2Jsb2NrKG9mZnNldF9yb3csIG9mZnNldF9jb2wsIEIpIHtcbiAgICAgICAgbGV0IFtyb3dzLCBjb2xzXSA9IEIuc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBpZiAocm93ID4gdGhpcy5fcm93cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sID4gdGhpcy5fY29scykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfZW50cnkocm93ICsgb2Zmc2V0X3JvdywgY29sICsgb2Zmc2V0X2NvbCwgQi5lbnRyeShyb3csIGNvbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBlbnRyaWVzIGZyb20gdGhlIHtAbGluayBzdGFydF9yb3d9PHN1cD50aDwvc3VwPiByb3cgdG8gdGhlIHtAbGluayBlbmRfcm93fTxzdXA+dGg8L3N1cD4gcm93LCB0aGUge0BsaW5rIHN0YXJ0X2NvbH08c3VwPnRoPC9zdXA+IGNvbHVtbiB0byB0aGUge0BsaW5rIGVuZF9jb2x9PHN1cD50aDwvc3VwPiBjb2x1bW4gb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBJZiB7QGxpbmsgZW5kX3Jvd30gb3Ige0BsaW5rIGVuZF9jb2x9IGlzIGVtcHR5LCB0aGUgcmVzcGVjdGl2ZSB2YWx1ZSBpcyBzZXQgdG8ge0BsaW5rIHRoaXMucm93c30gb3Ige0BsaW5rIHRoaXMuY29sc30uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0X3Jvd1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydF9jb2xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZF9yb3cgPSBudWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kX2NvbCA9IG51bGxdXG4gICAgICogQHJldHVybnMge01hdHJpeH0gUmV0dXJucyBhIGVuZF9yb3cgLSBzdGFydF9yb3cgdGltZXMgZW5kX2NvbCAtIHN0YXJ0X2NvbCBtYXRyaXgsIHdpdGggcmVzcGVjdGl2ZSBlbnRyaWVzIGZyb20gdGhlIG1hdHJpeC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDIsIDNdLCBbNCwgNSwgNl0sIFs3LCA4LCA5XV0pOyAvLyBhIDMgYnkgMyBtYXRyaXguXG4gICAgICpcbiAgICAgKiBBLmdldF9ibG9jaygxLCAxKTsgLy8gW1s1LCA2XSwgWzgsIDldXVxuICAgICAqIEEuZ2V0X2Jsb2NrKDAsIDAsIDEsIDEpOyAvLyBbWzFdXVxuICAgICAqIEEuZ2V0X2Jsb2NrKDEsIDEsIDIsIDIpOyAvLyBbWzVdXVxuICAgICAqIEEuZ2V0X2Jsb2NrKDAsIDAsIDIsIDIpOyAvLyBbWzEsIDJdLCBbNCwgNV1dXG4gICAgICovXG4gICAgZ2V0X2Jsb2NrKHN0YXJ0X3Jvdywgc3RhcnRfY29sLCBlbmRfcm93ID0gbnVsbCwgZW5kX2NvbCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgW3Jvd3MsIGNvbHNdID0gdGhpcy5zaGFwZTtcbiAgICAgICAgZW5kX3JvdyA9IGVuZF9yb3cgPz8gcm93cztcbiAgICAgICAgZW5kX2NvbCA9IGVuZF9jb2wgPz8gY29scztcbiAgICAgICAgaWYgKGVuZF9yb3cgPD0gc3RhcnRfcm93IHx8IGVuZF9jb2wgPD0gc3RhcnRfY29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgICAgICAgICAgIGVuZF9yb3cgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RhcnRfcm93LCBhbmQgXG4gICAgICAgICAgICAgICAgZW5kX2NvbCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdGFydF9jb2wsIGJ1dFxuICAgICAgICAgICAgICAgIGVuZF9yb3cgPSAke2VuZF9yb3d9LCBzdGFydF9yb3cgPSAke3N0YXJ0X3Jvd30sIGVuZF9jb2wgPSAke2VuZF9jb2x9LCBhbmQgc3RhcnRfY29sID0gJHtzdGFydF9jb2x9IWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFggPSBuZXcgTWF0cml4KGVuZF9yb3cgLSBzdGFydF9yb3csIGVuZF9jb2wgLSBzdGFydF9jb2wsIFwiemVyb3NcIik7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IHN0YXJ0X3JvdywgbmV3X3JvdyA9IDA7IHJvdyA8IGVuZF9yb3c7ICsrcm93LCArK25ld19yb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHN0YXJ0X2NvbCwgbmV3X2NvbCA9IDA7IGNvbCA8IGVuZF9jb2w7ICsrY29sLCArK25ld19jb2wpIHtcbiAgICAgICAgICAgICAgICBYLnNldF9lbnRyeShuZXdfcm93LCBuZXdfY29sLCB0aGlzLmVudHJ5KHJvdywgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFg7XG4gICAgICAgIC8vcmV0dXJuIG5ldyBNYXRyaXgoZW5kX3JvdyAtIHN0YXJ0X3JvdywgZW5kX2NvbCAtIHN0YXJ0X2NvbCwgKGksIGopID0+IHRoaXMuZW50cnkoaSArIHN0YXJ0X3JvdywgaiArIHN0YXJ0X2NvbCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgZ2F0aGVyaW5nIGVudHJpZXMgZGVmaW5lZCBieSB0aGUgaW5kaWNlcyBnaXZlbiBieSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHJvd19pbmRpY2VzIC0gQXJyYXkgY29uc2lzdHMgb2YgaW5kaWNlcyBvZiByb3dzIGZvciBnYXRoZXJpbmcgZW50cmllcyBvZiB0aGlzIG1hdHJpeFxuICAgICAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gY29sX2luZGljZXMgIC0gQXJyYXkgY29uc2lzdHMgb2YgaW5kaWNlcyBvZiBjb2xzIGZvciBnYXRoZXJpbmcgZW50cmllcyBvZiB0aGlzIG1hdHJpeFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgZ2F0aGVyKHJvd19pbmRpY2VzLCBjb2xfaW5kaWNlcykge1xuICAgICAgICBjb25zdCBOID0gcm93X2luZGljZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBEID0gY29sX2luZGljZXMubGVuZ3RoO1xuXG4gICAgICAgIGNvbnN0IFIgPSBuZXcgTWF0cml4KE4sIEQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgcm93X2luZGV4ID0gcm93X2luZGljZXNbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbF9pbmRleCA9IGNvbF9pbmRpY2VzW2pdO1xuICAgICAgICAgICAgICAgIFIuc2V0X2VudHJ5KGksIGosIHRoaXMuZW50cnkocm93X2luZGV4LCBjb2xfaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXguXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmIGZ1bmN0aW9uIHRha2VzIDIgcGFyYW1ldGVycywgdGhlIHZhbHVlIG9mIHRoZSBhY3R1YWwgZW50cnkgYW5kIGEgdmFsdWUgZ2l2ZW4gYnkgdGhlIGZ1bmN0aW9uIHtAbGluayB2fS4gVGhlIHJlc3VsdCBvZiB7QGxpbmsgZn0gZ2V0cyB3cml0ZW4gdG8gdGhlIE1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB2IGZ1bmN0aW9uIHRha2VzIDIgcGFyYW1ldGVycyBmb3Igcm93IGFuZCBjb2wsIGFuZCByZXR1cm5zIGEgdmFsdWUgd2l0Y2ggc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIGNvbHRoIGVudHJ5IG9mIHRoZSByb3d0aCByb3cgb2YgdGhlIG1hdHJpeC5cbiAgICAgKi9cbiAgICBfYXBwbHlfYXJyYXkoZiwgdikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IFtyb3dzLCBjb2xzXSA9IHRoaXMuc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gb2Zmc2V0ICsgY29sO1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBmKGRhdGFbaV0sIHYocm93LCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfYXBwbHlfcm93d2lzZV9hcnJheSh2YWx1ZXMsIGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5X2FycmF5KGYsIChfLCBqKSA9PiB2YWx1ZXNbal0pO1xuICAgIH1cblxuICAgIF9hcHBseV9jb2x3aXNlX2FycmF5KHZhbHVlcywgZikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IFtyb3dzLCBjb2xzXSA9IHRoaXMuc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gb2Zmc2V0ICsgY29sO1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBmKGRhdGFbaV0sIHZhbHVlc1tyb3ddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfYXBwbHkodmFsdWUsIGYpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgW3ZhbHVlX3Jvd3MsIHZhbHVlX2NvbHNdID0gdmFsdWUuc2hhcGU7XG4gICAgICAgICAgICBsZXQgW3Jvd3MsIGNvbHNdID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZV9yb3dzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHMgIT09IHZhbHVlX2NvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb2xzICE9PSB2YWx1ZV9jb2xzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gZihkYXRhW3JvdyAqIGNvbHMgKyBjb2xdLCB2YWx1ZS5lbnRyeSgwLCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVfY29scyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3dzICE9PSB2YWx1ZV9yb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcm93cyAhPT0gdmFsdWVfcm93c2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWUuZW50cnkocm93LCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJvd3MgPT0gdmFsdWVfcm93cyAmJiBjb2xzID09IHZhbHVlX2NvbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWUuZW50cnkocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgICAgICBsZXQgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSByb3dzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbcm93ICogY29scyArIGNvbF0gPSBmKGRhdGFbcm93ICogY29scyArIGNvbF0sIHZhbHVlW3Jvd10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IGNvbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWVbY29sXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXJyb3JgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fcm93cyAqIHRoaXMuX2NvbHM7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2ldID0gZihkYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgbGV0IEIgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIEIuX3Jvd3MgPSB0aGlzLl9yb3dzO1xuICAgICAgICBCLl9jb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgQi5fZGF0YSA9IHRoaXMudmFsdWVzLnNsaWNlKDApO1xuICAgICAgICByZXR1cm4gQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnRyeXdpc2UgbXVsdGlwbGljYXRpb24gd2l0aCB7QGxpbmsgdmFsdWV9LlxuICAgICAqIEBwYXJhbSB7TWF0cml4fEFycmF5fE51bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBsZXQgQSA9IE1hdHJpeC5mcm9tKFtbMSwgMl0sIFszLCA0XV0pOyAvLyBhIDIgYnkgMiBtYXRyaXguXG4gICAgICogbGV0IEIgPSBBLmNsb25lKCk7IC8vIEIgPT0gQTtcbiAgICAgKlxuICAgICAqIEEubXVsdCgyKTsgLy8gW1syLCA0XSwgWzYsIDhdXTtcbiAgICAgKiBBLm11bHQoQik7IC8vIFtbMSwgNF0sIFs5LCAxNl1dO1xuICAgICAqL1xuICAgIG11bHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYXBwbHkodmFsdWUsIChhLCBiKSA9PiBhICogYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW50cnl3aXNlIGRpdmlzaW9uIHdpdGgge0BsaW5rIHZhbHVlfS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeHxBcnJheXxOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDJdLCBbMywgNF1dKTsgLy8gYSAyIGJ5IDIgbWF0cml4LlxuICAgICAqIGxldCBCID0gQS5jbG9uZSgpOyAvLyBCID09IEE7XG4gICAgICpcbiAgICAgKiBBLmRpdmlkZSgyKTsgLy8gW1swLjUsIDFdLCBbMS41LCAyXV07XG4gICAgICogQS5kaXZpZGUoQik7IC8vIFtbMSwgMV0sIFsxLCAxXV07XG4gICAgICovXG4gICAgZGl2aWRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2FwcGx5KHZhbHVlLCAoYSwgYikgPT4gYSAvIGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudHJ5d2lzZSBhZGRpdGlvbiB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAyXSwgWzMsIDRdXSk7IC8vIGEgMiBieSAyIG1hdHJpeC5cbiAgICAgKiBsZXQgQiA9IEEuY2xvbmUoKTsgLy8gQiA9PSBBO1xuICAgICAqXG4gICAgICogQS5hZGQoMik7IC8vIFtbMywgNF0sIFs1LCA2XV07XG4gICAgICogQS5hZGQoQik7IC8vIFtbMiwgNF0sIFs2LCA4XV07XG4gICAgICovXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2FwcGx5KHZhbHVlLCAoYSwgYikgPT4gYSArIGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudHJ5d2lzZSBzdWJ0cmFjdGlvbiB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAyXSwgWzMsIDRdXSk7IC8vIGEgMiBieSAyIG1hdHJpeC5cbiAgICAgKiBsZXQgQiA9IEEuY2xvbmUoKTsgLy8gQiA9PSBBO1xuICAgICAqXG4gICAgICogQS5zdWIoMik7IC8vIFtbLTEsIDBdLCBbMSwgMl1dO1xuICAgICAqIEEuc3ViKEIpOyAvLyBbWzAsIDBdLCBbMCwgMF1dO1xuICAgICAqL1xuICAgIHN1Yih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9hcHBseSh2YWx1ZSwgKGEsIGIpID0+IGEgLSBiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgTWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gQXJyYXkgaW4gdGhlIGZvcm0gW3Jvd3MsIGNvbHVtbnNdLlxuICAgICAqL1xuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl9yb3dzLCB0aGlzLl9jb2xzXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRyaXggaW4gdGhlIGdpdmVuIHNoYXBlIHdpdGggdGhlIGdpdmVuIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdmFsdWVzIGZvciB0aGUgZW50cmllcyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtZXRlciAtIHRha2VzIGFuIEFycmF5IGluIHRoZSBmb3JtIFtyb3dzLCBjb2xzLCB2YWx1ZV0sIHdoZXJlIHJvd3MgYW5kIGNvbHMgYXJlIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgbWF0cml4LCBhbmQgdmFsdWUgaXMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gcGFyYW1ldGVycyAocm93IGFuZCBjb2wpIHdoaWNoIGhhcyB0byByZXR1cm4gYSB2YWx1ZSBmb3IgdGhlIGNvbHRoIGVudHJ5IG9mIHRoZSByb3d0aCByb3cuXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzZXQgc2hhcGUoW3Jvd3MsIGNvbHMsIHZhbHVlID0gKCkgPT4gMF0pIHtcbiAgICAgICAgdGhpcy5fcm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuX2NvbHMgPSBjb2xzO1xuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0NjRBcnJheShyb3dzICogY29scyk7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbcm93ICogY29scyArIGNvbF0gPSB2YWx1ZShyb3csIGNvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTWF0cml4IGFzIGEgQXJyYXkgb2YgRmxvYXQ2NEFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8RmxvYXQ2NEFycmF5Pn1cbiAgICAgKi9cbiAgICBnZXQgdG8yZEFycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5pdGVyYXRlX3Jvd3MoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE1hdHJpeCBhcyBhIEFycmF5IG9mIEFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fVxuICAgICAqL1xuICAgIGdldCBhc0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5pdGVyYXRlX3Jvd3MoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goQXJyYXkuZnJvbShyb3cpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpYWdvbmFsIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgZGlhZygpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICBjb25zdCBtaW5fcm93X2NvbCA9IE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEZsb2F0NjRBcnJheShtaW5fcm93X2NvbCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluX3Jvd19jb2w7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5lbnRyeShpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1lYW4gb2YgYWxsIGVudHJpZXMgb2YgdGhlIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBtZWFuKCkge1xuICAgICAgICBjb25zdCBzdW0gPSB0aGlzLnN1bTtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX3Jvd3MgKiB0aGlzLl9jb2xzO1xuICAgICAgICByZXR1cm4gc3VtIC8gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb29mIGFsbCBlbnRyaWVzIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3VtKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIHJldHVybiBuZXVtYWlyX3N1bShkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb29mIGFsbCBlbnRyaWVzIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWVhbiBvZiBlYWNoIHJvdyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtGbG9hdDY0QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IG1lYW5Sb3dzKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0aGlzLl9yb3dzO1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRmxvYXQ2NEFycmF5LmZyb20oeyBsZW5ndGg6IHJvd3MgfSk7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICByZXN1bHRbcm93XSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyb3ddICs9IGRhdGFbcm93ICogY29scyArIGNvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbcm93XSAvPSBjb2xzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgdGhlIG1lYW4gb2YgZWFjaCBjb2x1bW4gb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7RmxvYXQ2NEFycmF5fVxuICAgICAqL1xuICAgIGdldCBtZWFuQ29scygpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMudmFsdWVzO1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEZsb2F0NjRBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb2xzIH0pO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgcmVzdWx0W2NvbF0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY29sXSArPSBkYXRhW3JvdyAqIGNvbHMgKyBjb2xdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2NvbF0gLz0gcm93cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNvbHZlcyB0aGUgZXF1YXRpb24ge0BsaW5rIEF9eCA9IHtAbGluayBifSB1c2luZyB0aGUgY29uanVnYXRlIGdyYWRpZW50IG1ldGhvZC4gUmV0dXJucyB0aGUgcmVzdWx0IHguXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEEgLSBNYXRyaXhcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gYiAtIE1hdHJpeFxuICAgICAqIEBwYXJhbSB7UmFuZG9taXplcn0gW3JhbmRvbWl6ZXI9bnVsbF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RvbD0xZS0zXVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc3RhdGljIHNvbHZlX0NHKEEsIGIsIHJhbmRvbWl6ZXIsIHRvbCA9IDFlLTMpIHtcbiAgICAgICAgaWYgKHJhbmRvbWl6ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJhbmRvbWl6ZXIgPSBuZXcgUmFuZG9taXplcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvd3MgPSBBLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBjb2xzID0gYi5zaGFwZVsxXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBNYXRyaXgocm93cywgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sczsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBiX2kgPSBNYXRyaXguZnJvbShiLmNvbChpKSkuVDtcbiAgICAgICAgICAgIGxldCB4ID0gbmV3IE1hdHJpeChyb3dzLCAxLCAoKSA9PiByYW5kb21pemVyLnJhbmRvbSk7XG4gICAgICAgICAgICBsZXQgciA9IGJfaS5zdWIoQS5kb3QoeCkpO1xuICAgICAgICAgICAgbGV0IGQgPSByLmNsb25lKCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IEEuZG90KGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscGhhID0gci5ULmRvdChyKS5lbnRyeSgwLCAwKSAvIGQuVC5kb3QoeikuZW50cnkoMCwgMCk7XG4gICAgICAgICAgICAgICAgeCA9IHguYWRkKGQubXVsdChhbHBoYSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJfbmV4dCA9IHIuc3ViKHoubXVsdChhbHBoYSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJldGEgPSByX25leHQuVC5kb3Qocl9uZXh0KS5lbnRyeSgwLCAwKSAvIHIuVC5kb3QocikuZW50cnkoMCwgMCk7XG4gICAgICAgICAgICAgICAgZCA9IHJfbmV4dC5hZGQoZC5tdWx0KGJldGEpKTtcbiAgICAgICAgICAgICAgICByID0gcl9uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAoTWF0aC5hYnMoci5tZWFuKSA+IHRvbCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHgsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNvbHZlcyB0aGUgZXF1YXRpb24ge0BsaW5rIEF9eCA9IHtAbGluayBifS4gUmV0dXJucyB0aGUgcmVzdWx0IHguXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEEgLSBNYXRyaXggb3IgTFUgRGVjb21wb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBiIC0gTWF0cml4XG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzdGF0aWMgc29sdmUoQSwgYikge1xuICAgICAgICBsZXQgeyBMOiBMLCBVOiBVIH0gPSBcIkxcIiBpbiBBICYmIFwiVVwiIGluIEEgPyBBIDogTWF0cml4LkxVKEEpO1xuICAgICAgICBsZXQgcm93cyA9IEwuc2hhcGVbMF07XG4gICAgICAgIGxldCB4ID0gYi5jbG9uZSgpO1xuXG4gICAgICAgIC8vIGZvcndhcmRcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHJvdyAtIDE7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgeC5zZXRfZW50cnkoMCwgcm93LCB4LmVudHJ5KDAsIHJvdykgLSBMLmVudHJ5KHJvdywgY29sKSAqIHguZW50cnkoMSwgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4LnNldF9lbnRyeSgwLCByb3csIHguZW50cnkoMCwgcm93KSAvIEwuZW50cnkocm93LCByb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJhY2t3YXJkXG4gICAgICAgIGZvciAobGV0IHJvdyA9IHJvd3MgLSAxOyByb3cgPj0gMDsgLS1yb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHJvd3MgLSAxOyBjb2wgPiByb3c7IC0tY29sKSB7XG4gICAgICAgICAgICAgICAgeC5zZXRfZW50cnkoMCwgcm93LCB4LmVudHJ5KDAsIHJvdykgLSBVLmVudHJ5KHJvdywgY29sKSAqIHguZW50cnkoMCwgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4LnNldF9lbnRyeSgwLCByb3csIHguZW50cnkoMCwgcm93KSAvIFUuZW50cnkocm93LCByb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHtAbGluayBMfXtAbGluayBVfSBkZWNvbXBvc2l0aW9uIG9mIHRoZSBNYXRyaXgge0BsaW5rIEF9LiBDcmVhdGVzIHR3byBtYXRyaWNlcywgc28gdGhhdCB0aGUgZG90IHByb2R1Y3QgTFUgZXF1YWxzIEEuXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEFcbiAgICAgKiBAcmV0dXJucyB7e0w6IE1hdHJpeCwgVTogTWF0cml4fX0gcmVzdWx0IC0gUmV0dXJucyB0aGUgbGVmdCB0cmlhbmdsZSBtYXRyaXgge0BsaW5rIEx9IGFuZCB0aGUgdXBwZXIgdHJpYW5nbGUgbWF0cml4IHtAbGluayBVfS5cbiAgICAgKi9cbiAgICBzdGF0aWMgTFUoQSkge1xuICAgICAgICBjb25zdCByb3dzID0gQS5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgTCA9IG5ldyBNYXRyaXgocm93cywgcm93cywgXCJ6ZXJvc1wiKTtcbiAgICAgICAgY29uc3QgVSA9IG5ldyBNYXRyaXgocm93cywgcm93cywgXCJpZGVudGl0eVwiKTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd3M7ICsraikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGo7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGo7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gTC5lbnRyeShpLCBrKSAqIFUuZW50cnkoaywgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEwuc2V0X2VudHJ5KGksIGosIEEuZW50cnkoaSwgaikgLSBzdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGo7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoTC5lbnRyeShqLCBqKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGo7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gTC5lbnRyeShqLCBrKSAqIFUuZW50cnkoaywgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFUuc2V0X2VudHJ5KGosIGksIChBLmVudHJ5KGosIGkpIC0gc3VtKSAvIEwuZW50cnkoaiwgaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgTDogTCwgVTogVSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkZXRlcm1pbmFudGUgb2Yge0BsaW5rIEF9LCBieSB1c2luZyB0aGUgTFUgZGVjb21wb3NpdGlvbiBvZiB7QGxpbmsgQX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEFcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBkZXQgLSBSZXR1cm5zIHRoZSBkZXRlcm1pbmF0ZSBvZiB0aGUgTWF0cml4IHtAbGluayBBfS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGV0KEEpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IEEuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHsgTCwgVSB9ID0gTWF0cml4LkxVKEEpO1xuICAgICAgICBjb25zdCBMX2RpYWcgPSBMLmRpYWc7XG4gICAgICAgIGNvbnN0IFVfZGlhZyA9IFUuZGlhZztcbiAgICAgICAgbGV0IGRldCA9IExfZGlhZ1swXSAqIFVfZGlhZ1swXTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMTsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGRldCAqPSBMX2RpYWdbcm93XSAqIFVfZGlhZ1tyb3ddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHtAbGluayBrfSBjb21wb25lbnRzIG9mIHRoZSBTVkQgZGVjb21wb3NpdGlvbiBvZiB0aGUgbWF0cml4IHtAbGluayBNfVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBNXG4gICAgICogQHBhcmFtIHtpbnR9IFtrPTJdXG4gICAgICogQHJldHVybnMge3tVOiBNYXRyaXgsIFNpZ21hOiBNYXRyaXgsIFY6IE1hdHJpeH19XG4gICAgICovXG4gICAgc3RhdGljIFNWRChNLCBrID0gMikge1xuICAgICAgICBjb25zdCBNVCA9IE0uVDtcbiAgICAgICAgbGV0IE10TSA9IE1ULmRvdChNKTtcbiAgICAgICAgbGV0IE1NdCA9IE0uZG90KE1UKTtcbiAgICAgICAgbGV0IHsgZWlnZW52ZWN0b3JzOiBWLCBlaWdlbnZhbHVlczogU2lnbWEgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihNdE0sIGspO1xuICAgICAgICBsZXQgeyBlaWdlbnZlY3RvcnM6IFUgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihNTXQsIGspO1xuICAgICAgICByZXR1cm4geyBVOiBVLCBTaWdtYTogU2lnbWEubWFwKChzaWdtYSkgPT4gTWF0aC5zcXJ0KHNpZ21hKSksIFY6IFYgfTtcblxuICAgICAgICAvL0FsZ29yaXRobSAxYTogSG91c2Vob2xkZXIgcmVkdWN0aW9uIHRvIGJpZGlhZ29uYWwgZm9ybTpcbiAgICAgICAgLyogY29uc3QgW20sIG5dID0gQS5zaGFwZTtcbiAgICAgICAgbGV0IFUgPSBuZXcgTWF0cml4KG0sIG4sIChpLCBqKSA9PiBpID09IGogPyAxIDogMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFUudG8yZEFycmF5KVxuICAgICAgICBsZXQgViA9IG5ldyBNYXRyaXgobiwgbSwgKGksIGopID0+IGkgPT0gaiA/IDEgOiAwKTtcbiAgICAgICAgY29uc29sZS5sb2coVi50bzJkQXJyYXkpXG4gICAgICAgIGxldCBCID0gTWF0cml4LmJpZGlhZ29uYWwoQS5jbG9uZSgpLCBVLCBWKTtcbiAgICAgICAgY29uc29sZS5sb2coVSxWLEIpXG4gICAgICAgIHJldHVybiB7IFU6IFUsIFwiU2lnbWFcIjogQiwgVjogViB9OyAqL1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGxpbnNwYWNlLCBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnV0aWxzXG4gKiBAYWxpYXMgUmFuZG9taXplclxuICovXG5leHBvcnQgY2xhc3MgUmFuZG9taXplciB7XG4gICAgLyoqXG4gICAgICogTWVyc2VubmUgVHdpc3RlciByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW19zZWVkPW5ldyBEYXRlKCkuZ2V0VGltZSgpXSAtIFRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuIElmIDxjb2RlPl9zZWVkID09IG51bGw8L2NvZGU+IHRoZW4gdGhlIGFjdHVhbCB0aW1lIGdldHMgdXNlZCBhcyBzZWVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JtdXJyYXk3L21lcnNlbm5lLXR3aXN0ZXItZXhhbXBsZXMvYmxvYi9tYXN0ZXIvamF2YXNjcmlwdC1tZXJzZW5uZS10d2lzdGVyLmpzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX3NlZWQpIHtcbiAgICAgICAgdGhpcy5fTiA9IDYyNDtcbiAgICAgICAgdGhpcy5fTSA9IDM5NztcbiAgICAgICAgdGhpcy5fTUFUUklYX0EgPSAweDk5MDhiMGRmO1xuICAgICAgICB0aGlzLl9VUFBFUl9NQVNLID0gMHg4MDAwMDAwMDtcbiAgICAgICAgdGhpcy5fTE9XRVJfTUFTSyA9IDB4N2ZmZmZmZmY7XG4gICAgICAgIHRoaXMuX210ID0gbmV3IEFycmF5KHRoaXMuX04pO1xuICAgICAgICB0aGlzLl9tdGkgPSB0aGlzLk4gKyAxO1xuXG4gICAgICAgIHRoaXMuc2VlZCA9IF9zZWVkIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXQgc2VlZChfc2VlZCkge1xuICAgICAgICB0aGlzLl9zZWVkID0gX3NlZWQ7XG4gICAgICAgIGxldCBtdCA9IHRoaXMuX210O1xuXG4gICAgICAgIG10WzBdID0gX3NlZWQgPj4+IDA7XG4gICAgICAgIGZvciAodGhpcy5fbXRpID0gMTsgdGhpcy5fbXRpIDwgdGhpcy5fTjsgdGhpcy5fbXRpICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBtdGkgPSB0aGlzLl9tdGk7XG4gICAgICAgICAgICBsZXQgcyA9IG10W210aSAtIDFdIF4gKG10W210aSAtIDFdID4+PiAzMCk7XG4gICAgICAgICAgICBtdFttdGldID0gKCgoKHMgJiAweGZmZmYwMDAwKSA+Pj4gMTYpICogMTgxMjQzMzI1MykgPDwgMTYpICsgKHMgJiAweDAwMDBmZmZmKSAqIDE4MTI0MzMyNTMgKyBtdGk7XG4gICAgICAgICAgICBtdFttdGldID4+Pj0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlZWQgb2YgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIHNlZWQuXG4gICAgICovXG4gICAgZ2V0IHNlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybnMge051bWJlcn0gLSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBbMCwgMV1cbiAgICAgKi9cbiAgICBnZXQgcmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5kb21faW50ICogKDEuMCAvIDQyOTQ5NjcyOTYuMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgTUFYX0lOVEVHRVIuXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9IC0gQSByYW5kb20gaW50ZWdlci5cbiAgICAgKi9cbiAgICBnZXQgcmFuZG9tX2ludCgpIHtcbiAgICAgICAgbGV0IHksXG4gICAgICAgICAgICBtYWcwMSA9IG5ldyBBcnJheSgweDAsIHRoaXMuX01BVFJJWF9BKTtcbiAgICAgICAgaWYgKHRoaXMuX210aSA+PSB0aGlzLl9OKSB7XG4gICAgICAgICAgICBsZXQga2s7XG5cbiAgICAgICAgICAgIC8qIGlmICh0aGlzLl9tdGkgPT0gdGhpcy5fTiArIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlZWQgPSA1NDg5O1xuICAgICAgICAgICAgfSAqL1xuXG4gICAgICAgICAgICBsZXQgTl9NID0gdGhpcy5fTiAtIHRoaXMuX007XG4gICAgICAgICAgICBsZXQgTV9OID0gdGhpcy5fTSAtIHRoaXMuX047XG5cbiAgICAgICAgICAgIGZvciAoa2sgPSAwOyBrayA8IE5fTTsgKytraykge1xuICAgICAgICAgICAgICAgIHkgPSAodGhpcy5fbXRba2tdICYgdGhpcy5fVVBQRVJfTUFTSykgfCAodGhpcy5fbXRba2sgKyAxXSAmIHRoaXMuX0xPV0VSX01BU0spO1xuICAgICAgICAgICAgICAgIHRoaXMuX210W2trXSA9IHRoaXMuX210W2trICsgdGhpcy5fTV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyBrayA8IHRoaXMuX04gLSAxOyArK2trKSB7XG4gICAgICAgICAgICAgICAgeSA9ICh0aGlzLl9tdFtra10gJiB0aGlzLl9VUFBFUl9NQVNLKSB8ICh0aGlzLl9tdFtrayArIDFdICYgdGhpcy5fTE9XRVJfTUFTSyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbXRba2tdID0gdGhpcy5fbXRba2sgKyBNX05dIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHkgPSAodGhpcy5fbXRbdGhpcy5fTiAtIDFdICYgdGhpcy5fVVBQRVJfTUFTSykgfCAodGhpcy5fbXRbMF0gJiB0aGlzLl9MT1dFUl9NQVNLKTtcbiAgICAgICAgICAgIHRoaXMuX210W3RoaXMuX04gLSAxXSA9IHRoaXMuX210W3RoaXMuX00gLSAxXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdO1xuXG4gICAgICAgICAgICB0aGlzLl9tdGkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgeSA9IHRoaXMuX210Wyh0aGlzLl9tdGkgKz0gMSldO1xuICAgICAgICB5IF49IHkgPj4+IDExO1xuICAgICAgICB5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcbiAgICAgICAgeSBePSAoeSA8PCAxNSkgJiAweGVmYzYwMDAwO1xuICAgICAgICB5IF49IHkgPj4+IDE4O1xuXG4gICAgICAgIHJldHVybiB5ID4+PiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2FtcGxlcyBmcm9tIGFuIGlucHV0IE1hdHJpeCBvciBBcnJheS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeHxBcnJheXxGbG9hdDY0QXJyYXl9IEEgLSBUaGUgaW5wdXQgTWF0cml4IG9yIEFycmF5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSBBIHJhbmRvbSBzZWxlY3Rpb24gZm9ybSB7QGxpbmsgQX0gb2Yge0BsaW5rIG59IHNhbXBsZXMuXG4gICAgICovXG4gICAgY2hvaWNlKEEsIG4pIHtcbiAgICAgICAgaWYgKEEgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gQS5zaGFwZVswXTtcbiAgICAgICAgICAgIGlmIChuID4gcm93cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm4gYmlnZ2VyIHRoYW4gQSFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2FtcGxlID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgbGV0IGluZGV4X2xpc3QgPSBsaW5zcGFjZSgwLCByb3dzIC0gMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGluZGV4X2xpc3QubGVuZ3RoOyBpIDwgbjsgKytpLCAtLWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZG9tX2luZGV4ID0gdGhpcy5yYW5kb21faW50ICUgbDtcbiAgICAgICAgICAgICAgICBzYW1wbGVbaV0gPSBpbmRleF9saXN0LnNwbGljZShyYW5kb21faW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZS5tYXAoKGQpID0+IEEucm93KGQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEEpIHx8IEEgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gQS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobiA+IHJvd3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuIGJpZ2dlciB0aGFuIEEhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNhbXBsZSA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGxldCBpbmRleF9saXN0ID0gbGluc3BhY2UoMCwgcm93cyAtIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpbmRleF9saXN0Lmxlbmd0aDsgaSA8IG47ICsraSwgLS1sKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmRvbV9pbmRleCA9IHRoaXMucmFuZG9tX2ludCAlIGw7XG4gICAgICAgICAgICAgICAgc2FtcGxlW2ldID0gaW5kZXhfbGlzdC5zcGxpY2UocmFuZG9tX2luZGV4LCAxKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYW1wbGUubWFwKChkKSA9PiBBW2RdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBSZXR1cm5zIHNhbXBsZXMgZnJvbSBhbiBpbnB1dCBNYXRyaXggb3IgQXJyYXkuXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8RmxvYXQ2NEFycmF5fSBBIC0gVGhlIGlucHV0IE1hdHJpeCBvciBBcnJheS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiAtIFRoZSBudW1iZXIgb2Ygc2FtcGxlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VlZCAtIFRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIEEgcmFuZG9tIHNlbGVjdGlvbiBmb3JtIHtAbGluayBBfSBvZiB7QGxpbmsgbn0gc2FtcGxlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY2hvaWNlKEEsIG4sIHNlZWQgPSAxMjEyKSB7XG4gICAgICAgIGNvbnN0IFIgPSBuZXcgUmFuZG9taXplcihzZWVkKTtcbiAgICAgICAgcmV0dXJuIFIuY2hvaWNlKEEsIG4pO1xuICAgICAgICAvKiBsZXQgcm93cyA9IEEuc2hhcGVbMF07XG4gICAgICAgIGlmIChuID4gcm93cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibiBiaWdnZXIgdGhhbiBBIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZCA9IG5ldyBSYW5kb21pemVyKHNlZWQpO1xuICAgICAgICBsZXQgc2FtcGxlID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBsZXQgaW5kZXhfbGlzdCA9IGxpbnNwYWNlKDAsIHJvd3MgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpbmRleF9saXN0Lmxlbmd0aDsgaSA8IG47ICsraSwgLS1sKSB7XG4gICAgICAgICAgICBsZXQgcmFuZG9tX2luZGV4ID0gcmFuZC5yYW5kb21faW50ICUgbDtcbiAgICAgICAgICAgIHNhbXBsZVtpXSA9IGluZGV4X2xpc3Quc3BsaWNlKHJhbmRvbV9pbmRleCwgMSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy9yZXR1cm4gcmVzdWx0O1xuICAgICAgICAvL3JldHVybiBuZXcgTWF0cml4KG4sIGNvbHMsIChyb3csIGNvbCkgPT4gQS5lbnRyeShzYW1wbGVbcm93XSwgY29sKSlcbiAgICAgICAgcmV0dXJuIHNhbXBsZS5tYXAoKGQpID0+IEEucm93KGQpKTsgKi9cbiAgICB9XG59XG4iLCIvKipcbiAqIFJldHVybnMgbWF4aW11bSBpbiBBcnJheSB7QGxpbmsgdmFsdWVzfS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dXRpbHNcbiAqIEBhbGlhcyBtYXhcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICBsZXQgbWF4O1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbn0iLCIvKipcbiAqIFJldHVybnMgbWF4aW11bSBpbiBBcnJheSB7QGxpbmsgdmFsdWVzfS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dXRpbHNcbiAqIEBhbGlhcyBtaW5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIGxldCBtaW47XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA8PSB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluO1xufSIsIi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSGVhcFxuICovXG5leHBvcnQgY2xhc3MgSGVhcCB7XG4gICAgLyoqXG4gICAgICogQSBoZWFwIGlzIGEgZGF0YXN0cnVjdHVyZSBob2xkaW5nIGl0cyBlbGVtZW50cyBpbiBhIHNwZWNpZmljIHdheSwgc28gdGhhdCB0aGUgdG9wIGVsZW1lbnQgd291bGQgYmUgdGhlIGZpcnN0IGVudHJ5IG9mIGFuIG9yZGVyZWQgbGlzdC5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRhdGFzdHJ1Y3R1cmVcbiAgICAgKiBAYWxpYXMgSGVhcFxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBlbGVtZW50cyAtIENvbnRhaW5zIHRoZSBlbGVtZW50cyBmb3IgdGhlIEhlYXAuIHtAbGluayBlbGVtZW50c30gY2FuIGJlIG51bGwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2FjY2Vzc29yID0gKGQpID0+IGRdIC0gRnVuY3Rpb24gcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHsoXCJtaW5cInxcIm1heFwifEZ1bmN0aW9uKX0gW2NvbXBhcmF0b3IgPSBcIm1pblwiXSAtIEZ1bmN0aW9uIHJldHVybmluZyB0cnVlIG9yIGZhbHNlIGRlZmluaW5nIHRoZSB3aXNoZWQgb3JkZXIgb2YgdGhlIEhlYXAsIG9yIFN0cmluZyBmb3IgcHJlZGVmaW5lZCBmdW5jdGlvbi4gKFwibWluXCIgZm9yIGEgTWluLUhlYXAsIFwibWF4XCIgZm9yIGEgTWF4X2hlYXApXG4gICAgICogQHJldHVybnMge0hlYXB9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmluYXJ5X2hlYXB9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMgPSBudWxsLCBhY2Nlc3NvciA9IGQgPT4gZCwgY29tcGFyYXRvciA9IFwibWluXCIpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gSGVhcC5oZWFwaWZ5KGVsZW1lbnRzLCBhY2Nlc3NvciwgY29tcGFyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hY2Nlc3NvciA9IGFjY2Vzc29yO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gW107XG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvciA9PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IChhLCBiKSA9PiBhIDwgYjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGFyYXRvciA9PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IChhLCBiKSA9PiBhID4gYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEhlYXAgZnJvbSBhbiBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl8U2V0fSBlbGVtZW50cyAtIENvbnRhaW5zIHRoZSBlbGVtZW50cyBmb3IgdGhlIEhlYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbj19IFthY2Nlc3NvciA9IChkKSA9PiBkXSAtIEZ1bmN0aW9uIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7KFN0cmluZz18RnVuY3Rpb24pfSBbY29tcGFyYXRvciA9IFwibWluXCJdIC0gRnVuY3Rpb24gcmV0dXJuaW5nIHRydWUgb3IgZmFsc2UgZGVmaW5pbmcgdGhlIHdpc2hlZCBvcmRlciBvZiB0aGUgSGVhcCwgb3IgU3RyaW5nIGZvciBwcmVkZWZpbmVkIGZ1bmN0aW9uLiAoXCJtaW5cIiBmb3IgYSBNaW4tSGVhcCwgXCJtYXhcIiBmb3IgYSBNYXhfaGVhcClcbiAgICAgKiBAcmV0dXJucyB7SGVhcH1cbiAgICAgKi9cbiAgICBzdGF0aWMgaGVhcGlmeShlbGVtZW50cywgYWNjZXNzb3IgPSBkID0+IGQsIGNvbXBhcmF0b3IgPSBcIm1pblwiKSB7XG4gICAgICAgIGNvbnN0IGhlYXAgPSBuZXcgSGVhcChudWxsLCBhY2Nlc3NvciwgY29tcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGhlYXAuX2NvbnRhaW5lcjtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb250YWluZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgXCJlbGVtZW50XCI6IGUsXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBhY2Nlc3NvcihlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLmZsb29yKChlbGVtZW50cy5sZW5ndGggLyAyKSAtIDEpOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaGVhcC5faGVhcGlmeV9kb3duKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGVsZW1lbnRzIG9mIGNvbnRhaW5lciBhcnJheS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleF9hIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleF9iIFxuICAgICAqL1xuICAgIF9zd2FwKGluZGV4X2EsIGluZGV4X2IpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBbY29udGFpbmVyW2luZGV4X2JdLCBjb250YWluZXJbaW5kZXhfYV1dID0gW2NvbnRhaW5lcltpbmRleF9hXSwgY29udGFpbmVyW2luZGV4X2JdXTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hlYXBpZnlfdXAoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgbGV0IGluZGV4ID0gY29udGFpbmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRJbmRleCA9IE1hdGguZmxvb3IoKGluZGV4IC0gMSkgLyAyKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29tcGFyYXRvcihjb250YWluZXJbaW5kZXhdLnZhbHVlLCBjb250YWluZXJbcGFyZW50SW5kZXhdLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N3YXAocGFyZW50SW5kZXgsIGluZGV4KVxuICAgICAgICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1c2hlcyB0aGUgZWxlbWVudCB0byB0aGUgaGVhcC5cbiAgICAgKiBAcGFyYW0ge30gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtIZWFwfVxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2FjY2Vzc29yKGVsZW1lbnQpO1xuICAgICAgICAvL2NvbnN0IG5vZGUgPSBuZXcgTm9kZShlbGVtZW50LCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB7XCJlbGVtZW50XCI6IGVsZW1lbnQsIFwidmFsdWVcIjogdmFsdWV9O1xuICAgICAgICB0aGlzLl9jb250YWluZXIucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5faGVhcGlmeV91cCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRfaW5kZXggPSAwXSBcbiAgICAgKi9cbiAgICBfaGVhcGlmeV9kb3duKHN0YXJ0X2luZGV4PTApIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBjb25zdCBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY29udGFpbmVyLmxlbmd0aDtcbiAgICAgICAgbGV0IGxlZnQgPSAyICogc3RhcnRfaW5kZXggKyAxO1xuICAgICAgICBsZXQgcmlnaHQgPSAyICogc3RhcnRfaW5kZXggKyAyO1xuICAgICAgICBsZXQgaW5kZXggPSBzdGFydF9pbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoKSB0aHJvdyBcImluZGV4IGhpZ2hlciB0aGFuIGxlbmd0aFwiXG4gICAgICAgIGlmIChsZWZ0IDwgbGVuZ3RoICYmIGNvbXBhcmF0b3IoY29udGFpbmVyW2xlZnRdLnZhbHVlLCBjb250YWluZXJbaW5kZXhdLnZhbHVlKSkge1xuICAgICAgICAgICAgaW5kZXggPSBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCA8IGxlbmd0aCAmJiBjb21wYXJhdG9yKGNvbnRhaW5lcltyaWdodF0udmFsdWUsIGNvbnRhaW5lcltpbmRleF0udmFsdWUpKSB7XG4gICAgICAgICAgICBpbmRleCA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPT0gc3RhcnRfaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N3YXAoc3RhcnRfaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX2hlYXBpZnlfZG93bihpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSB0b3AgZW50cnkgb2YgdGhlIGhlYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IGNvbnNpc3RzIG9mIHRoZSBlbGVtZW50IGFuZCBpdHMgdmFsdWUgKGNvbXB1dGVkIGJ5IHtAbGluayBhY2Nlc3Nvcn0pLlxuICAgICAqL1xuICAgIHBvcCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zd2FwKDAsIGNvbnRhaW5lci5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgaXRlbSA9IGNvbnRhaW5lci5wb3AoKTtcbiAgICAgICAgdGhpcy5faGVhcGlmeV9kb3duKCk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvcCBlbnRyeSBvZiB0aGUgaGVhcCB3aXRob3V0IHJlbW92aW5nIGl0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb25zaXN0cyBvZiB0aGUgZWxlbWVudCBhbmQgaXRzIHZhbHVlIChjb21wdXRlZCBieSB7QGxpbmsgYWNjZXNzb3J9KS5cbiAgICAgKi9cbiAgICBnZXQgZmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXIubGVuZ3RoID4gMCA/IHRoaXMuX2NvbnRhaW5lclswXSA6IG51bGw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBZaWVsZHMgdGhlIHJhdyBkYXRhXG4gICAgICogQHlpZWxkcyB7T2JqZWN0fSBPYmplY3QgY29uc2lzdHMgb2YgdGhlIGVsZW1lbnQgYW5kIGl0cyB2YWx1ZSAoY29tcHV0ZWQgYnkge0BsaW5rIGFjY2Vzc29yfSkuXG4gICAgICovXG4gICAgKiBpdGVyYXRlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NvbnRhaW5lci5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX2NvbnRhaW5lcltpXS5lbGVtZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVhcCBhcyBvcmRlcmVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgY29uc2lzdGluZyB0aGUgZWxlbWVudHMgb3JkZXJlZCBieSB7QGxpbmsgY29tcGFyYXRvcn0uXG4gICAgICovXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpXG4gICAgICAgICAgICAuc29ydCgoYSxiKSA9PiB0aGlzLl9jb21wYXJhdG9yKGEsIGIpID8gLTEgOiAwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZWxlbWVudHMgb2YgY29udGFpbmVyIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgY29uc2lzdGluZyB0aGUgZWxlbWVudHMuXG4gICAgICovXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lclxuICAgICAgICAgICAgLm1hcChkID0+IGQuZWxlbWVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250YWluZXIgYXJyYXkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgY29udGFpbmVyIGFycmF5LlxuICAgICAqL1xuICAgIHJhd19kYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSBoZWFwLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lci5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmYWxzZSBpZiB0aGUgdGhlIGhlYXAgaGFzIGVudHJpZXMsIHRydWUgaWYgdGhlIGhlYXAgaGFzIG5vIGVudHJpZXMuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gICAgfVxufSIsIi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgRGlzam9pbnRTZXRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc2pvaW50LXNldF9kYXRhX3N0cnVjdHVyZX1cbiAqL1xuZXhwb3J0IGNsYXNzIERpc2pvaW50U2V0IHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgRGlzam9pbnRTZXRcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRhdGFzdHJ1Y3R1cmVcbiAgICAgKiBAcGFyYW0ge0FycmF5PX0gZWxlbWVudHMgXG4gICAgICogQHJldHVybnMge0Rpc2pvaW50U2V0fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9saXN0ID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMubWFrZV9zZXQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbWFrZV9zZXQoeCkge1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgaWYgKCFsaXN0Lmhhcyh4KSkge1xuICAgICAgICAgICAgbGlzdC5hZGQoeCk7XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0ID0ge307XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0LnBhcmVudCA9IHg7XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuID0gbmV3IFNldChbeF0pO1xuICAgICAgICAgICAgeC5fX2Rpc2pvaW50X3NldC5zaXplID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmaW5kKHgpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIGlmIChsaXN0Lmhhcyh4KSkge1xuICAgICAgICAgICAgaWYgKHguX19kaXNqb2ludF9zZXQucGFyZW50ICE9PSB4KSB7XG4gICAgICAgICAgICAgICAgeC5fX2Rpc2pvaW50X3NldC5jaGlsZHJlbi5hZGQoLi4ueCk7XG4gICAgICAgICAgICAgICAgeC5fX2Rpc2pvaW50X3NldC5wYXJlbnQgPSB0aGlzLmZpbmQoeC5fX2Rpc2pvaW50X3NldC5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB4Ll9fZGlzam9pbnRfc2V0LnBhcmVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuaW9uKHgsIHkpIHtcbiAgICAgICAgbGV0IG5vZGVfeCA9IHRoaXMuZmluZCh4KTtcbiAgICAgICAgbGV0IG5vZGVfeSA9IHRoaXMuZmluZCh5KTtcblxuICAgICAgICBpZiAobm9kZV94ID09PSBub2RlX3kpIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAobm9kZV94Ll9fZGlzam9pbnRfc2V0LnNpemUgPCBub2RlX3kuX19kaXNqb2ludF9zZXQuc2l6ZSkgW25vZGVfeCwgbm9kZV95XSA9IFtub2RlX3ksIG5vZGVfeF07XG5cbiAgICAgICAgbm9kZV95Ll9fZGlzam9pbnRfc2V0LnBhcmVudCA9IG5vZGVfeDtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbj9cbiAgICAgICAgbm9kZV95Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuLmZvckVhY2gobm9kZV94Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuLmFkZCwgbm9kZV94Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuKTtcbiAgICAgICAgbm9kZV94Ll9fZGlzam9pbnRfc2V0LnNpemUgKz0gbm9kZV95Ll9fZGlzam9pbnRfc2V0LnNpemU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBIZWFwIH0gZnJvbSBcIi4uL2RhdGFzdHJ1Y3R1cmUvaW5kZXguanNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgQmFsbFRyZWVcbiAqL1xuZXhwb3J0IGNsYXNzIEJhbGxUcmVlIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBCYWxsVHJlZSB3aXRoIGdpdmVuIHtAbGluayBlbGVtZW50c30uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTprbm5cbiAgICAgKiBAYWxpYXMgQmFsbFRyZWVcbiAgICAgKiBAcGFyYW0ge0FycmF5PX0gZWxlbWVudHMgLSBFbGVtZW50cyB3aGljaCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIEJhbGxUcmVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gbWV0cmljIHRvIHVzZTogKGEsIGIpID0+IGRpc3RhbmNlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFsbF90cmVlfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbnZpc2FsL25vb2Jqcy9ibG9iL21hc3Rlci9zcmMvdHJlZS9CYWxsVHJlZS5qc31cbiAgICAgKiBAcmV0dXJucyB7QmFsbFRyZWV9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMgPSBudWxsLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICAgICAgdGhpcy5fTm9kZSA9IGNsYXNzIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBpdm90LCBjaGlsZDE9bnVsbCwgY2hpbGQyPW51bGwsIHJhZGl1cz1udWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waXZvdCA9IHBpdm90O1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQxID0gY2hpbGQxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQyID0gY2hpbGQyO1xuICAgICAgICAgICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX0xlYWYgPSBjbGFzcyB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcihwb2ludHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZXRyaWMgPSBtZXRyaWM7XG4gICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5hZGQoZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXk8Kj59IGVsZW1lbnRzIC0gbmV3IGVsZW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtCYWxsVHJlZX1cbiAgICAgKi9cbiAgICBhZGQoZWxlbWVudHMpIHtcbiAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cy5tYXAoKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpbmRleCwgZWxlbWVudDogZWxlbWVudH1cbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX2NvbnN0cnVjdChlbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gZWxlbWVudHMgXG4gICAgICogQHJldHVybnMge05vZGV9IHJvb3Qgb2YgYmFsbHRyZWUuXG4gICAgICovXG4gICAgX2NvbnN0cnVjdChlbGVtZW50cykge1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuX0xlYWYoZWxlbWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGMgPSB0aGlzLl9ncmVhdGVzdF9zcHJlYWQoZWxlbWVudHMpO1xuICAgICAgICAgICAgbGV0IHNvcnRlZF9lbGVtZW50cyA9IGVsZW1lbnRzLnNvcnQoKGEsIGIpID0+IGEuZWxlbWVudFtjXSAtIGIuZWxlbWVudFtjXSk7XG4gICAgICAgICAgICBsZXQgbiA9IHNvcnRlZF9lbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcF9pbmRleCA9IE1hdGguZmxvb3IobiAvIDIpO1xuICAgICAgICAgICAgbGV0IHAgPSBlbGVtZW50c1twX2luZGV4XTtcbiAgICAgICAgICAgIGxldCBMID0gc29ydGVkX2VsZW1lbnRzLnNsaWNlKDAsIHBfaW5kZXgpO1xuICAgICAgICAgICAgbGV0IFIgPSBzb3J0ZWRfZWxlbWVudHMuc2xpY2UocF9pbmRleCwgbik7XG4gICAgICAgICAgICBsZXQgcmFkaXVzID0gTWF0aC5tYXgoLi4uZWxlbWVudHMubWFwKGQgPT4gdGhpcy5fbWV0cmljKHAuZWxlbWVudCwgZC5lbGVtZW50KSkpO1xuICAgICAgICAgICAgbGV0IEJcbiAgICAgICAgICAgIGlmIChMLmxlbmd0aCA+IDAgJiYgUi5sZW5ndGggPiAwKSB7ICAgICAgICAgXG4gICAgICAgICAgICAgICAgQiA9IG5ldyB0aGlzLl9Ob2RlKHAsIHRoaXMuX2NvbnN0cnVjdChMKSwgdGhpcy5fY29uc3RydWN0KFIpLCByYWRpdXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBCID0gbmV3IHRoaXMuX0xlYWYoZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gQiBcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIF9ncmVhdGVzdF9zcHJlYWQoQikge1xuICAgICAgICBsZXQgZCA9IEJbMF0uZWxlbWVudC5sZW5ndGg7XG4gICAgICAgIGxldCBzdGFydCA9IG5ldyBBcnJheShkKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQ7ICsraSkge1xuICAgICAgICAgICAgc3RhcnRbaV0gPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3ByZWFkID0gQi5yZWR1Y2UoKGFjYywgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkOyArK2kpIHtcbiAgICAgICAgICAgICAgICBhY2NbaV1bMF0gPSBNYXRoLm1pbihhY2NbaV1bMF0sIGN1cnJlbnQuZWxlbWVudFtpXSk7XG4gICAgICAgICAgICAgICAgYWNjW2ldWzFdID0gTWF0aC5tYXgoYWNjW2ldWzFdLCBjdXJyZW50LmVsZW1lbnRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgc3RhcnQpO1xuICAgICAgICBzcHJlYWQgPSBzcHJlYWQubWFwKGQgPT4gZFsxXSAtIGRbMF0pO1xuICAgICAgICBcbiAgICAgICAgbGV0IGMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQ7ICsraSkge1xuICAgICAgICAgICAgYyA9IHNwcmVhZFtpXSA+IHNwcmVhZFtjXSA/IGkgOiBjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Kn0gdCAtIHF1ZXJ5IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtrID0gNV0gLSBudW1iZXIgb2YgbmVhcmVzdCBuZWlnaGJvcnMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtIZWFwfSAtIEhlYXAgY29uc2lzdHMgb2YgdGhlIHtAbGluayBrfSBuZWFyZXN0IG5laWdoYm9ycy5cbiAgICAgKi9cbiAgICBzZWFyY2godCwgayA9IDUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaCh0LCBrLCBuZXcgSGVhcChudWxsLCBkID0+IHRoaXMuX21ldHJpYyhkLmVsZW1lbnQsIHQpLCBcIm1heFwiKSwgdGhpcy5fcm9vdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHQgLSBxdWVyeSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbayA9IDVdIC0gbnVtYmVyIG9mIG5lYXJlc3QgbmVpZ2hib3JzIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0ge0hlYXB9IFEgLSBIZWFwIGNvbnNpc3RzIG9mIHRoZSBjdXJyZW50bHkgZm91bmQge0BsaW5rIGt9IG5lYXJlc3QgbmVpZ2hib3JzLlxuICAgICAqIEBwYXJhbSB7Tm9kZXxMZWFmfSBCIFxuICAgICAqL1xuICAgIF9zZWFyY2godCwgaywgUSwgQikge1xuICAgICAgICAvLyBCIGlzIE5vZGVcbiAgICAgICAgaWYgKFEubGVuZ3RoID49IGsgJiYgQi5waXZvdCAmJiBCLnJhZGl1cyAmJiB0aGlzLl9tZXRyaWModCwgQi5waXZvdC5lbGVtZW50KSAtIEIucmFkaXVzID49IFEuZmlyc3QudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9IFxuICAgICAgICBpZiAoQi5jaGlsZDEpIHRoaXMuX3NlYXJjaCh0LCBrLCBRLCBCLmNoaWxkMSk7XG4gICAgICAgIGlmIChCLmNoaWxkMikgdGhpcy5fc2VhcmNoKHQsIGssIFEsIEIuY2hpbGQyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEIgaXMgbGVhZlxuICAgICAgICBpZiAoQi5wb2ludHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gQi5wb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHAgPSBCLnBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoayA+IFEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIFEucHVzaChwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBRLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIFEucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBRO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSGVhcCB9IGZyb20gXCIuLi9kYXRhc3RydWN0dXJlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkaXN0YW5jZV9tYXRyaXgsIE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBLTk5cbiAqL1xuZXhwb3J0IGNsYXNzIEtOTiB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgS05OIGxpc3Qgd2l0aCBnaXZlbiB7QGxpbmsgZWxlbWVudHN9LlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6a25uXG4gICAgICogQGFsaWFzIEtOTlxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBlbGVtZW50cyAtIEVsZW1lbnRzIHdoaWNoIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgS05OIGxpc3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFwicHJlY29tcHV0ZWRcIn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gbWV0cmljIGlzIGVpdGhlciBwcmVjb21wdXRlZCBvciBhIGZ1bmN0aW9uIHRvIHVzZTogKGEsIGIpID0+IGRpc3RhbmNlXG4gICAgICogQHJldHVybnMge0tOTn1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cz1udWxsLCBtZXRyaWM9ZXVjbGlkZWFuKSB7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBlbGVtZW50cyBpbnN0YW5jZW9mIE1hdHJpeCA/IGVsZW1lbnRzIDogTWF0cml4LmZyb20oZWxlbWVudHMpO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fZWxlbWVudHMuc2hhcGVbMF07XG4gICAgICAgIGlmIChtZXRyaWMgPT09IFwicHJlY29tcHV0ZWRcIikge1xuICAgICAgICAgICAgdGhpcy5fRCA9IHRoaXMuX2VsZW1lbnRzLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9EID0gZGlzdGFuY2VfbWF0cml4KHRoaXMuX2VsZW1lbnRzLCBtZXRyaWMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuS05OID0gW107XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IE47ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSB0aGlzLl9ELnJvdyhyb3cpO1xuICAgICAgICAgICAgY29uc3QgSCA9IG5ldyBIZWFwKG51bGwsIGQgPT4gZC52YWx1ZSwgXCJtaW5cIik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIEgucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkaXN0YW5jZXNbal0sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBqLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5LTk4ucHVzaChIKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSB0IC0gcXVlcnkgZWxlbWVudCBvciBpbmRleC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2sgPSA1XSAtIG51bWJlciBvZiBuZWFyZXN0IG5laWdoYm9ycyB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0hlYXB9IC0gSGVhcCBjb25zaXN0cyBvZiB0aGUge0BsaW5rIGt9IG5lYXJlc3QgbmVpZ2hib3JzLlxuICAgICAqL1xuICAgIHNlYXJjaCh0LCBrID0gNSkge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IEtOTiA9IHRoaXMuS05OO1xuICAgICAgICBsZXQgSDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZXRyaWMgPT0gXCJwcmVjb21wdXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJTZWFyY2ggYnkgcXVlcnkgZWxlbWVudCBpcyBvbmx5IHBvc3NpYmxlIHdoZW4gbm90IHVzaW5nIGEgcHJlY29tcHV0ZWQgZGlzdGFuY2UgbWF0cml4IVwiXG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cztcbiAgICAgICAgICAgIGNvbnN0IE4gPSBLTk4ubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG5lYXJlc3RfZWxlbWVudF9pbmRleCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbmVhcmVzdF9kaXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50cy5yb3coaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IG1ldHJpYyh0LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG5lYXJlc3RfZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0X2VsZW1lbnRfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0X2Rpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEggPSBLTk5bbmVhcmVzdF9lbGVtZW50X2luZGV4XTtcbiAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHQpKSB7XG4gICAgICAgICAgICBIID0gS05OW3RdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0ID0gW11cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKEgucG9wKCkpXG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmZvckVhY2gocmVzID0+IEgucHVzaChyZXMuZWxlbWVudCkpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9ICAgIFxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IFJhbmRvbWl6ZXIgfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIERSXG4gKiBAYm9ycm93cyBEUiNwYXJhbWV0ZXIgYXMgRFIjcGFyYVxuICogQGJvcnJvd3MgRFIjcGFyYW1ldGVyIGFzIERSI3BcbiAqL1xuZXhwb3J0IGNsYXNzIERSIHtcbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzIGFuZCBzZWFscyB0aGVtLCByZW1lbWJlcnMgdGhlIHR5cGUgb2YgaW5wdXQge0BsaW5rIFh9LCBhbmQgaW5pdGlhbGl6ZXMgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIERSXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXk8QXJyYXk8TnVtYmVyPj59IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5kID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtZXRlcnMubWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCB2YWx1ZSBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtEUn1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBkZWZhdWx0X3BhcmFtZXRlcnMsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LnNlYWwoZGVmYXVsdF9wYXJhbWV0ZXJzKSwgcGFyYW1ldGVycyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KFgpKSB7XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gXCJhcnJheVwiO1xuICAgICAgICAgICAgdGhpcy5YID0gTWF0cml4LmZyb20oWCk7XG4gICAgICAgIH0gZWxzZSBpZiAoWCBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IFwibWF0cml4XCI7XG4gICAgICAgICAgICB0aGlzLlggPSBYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgdHlwZSBmb3IgWCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgW3RoaXMuX04sIHRoaXMuX0RdID0gdGhpcy5YLnNoYXBlO1xuICAgICAgICB0aGlzLl9yYW5kb21pemVyID0gbmV3IFJhbmRvbWl6ZXIodGhpcy5fcGFyYW1ldGVycy5zZWVkKTtcbiAgICAgICAgdGhpcy5faXNfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGFuZCBnZXQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7YW55fSBbdmFsdWUgPSBudWxsXSAtIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtEUnxhbnl9IC0gT24gc2V0dGluZyBhIHBhcmFtZXRlciwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBEUiBvYmplY3QuIElmIDxjb2RlPnZhbHVlID09IG51bGw8L2NvZGU+IHRoZW4gcmV0dXJuIGFjdHVhbCBwYXJhbWV0ZXIgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBEUiA9IG5ldyBkcnVpZC5UU05FKFgsIHtkOiAzfSk7IC8vIGNyZWF0ZXMgYSBuZXcgRFIgb2JqZWN0LCB3aXRoIHBhcmFtZXRlciBmb3IgPGNvZGU+ZDwvY29kZT4gPSAzLlxuICAgICAqIERSLnBhcmFtZXRlcihcImRcIik7IC8vIHJldHVybnMgMyxcbiAgICAgKiBEUi5wYXJhbWV0ZXIoXCJkXCIsIDIpOyAvLyBzZXRzIHBhcmFtZXRlciA8Y29kZT5kPC9jb2RlPiB0byAyIGFuZCByZXR1cm5zIDxjb2RlPkRSPC9jb2RlPi5cbiAgICAgKi9cbiAgICBwYXJhbWV0ZXIobmFtZSwgdmFsdWUgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlciFgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtZXRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJzW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFyYShuYW1lLCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVyKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBwKG5hbWUsIHZhbHVlID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXIobmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IC0gUmV0dXJucyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtHZW5lcmF0b3J9IC0gQSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIGludGVybWVkaWF0ZSBzdGVwcyBvZiB0aGUgZGltZW5zaW9uYWxpdHkgcmVkdWN0aW9uIG1ldGhvZC5cbiAgICAgKi9cbiAgICAqZ2VuZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcmVzcGVjdGl2ZSBEUiBtZXRob2QgaGFzIGFuIDxjb2RlPmluaXQ8L2NvZGU+IGZ1bmN0aW9uLCBjYWxsIGl0IGJlZm9yZSA8Y29kZT50cmFuc2Zvcm08L2NvZGU+LlxuICAgICAqIEByZXR1cm5zIHtEUn1cbiAgICAgKi9cbiAgICBjaGVja19pbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzX2luaXRpYWxpemVkICYmIHR5cGVvZiB0aGlzLmluaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLl9pc19pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge01hdHJpeHxBcnJheX0gUmV0dXJucyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgcHJvamVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoXCJZXCIpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlID09PSBcIm1hdHJpeFwiID8gdGhpcy5ZIDogdGhpcy5ZLnRvMmRBcnJheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhc2V0IGlzIG5vdCB0cmFuc2Zvcm1lZCB5ZXQhXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgLSBBcmd1bWVudHMgdGhlIHRyYW5zZm9ybSBtZXRob2Qgb2YgdGhlIHJlc3BlY3RpdmUgRFIgbWV0aG9kIHRha2VzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB5aWVsZGluZyB0aGUgZGltZW5zaW9uYWxpdHkgcmVkdWNlZCBkYXRhc2V0LlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybV9hc3luYyguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSguLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIC0gVGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIG9mIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcmVzcGVjdGl2ZSBEUiBtZXRob2QuXG4gICAgICogQHJldHVybnMge01hdHJpeHxBcnJheX0gLSBUaGUgZGltZW5zaW9uYWxpdHkgcmVkdWNlZCBkYXRhc2V0LlxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2Zvcm0oLi4uYXJncykge1xuICAgICAgICBsZXQgZHIgPSBuZXcgdGhpcyguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIGRyLnRyYW5zZm9ybSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgLSBUYWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgb2YgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSByZXNwZWN0aXZlIERSIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBBIHByb21pc2UgeWllbGRpbmcgdGhlIGRpbWVuc2lvbmFsaXR5IHJlZHVjZWQgZGF0YXNldC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgdHJhbnNmb3JtX2FzeW5jKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgLSBUYWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgb2YgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSByZXNwZWN0aXZlIERSIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7R2VuZXJhdG9yfSAtIEEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSBpbnRlcm1lZGlhdGUgc3RlcHMgb2YgdGhlIGRpbWVuc2lvbmFsaXR5IHJlZHVjdGlvbiBtZXRob2QuXG4gICAgICovXG4gICAgc3RhdGljICpnZW5lcmF0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBkciA9IG5ldyB0aGlzKC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBkci5nZW5lcmF0b3IoKTtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICB5aWVsZCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBQQ0FcbiAqIEBhdWdtZW50cyBEUlxuICovXG5leHBvcnQgY2xhc3MgUENBIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIFBDQVxuICAgICAqIEBwYXJhbSB7TWF0cml4fEFycmF5PEFycmF5PE51bWJlcj4+fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcml6YXRpb24gb2YgdGhlIERSIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5laWdfYXJnc10gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZWlnZW5kZWNvbXBvc2l0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcmV0dXJucyB7UENBfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBkOiAyLCBzZWVkOiAxMjEyLCBlaWdfYXJnczoge30gfSwgcGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghdGhpcy5fcGFyYW1ldGVycy5laWdfYXJncy5oYXNPd25Qcm9wZXJ0eShcInNlZWRcIikpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtZXRlcnMuZWlnX2FyZ3Muc2VlZCA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXRkYXRhIHtAbGluayBYfSB0byBkaW1lbnNpb25hbGl0eSB7QGxpbmsgZH0uIElmIHBhcmFtZXRlciB7QGxpbmsgQX0gaXMgZ2l2ZW4sIHRoZW4gcHJvamVjdCB7QGxpbmsgQX0gd2l0aCB0aGUgcHJpbmNpcGFsIGNvbXBvbmVudHMgb2Yge0BsaW5rIFh9LlxuICAgICAqIEBwYXJhbSB7bnVsbHxNYXRyaXh8QXJyYXl9IFtBID0gbnVsbF0gLSBJZiBnaXZlbiwgdGhlIGRhdGEgdG8gcHJvamVjdC5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fEFycmF5fSAtIFRoZSBwcm9qZWN0ZWQgZGF0YS5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oQSA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgViA9IHRoaXMucHJpbmNpcGFsX2NvbXBvbmVudHMoKTtcbiAgICAgICAgaWYgKEEgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgICAgIHRoaXMuWSA9IFguZG90KFYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEEpKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0cml4LmZyb20oQSkuZG90KFYpLmFzQXJyYXk7XG4gICAgICAgIH0gZWxzZSBpZiAoQSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgcmV0dXJuIEEuZG90KFYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgdHlwZSBmb3IgQSFcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUge0BsaW5rIGR9IHByaW5jaXBhbCBjb21wb25lbnRzIG9mIE1hdHJpeCB7QGxpbmsgWH0uXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBwcmluY2lwYWxfY29tcG9uZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMuVikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGQsIGVpZ19hcmdzIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBtZWFucyA9IE1hdHJpeC5mcm9tKFgubWVhbkNvbHMpO1xuICAgICAgICBjb25zdCBYX2NlbnQgPSBYLnN1YihtZWFucyk7XG4gICAgICAgIGNvbnN0IEMgPSBYX2NlbnQudHJhbnNwb3NlKCkuZG90KFhfY2VudCk7XG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBWIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oQywgZCwgZWlnX2FyZ3MpO1xuICAgICAgICB0aGlzLlYgPSBNYXRyaXguZnJvbShWKS50cmFuc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuVjtcbiAgICB9XG5cbiAgICBzdGF0aWMgcHJpbmNpcGFsX2NvbXBvbmVudHMoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBkciA9IG5ldyB0aGlzKFgsIHBhcmFtZXRlcnMpO1xuICAgICAgICByZXR1cm4gZHIucHJpbmNpcGFsX2NvbXBvbmVudHMoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IGRpc3RhbmNlX21hdHJpeCwgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBNRFNcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBNRFMgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogQ2xhc3NpY2FsIE1EUy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBNRFNcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmQgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFwicHJlY29tcHV0ZWRcIn0gW3BhcmFtZXRlcnMubWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5laWdfYXJnc10gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZWlnZW5kZWNvbXBvc2l0aW9uIGFsZ29yaXRobS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKFgsIHsgZDogMiwgbWV0cmljOiBldWNsaWRlYW4sIHNlZWQ6IDEyMTIsIGVpZ19hcmdzOiB7fSB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLmhhc093blByb3BlcnR5KFwic2VlZFwiKSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVycy5laWdfYXJncy5zZWVkID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuc2lvbmFsaXR5IHtAbGluayBkfS5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fEFycmF5fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3Qgcm93cyA9IFguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHsgZCwgbWV0cmljLCBlaWdfYXJncyB9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgY29uc3QgQSA9IG1ldHJpYyA9PT0gXCJwcmVjb21wdXRlZFwiID8gWCA6IGRpc3RhbmNlX21hdHJpeChYLCBtZXRyaWMpO1xuICAgICAgICBjb25zdCBhaV8gPSBBLm1lYW5Db2xzO1xuICAgICAgICBjb25zdCBhX2ogPSBBLm1lYW5Sb3dzO1xuICAgICAgICBjb25zdCBhX18gPSBBLm1lYW47XG5cbiAgICAgICAgdGhpcy5fZF9YID0gQTtcbiAgICAgICAgY29uc3QgQiA9IG5ldyBNYXRyaXgocm93cywgcm93cywgKGksIGopID0+IEEuZW50cnkoaSwgaikgLSBhaV9baV0gLSBhX2pbal0gKyBhX18pO1xuXG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBWIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oQiwgZCwgZWlnX2FyZ3MpO1xuICAgICAgICB0aGlzLlkgPSBNYXRyaXguZnJvbShWKS50cmFuc3Bvc2UoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gdGhlIHN0cmVzcyBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICBzdHJlc3MoKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLlguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IFkgPSB0aGlzLlk7XG4gICAgICAgIGNvbnN0IGRfWCA9IHRoaXMuX2RfWDtcbiAgICAgICAgY29uc3QgZF9ZID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBkX1kuc2hhcGUgPSBbXG4gICAgICAgICAgICBOLFxuICAgICAgICAgICAgTixcbiAgICAgICAgICAgIChpLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPCBqID8gZXVjbGlkZWFuKFkucm93KGkpLCBZLnJvdyhqKSkgOiBkX1kuZW50cnkoaiwgaSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICBsZXQgdG9wX3N1bSA9IDA7XG4gICAgICAgIGxldCBib3R0b21fc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIHRvcF9zdW0gKz0gTWF0aC5wb3coZF9YLmVudHJ5KGksIGopIC0gZF9ZLmVudHJ5KGksIGopLCAyKTtcbiAgICAgICAgICAgICAgICBib3R0b21fc3VtICs9IE1hdGgucG93KGRfWC5lbnRyeShpLCBqKSwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0b3Bfc3VtIC8gYm90dG9tX3N1bSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uIH0gZnJvbSBcIi4uL2xpbmVhcl9hbGdlYnJhL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBIZWFwIH0gZnJvbSBcIi4uL2RhdGFzdHJ1Y3R1cmUvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcbmltcG9ydCBldWNsaWRlYW4gZnJvbSBcIi4uL21ldHJpY3MvZXVjbGlkZWFuLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSVNPTUFQXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgSVNPTUFQIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIElzb21ldHJpYyBmZWF0dXJlIG1hcHBpbmcgKElTT01BUCkuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgSVNPTUFQXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbWV0ZXJzLm5laWdoYm9ycyAtIHRoZSBudW1iZXIgb2YgbmVpZ2hib3JzIHtAbGluayBJU09NQVB9IHNob3VsZCB1c2UgdG8gcHJvamVjdCB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbWV0ZXJzLm1ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuc2VlZCA9IDEyMTJdIC0gdGhlIHNlZWQgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZWlnX2FyZ3NdIC0gUGFyYW1ldGVycyBmb3IgdGhlIGVpZ2VuZGVjb21wb3NpdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2kub3JnLzEwLjExMjYvc2NpZW5jZS4yOTAuNTUwMC4yMzE5fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBuZWlnaGJvcnM6IHVuZGVmaW5lZCwgZDogMiwgbWV0cmljOiBldWNsaWRlYW4sIHNlZWQ6IDEyMTIsIGVpZ19hcmdzOiB7fSB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJuZWlnaGJvcnNcIiwgTWF0aC5taW4odGhpcy5fcGFyYW1ldGVycy5uZWlnaGJvcnMgPz8gTWF0aC5tYXgoTWF0aC5mbG9vcih0aGlzLlguc2hhcGVbMF0gLyAxMCksIDIpLCB0aGlzLl9OIC0gMSkpO1xuICAgICAgICBpZiAoIXRoaXMuX3BhcmFtZXRlcnMuZWlnX2FyZ3MuaGFzT3duUHJvcGVydHkoXCJzZWVkXCIpKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLnNlZWQgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IFJldHVybnMgdGhlIHByb2plY3Rpb24uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IHsgZCwgbWV0cmljLCBlaWdfYXJncywgbmVpZ2hib3JzIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICAvLyBUT0RPOiBtYWtlIGtubiBleHRlcm4gYW5kIHBhcmFtZXRlciBmb3IgY29uc3RydWN0b3Igb3IgdHJhbnNmb3JtP1xuICAgICAgICBjb25zdCBEID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBELnNoYXBlID0gW3Jvd3MsIHJvd3MsIChpLCBqKSA9PiAoaSA8PSBqID8gbWV0cmljKFgucm93KGkpLCBYLnJvdyhqKSkgOiBELmVudHJ5KGosIGkpKV07XG4gICAgICAgIGNvbnN0IGtOZWFyZXN0TmVpZ2hib3JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93czsgKytqKSB7XG4gICAgICAgICAgICAgICAgcm93LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogaixcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IEQuZW50cnkoaSwgaiksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBIID0gbmV3IEhlYXAocm93LCAoZCkgPT4gZC5kaXN0YW5jZSwgXCJtaW5cIik7XG4gICAgICAgICAgICBrTmVhcmVzdE5laWdoYm9ycy5wdXNoKEgudG9BcnJheSgpLnNsaWNlKDEsIG5laWdoYm9ycyArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qRCA9IGRpamtzdHJhKGtOZWFyZXN0TmVpZ2hib3JzKTsqL1xuICAgICAgICAvLyBjb21wdXRlIHNob3J0ZXN0IHBhdGhzXG4gICAgICAgIC8vIFRPRE86IG1ha2UgZXh0ZXJuXG4gICAgICAgIC8qKiBAc2VlIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZCVFMiU4MCU5M1dhcnNoYWxsX2FsZ29yaXRobX0gKi9cbiAgICAgICAgY29uc3QgRyA9IG5ldyBNYXRyaXgocm93cywgcm93cywgKGksIGopID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0ga05lYXJlc3ROZWlnaGJvcnNbaV0uZmluZCgobikgPT4gbi5pbmRleCA9PT0gaik7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPyBvdGhlci5kaXN0YW5jZSA6IEluZmluaXR5O1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dzOyArK2opIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJvd3M7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBHLnNldF9lbnRyeShpLCBqLCBNYXRoLm1pbihHLmVudHJ5KGksIGopLCBHLmVudHJ5KGksIGspICsgRy5lbnRyeShrLCBqKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhaV8gPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MpO1xuICAgICAgICBsZXQgYV9qID0gbmV3IEZsb2F0NjRBcnJheShyb3dzKTtcbiAgICAgICAgbGV0IGFfXyA9IDA7XG4gICAgICAgIGNvbnN0IEEgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIChpLCBqKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsID0gRy5lbnRyeShpLCBqKTtcbiAgICAgICAgICAgIHZhbCA9IHZhbCA9PT0gSW5maW5pdHkgPyAwIDogdmFsO1xuICAgICAgICAgICAgYWlfW2ldICs9IHZhbDtcbiAgICAgICAgICAgIGFfaltqXSArPSB2YWw7XG4gICAgICAgICAgICBhX18gKz0gdmFsO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWlfID0gYWlfLm1hcCgodikgPT4gdiAvIHJvd3MpO1xuICAgICAgICBhX2ogPSBhX2oubWFwKCh2KSA9PiB2IC8gcm93cyk7XG4gICAgICAgIGFfXyAvPSByb3dzICoqIDI7XG4gICAgICAgIGNvbnN0IEIgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIChpLCBqKSA9PiBBLmVudHJ5KGksIGopIC0gYWlfW2ldIC0gYV9qW2pdICsgYV9fKTtcblxuICAgICAgICAvLyBjb21wdXRlIGQgZWlnZW52ZWN0b3JzXG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBWIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oQiwgZCwgZWlnX2FyZ3MpO1xuICAgICAgICB0aGlzLlkgPSBNYXRyaXguZnJvbShWKS50cmFuc3Bvc2UoKTtcbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZ1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEZBU1RNQVBcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBGQVNUTUFQIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIEZhc3RNYXA6IGEgZmFzdCBhbGdvcml0aG0gZm9yIGluZGV4aW5nLCBkYXRhLW1pbmluZyBhbmQgdmlzdWFsaXphdGlvbiBvZiB0cmFkaXRpb25hbCBhbmQgbXVsdGltZWRpYSBkYXRhc2V0c1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIEZBU1RNQVBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmQgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1ldGVycy5tZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RkFTVE1BUH1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvaS5vcmcvMTAuMTE0NS8yMjM3ODQuMjIzODEyfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hvb3NlcyB0d28gcG9pbnRzIHdoaWNoIGFyZSB0aGUgbW9zdCBkaXN0YW50IGluIHRoZSBhY3R1YWwgcHJvamVjdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgZmlyc3QgaW5kZXgsIHNlY29uZCBpbmRleCwgYW5kIGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXG4gICAgICovXG4gICAgX2Nob29zZV9kaXN0YW50X29iamVjdHMoZGlzdCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgbGV0IGFfaW5kZXggPSAodGhpcy5fcmFuZG9taXplci5yYW5kb21faW50ICUgTikgLSAxO1xuICAgICAgICBsZXQgYl9pbmRleCA9IG51bGw7XG4gICAgICAgIGxldCBtYXhfZGlzdCA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGRfYWkgPSBkaXN0KGFfaW5kZXgsIGkpO1xuICAgICAgICAgICAgaWYgKGRfYWkgPiBtYXhfZGlzdCkge1xuICAgICAgICAgICAgICAgIG1heF9kaXN0ID0gZF9haTtcbiAgICAgICAgICAgICAgICBiX2luZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXhfZGlzdCA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGRfYmkgPSBkaXN0KGJfaW5kZXgsIGkpO1xuICAgICAgICAgICAgaWYgKGRfYmkgPiBtYXhfZGlzdCkge1xuICAgICAgICAgICAgICAgIG1heF9kaXN0ID0gZF9iaTtcbiAgICAgICAgICAgICAgICBhX2luZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FfaW5kZXgsIGJfaW5kZXgsIG1heF9kaXN0XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSBUaGUge0BsaW5rIGR9LWRpbWVuc2lvbmFsIHByb2plY3Rpb24gb2YgdGhlIGRhdGEgbWF0cml4IHtAbGluayBYfS5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IE4gPSBYLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCB7IGQsIG1ldHJpYyB9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgY29uc3QgWSA9IG5ldyBNYXRyaXgoTiwgZCwgMCk7XG4gICAgICAgIGxldCBkaXN0ID0gKGEsIGIpID0+IG1ldHJpYyhYLnJvdyhhKSwgWC5yb3coYikpO1xuXG4gICAgICAgIGZvciAobGV0IF9jb2wgPSAwOyBfY29sIDwgZDsgKytfY29sKSB7XG4gICAgICAgICAgICBsZXQgb2xkX2Rpc3QgPSBkaXN0O1xuICAgICAgICAgICAgLy8gY2hvb3NlIHBpdm90IG9iamVjdHNcbiAgICAgICAgICAgIGNvbnN0IFthX2luZGV4LCBiX2luZGV4LCBkX2FiXSA9IHRoaXMuX2Nob29zZV9kaXN0YW50X29iamVjdHMoZGlzdCk7XG4gICAgICAgICAgICBpZiAoZF9hYiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHByb2plY3QgdGhlIG9iamVjdHMgb24gdGhlIGxpbmUgKE9fYSwgT19iKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRfYWkgPSBkaXN0KGFfaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkX2JpID0gZGlzdChiX2luZGV4LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeV9pID0gKGRfYWkgKiogMiArIGRfYWIgKiogMiAtIGRfYmkgKiogMikgLyAoMiAqIGRfYWIpO1xuICAgICAgICAgICAgICAgICAgICBZLnNldF9lbnRyeShpLCBfY29sLCB5X2kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgcHJvamVjdGlvbnMgb2YgdGhlIG9iamVjdHMgb24gYVxuICAgICAgICAgICAgICAgIC8vIGh5cGVycGxhbmUgcGVycGVuZGljbHVhciB0byB0aGUgbGluZSAoYSwgYik7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGRpc3RhbmNlIGZ1bmN0aW9uIEQnKCkgYmV0d2VlbiB0d29cbiAgICAgICAgICAgICAgICAvLyBwcm9qZWN0aW9ucyBpcyBnaXZlbiBieSBFcS40XG4gICAgICAgICAgICAgICAgZGlzdCA9IChhLCBiKSA9PiBNYXRoLnNxcnQob2xkX2Rpc3QoYSwgYikgKiogMiAtIChZLmVudHJ5KGEsIF9jb2wpIC0gWS5lbnRyeShiLCBfY29sKSkgKiogMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZy5cbiAgICAgICAgdGhpcy5ZID0gWTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBMREFcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBMREEgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogTGluZWFyIERpc2NyaW1pbmFudCBBbmFseXNpcy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBMREFcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIFRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1ldGVycy5sYWJlbHMgLSBUaGUgbGFiZWxzIC8gY2xhc3NlcyBmb3IgZWFjaCBkYXRhIHBvaW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1ldGVycy5kID0gMl0gLSBUaGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmVpZ19hcmdzXSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBlaWdlbmRlY29tcG9zaXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vb25saW5lbGlicmFyeS53aWxleS5jb20vZG9pLzEwLjExMTEvai4xNDY5LTE4MDkuMTkzNi50YjAyMTM3Lnh9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IGxhYmVsczogbnVsbCwgZDogMiwgc2VlZDogMTIxMiwgZWlnX2FyZ3M6IHt9IH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3BhcmFtZXRlcnMuZWlnX2FyZ3MuaGFzT3duUHJvcGVydHkoXCJzZWVkXCIpKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLnNlZWQgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0ZGF0YSB7QGxpbmsgWH0gdG8gZGltZW5pb25hbGl0eSB7QGxpbmsgZH0uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBbcm93cywgY29sc10gPSBYLnNoYXBlO1xuICAgICAgICBjb25zdCB7IGQsIGxhYmVscywgZWlnX2FyZ3MgfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGlmIChsYWJlbHMgPT09IG51bGwgfHwgbGFiZWxzLmxlbmd0aCAhPSByb3dzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMREEgbmVlZHMgcGFyYW1ldGVyIGxhYmVsIHRvIGV2ZXJ5IGRhdGFwb2ludCB0byB3b3JrIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bmlxdWVfbGFiZWxzID0ge307XG4gICAgICAgIGxldCBsYWJlbF9pZCA9IDA7XG4gICAgICAgIGxhYmVscy5mb3JFYWNoKChsLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAobCBpbiB1bmlxdWVfbGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlX2xhYmVsc1tsXS5jb3VudCsrO1xuICAgICAgICAgICAgICAgIHVuaXF1ZV9sYWJlbHNbbF0ucm93cy5wdXNoKFgucm93KGkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlX2xhYmVsc1tsXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGxhYmVsX2lkKyssXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICByb3dzOiBbWC5yb3coaSldLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBYX21lYW4gYW5kIHZlY3RvciBtZWFucztcbiAgICAgICAgY29uc3QgWF9tZWFuID0gWC5tZWFuO1xuICAgICAgICBjb25zdCBWX21lYW4gPSBuZXcgTWF0cml4KGxhYmVsX2lkLCBjb2xzKTtcbiAgICAgICAgZm9yIChjb25zdCBsYWJlbCBpbiB1bmlxdWVfbGFiZWxzKSB7XG4gICAgICAgICAgICBjb25zdCBWID0gTWF0cml4LmZyb20odW5pcXVlX2xhYmVsc1tsYWJlbF0ucm93cyk7XG4gICAgICAgICAgICBjb25zdCB2X21lYW4gPSBWLm1lYW5Db2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcbiAgICAgICAgICAgICAgICBWX21lYW4uc2V0X2VudHJ5KHVuaXF1ZV9sYWJlbHNbbGFiZWxdLmlkLCBqLCB2X21lYW5bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNjYXR0ZXJfYmV0d2VlblxuICAgICAgICBsZXQgU19iID0gbmV3IE1hdHJpeChjb2xzLCBjb2xzKTtcbiAgICAgICAgZm9yIChjb25zdCBsYWJlbCBpbiB1bmlxdWVfbGFiZWxzKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gVl9tZWFuLnJvdyh1bmlxdWVfbGFiZWxzW2xhYmVsXS5pZCk7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3IE1hdHJpeChjb2xzLCAxLCAoaikgPT4gdltqXSAtIFhfbWVhbik7XG4gICAgICAgICAgICBjb25zdCBOID0gdW5pcXVlX2xhYmVsc1tsYWJlbF0uY291bnQ7XG4gICAgICAgICAgICBTX2IgPSBTX2IuYWRkKG0uZG90KG0udHJhbnNwb3NlKCkpLm11bHQoTikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2NhdHRlcl93aXRoaW5cbiAgICAgICAgbGV0IFNfdyA9IG5ldyBNYXRyaXgoY29scywgY29scyk7XG4gICAgICAgIGZvciAoY29uc3QgbGFiZWwgaW4gdW5pcXVlX2xhYmVscykge1xuICAgICAgICAgICAgY29uc3QgdiA9IFZfbWVhbi5yb3codW5pcXVlX2xhYmVsc1tsYWJlbF0uaWQpO1xuICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXgoY29scywgMSwgKGopID0+IHZbal0pO1xuICAgICAgICAgICAgY29uc3QgUiA9IHVuaXF1ZV9sYWJlbHNbbGFiZWxdLnJvd3M7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHVuaXF1ZV9sYWJlbHNbbGFiZWxdLmNvdW50OyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93X3YgPSBuZXcgTWF0cml4KGNvbHMsIDEsIChqLCBfKSA9PiBSW2ldW2pdIC0gbS5lbnRyeShqLCAwKSk7XG4gICAgICAgICAgICAgICAgU193ID0gU193LmFkZChyb3dfdi5kb3Qocm93X3YudHJhbnNwb3NlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB7IGVpZ2VudmVjdG9yczogViB9ID0gc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uKFNfdy5pbnZlcnNlKCkuZG90KFNfYiksIGQsIGVpZ19hcmdzKTtcbiAgICAgICAgViA9IE1hdHJpeC5mcm9tKFYpLnRyYW5zcG9zZSgpO1xuICAgICAgICB0aGlzLlkgPSBYLmRvdChWKTtcblxuICAgICAgICAvLyByZXR1cm4gZW1iZWRkaW5nXG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbiB9IGZyb20gXCIuLi9saW5lYXJfYWxnZWJyYS9pbmRleC5qc1wiO1xuaW1wb3J0IHsga19uZWFyZXN0X25laWdoYm9ycyB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IG5ldW1haXJfc3VtIH0gZnJvbSBcIi4uL251bWVyaWNhbC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIExMRVxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIExMRSBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKiBMb2NhbGx5IExpbmVhciBFbWJlZGRpbmcuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgTExFXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuZWlnaGJvcnMgLSB0aGUgbGFiZWwgLyBjbGFzcyBvZiBlYWNoIGRhdGEgcG9pbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZWlnX2FyZ3NdIC0gUGFyYW1ldGVycyBmb3IgdGhlIGVpZ2VuZGVjb21wb3NpdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2kub3JnLzEwLjExMjYvc2NpZW5jZS4yOTAuNTUwMC4yMzIzfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBuZWlnaGJvcnM6IHVuZGVmaW5lZCwgZDogMiwgbWV0cmljOiBldWNsaWRlYW4sIHNlZWQ6IDEyMTIsIGVpZ19hcmdzOiB7fSB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJuZWlnaGJvcnNcIiwgTWF0aC5taW4ocGFyYW1ldGVycy5uZWlnaGJvcnMgPz8gTWF0aC5tYXgoTWF0aC5mbG9vcih0aGlzLl9OIC8gMTApLCAyKSwgdGhpcy5fTiAtIDEpKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLmhhc093blByb3BlcnR5KFwic2VlZFwiKSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVycy5laWdfYXJncy5zZWVkID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuaW9uYWxpdHkge0BsaW5rIGR9LlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9EO1xuICAgICAgICBjb25zdCB7IG5laWdoYm9ycywgZCwgZWlnX2FyZ3MsIG1ldHJpYyB9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgbk4gPSBrX25lYXJlc3RfbmVpZ2hib3JzKFgsIG5laWdoYm9ycywgbWV0cmljKTtcbiAgICAgICAgY29uc3QgTyA9IG5ldyBNYXRyaXgobmVpZ2hib3JzLCAxLCAxKTtcbiAgICAgICAgY29uc3QgVyA9IG5ldyBNYXRyaXgocm93cywgcm93cyk7XG5cbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IG5OX3JvdyA9IG5OW3Jvd107XG4gICAgICAgICAgICBjb25zdCBaID0gbmV3IE1hdHJpeChuZWlnaGJvcnMsIGNvbHMsIChpLCBqKSA9PiBYLmVudHJ5KG5OX3Jvd1tpXS5qLCBqKSAtIFguZW50cnkocm93LCBqKSk7XG4gICAgICAgICAgICBjb25zdCBDID0gWi5kb3QoWi5UKTtcbiAgICAgICAgICAgIGlmIChuZWlnaGJvcnMgPiBjb2xzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgQ190cmFjZSA9IG5ldW1haXJfc3VtKEMuZGlhZykgLyAxMDAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmVpZ2hib3JzOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgQy5zZXRfZW50cnkoaiwgaiwgQy5lbnRyeShqLCBqKSArIENfdHJhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlY29uc3RydWN0O1xuICAgICAgICAgICAgbGV0IHcgPSBNYXRyaXguc29sdmVfQ0coQywgTywgdGhpcy5fcmFuZG9taXplcik7XG4gICAgICAgICAgICB3ID0gdy5kaXZpZGUody5zdW0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuZWlnaGJvcnM7ICsraikge1xuICAgICAgICAgICAgICAgIFcuc2V0X2VudHJ5KHJvdywgbk5fcm93W2pdLmosIHcuZW50cnkoaiwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXAgZW1iZWRkaW5nXG4gICAgICAgIGNvbnN0IEkgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIFwiaWRlbnRpdHlcIik7XG4gICAgICAgIGNvbnN0IElXID0gSS5zdWIoVyk7XG4gICAgICAgIGNvbnN0IE0gPSBJVy5ULmRvdChJVyk7XG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBWIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oTS5ULmludmVyc2UoKSwgZCArIDEsIGVpZ19hcmdzKTtcbiAgICAgICAgdGhpcy5ZID0gTWF0cml4LmZyb20oVi5zbGljZSgxLCAxICsgZCkpLlQ7XG5cbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZ1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE1hdHJpeCwga19uZWFyZXN0X25laWdoYm9ycyB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBMVFNBXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgTFRTQSBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKiBMb2NhbCBUYW5nZW50IFNwYWNlIEFsaWdubWVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIExUU0FcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtZXRlcnMubmVpZ2hib3JzIC0gdGhlIG51bWJlciBvZiBuZWlnaGJvcnMge0BsaW5rIExUU0F9IHNob3VsZCB1c2UgdG8gcHJvamVjdCB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbWV0ZXJzLm1ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuc2VlZCA9IDEyMTJdIC0gdGhlIHNlZWQgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZWlnX2FyZ3NdIC0gUGFyYW1ldGVycyBmb3IgdGhlIGVpZ2VuZGVjb21wb3NpdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lcHVicy5zaWFtLm9yZy9kb2kvYWJzLzEwLjExMzcvUzEwNjQ4Mjc1MDI0MTkxNTR9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IG5laWdoYm9yczogdW5kZWZpbmVkLCBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiwgZWlnX2FyZ3M6IHt9IH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcIm5laWdoYm9yc1wiLCBNYXRoLm1pbihwYXJhbWV0ZXJzLm5laWdoYm9ycyA/PyBNYXRoLm1heChNYXRoLmZsb29yKHRoaXMuX04gLyAxMCksIDIpLCB0aGlzLl9OIC0gMSkpO1xuICAgICAgICBpZiAoIXRoaXMuX3BhcmFtZXRlcnMuZWlnX2FyZ3MuaGFzT3duUHJvcGVydHkoXCJzZWVkXCIpKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLnNlZWQgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9EIDw9IHRoaXMucGFyYW1ldGVyKFwiZFwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaW1lbnNpb25hbGl0eSBvZiBYIChEID0gJHt0aGlzLl9EfSkgbXVzdCBiZSBncmVhdGVyIHRoYW4gdGhlIHJlcXVpcmVkIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSByZXN1bHQgKGQgPSAke3RoaXMucGFyYW1ldGVyKFwiZFwiKX0pIWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0ZGF0YSB7QGxpbmsgWH0gdG8gZGltZW5pb25hbGl0eSB7QGxpbmsgZH0uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBbcm93cywgRF0gPSBYLnNoYXBlO1xuICAgICAgICBjb25zdCB7IGQsIG5laWdoYm9ycywgbWV0cmljLCBlaWdfYXJncyB9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgLy8gMS4xIGRldGVybWluZSBrIG5lYXJlc3QgbmVpZ2hib3JzXG4gICAgICAgIGNvbnN0IG5OID0ga19uZWFyZXN0X25laWdoYm9ycyhYLCBuZWlnaGJvcnMsIG1ldHJpYyk7XG4gICAgICAgIC8vIGNlbnRlciBtYXRyaXhcbiAgICAgICAgY29uc3QgTyA9IG5ldyBNYXRyaXgoRCwgRCwgXCJjZW50ZXJcIik7XG4gICAgICAgIGNvbnN0IEIgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIDApO1xuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAvLyAxLjIgY29tcHV0ZSB0aGUgZCBsYXJnZXN0IGVpZ2VudmVjdG9ycyBvZiB0aGUgY29ycmVsYXRpb24gbWF0cml4XG4gICAgICAgICAgICBjb25zdCBJX2kgPSBbcm93LCAuLi5uTltyb3ddLm1hcCgobikgPT4gbi5qKV07XG4gICAgICAgICAgICBsZXQgWF9pID0gTWF0cml4LmZyb20oSV9pLm1hcCgobikgPT4gWC5yb3cobikpKTtcbiAgICAgICAgICAgIC8vIGNlbnRlciBYX2lcbiAgICAgICAgICAgIFhfaSA9IFhfaS5kb3QoTyk7XG4gICAgICAgICAgICAvLyBjb3JyZWxhdGlvbiBtYXRyaXhcbiAgICAgICAgICAgIGNvbnN0IEMgPSBYX2kuZG90KFhfaS50cmFuc3Bvc2UoKSk7XG4gICAgICAgICAgICBjb25zdCB7IGVpZ2VudmVjdG9yczogZyB9ID0gc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uKEMsIGQsIGVpZ19hcmdzKTtcbiAgICAgICAgICAgIC8vZy5wdXNoKGxpbnNwYWNlKDAsIGspLm1hcChfID0+IDEgLyBNYXRoLnNxcnQoayArIDEpKSk7XG4gICAgICAgICAgICBjb25zdCBHX2lfdCA9IE1hdHJpeC5mcm9tKGcpO1xuICAgICAgICAgICAgLy8gMi4gQ29uc3RydWN0aW5nIGFsaWdubWVudCBtYXRyaXhcbiAgICAgICAgICAgIGNvbnN0IFdfaSA9IEdfaV90LnRyYW5zcG9zZSgpXG4gICAgICAgICAgICAgICAgLmRvdChHX2lfdClcbiAgICAgICAgICAgICAgICAuYWRkKDEgLyBNYXRoLnNxcnQobmVpZ2hib3JzICsgMSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnMgKyAxOyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5laWdoYm9ycyArIDE7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShJX2lbaV0sIElfaVtqXSwgQi5lbnRyeShJX2lbaV0sIElfaVtqXSkgLSAoaSA9PT0gaiA/IDEgOiAwKSArIFdfaS5lbnRyeShpLCBqKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gQWxpZ25pbmcgZ2xvYmFsIGNvb3JkaW5hdGVzXG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBZIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oQiwgZCArIDEsIGVpZ19hcmdzKTtcbiAgICAgICAgdGhpcy5ZID0gTWF0cml4LmZyb20oWS5zbGljZSgxKSkudHJhbnNwb3NlKCk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZ1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgVFNORVxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIFRTTkUgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBUU05FXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5wZXJwbGV4aXR5ID0gNTBdIC0gcGVycGxleGl0eS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZXBzaWxvbiA9IDEwXSAtIGxlYXJuaW5nIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbcGFyYW1ldGVycy5tZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge1RTTkV9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IHBlcnBsZXhpdHk6IDUwLCBlcHNpbG9uOiAxMCwgZDogMiwgbWV0cmljOiBldWNsaWRlYW4sIHNlZWQ6IDEyMTIgfSwgcGFyYW1ldGVycyk7XG4gICAgICAgIFt0aGlzLl9OLCB0aGlzLl9EXSA9IHRoaXMuWC5zaGFwZTtcbiAgICAgICAgdGhpcy5faXRlciA9IDA7XG4gICAgICAgIHRoaXMuWSA9IG5ldyBNYXRyaXgodGhpcy5fTiwgdGhpcy5wYXJhbWV0ZXIoXCJkXCIpLCAoKSA9PiB0aGlzLl9yYW5kb21pemVyLnJhbmRvbSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGRpc3RhbmNlX21hdHJpeCAtIGFjY2VwdHMgYSBwcmVjb21wdXRlZCBkaXN0YW5jZSBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB7VFNORX1cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICAvLyBpbml0XG4gICAgICAgIGNvbnN0IEh0YXJnZXQgPSBNYXRoLmxvZyh0aGlzLnBhcmFtZXRlcihcInBlcnBsZXhpdHlcIikpO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgRCA9IHRoaXMuX0Q7XG4gICAgICAgIGNvbnN0IHttZXRyaWN9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgbGV0IERlbHRhO1xuICAgICAgICBpZiAobWV0cmljID09XCJwcmVjb21wdXRlZFwiKSB7XG4gICAgICAgICAgICBEZWx0YSA9IGRydWlkLk1hdHJpeC5mcm9tKFgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRGVsdGEgPSBuZXcgTWF0cml4KE4sIE4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBYX2kgPSBYLnJvdyhpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBtZXRyaWMoWF9pLCBYLnJvdyhqKSk7XG4gICAgICAgICAgICAgICAgICAgIERlbHRhLnNldF9lbnRyeShpLCBqLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIERlbHRhLnNldF9lbnRyeShqLCBpLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgUCA9IG5ldyBNYXRyaXgoTiwgTiwgXCJ6ZXJvc1wiKTtcblxuICAgICAgICB0aGlzLl95c3RlcCA9IG5ldyBNYXRyaXgoTiwgRCwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgdGhpcy5fZ2FpbnMgPSBuZXcgTWF0cml4KE4sIEQsIDEpO1xuXG4gICAgICAgIC8vIHNlYXJjaCBmb3IgZml0dGluZyBzaWdtYVxuICAgICAgICBsZXQgcHJvdyA9IG5ldyBGbG9hdDY0QXJyYXkoTilcbiAgICAgICAgY29uc3QgdG9sID0gMWUtNDtcbiAgICAgICAgY29uc3QgbWF4dHJpZXMgPSA1MDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBiZXRhbWluID0gLUluZmluaXR5O1xuICAgICAgICAgICAgbGV0IGJldGFtYXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBiZXRhID0gMTtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGxldCBudW0gPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaiA9IE1hdGguZXhwKC1EZWx0YS5lbnRyeShpLCBqKSAqIGJldGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaikgcGogPSAwO1xuICAgICAgICAgICAgICAgICAgICBwcm93W2pdID0gcGo7XG4gICAgICAgICAgICAgICAgICAgIHBzdW0gKz0gcGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBIaGVyZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBqID0gcHN1bSA9PT0gMCA/IDAgOiBwcm93W2pdIC8gcHN1bTtcbiAgICAgICAgICAgICAgICAgICAgcHJvd1tqXSA9IHBqO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGogPiAxZS03KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBIaGVyZSAtPSBwaiAqIE1hdGgubG9nKHBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoSGhlcmUgPiBIdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJldGFtaW4gPSBiZXRhO1xuICAgICAgICAgICAgICAgICAgICBiZXRhID0gYmV0YW1heCA9PT0gSW5maW5pdHkgPyBiZXRhICogMiA6IChiZXRhICsgYmV0YW1heCkgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJldGFtYXggPSBiZXRhO1xuICAgICAgICAgICAgICAgICAgICBiZXRhID0gYmV0YW1pbiA9PT0gLUluZmluaXR5ID8gYmV0YSAvIDIgOiAoYmV0YSArIGJldGFtaW4pIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytudW07XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKEhoZXJlIC0gSHRhcmdldCkgPCB0b2wpIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChudW0gPj0gbWF4dHJpZXMpIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIFAuc2V0X2VudHJ5KGksIGosIHByb3dbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9jb21wdXRlIHByb2JhYmlsaXRpZXNcbiAgICAgICAgY29uc3QgUG91dCA9IG5ldyBNYXRyaXgoTiwgTiwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgY29uc3QgTjIgPSBOICogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IE1hdGgubWF4KChQLmVudHJ5KGksIGopICsgUC5lbnRyeShqLCBpKSkgLyBOMiwgMWUtMTAwKTtcbiAgICAgICAgICAgICAgICBQb3V0LnNldF9lbnRyeShpLCBqLCBwKTtcbiAgICAgICAgICAgICAgICBQb3V0LnNldF9lbnRyeShqLCBpLCBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9QID0gUG91dDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2l0ZXJhdGlvbnM9NTAwXSAtIG51bWJlciBvZiBpdGVyYXRpb25zLlxuICAgICAqIEB5aWVsZHMge01hdHJpeHxBcnJheTxBcnJheT59IC0gdGhlIHByb2plY3Rpb24uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKGl0ZXJhdGlvbnMgPSA1MDApIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpdGVyYXRpb25zPTUwMF0gLSBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAgICAgKiBAeWllbGRzIHtNYXRyaXh8QXJyYXk8QXJyYXk+fSAtIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgICpnZW5lcmF0b3IoaXRlcmF0aW9ucyA9IDUwMCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGVyZm9ybXMgYSBvcHRpbWl6YXRpb24gc3RlcFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyID0gKyt0aGlzLl9pdGVyO1xuICAgICAgICBjb25zdCBQID0gdGhpcy5fUDtcbiAgICAgICAgY29uc3QgeXN0ZXAgPSB0aGlzLl95c3RlcDtcbiAgICAgICAgY29uc3QgZ2FpbnMgPSB0aGlzLl9nYWlucztcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IHsgZDogZGltLCBlcHNpbG9ufSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGxldCBZID0gdGhpcy5ZO1xuXG4gICAgICAgIC8vY2FsYyBjb3N0IGdyYWRpZW50O1xuICAgICAgICBjb25zdCBwbXVsID0gaXRlciA8IDEwMCA/IDQgOiAxO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgUSBkaXN0ICh1bm5vcm1hbGl6ZWQpXG4gICAgICAgIGNvbnN0IFF1ID0gbmV3IE1hdHJpeChOLCBOLCBcInplcm9zXCIpO1xuICAgICAgICBsZXQgcXN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgZHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaGVyZSA9IFkuZW50cnkoaSwgZCkgLSBZLmVudHJ5KGosIGQpO1xuICAgICAgICAgICAgICAgICAgICBkc3VtICs9IGRoZXJlICogZGhlcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHF1ID0gMSAvICgxICsgZHN1bSk7XG4gICAgICAgICAgICAgICAgUXUuc2V0X2VudHJ5KGksIGosIHF1KTtcbiAgICAgICAgICAgICAgICBRdS5zZXRfZW50cnkoaiwgaSwgcXUpO1xuICAgICAgICAgICAgICAgIHFzdW0gKz0gMiAqIHF1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIFEgZGlzdFxuICAgICAgICBjb25zdCBRID0gbmV3IE1hdHJpeChOLCBOLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IE1hdGgubWF4KFF1LmVudHJ5KGksIGopIC8gcXN1bSwgMWUtMTAwKTtcbiAgICAgICAgICAgICAgICBRLnNldF9lbnRyeShpLCBqLCB2YWwpO1xuICAgICAgICAgICAgICAgIFEuc2V0X2VudHJ5KGosIGksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBncmFkID0gbmV3IE1hdHJpeChOLCBkaW0sIFwiemVyb3NcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZW11bHQgPSA0ICogKHBtdWwgKiBQLmVudHJ5KGksIGopIC0gUS5lbnRyeShpLCBqKSkgKiBRdS5lbnRyeShpLCBqKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWQuc2V0X2VudHJ5KGksIGQsIGdyYWQuZW50cnkoaSwgZCkgKyBwcmVtdWx0ICogKFkuZW50cnkoaSwgZCkgLSBZLmVudHJ5KGosIGQpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVyZm9ybSBncmFkaWVudCBzdGVwXG4gICAgICAgIGxldCB5bWVhbiA9IG5ldyBGbG9hdDY0QXJyYXkoZGltKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnaWQgPSBncmFkLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZCA9IHlzdGVwLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhaW5pZCA9IGdhaW5zLmVudHJ5KGksIGQpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG5ld2dhaW4gPSBNYXRoLnNpZ24oZ2lkKSA9PT0gTWF0aC5zaWduKHNpZCkgPyBnYWluaWQgKiAwLjggOiBnYWluaWQgKyAwLjI7XG4gICAgICAgICAgICAgICAgaWYgKG5ld2dhaW4gPCAwLjAxKSBuZXdnYWluID0gMC4wMTtcbiAgICAgICAgICAgICAgICBnYWlucy5zZXRfZW50cnkoaSwgZCwgbmV3Z2Fpbik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtb212YWwgPSBpdGVyIDwgMjUwID8gMC41IDogMC44O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld3NpZCA9IG1vbXZhbCAqIHNpZCAtIGVwc2lsb24gKiBuZXdnYWluICogZ2lkO1xuICAgICAgICAgICAgICAgIHlzdGVwLnNldF9lbnRyeShpLCBkLCBuZXdzaWQpO1xuXG4gICAgICAgICAgICAgICAgWS5zZXRfZW50cnkoaSwgZCwgWS5lbnRyeShpLCBkKSArIG5ld3NpZCk7XG4gICAgICAgICAgICAgICAgeW1lYW5bZF0gKz0gWS5lbnRyeShpLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDI7ICsrZCkge1xuICAgICAgICAgICAgICAgIFkuc2V0X2VudHJ5KGksIGQsIFkuZW50cnkoaSwgZCkgLSB5bWVhbltkXSAvIE4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuWTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm9wdGltaXphdGlvblxuICogQGFsaWFzIHBvd2VsbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHtBcnJheX0geDBcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4X2l0ZXIgPSAzMDBdXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAc2VlIGh0dHA6Ly9vcHRpbWl6YXRpb24tanMuZ2l0aHViLmlvL29wdGltaXphdGlvbi1qcy9vcHRpbWl6YXRpb24uanMuaHRtbCNsaW5lNDM4XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChmLCB4MCwgbWF4X2l0ZXIgPSAzMDApIHtcbiAgICBjb25zdCBlcHNpbG9uID0gMWUtMjtcbiAgICBjb25zdCBuID0geDAubGVuZ3RoO1xuICAgIGxldCBhbHBoYSA9IDFlLTM7XG4gICAgbGV0IHBmeCA9IDEwMDAwO1xuICAgIGxldCB4ID0geDAuc2xpY2UoKTtcbiAgICBsZXQgZnggPSBmKHgpO1xuICAgIGxldCBjb252ZXJnZW5jZSA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKG1heF9pdGVyLS0gPj0gMCAmJiAhY29udmVyZ2VuY2UpIHtcbiAgICAgICAgY29udmVyZ2VuY2UgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgeFtpXSArPSAxZS02O1xuICAgICAgICAgICAgbGV0IGZ4aSA9IGYoeCk7XG4gICAgICAgICAgICB4W2ldIC09IDFlLTY7XG4gICAgICAgICAgICBsZXQgZHggPSAoZnhpIC0gZngpIC8gMWUtNjtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeCkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgY29udmVyZ2VuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhbaV0gLT0gYWxwaGEgKiBkeDtcbiAgICAgICAgICAgIGZ4ID0gZih4KTtcbiAgICAgICAgfVxuICAgICAgICBhbHBoYSAqPSBwZnggPj0gZnggPyAxLjA1IDogMC40O1xuICAgICAgICBwZnggPSBmeDtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4sIGV1Y2xpZGVhbl9zcXVhcmVkIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IEJhbGxUcmVlIH0gZnJvbSBcIi4uL2tubi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBsaW5zcGFjZSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IHBvd2VsbCB9IGZyb20gXCIuLi9vcHRpbWl6YXRpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBLTk4gfSBmcm9tIFwiLi4va25uL2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgVU1BUFxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIFVNQVAgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBVTUFQXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5uX25laWdoYm9ycyA9IDE1XSAtIHNpemUgb2YgdGhlIGxvY2FsIG5laWdoYm9yaG9vZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMubG9jYWxfY29ubmVjdGl2aXR5ID0gMV0gLSBudW1iZXIgb2YgbmVhcmVzdCBuZWlnaGJvcnMgY29ubmVjdGVkIGluIHRoZSBsb2NhbCBuZWlnaGJvcmhvb2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLm1pbl9kaXN0ID0gMV0gLSBjb250cm9scyBob3cgdGlnaHRseSBwb2ludHMgZ2V0IHBhY2tlZCB0b2dldGhlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbWV0ZXJzLm1ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBpbiB0aGUgaGlnaC1kaW1lbnNpb25hbCBzcGFjZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuX3NwcmVhZCA9IDFdIC0gVGhlIGVmZmVjdGl2ZSBzY2FsZSBvZiBlbWJlZGRlZCBwb2ludHMuIChJbiBjb21iaW5hdGlvbiB3aXRoIHtAbGluayBwYXJhbWV0ZXJzLm1pbl9kaXN0fSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuX3NldF9vcF9taXhfcmF0aW8gPSAxXSAtIEludGVycG9sYXRlIGJldHdlZW4gdW5pb24gYW5kIGludGVyc2VjdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuX3JlcHVsc2lvbl9zdHJlbmd0aCA9IDFdICAtIFdlaWdodGluZyBhcHBsaWVkIHRvIG5lZ2F0aXZlIHNhbXBsZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLl9uZWdhdGl2ZV9zYW1wbGVfcmF0ZSA9IDVdIC0gVGhlIG51bWJlciBvZiBuZWdhdGl2ZSBzYW1wbGVzIHBlciBwb3NpdGl2ZSBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLl9uX2Vwb2NocyA9IDM1MF0gLSBUaGUgbnVtYmVyIG9mIHRyYWluaW5nIGVwb2Nocy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlci5faW5pdGlhbF9hbHBoYSA9IDFdIC0gVGhlIGluaXRpYWwgbGVhcm5pbmcgcmF0ZSBmb3IgdGhlIG9wdGltaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuc2VlZCA9IDEyMTJdIC0gdGhlIHNlZWQgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7VU1BUH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKFgsIHsgbl9uZWlnaGJvcnM6IDE1LCBsb2NhbF9jb25uZWN0aXZpdHk6IDEsIG1pbl9kaXN0OiAxLCBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiwgX3NwcmVhZDogMSwgX3NldF9vcF9taXhfcmF0aW86IDEsIF9yZXB1bHNpb25fc3RyZW5ndGg6IDEsIF9uZWdhdGl2ZV9zYW1wbGVfcmF0ZTogNSwgX25fZXBvY2hzOiAzNTAsIF9pbml0aWFsX2FscGhhOiAxIH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICBbdGhpcy5fTiwgdGhpcy5fRF0gPSB0aGlzLlguc2hhcGU7XG4gICAgICAgIC8qIGxldCBuX25laWdoYm9ycyA9IE1hdGgubWluKHRoaXMuX04gLSAxLCBwYXJhbWV0ZXJzLm5fbmVpZ2hib3JzKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJuX25laWdoYm9yc1wiLCBuX25laWdoYm9ycyk7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyKFwibG9jYWxfY29ubmVjdGl2aXR5XCIsIE1hdGgubWluKHRoaXMucGFyYW1ldGVyKFwibG9jYWxfY29ubmVjdGl2aXR5XCIpLCBuX25laWdoYm9ycyAtIDEpKTsgKi9cbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVyKFwibl9uZWlnaGJvcnNcIikgPiB0aGlzLl9OKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBuX25laWdoYm9ycyAoPSR7dGhpcy5wYXJhbWV0ZXIoXCJuX25laWdoYm9yc1wiKX0pIG5lZWRzIHRvIGJlIHNtYWxsZXIgdGhhbiBkYXRhc2V0IHNpemUgKE49JHt0aGlzLl9OfSkhYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVyKFwibG9jYWxfY29ubmVjdGl2aXR5XCIpID4gdGhpcy5wYXJhbWV0ZXIoXCJuX25laWdoYm9yc1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgbG9jYWxfY29ubmVjdGl2aXR5ICg9JHt0aGlzLnBhcmFtZXRlcihcImxvY2FsX2Nvbm5lY3Rpdml0eVwiKX0pIG5lZWRzIHRvIGJlIHNtYWxsZXIgdGhhbiBwYXJhbWV0ZXIgbl9uZWlnaGJvcnMgKD0ke3RoaXMucGFyYW1ldGVyKFwibl9uZWlnaGJvcnNcIil9KWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2l0ZXIgPSAwO1xuICAgICAgICBjb25zdCByYW5kb21pemVyID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgdGhpcy5ZID0gbmV3IE1hdHJpeCh0aGlzLl9OLCB0aGlzLnBhcmFtZXRlcihcImRcIiksICgpID0+IHJhbmRvbWl6ZXIucmFuZG9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3ByZWFkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbl9kaXN0XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIF9maW5kX2FiX3BhcmFtcyhzcHJlYWQsIG1pbl9kaXN0KSB7XG4gICAgICAgIGNvbnN0IGN1cnZlID0gKHgsIGEsIGIpID0+IDEgLyAoMSArIGEgKiBNYXRoLnBvdyh4LCAyICogYikpO1xuICAgICAgICBjb25zdCB4diA9IGxpbnNwYWNlKDAsIHNwcmVhZCAqIDMsIDMwMCk7XG4gICAgICAgIGNvbnN0IHl2ID0gbGluc3BhY2UoMCwgc3ByZWFkICogMywgMzAwKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHh2Lmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgeHZfaSA9IHh2W2ldO1xuICAgICAgICAgICAgeXZbaV0gPSB4dl9pIDwgbWluX2Rpc3QgPyAxIDogTWF0aC5leHAoLSh4dl9pIC0gbWluX2Rpc3QpIC8gc3ByZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVyciA9IChwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGxpbnNwYWNlKDEsIDMwMCkubWFwKChfLCBpKSA9PiB5dltpXSAtIGN1cnZlKHh2W2ldLCBwWzBdLCBwWzFdKSk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KG5ldW1haXJfc3VtKGVycm9yLm1hcCgoZSkgPT4gZSAqIGUpKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHBvd2VsbChlcnIsIFsxLCAxXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gZGlzdGFuY2VzXG4gICAgICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBzaWdtYXNcbiAgICAgKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHJob3NcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgX2NvbXB1dGVfbWVtYmVyc2hpcF9zdHJlbmd0aHMoZGlzdGFuY2VzLCBzaWdtYXMsIHJob3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBkaXN0YW5jZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbSA9IGRpc3RhbmNlc1tpXS5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gZGlzdGFuY2VzW2ldW2pdLnZhbHVlIC0gcmhvc1tpXTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXNbaV1bal0udmFsdWUgPSB2ID4gMCA/IE1hdGguZXhwKC12IC8gc2lnbWFzW2ldKSA6IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7S05OfEJhbGxUcmVlfSBrbm5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgX3Ntb290aF9rbm5fZGlzdChrbm4sIGspIHtcbiAgICAgICAgY29uc3QgU01PT1RIX0tfVE9MRVJBTkNFID0gMWUtNTtcbiAgICAgICAgY29uc3QgTUlOX0tfRElTVF9TQ0FMRSA9IDFlLTM7XG4gICAgICAgIGNvbnN0IG5faXRlciA9IDY0O1xuICAgICAgICBjb25zdCB7IGxvY2FsX2Nvbm5lY3Rpdml0eSwgbWV0cmljIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBNYXRoLmxvZzIoayk7XG4gICAgICAgIGNvbnN0IHJob3MgPSBbXTtcbiAgICAgICAgY29uc3Qgc2lnbWFzID0gW107XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IE4gPSBYLnNoYXBlWzBdO1xuICAgICAgICAvL2NvbnN0IGRpc3RhbmNlcyA9IFsuLi5YXS5tYXAoeF9pID0+IGtubi5zZWFyY2goeF9pLCBrKS5yYXdfZGF0YSgpLnJldmVyc2UoKSk7XG5cbiAgICAgICAgY29uc3QgZGlzdGFuY2VzID0gW107XG4gICAgICAgIGlmIChtZXRyaWMgPT09IFwicHJlY29tcHV0ZWRcIikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXMucHVzaChrbm4uc2VhcmNoKGksIGspLnJldmVyc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHhfaSBvZiBYKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzLnB1c2goa25uLnNlYXJjaCh4X2ksIGspLnJhd19kYXRhKCkucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBsZXQgbG8gPSAwO1xuICAgICAgICAgICAgbGV0IGhpID0gSW5maW5pdHk7XG4gICAgICAgICAgICBsZXQgbWlkID0gMTtcblxuICAgICAgICAgICAgY29uc3Qgc2VhcmNoX3Jlc3VsdCA9IGRpc3RhbmNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG5vbl96ZXJvX2Rpc3QgPSBzZWFyY2hfcmVzdWx0LmZpbHRlcigoZCkgPT4gZC52YWx1ZSA+IDApO1xuICAgICAgICAgICAgY29uc3Qgbm9uX3plcm9fZGlzdF9sZW5ndGggPSBub25femVyb19kaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChub25femVyb19kaXN0X2xlbmd0aCA+PSBsb2NhbF9jb25uZWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IE1hdGguZmxvb3IobG9jYWxfY29ubmVjdGl2aXR5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW9uID0gbG9jYWxfY29ubmVjdGl2aXR5IC0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByaG9zLnB1c2gobm9uX3plcm9fZGlzdFtpbmRleCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVycG9sYXRpb24gPiBTTU9PVEhfS19UT0xFUkFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJob3NbaV0udmFsdWUgKz0gaW50ZXJwb2xhdGlvbiAqIChub25femVyb19kaXN0W2luZGV4XS52YWx1ZSAtIG5vbl96ZXJvX2Rpc3RbaW5kZXggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByaG9zW2ldLnZhbHVlID0gaW50ZXJwb2xhdGlvbiAqIG5vbl96ZXJvX2Rpc3RbMF0udmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub25femVyb19kaXN0X2xlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByaG9zW2ldID0gbm9uX3plcm9fZGlzdFtub25femVyb19kaXN0X2xlbmd0aCAtIDFdLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBuX2l0ZXI7ICsreCkge1xuICAgICAgICAgICAgICAgIGxldCBwc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGs7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkID0gc2VhcmNoX3Jlc3VsdFtqXS52YWx1ZSAtIHJob3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHBzdW0gKz0gZCA+IDAgPyBNYXRoLmV4cCgtKGQgLyBtaWQpKSA6IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhwc3VtIC0gdGFyZ2V0KSA8IFNNT09USF9LX1RPTEVSQU5DRSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBzdW0gPiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgW2hpLCBtaWRdID0gW21pZCwgKGxvICsgaGkpIC8gMl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2xvLCBtaWRdID0gW21pZCwgbWlkICogMl07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbbG8sIG1pZF0gPSBbbWlkLCAobG8gKyBoaSkgLyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpZ21hc1tpXSA9IG1pZDtcblxuICAgICAgICAgICAgY29uc3QgbWVhbl9pdGhkID0gc2VhcmNoX3Jlc3VsdC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLnZhbHVlLCAwKSAvIHNlYXJjaF9yZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgLy9sZXQgbWVhbl9kID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyaG9zW2ldID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzaWdtYXNbaV0gPCBNSU5fS19ESVNUX1NDQUxFICogbWVhbl9pdGhkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ21hc1tpXSA9IE1JTl9LX0RJU1RfU0NBTEUgKiBtZWFuX2l0aGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZWFuX2QgPSBkaXN0YW5jZXMucmVkdWNlKChhY2MsIHJlcykgPT4gYWNjICsgcmVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIudmFsdWUsIDApIC8gcmVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ21hc1tpXSA+IE1JTl9LX0RJU1RfU0NBTEUgKiBtZWFuX2QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbWFzW2ldID0gTUlOX0tfRElTVF9TQ0FMRSAqIG1lYW5fZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3RhbmNlczogZGlzdGFuY2VzLFxuICAgICAgICAgICAgc2lnbWFzOiBzaWdtYXMsXG4gICAgICAgICAgICByaG9zOiByaG9zLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbl9uZWlnaGJvcnNcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIF9mdXp6eV9zaW1wbGljaWFsX3NldChYLCBuX25laWdoYm9ycykge1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgeyBtZXRyaWMsIF9zZXRfb3BfbWl4X3JhdGlvIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBrbm4gPSBtZXRyaWMgPT09IFwicHJlY29tcHV0ZWRcIiA/IG5ldyBLTk4oWCwgXCJwcmVjb21wdXRlZFwiKSA6IG5ldyBCYWxsVHJlZShYLnRvMmRBcnJheSwgbWV0cmljKTtcbiAgICAgICAgbGV0IHsgZGlzdGFuY2VzLCBzaWdtYXMsIHJob3MgfSA9IHRoaXMuX3Ntb290aF9rbm5fZGlzdChrbm4sIG5fbmVpZ2hib3JzKTtcbiAgICAgICAgZGlzdGFuY2VzID0gdGhpcy5fY29tcHV0ZV9tZW1iZXJzaGlwX3N0cmVuZ3RocyhkaXN0YW5jZXMsIHNpZ21hcywgcmhvcyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgoTiwgTiwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlc19pID0gZGlzdGFuY2VzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaXN0YW5jZXNfaS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRfZW50cnkoaSwgZGlzdGFuY2VzX2lbal0uZWxlbWVudC5pbmRleCwgZGlzdGFuY2VzX2lbal0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHJhbnNwb3NlZF9yZXN1bHQgPSByZXN1bHQuVDtcbiAgICAgICAgY29uc3QgcHJvZF9tYXRyaXggPSByZXN1bHQubXVsdCh0cmFuc3Bvc2VkX3Jlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIC5hZGQodHJhbnNwb3NlZF9yZXN1bHQpXG4gICAgICAgICAgICAuc3ViKHByb2RfbWF0cml4KVxuICAgICAgICAgICAgLm11bHQoX3NldF9vcF9taXhfcmF0aW8pXG4gICAgICAgICAgICAuYWRkKHByb2RfbWF0cml4Lm11bHQoMSAtIF9zZXRfb3BfbWl4X3JhdGlvKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbl9lcG9jaHNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgX21ha2VfZXBvY2hzX3Blcl9zYW1wbGUobl9lcG9jaHMpIHtcbiAgICAgICAgY29uc3Qgd2VpZ2h0cyA9IHRoaXMuX3dlaWdodHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkod2VpZ2h0cy5sZW5ndGgpLmZpbGwoLTEpO1xuICAgICAgICBjb25zdCB3ZWlnaHRzX21heCA9IG1heCh3ZWlnaHRzKTtcbiAgICAgICAgY29uc3Qgbl9zYW1wbGVzID0gd2VpZ2h0cy5tYXAoKHcpID0+IG5fZXBvY2hzICogKHcgLyB3ZWlnaHRzX21heCkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkgaWYgKG5fc2FtcGxlc1tpXSA+IDApIHJlc3VsdFtpXSA9IE1hdGgucm91bmQobl9lcG9jaHMgLyBuX3NhbXBsZXNbaV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGdyYXBoXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBfdG9jb28oZ3JhcGgpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgICBjb25zdCBjb2xzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgY29uc3QgW3Jvd3NfbiwgY29sc19uXSA9IGdyYXBoLnNoYXBlO1xuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzX247ICsrcm93KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzX247ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBncmFwaC5lbnRyeShyb3csIGNvbCk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgICAgICBjb2xzLnB1c2goY29sKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvd3M6IHJvd3MsXG4gICAgICAgICAgICBjb2xzOiBjb2xzLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhbGwgbmVjZXNzYXJ5XG4gICAgICogQHJldHVybnMge1VNQVB9XG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3QgeyBfc3ByZWFkLCBtaW5fZGlzdCwgbl9uZWlnaGJvcnMsIF9uX2Vwb2NocywgX25lZ2F0aXZlX3NhbXBsZV9yYXRlIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBbYSwgYl0gPSB0aGlzLl9maW5kX2FiX3BhcmFtcyhfc3ByZWFkLCBtaW5fZGlzdCk7XG4gICAgICAgIHRoaXMuX2EgPSBhO1xuICAgICAgICB0aGlzLl9iID0gYjtcbiAgICAgICAgdGhpcy5fZ3JhcGggPSB0aGlzLl9mdXp6eV9zaW1wbGljaWFsX3NldCh0aGlzLlgsIG5fbmVpZ2hib3JzKTtcbiAgICAgICAgY29uc3QgeyByb3dzLCBjb2xzLCBkYXRhOiB3ZWlnaHRzIH0gPSB0aGlzLl90b2Nvbyh0aGlzLl9ncmFwaCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSByb3dzO1xuICAgICAgICB0aGlzLl90YWlsID0gY29scztcbiAgICAgICAgdGhpcy5fd2VpZ2h0cyA9IHdlaWdodHM7XG4gICAgICAgIHRoaXMuX2Vwb2Noc19wZXJfc2FtcGxlID0gdGhpcy5fbWFrZV9lcG9jaHNfcGVyX3NhbXBsZShfbl9lcG9jaHMpO1xuICAgICAgICB0aGlzLl9lcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZSA9IHRoaXMuX2Vwb2Noc19wZXJfc2FtcGxlLm1hcCgoZCkgPT4gZCAqIF9uZWdhdGl2ZV9zYW1wbGVfcmF0ZSk7XG4gICAgICAgIHRoaXMuX2Vwb2NoX29mX25leHRfc2FtcGxlID0gdGhpcy5fZXBvY2hzX3Blcl9zYW1wbGUuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5fZXBvY2hfb2ZfbmV4dF9uZWdhdGl2ZV9zYW1wbGUgPSB0aGlzLl9lcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBncmFwaCgpIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIHJldHVybiB7IGNvbHM6IHRoaXMuX2hlYWQsIHJvd3M6IHRoaXMuX3RhaWwsIHdlaWdodHM6IHRoaXMuX3dlaWdodHMgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaXRlcmF0aW9ucz0zNTBdIC0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gICAgICogQHJldHVybnMge01hdHJpeHxBcnJheX1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oaXRlcmF0aW9ucyA9IDM1MCkge1xuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXIoXCJfbl9lcG9jaHNcIikgIT0gaXRlcmF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJfbl9lcG9jaHNcIiwgaXRlcmF0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2l0ZXJhdGlvbnM9MzUwXSAtIG51bWJlciBvZiBpdGVyYXRpb25zLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh8QXJyYXl9XG4gICAgICovXG4gICAgKmdlbmVyYXRvcihpdGVyYXRpb25zID0gMzUwKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcihcIl9uX2Vwb2Noc1wiKSAhPSBpdGVyYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcihcIl9uX2Vwb2Noc1wiLCBpdGVyYXRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnByb2plY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBfY2xpcCh4KSB7XG4gICAgICAgIGlmICh4ID4gNCkgcmV0dXJuIDQ7XG4gICAgICAgIGlmICh4IDwgLTQpIHJldHVybiAtNDtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGVyZm9ybXMgdGhlIG9wdGltaXphdGlvbiBzdGVwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGhlYWRfZW1iZWRkaW5nXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IHRhaWxfZW1iZWRkaW5nXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGhlYWRcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gdGFpbFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgX29wdGltaXplX2xheW91dChoZWFkX2VtYmVkZGluZywgdGFpbF9lbWJlZGRpbmcsIGhlYWQsIHRhaWwpIHtcbiAgICAgICAgY29uc3QgcmFuZG9taXplciA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIGNvbnN0IHsgX3JlcHVsc2lvbl9zdHJlbmd0aCwgZDogZGltIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCB7IF9hbHBoYTogYWxwaGEsIF9hOiBhLCBfYjogYiwgX2Vwb2Noc19wZXJfc2FtcGxlOiBlcG9jaHNfcGVyX3NhbXBsZSwgX2Vwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlOiBlcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZSwgX2Vwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlOiBlcG9jaF9vZl9uZXh0X25lZ2F0aXZlX3NhbXBsZSwgX2Vwb2NoX29mX25leHRfc2FtcGxlOiBlcG9jaF9vZl9uZXh0X3NhbXBsZSwgX2NsaXA6IGNsaXAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRhaWxfbGVuZ3RoID0gdGFpbC5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBlcG9jaHNfcGVyX3NhbXBsZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChlcG9jaF9vZl9uZXh0X3NhbXBsZVtpXSA8PSB0aGlzLl9pdGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaiA9IGhlYWRbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgayA9IHRhaWxbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGhlYWRfZW1iZWRkaW5nLnJvdyhqKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlciA9IHRhaWxfZW1iZWRkaW5nLnJvdyhrKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gZXVjbGlkZWFuX3NxdWFyZWQoY3VycmVudCwgb3RoZXIpO1xuICAgICAgICAgICAgICAgIGxldCBncmFkX2NvZWZmID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZF9jb2VmZiA9ICgtMiAqIGEgKiBiICogTWF0aC5wb3coZGlzdCwgYiAtIDEpKSAvIChhICogTWF0aC5wb3coZGlzdCwgYikgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBncmFkX2QgPSBjbGlwKGdyYWRfY29lZmYgKiAoY3VycmVudFtkXSAtIG90aGVyW2RdKSkgKiBhbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGN1cnJlbnRbZF0gKyBncmFkX2Q7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBvdGhlcltkXSAtIGdyYWRfZDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFtkXSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyW2RdID0gbztcbiAgICAgICAgICAgICAgICAgICAgaGVhZF9lbWJlZGRpbmcuc2V0X2VudHJ5KGosIGQsIGMpO1xuICAgICAgICAgICAgICAgICAgICB0YWlsX2VtYmVkZGluZy5zZXRfZW50cnkoaywgZCwgbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVwb2NoX29mX25leHRfc2FtcGxlW2ldICs9IGVwb2Noc19wZXJfc2FtcGxlW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5fbmVnX3NhbXBsZXMgPSAodGhpcy5faXRlciAtIGVwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlW2ldKSAvIGVwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbl9uZWdfc2FtcGxlczsgKytwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGsgPSByYW5kb21pemVyLnJhbmRvbV9pbnQgJSB0YWlsX2xlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSB0YWlsX2VtYmVkZGluZy5yb3codGFpbFtrXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBldWNsaWRlYW5fc3F1YXJlZChjdXJyZW50LCBvdGhlcik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBncmFkX2NvZWZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkX2NvZWZmID0gKDIgKiBfcmVwdWxzaW9uX3N0cmVuZ3RoICogYikgLyAoKDAuMDEgKyBkaXN0KSAqIChhICogTWF0aC5wb3coZGlzdCwgYikgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaiA9PT0gaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3JhZF9kID0gY2xpcChncmFkX2NvZWZmICogKGN1cnJlbnRbZF0gLSBvdGhlcltkXSkpICogYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gY3VycmVudFtkXSArIGdyYWRfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBvdGhlcltkXSAtIGdyYWRfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRbZF0gPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJbZF0gPSBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZF9lbWJlZGRpbmcuc2V0X2VudHJ5KGosIGQsIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFpbF9lbWJlZGRpbmcuc2V0X2VudHJ5KHRhaWxba10sIGQsIG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlW2ldICs9IG5fbmVnX3NhbXBsZXMgKiBlcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZF9lbWJlZGRpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSArK3RoaXMuX2l0ZXI7XG4gICAgICAgIGNvbnN0IFkgPSB0aGlzLlk7XG4gICAgICAgIGNvbnN0IHsgX2luaXRpYWxfYWxwaGEsIF9uX2Vwb2NocyB9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fYWxwaGEgPSBfaW5pdGlhbF9hbHBoYSAqICgxIC0gaXRlciAvIF9uX2Vwb2Nocyk7XG4gICAgICAgIHRoaXMuWSA9IHRoaXMuX29wdGltaXplX2xheW91dChZLCBZLCB0aGlzLl9oZWFkLCB0aGlzLl90YWlsKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ZO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE1hdHJpeCwgbGluc3BhY2UgfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUENBIH0gZnJvbSBcIi4vUENBLmpzXCI7XG5pbXBvcnQgeyBCYWxsVHJlZSB9IGZyb20gXCIuLi9rbm4vaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBUcmlNYXBcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmlNYXAgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBUcmlNYXBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLndlaWdodF9hZGogPSA1MDBdIC0gc2NhbGluZyBmYWN0b3IuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmMgPSA1XSAtIG51bWJlciBvZiB0cmlwbGV0cyBtdWx0aXBsaWVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5kID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnRvbCA9IDFlLThdIC1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1ldGVycy5tZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge1RyaU1hcH1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2FyeGl2Lm9yZy9wZGYvMTkxMC4wMDIwNHYxLnBkZn1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZWFtaWQvdHJpbWFwfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyB3ZWlnaHRfYWRqOiA1MDAsIGM6IDUsIGQ6IDIsIG1ldHJpYzogZXVjbGlkZWFuLCB0b2w6IDFlLTgsIHNlZWQ6IDEyMTIgfSwgcGFyYW1ldGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFtwY2EgPSBudWxsXSAtIEluaXRpYWwgRW1iZWRkaW5nIChpZiBudWxsIHRoZW4gUENBIGdldHMgdXNlZCkuXG4gICAgICogQHBhcmFtIHtLTk59IFtrbm4gPSBudWxsXSAtIEtOTiBPYmplY3QgKGlmIG51bGwgdGhlbiBCYWxsVHJlZSBnZXRzIHVzZWQpLlxuICAgICAqL1xuICAgIGluaXQocGNhID0gbnVsbCwga25uID0gbnVsbCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgeyBkLCBtZXRyaWMsIGMgfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMubl9pbmxpZXJzID0gMiAqIGM7XG4gICAgICAgIHRoaXMubl9vdXRsaWVycyA9IDEgKiBjO1xuICAgICAgICB0aGlzLm5fcmFuZG9tID0gMSAqIGM7XG4gICAgICAgIHRoaXMuWSA9IHBjYSB8fCBuZXcgUENBKFgsIGQpLnRyYW5zZm9ybSgpO1xuICAgICAgICB0aGlzLmtubiA9IGtubiB8fCBuZXcgQmFsbFRyZWUoWC50bzJkQXJyYXksIG1ldHJpYyk7XG4gICAgICAgIGNvbnN0IHsgdHJpcGxldHMsIHdlaWdodHMgfSA9IHRoaXMuX2dlbmVyYXRlX3RyaXBsZXRzKHRoaXMubl9pbmxpZXJzLCB0aGlzLm5fb3V0bGllcnMsIHRoaXMubl9yYW5kb20pO1xuICAgICAgICB0aGlzLnRyaXBsZXRzID0gdHJpcGxldHM7XG4gICAgICAgIHRoaXMud2VpZ2h0cyA9IHdlaWdodHM7XG4gICAgICAgIHRoaXMubHIgPSAoMTAwMCAqIE4pIC8gdHJpcGxldHMuc2hhcGVbMF07XG4gICAgICAgIHRoaXMuQyA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLnZlbCA9IG5ldyBNYXRyaXgoTiwgZCwgMCk7XG4gICAgICAgIHRoaXMuZ2FpbiA9IG5ldyBNYXRyaXgoTiwgZCwgMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB7QGxpbmsgbl9pbmxpZXJzfSB4IHtAbGluayBuX291dGxpZXJzfSB4IHtAbGluayBuX3JhbmRvbX0gdHJpcGxldHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5faW5saWVyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX291dGxpZXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5fcmFuZG9tXG4gICAgICovXG4gICAgX2dlbmVyYXRlX3RyaXBsZXRzKG5faW5saWVycywgbl9vdXRsaWVycywgbl9yYW5kb20pIHtcbiAgICAgICAgY29uc3QgeyBtZXRyaWMsIHdlaWdodF9hZGogfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IE4gPSBYLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBrbm4gPSB0aGlzLmtubjtcbiAgICAgICAgY29uc3Qgbl9leHRyYSA9IE1hdGgubWluKG5faW5saWVycyArIDIwLCBOKTtcbiAgICAgICAgY29uc3QgbmJycyA9IG5ldyBNYXRyaXgoTiwgbl9leHRyYSk7XG4gICAgICAgIGNvbnN0IGtubl9kaXN0YW5jZXMgPSBuZXcgTWF0cml4KE4sIG5fZXh0cmEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAga25uLnNlYXJjaChYLnJvdyhpKSwgbl9leHRyYSArIDEpXG4gICAgICAgICAgICAgICAgLnJhd19kYXRhKClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChkKSA9PiBkLnZhbHVlICE9IDApXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEudmFsdWUgLSBiLnZhbHVlKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChkLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG5icnMuc2V0X2VudHJ5KGksIGosIGQuZWxlbWVudC5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGtubl9kaXN0YW5jZXMuc2V0X2VudHJ5KGksIGosIGQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNjYWxlIHBhcmFtZXRlclxuICAgICAgICBjb25zdCBzaWcgPSBuZXcgRmxvYXQ2NEFycmF5KE4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgc2lnW2ldID0gTWF0aC5tYXgoKGtubl9kaXN0YW5jZXMuZW50cnkoaSwgMykgKyBrbm5fZGlzdGFuY2VzLmVudHJ5KGksIDQpICsga25uX2Rpc3RhbmNlcy5lbnRyeShpLCA1KSArIGtubl9kaXN0YW5jZXMuZW50cnkoaSwgNikpIC8gNCwgMWUtMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgUCA9IHRoaXMuX2ZpbmRfcChrbm5fZGlzdGFuY2VzLCBzaWcsIG5icnMpO1xuXG4gICAgICAgIGxldCB0cmlwbGV0cyA9IHRoaXMuX3NhbXBsZV9rbm5fdHJpcGxldHMoUCwgbmJycywgbl9pbmxpZXJzLCBuX291dGxpZXJzKTtcbiAgICAgICAgbGV0IG5fdHJpcGxldHMgPSB0cmlwbGV0cy5zaGFwZVswXTtcbiAgICAgICAgY29uc3Qgb3V0bGllcl9kaXN0YW5jZXMgPSBuZXcgRmxvYXQ2NEFycmF5KG5fdHJpcGxldHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5fdHJpcGxldHM7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgaiA9IHRyaXBsZXRzLmVudHJ5KGksIDApO1xuICAgICAgICAgICAgY29uc3QgayA9IHRyaXBsZXRzLmVudHJ5KGksIDIpO1xuICAgICAgICAgICAgb3V0bGllcl9kaXN0YW5jZXNbaV0gPSBtZXRyaWMoWC5yb3coaiksIFgucm93KGspKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2VpZ2h0cyA9IHRoaXMuX2ZpbmRfd2VpZ2h0cyh0cmlwbGV0cywgUCwgbmJycywgb3V0bGllcl9kaXN0YW5jZXMsIHNpZyk7XG5cbiAgICAgICAgaWYgKG5fcmFuZG9tID4gMCkge1xuICAgICAgICAgICAgY29uc3QgeyByYW5kb21fdHJpcGxldHMsIHJhbmRvbV93ZWlnaHRzIH0gPSB0aGlzLl9zYW1wbGVfcmFuZG9tX3RyaXBsZXRzKFgsIG5fcmFuZG9tLCBzaWcpO1xuICAgICAgICAgICAgdHJpcGxldHMgPSB0cmlwbGV0cy5jb25jYXQocmFuZG9tX3RyaXBsZXRzLCBcInZlcnRpY2FsXCIpO1xuICAgICAgICAgICAgd2VpZ2h0cyA9IEZsb2F0NjRBcnJheS5mcm9tKFsuLi53ZWlnaHRzLCAuLi5yYW5kb21fd2VpZ2h0c10pO1xuICAgICAgICB9XG4gICAgICAgIG5fdHJpcGxldHMgPSB0cmlwbGV0cy5zaGFwZVswXTtcbiAgICAgICAgbGV0IG1heF93ZWlnaHQgPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbl90cmlwbGV0czsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4od2VpZ2h0c1tpXSkpIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhfd2VpZ2h0IDwgd2VpZ2h0c1tpXSkgbWF4X3dlaWdodCA9IHdlaWdodHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1heF93ZWlnaHRfMiA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuX3RyaXBsZXRzOyArK2kpIHtcbiAgICAgICAgICAgIHdlaWdodHNbaV0gLz0gbWF4X3dlaWdodDtcbiAgICAgICAgICAgIHdlaWdodHNbaV0gKz0gMC4wMDAxO1xuICAgICAgICAgICAgd2VpZ2h0c1tpXSA9IE1hdGgubG9nKDEgKyB3ZWlnaHRfYWRqICogd2VpZ2h0c1tpXSk7XG4gICAgICAgICAgICBpZiAobWF4X3dlaWdodF8yIDwgd2VpZ2h0c1tpXSkgbWF4X3dlaWdodF8yID0gd2VpZ2h0c1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5fdHJpcGxldHM7ICsraSkge1xuICAgICAgICAgICAgd2VpZ2h0c1tpXSAvPSBtYXhfd2VpZ2h0XzI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyaXBsZXRzOiB0cmlwbGV0cyxcbiAgICAgICAgICAgIHdlaWdodHM6IHdlaWdodHMsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgc2ltaWxhcml0eSBtYXRyaXggUFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGtubl9kaXN0YW5jZXMgLSBtYXRyaXggb2YgcGFpcndpc2Uga25uIGRpc3RhbmNlc1xuICAgICAqIEBwYXJhbSB7RmxvYXQ2NEFycmF5fSBzaWcgLSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIGRpc3RhbmNlc1xuICAgICAqIEBwYXJhbSB7TWF0cml4fSBuYnJzIC0gbmVhcmVzdCBuZWlnaGJvcnNcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSBwYWlyd2lzZSBzaW1pbGFyaXR5IG1hdHJpeFxuICAgICAqL1xuICAgIF9maW5kX3Aoa25uX2Rpc3RhbmNlcywgc2lnLCBuYnJzKSB7XG4gICAgICAgIGNvbnN0IFtOLCBuX25laWdoYm9yc10gPSBrbm5fZGlzdGFuY2VzLnNoYXBlO1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChOLCBuX25laWdoYm9ycywgKGksIGopID0+IHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmV4cCgtKGtubl9kaXN0YW5jZXMuZW50cnkoaSwgaikgKiogMiAvIHNpZ1tpXSAvIHNpZ1tuYnJzLmVudHJ5KGksIGopXSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYW1wbGUgbmVhcmVzdCBuZWlnaGJvcnMgdHJpcGxldHMgYmFzZWQgb24gdGhlIHNpbWlsYXJpdHkgdmFsdWVzIGdpdmVuIGluIFAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gUCAtIE1hdHJpeCBvZiBwYWlyd2lzZSBzaW1pbGFyaXRpZXMgYmV0d2VlbiBlYWNoIHBvaW50IGFuZCBpdHMgbmVpZ2hib3JzIGdpdmVuIGluIG1hdHJpeCBuYnJzLlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBuYnJzIC0gTmVhcmVzdCBuZWlnaGJvcnMgaW5kaWNlcyBmb3IgZWFjaCBwb2ludC4gVGhlIHNpbWlsYXJpdHkgdmFsdWVzIGFyZSBnaXZlbiBpbiBtYXRyaXgge0BsaW5rIFB9LiBSb3cgaSBjb3JyZXNwb25kcyB0byB0aGUgaS10aCBwb2ludC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbl9pbmxpZXJzIC0gTnVtYmVyIG9mIGlubGllciBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5fb3V0bGllcnMgLSBOdW1iZXIgb2Ygb3V0bGllciBwb2ludHMuXG4gICAgICpcbiAgICAgKi9cbiAgICBfc2FtcGxlX2tubl90cmlwbGV0cyhQLCBuYnJzLCBuX2lubGllcnMsIG5fb3V0bGllcnMpIHtcbiAgICAgICAgY29uc3QgTiA9IG5icnMuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHRyaXBsZXRzID0gbmV3IE1hdHJpeChOICogbl9pbmxpZXJzICogbl9vdXRsaWVycywgMyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBsZXQgbl9pID0gaSAqIG5faW5saWVycyAqIG5fb3V0bGllcnM7XG4gICAgICAgICAgICBjb25zdCBzb3J0X2luZGljZXMgPSB0aGlzLl9fYXJnc29ydChQLnJvdyhpKS5tYXAoKGQpID0+IC1kKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5faW5saWVyczsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5faiA9IGogKiBuX291dGxpZXJzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpbSA9IG5icnMuZW50cnkoaSwgc29ydF9pbmRpY2VzW2pdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1wbGVzID0gdGhpcy5fcmVqZWN0aW9uX3NhbXBsZShuX291dGxpZXJzLCBOLCBzb3J0X2luZGljZXMuc2xpY2UoMCwgaiArIDEpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5fb3V0bGllcnM7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG5faSArIG5faiArIGs7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dCA9IHNhbXBsZXNba107XG4gICAgICAgICAgICAgICAgICAgIHRyaXBsZXRzLnNldF9lbnRyeShpbmRleCwgMCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIHRyaXBsZXRzLnNldF9lbnRyeShpbmRleCwgMSwgc2ltKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpcGxldHMuc2V0X2VudHJ5KGluZGV4LCAyLCBvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJpcGxldHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIGRvIHRoZSBzYW1lIGFzIG5wLmFyZ3NvcnQoKVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gQVxuICAgICAqL1xuICAgIF9fYXJnc29ydChBKSB7XG4gICAgICAgIHJldHVybiBBLm1hcCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgZDogZCwgaTogaSB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZCAtIGIuZClcbiAgICAgICAgICAgIC5tYXAoKGQpID0+IGQuaSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2FtcGxlcyB7QGxpbmsgbl9zYW1wbGVzfSBpbnRlZ2VycyBmcm9tIGEgZ2l2ZW4gaW50ZXJ2YWwgWzAsIHtAbGluayBtYXhfaW50fV0gd2hpbGUgcmVqZWN0aW9uIHRoZSB2YWx1ZXMgdGhhdCBhcmUgaW4gdGhlIHtAbGluayByZWplY3RzfS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gbl9zYW1wbGVzXG4gICAgICogQHBhcmFtIHsqfSBtYXhfaW50XG4gICAgICogQHBhcmFtIHsqfSByZWplY3RzXG4gICAgICovXG4gICAgX3JlamVjdGlvbl9zYW1wbGUobl9zYW1wbGVzLCBtYXhfaW50LCByZWplY3RzKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbWl6ZXIgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IGxpbnNwYWNlKDAsIG1heF9pbnQgLSAxKS5maWx0ZXIoKGQpID0+IHJlamVjdHMuaW5kZXhPZihkKSA8IDApO1xuICAgICAgICByZXR1cm4gcmFuZG9taXplci5jaG9pY2UoaW50ZXJ2YWwsIE1hdGgubWluKG5fc2FtcGxlcywgaW50ZXJ2YWwubGVuZ3RoIC0gMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHdlaWdodHMgZm9yIHRoZSBzYW1wbGVkIG5lYXJlc3QgbmVpZ2hib3JzIHRyaXBsZXRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gdHJpcGxldHMgLSBTYW1wbGVkIFRyaXBsZXRzLlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBQIC0gUGFpcndpc2Ugc2ltaWxhcml0eSBtYXRyaXguXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IG5icnMgLSBuZWFyZXN0IE5laWdoYm9yc1xuICAgICAqIEBwYXJhbSB7RmxvYXQ2NEFycmF5fSBvdXRsaWVyX2Rpc3RhbmNlcyAtIE1hdHJpeCBvZiBwYWlyd2lzZSBvdXRsaWVyIGRpc3RhbmNlc1xuICAgICAqIEBwYXJhbSB7RmxvYXQ2NEFycmF5fSBzaWcgLSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIGRpc3RhbmNlcy5cbiAgICAgKi9cbiAgICBfZmluZF93ZWlnaHRzKHRyaXBsZXRzLCBQLCBuYnJzLCBvdXRsaWVyX2Rpc3RhbmNlcywgc2lnKSB7XG4gICAgICAgIGNvbnN0IG5fdHJpcGxldHMgPSB0cmlwbGV0cy5zaGFwZVswXTtcbiAgICAgICAgY29uc3Qgd2VpZ2h0cyA9IG5ldyBGbG9hdDY0QXJyYXkobl90cmlwbGV0cyk7XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgbl90cmlwbGV0czsgKyt0KSB7XG4gICAgICAgICAgICBjb25zdCBpID0gdHJpcGxldHMuZW50cnkodCwgMCk7XG4gICAgICAgICAgICBjb25zdCBzaW0gPSBuYnJzLnJvdyhpKS5pbmRleE9mKHRyaXBsZXRzLmVudHJ5KHQsIDEpKTtcbiAgICAgICAgICAgIGNvbnN0IHBfc2ltID0gUC5lbnRyeShpLCBzaW0pO1xuICAgICAgICAgICAgbGV0IHBfb3V0ID0gTWF0aC5leHAoLShvdXRsaWVyX2Rpc3RhbmNlc1t0XSAqKiAyIC8gKHNpZ1tpXSAqIHNpZ1t0cmlwbGV0cy5lbnRyeSh0LCAyKV0pKSk7XG4gICAgICAgICAgICBpZiAocF9vdXQgPCAxZS0yMCkgcF9vdXQgPSAxZS0yMDtcbiAgICAgICAgICAgIHdlaWdodHNbdF0gPSBwX3NpbSAvIHBfb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWlnaHRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhbXBsZSB1bmlmb3JtbHkgcmFub20gdHJpcGxldHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBYIC0gRGF0YSBtYXRyaXguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5fcmFuZG9tIC0gTnVtYmVyIG9mIHJhbmRvbSB0cmlwbGV0cyBwZXIgcG9pbnRcbiAgICAgKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gc2lnIC0gU2NhbGluZyBmYWN0b3IgZm9yIHRoZSBkaXN0YW5jZXNcbiAgICAgKi9cbiAgICBfc2FtcGxlX3JhbmRvbV90cmlwbGV0cyhYLCBuX3JhbmRvbSwgc2lnKSB7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMucGFyYW1ldGVyKFwibWV0cmljXCIpO1xuICAgICAgICBjb25zdCByYW5kb21pemVyID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgY29uc3QgTiA9IFguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHJhbmRvbV90cmlwbGV0cyA9IG5ldyBNYXRyaXgoTiAqIG5fcmFuZG9tLCAzKTtcbiAgICAgICAgY29uc3QgcmFuZG9tX3dlaWdodHMgPSBuZXcgRmxvYXQ2NEFycmF5KE4gKiBuX3JhbmRvbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBuX2kgPSBpICogbl9yYW5kb207XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gWy4uLmxpbnNwYWNlKDAsIGkgLSAxKSwgLi4ubGluc3BhY2UoaSArIDEsIE4gLSAxKV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5fcmFuZG9tOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgW3NpbSwgb3V0XSA9IHJhbmRvbWl6ZXIuY2hvaWNlKGluZGljZXMsIDIpO1xuICAgICAgICAgICAgICAgIGxldCBwX3NpbSA9IE1hdGguZXhwKC0obWV0cmljKFgucm93KGkpLCBYLnJvdyhzaW0pKSAqKiAyIC8gKHNpZ1tpXSAqIHNpZ1tzaW1dKSkpO1xuICAgICAgICAgICAgICAgIGlmIChwX3NpbSA8IDFlLTIwKSBwX3NpbSA9IDFlLTIwO1xuICAgICAgICAgICAgICAgIGxldCBwX291dCA9IE1hdGguZXhwKC0obWV0cmljKFgucm93KGkpLCBYLnJvdyhvdXQpKSAqKiAyIC8gKHNpZ1tpXSAqIHNpZ1tvdXRdKSkpO1xuICAgICAgICAgICAgICAgIGlmIChwX291dCA8IDFlLTIwKSBwX291dCA9IDFlLTIwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBfc2ltIDwgcF9vdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgW3NpbSwgb3V0XSA9IFtvdXQsIHNpbV07XG4gICAgICAgICAgICAgICAgICAgIFtwX3NpbSwgcF9vdXRdID0gW3Bfb3V0LCBwX3NpbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbl9pICsgajtcbiAgICAgICAgICAgICAgICByYW5kb21fdHJpcGxldHMuc2V0X2VudHJ5KGluZGV4LCAwLCBpKTtcbiAgICAgICAgICAgICAgICByYW5kb21fdHJpcGxldHMuc2V0X2VudHJ5KGluZGV4LCAxLCBzaW0pO1xuICAgICAgICAgICAgICAgIHJhbmRvbV90cmlwbGV0cy5zZXRfZW50cnkoaW5kZXgsIDIsIG91dCk7XG4gICAgICAgICAgICAgICAgcmFuZG9tX3dlaWdodHNbaW5kZXhdID0gcF9zaW0gLyBwX291dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZG9tX3RyaXBsZXRzOiByYW5kb21fdHJpcGxldHMsXG4gICAgICAgICAgICByYW5kb21fd2VpZ2h0czogcmFuZG9tX3dlaWdodHMsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGdyYWRpZW50IGZvciB1cGRhdGluZyB0aGUgZW1iZWRkaW5nLlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBZIC0gVGhlIGVtYmVkZGluZ1xuICAgICAqL1xuICAgIF9ncmFkKFkpIHtcbiAgICAgICAgY29uc3Qgbl9pbmxpZXJzID0gdGhpcy5uX2lubGllcnM7XG4gICAgICAgIGNvbnN0IG5fb3V0bGllcnMgPSB0aGlzLm5fb3V0bGllcnM7XG4gICAgICAgIGNvbnN0IHRyaXBsZXRzID0gdGhpcy50cmlwbGV0cztcbiAgICAgICAgY29uc3Qgd2VpZ2h0cyA9IHRoaXMud2VpZ2h0cztcbiAgICAgICAgY29uc3QgW04sIGRpbV0gPSBZLnNoYXBlO1xuICAgICAgICBjb25zdCBuX3RyaXBsZXRzID0gdHJpcGxldHMuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IGdyYWQgPSBuZXcgTWF0cml4KE4sIGRpbSwgMCk7XG4gICAgICAgIGxldCB5X2lqID0gbmV3IEZsb2F0NjRBcnJheShkaW0pO1xuICAgICAgICBsZXQgeV9payA9IG5ldyBGbG9hdDY0QXJyYXkoZGltKTtcbiAgICAgICAgbGV0IGRfaWogPSAxO1xuICAgICAgICBsZXQgZF9payA9IDE7XG4gICAgICAgIGxldCBuX3Zpb2wgPSAwO1xuICAgICAgICBsZXQgbG9zcyA9IDA7XG4gICAgICAgIGNvbnN0IG5fa25uX3RyaXBsZXRzID0gTiAqIG5faW5saWVycyAqIG5fb3V0bGllcnM7XG5cbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBuX3RyaXBsZXRzOyArK3QpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpLCBqLCBrXSA9IHRyaXBsZXRzLnJvdyh0KTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB5X2lqLCB5X2lrLCBkX2lqLCBkX2lrXG4gICAgICAgICAgICBpZiAodCAlIG5fb3V0bGllcnMgPT0gMCB8fCB0ID49IG5fa25uX3RyaXBsZXRzKSB7XG4gICAgICAgICAgICAgICAgZF9paiA9IDE7XG4gICAgICAgICAgICAgICAgZF9payA9IDE7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBZX2lkID0gWS5lbnRyeShpLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWV9qZCA9IFkuZW50cnkoaiwgZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFlfa2QgPSBZLmVudHJ5KGssIGQpO1xuICAgICAgICAgICAgICAgICAgICB5X2lqW2RdID0gWV9pZCAtIFlfamQ7XG4gICAgICAgICAgICAgICAgICAgIHlfaWtbZF0gPSBZX2lkIC0gWV9rZDtcbiAgICAgICAgICAgICAgICAgICAgZF9paiArPSB5X2lqW2RdICoqIDI7XG4gICAgICAgICAgICAgICAgICAgIGRfaWsgKz0geV9pa1tkXSAqKiAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgeV9payBhbmQgZF9payBvbmx5XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRfaWsgPSAxO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWV9pZCA9IFkuZW50cnkoaSwgZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFlfa2QgPSBZLmVudHJ5KGssIGQpO1xuICAgICAgICAgICAgICAgICAgICB5X2lrW2RdID0gWV9pZCAtIFlfa2Q7XG4gICAgICAgICAgICAgICAgICAgIGRfaWsgKz0geV9pa1tkXSAqKiAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRfaWogPiBkX2lrKSArK25fdmlvbDtcbiAgICAgICAgICAgIGxvc3MgKz0gd2VpZ2h0c1t0XSAvICgxICsgZF9payAvIGRfaWopO1xuICAgICAgICAgICAgY29uc3QgdyA9ICh3ZWlnaHRzW3RdIC8gKGRfaWogKyBkX2lrKSkgKiogMjtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBncyA9IHlfaWpbZF0gKiBkX2lrICogdztcbiAgICAgICAgICAgICAgICBjb25zdCBnbyA9IHlfaWtbZF0gKiBkX2lqICogdztcbiAgICAgICAgICAgICAgICBncmFkLnNldF9lbnRyeShpLCBkLCBncmFkLmVudHJ5KGksIGQpICsgZ3MgLSBnbyk7XG4gICAgICAgICAgICAgICAgZ3JhZC5zZXRfZW50cnkoaiwgZCwgZ3JhZC5lbnRyeShqLCBkKSAtIGdzKTtcbiAgICAgICAgICAgICAgICBncmFkLnNldF9lbnRyeShrLCBkLCBncmFkLmVudHJ5KGssIGQpICsgZ28pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGdyYWQsIGxvc3MsIG5fdmlvbCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heF9pdGVyYXRpb25cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0obWF4X2l0ZXJhdGlvbiA9IDQwMCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaXRlciA9IDA7IGl0ZXIgPCBtYXhfaXRlcmF0aW9uOyArK2l0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQoaXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4X2l0ZXJhdGlvblxuICAgICAqIEB5aWVsZHMge01hdHJpeH1cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgICpnZW5lcmF0b3IobWF4X2l0ZXJhdGlvbiA9IDgwMCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaXRlciA9IDA7IGl0ZXIgPCBtYXhfaXRlcmF0aW9uOyArK2l0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQoaXRlcik7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnByb2plY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBpdGVyYXRpb24gc3RlcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyXG4gICAgICovXG4gICAgX25leHQoaXRlcikge1xuICAgICAgICBjb25zdCBnYW1tYSA9IGl0ZXIgPiAxNTAgPyAwLjUgOiAwLjM7XG4gICAgICAgIGNvbnN0IG9sZF9DID0gdGhpcy5DO1xuICAgICAgICBjb25zdCB2ZWwgPSB0aGlzLnZlbDtcbiAgICAgICAgY29uc3QgWSA9IHRoaXMuWS5hZGQodmVsLm11bHQoZ2FtbWEpKTtcbiAgICAgICAgY29uc3QgeyBncmFkLCBsb3NzLCBuX3Zpb2wgfSA9IHRoaXMuX2dyYWQoWSk7XG4gICAgICAgIHRoaXMuQyA9IGxvc3M7XG4gICAgICAgIHRoaXMuWSA9IHRoaXMuX3VwZGF0ZV9lbWJlZGRpbmcoWSwgaXRlciwgZ3JhZCk7XG4gICAgICAgIHRoaXMubHIgKj0gb2xkX0MgPiBsb3NzICsgdGhpcy5fcGFyYW1ldGVycy50b2wgPyAxLjAxIDogMC45O1xuICAgICAgICByZXR1cm4gdGhpcy5ZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGVtYmVkZGluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBZXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZXJcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gZ3JhZFxuICAgICAqL1xuICAgIF91cGRhdGVfZW1iZWRkaW5nKFksIGl0ZXIsIGdyYWQpIHtcbiAgICAgICAgY29uc3QgW04sIGRpbV0gPSBZLnNoYXBlO1xuICAgICAgICBjb25zdCBnYW1tYSA9IGl0ZXIgPiAxNTAgPyAwLjkgOiAwLjU7IC8vIG1vbWVudCBwYXJhbWV0ZXJcbiAgICAgICAgY29uc3QgbWluX2dhaW4gPSAwLjAxO1xuICAgICAgICBjb25zdCBnYWluID0gdGhpcy5nYWluO1xuICAgICAgICBjb25zdCB2ZWwgPSB0aGlzLnZlbDtcbiAgICAgICAgY29uc3QgbHIgPSB0aGlzLmxyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld19nYWluID0gTWF0aC5zaWduKHZlbC5lbnRyeShpLCBkKSkgIT0gTWF0aC5zaWduKGdyYWQuZW50cnkoaSwgZCkpID8gZ2Fpbi5lbnRyeShpLCBkKSArIDAuMiA6IE1hdGgubWF4KGdhaW4uZW50cnkoaSwgZCkgKiAwLjgsIG1pbl9nYWluKTtcbiAgICAgICAgICAgICAgICBnYWluLnNldF9lbnRyeShpLCBkLCBuZXdfZ2Fpbik7XG4gICAgICAgICAgICAgICAgdmVsLnNldF9lbnRyeShpLCBkLCBnYW1tYSAqIHZlbC5lbnRyeShpLCBkKSAtIGxyICogZ2Fpbi5lbnRyeShpLCBkKSAqIGdyYWQuZW50cnkoaSwgZCkpO1xuICAgICAgICAgICAgICAgIFkuc2V0X2VudHJ5KGksIGQsIFkuZW50cnkoaSwgZCkgKyB2ZWwuZW50cnkoaSwgZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBZO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEhpZXJhcmNoaWNhbF9DbHVzdGVyaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBIaWVyYXJjaGljYWxfQ2x1c3RlcmluZyB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjbHVzdGVyaW5nXG4gICAgICogQGFsaWFzIEhpZXJhcmNoaWNhbF9DbHVzdGVyaW5nXG4gICAgICogQHRvZG8gbmVlZHMgcmVzdHJ1Y3R1cmluZy5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gLSBEYXRhIG9yIGRpc3RhbmNlIG1hdHJpeCBpZiBtZXRyaWMgaXMgJ3ByZWNvbXB1dGVkJ1xuICAgICAqIEBwYXJhbSB7KFwic2luZ2xlXCJ8XCJjb21wbGV0ZVwifFwiYXZlcmFnZVwiKX0gW2xpbmthZ2UgPSBcImNvbXBsZXRlXCJdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxcInByZWNvbXB1dGVkXCJ9IFttZXRyaWMgPSBldWNsaWRlYW5dXG4gICAgICogQHJldHVybnMge0hpZXJhcmNoaWNhbF9DbHVzdGVyaW5nfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1hdHJpeCwgbGlua2FnZSA9IFwiY29tcGxldGVcIiwgbWV0cmljID0gZXVjbGlkZWFuKSB7XG4gICAgICAgIHRoaXMuX2lkID0gMDtcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbWF0cml4IGluc3RhbmNlb2YgTWF0cml4ID8gbWF0cml4IDogTWF0cml4LmZyb20obWF0cml4KTtcbiAgICAgICAgdGhpcy5fbWV0cmljID0gbWV0cmljO1xuICAgICAgICB0aGlzLl9saW5rYWdlID0gbGlua2FnZTtcbiAgICAgICAgaWYgKG1ldHJpYyA9PT0gXCJwcmVjb21wdXRlZFwiICYmIHRoaXMuX21hdHJpeC5zaGFwZVswXSAhPT0gdGhpcy5fbWF0cml4LnNoYXBlWzFdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJZiBtZXRyaWMgaXMgJ3ByZWNvbXB1dGVkJywgdGhlbiBtYXRyaXggaGFzIHRvIGJlIHNxdWFyZSFcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuZG8oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSB2YWx1ZSB3aGVyZSB0byBjdXQgdGhlIHRyZWUuXG4gICAgICogQHBhcmFtIHsoXCJkaXN0YW5jZVwifFwiZGVwdGhcIil9IFt0eXBlID0gXCJkaXN0YW5jZVwiXSAtIHR5cGUgb2YgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gLSBBcnJheSBvZiBjbHVzdGVycyB3aXRoIHRoZSBpbmRpY2VzIG9mIHRoZSByb3dzIGluIGdpdmVuIHtAbGluayBtYXRyaXh9LlxuICAgICAqL1xuICAgIGdldF9jbHVzdGVycyh2YWx1ZSwgdHlwZSA9IFwiZGlzdGFuY2VcIikge1xuICAgICAgICBsZXQgY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgbGV0IGFjY2Vzc29yO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkaXN0YW5jZVwiOlxuICAgICAgICAgICAgICAgIGFjY2Vzc29yID0gKGQpID0+IGQuZGlzdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkZXB0aFwiOlxuICAgICAgICAgICAgICAgIGFjY2Vzc29yID0gKGQpID0+IGQuZGVwdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmF2ZXJzZSh0aGlzLnJvb3QsIGFjY2Vzc29yLCB2YWx1ZSwgY2x1c3RlcnMpO1xuICAgICAgICByZXR1cm4gY2x1c3RlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gbm9kZVxuICAgICAqIEBwYXJhbSB7Kn0gZlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IHJlc3VsdFxuICAgICAqL1xuICAgIF90cmF2ZXJzZShub2RlLCBmLCB2YWx1ZSwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChmKG5vZGUpIDw9IHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChub2RlLmxlYXZlcygpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYXZlcnNlKG5vZGUubGVmdCwgZiwgdmFsdWUsIHJlc3VsdCk7XG4gICAgICAgICAgICB0aGlzLl90cmF2ZXJzZShub2RlLnJpZ2h0LCBmLCB2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbXB1dGVzIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX21hdHJpeDtcbiAgICAgICAgY29uc3QgbiA9ICh0aGlzLl9uID0gQS5zaGFwZVswXSk7XG4gICAgICAgIGNvbnN0IGRfbWluID0gKHRoaXMuX2RfbWluID0gbmV3IEZsb2F0NjRBcnJheShuKSk7XG4gICAgICAgIGxldCBkaXN0YW5jZV9tYXRyaXg7XG4gICAgICAgIGlmIChtZXRyaWMgIT09IFwicHJlY29tcHV0ZWRcIikge1xuICAgICAgICAgICAgZGlzdGFuY2VfbWF0cml4ID0gbmV3IE1hdHJpeChuLCBuLCAwKTsgLy9uZXcgQXJyYXkobik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGRfbWluW2ldID0gMDtcbiAgICAgICAgICAgICAgICAvL2Rpc3RhbmNlX21hdHJpeFtpXSA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VfbWF0cml4LnNldF9lbnRyeShpLCBqLCBpID09PSBqID8gSW5maW5pdHkgOiBtZXRyaWMoQS5yb3coaSksIEEucm93KGopKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZV9tYXRyaXguZW50cnkoaSwgZF9taW5baV0pID4gZGlzdGFuY2VfbWF0cml4LmVudHJ5KGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkX21pbltpXSA9IGo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXN0YW5jZV9tYXRyaXggPSB0aGlzLl9tYXRyaXguY2xvbmUoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlX21hdHJpeC5zZXRfZW50cnkoaSwgaiwgSW5maW5pdHkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc3RhbmNlX21hdHJpeC5lbnRyeShpLCBkX21pbltpXSkgPiBkaXN0YW5jZV9tYXRyaXguZW50cnkoaSwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRfbWluW2ldID0gajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXN0YW5jZV9tYXRyaXggPSBkaXN0YW5jZV9tYXRyaXg7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gKHRoaXMuX2NsdXN0ZXJzID0gbmV3IEFycmF5KG4pKTtcbiAgICAgICAgY29uc3QgY19zaXplID0gKHRoaXMuX2Nfc2l6ZSA9IG5ldyBVaW50MTZBcnJheShuKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBjbHVzdGVyc1tpXSA9IFtdO1xuICAgICAgICAgICAgY2x1c3RlcnNbaV1bMF0gPSBuZXcgQ2x1c3Rlcih0aGlzLl9pZCsrLCBudWxsLCBudWxsLCAwLCBBLnJvdyhpKSwgaSwgMSwgMCk7XG4gICAgICAgICAgICBjX3NpemVbaV0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbXB1dGVzIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIGRvKCkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fbjtcbiAgICAgICAgY29uc3QgZF9taW4gPSB0aGlzLl9kX21pbjtcbiAgICAgICAgY29uc3QgRCA9IHRoaXMuX2Rpc3RhbmNlX21hdHJpeDtcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSB0aGlzLl9jbHVzdGVycztcbiAgICAgICAgY29uc3QgY19zaXplID0gdGhpcy5fY19zaXplO1xuICAgICAgICBjb25zdCBsaW5rYWdlID0gdGhpcy5fbGlua2FnZTtcbiAgICAgICAgbGV0IHJvb3QgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBwID0gMCwgcF9tYXggPSBuIC0gMTsgcCA8IHBfbWF4OyArK3ApIHtcbiAgICAgICAgICAgIGxldCBjMSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCBEX2lfbWluID0gRC5lbnRyeShpLCBkX21pbltpXSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChEX2lfbWluID4gRC5lbnRyeShpLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZF9taW5baV0gPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgRF9pX21pbiA9IEQuZW50cnkoaSwgZF9taW5baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoRC5lbnRyeShpLCBkX21pbltpXSkgPCBELmVudHJ5KGMxLCBkX21pbltjMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYzIgPSBkX21pbltjMV07XG4gICAgICAgICAgICBsZXQgYzFfY2x1c3RlciA9IGNsdXN0ZXJzW2MxXVswXTtcbiAgICAgICAgICAgIGxldCBjMl9jbHVzdGVyID0gY2x1c3RlcnNbYzJdWzBdO1xuICAgICAgICAgICAgbGV0IGMxX2NsdXN0ZXJfaW5kaWNlcyA9IGMxX2NsdXN0ZXIuaXNMZWFmID8gW2MxX2NsdXN0ZXIuaW5kZXhdIDogYzFfY2x1c3Rlci5pbmRleDtcbiAgICAgICAgICAgIGxldCBjMl9jbHVzdGVyX2luZGljZXMgPSBjMl9jbHVzdGVyLmlzTGVhZiA/IFtjMl9jbHVzdGVyLmluZGV4XSA6IGMyX2NsdXN0ZXIuaW5kZXg7XG4gICAgICAgICAgICBsZXQgaW5kaWNlcyA9IGMxX2NsdXN0ZXJfaW5kaWNlcy5jb25jYXQoYzJfY2x1c3Rlcl9pbmRpY2VzKTtcbiAgICAgICAgICAgIGxldCBuZXdfY2x1c3RlciA9IG5ldyBDbHVzdGVyKHRoaXMuX2lkKyssIGMxX2NsdXN0ZXIsIGMyX2NsdXN0ZXIsIEQuZW50cnkoYzEsIGMyKSwgbnVsbCwgaW5kaWNlcyk7XG4gICAgICAgICAgICBjMV9jbHVzdGVyLnBhcmVudCA9IG5ld19jbHVzdGVyO1xuICAgICAgICAgICAgYzJfY2x1c3Rlci5wYXJlbnQgPSBuZXdfY2x1c3RlcjtcbiAgICAgICAgICAgIGNsdXN0ZXJzW2MxXS51bnNoaWZ0KG5ld19jbHVzdGVyKTtcbiAgICAgICAgICAgIGNfc2l6ZVtjMV0gKz0gY19zaXplW2MyXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgRF9jMV9qID0gRC5lbnRyeShjMSwgaik7XG4gICAgICAgICAgICAgICAgY29uc3QgRF9jMl9qID0gRC5lbnRyeShjMiwgaik7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobGlua2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgubWluKERfYzFfaiwgRF9jMl9qKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29tcGxldGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5tYXgoRF9jMV9qLCBEX2MyX2opO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhdmVyYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IChjX3NpemVbYzFdICogRF9jMV9qICsgY19zaXplW2MyXSAqIERfYzJfaikgLyAoY19zaXplW2MxXSArIGNfc2l6ZVtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgRC5zZXRfZW50cnkoaiwgYzEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBELnNldF9lbnRyeShjMSwgaiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBELnNldF9lbnRyeShjMSwgYzEsIEluZmluaXR5KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgRC5zZXRfZW50cnkoaSwgYzIsIEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICBELnNldF9lbnRyeShjMiwgaSwgSW5maW5pdHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBmb3IgKGxldCBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChkX21pbltqXSA9PT0gYzIpIHtcbiAgICAgICAgICAgICAgICAgICAgZF9taW5bal0gPSBjMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEQuZW50cnkoYzEsIGopIDwgRC5lbnRyeShjMSwgZF9taW5bYzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkX21pbltjMV0gPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKi9cbiAgICAgICAgICAgIHJvb3QgPSBuZXdfY2x1c3RlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG59XG5cbmNsYXNzIENsdXN0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBsZWZ0LCByaWdodCwgZGlzdCwgY2VudHJvaWQsIGluZGV4LCBzaXplLCBkZXB0aCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5kaXN0ID0gZGlzdDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplID8/IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aCA/PyAxICsgTWF0aC5tYXgobGVmdC5kZXB0aCwgcmlnaHQuZGVwdGgpO1xuICAgICAgICB0aGlzLmNlbnRyb2lkID0gY2VudHJvaWQgPz8gdGhpcy5fY2FsY3VsYXRlX2NlbnRyb2lkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlX2NlbnRyb2lkKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGxfc2l6ZSA9IGxlZnQuc2l6ZTtcbiAgICAgICAgY29uc3Qgcl9zaXplID0gcmlnaHQuc2l6ZTtcbiAgICAgICAgY29uc3QgbF9jZW50cm9pZCA9IGxlZnQuY2VudHJvaWQ7XG4gICAgICAgIGNvbnN0IHJfY2VudHJvaWQgPSByaWdodC5jZW50cm9pZDtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgY29uc3QgbiA9IGxlZnQuY2VudHJvaWQubGVuZ3RoO1xuICAgICAgICBjb25zdCBuZXdfY2VudHJvaWQgPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgbmV3X2NlbnRyb2lkW2ldID0gKGxfc2l6ZSAqIGxfY2VudHJvaWRbaV0gKyByX3NpemUgKiByX2NlbnRyb2lkW2ldKSAvIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld19jZW50cm9pZDtcbiAgICB9XG5cbiAgICBnZXQgaXNMZWFmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXB0aCA9PT0gMDtcbiAgICB9XG5cbiAgICBsZWF2ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTGVhZikgcmV0dXJuIFt0aGlzXTtcbiAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMubGVmdDtcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnJpZ2h0O1xuICAgICAgICByZXR1cm4gKGxlZnQuaXNMZWFmID8gW2xlZnRdIDogbGVmdC5sZWF2ZXMoKSkuY29uY2F0KHJpZ2h0LmlzTGVhZiA/IFtyaWdodF0gOiByaWdodC5sZWF2ZXMoKSk7XG4gICAgfVxuXG4gICAgZGVzY2VuZGFudHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTGVhZikgcmV0dXJuIFt0aGlzXTtcbiAgICAgICAgY29uc3QgbGVmdF9kZXNjZW5kYW50cyA9IHRoaXMubGVmdC5kZXNjZW5kYW50cygpO1xuICAgICAgICBjb25zdCByaWdodF9kZXNjZW5kYW50cyA9IHRoaXMucmlnaHQuZGVzY2VuZGFudHMoKTtcbiAgICAgICAgcmV0dXJuIGxlZnRfZGVzY2VuZGFudHMuY29uY2F0KHJpZ2h0X2Rlc2NlbmRhbnRzKS5jb25jYXQoW3RoaXNdKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUmFuZG9taXplciB9IGZyb20gXCIuLi91dGlsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBIZWFwIH0gZnJvbSBcIi4uL2RhdGFzdHJ1Y3R1cmUvaW5kZXguanNcIjtcbmltcG9ydCB7IGxpbnNwYWNlIH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEtNZWFuc1xuICovXG5leHBvcnQgY2xhc3MgS01lYW5zIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNsdXN0ZXJpbmdcbiAgICAgKiBAYWxpYXMgS01lYW5zXG4gICAgICogQHRvZG8gbmVlZHMgcmVzdHJ1Y3R1cmluZy4gXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeCBcbiAgICAgKiBAcGFyYW0ge051bWJlcnN9IEsgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWVkID0gMTk4N11cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbml0ID0gdHJ1ZV1cbiAgICAgKiBAcmV0dXJucyB7S01lYW5zfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1hdHJpeCwgSywgbWV0cmljID0gZXVjbGlkZWFuLCBzZWVkPTE5ODcsIGluaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbWF0cml4O1xuICAgICAgICB0aGlzLl9LID0gSztcbiAgICAgICAgY29uc3QgW04sIERdID0gbWF0cml4LnNoYXBlO1xuICAgICAgICB0aGlzLl9OID0gTjtcbiAgICAgICAgdGhpcy5fRCA9IEQ7XG4gICAgICAgIGlmIChLID4gTikgSyA9IE47XG4gICAgICAgIHRoaXMuX3JhbmRvbWl6ZXIgPSBuZXcgUmFuZG9taXplcihzZWVkKTtcbiAgICAgICAgdGhpcy5fY2x1c3RlcnMgPSBuZXcgQXJyYXkoTikuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl9jbHVzdGVyX2NlbnRyb2lkcyA9IHRoaXMuX2dldF9yYW5kb21fY2VudHJvaWRzKEspO1xuICAgICAgICBpZiAoaW5pdCkgdGhpcy5pbml0KEssIHRoaXMuX2NsdXN0ZXJfY2VudHJvaWRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gLSBBcnJheSBvZiBjbHVzdGVycyB3aXRoIHRoZSBpbmRpY2VzIG9mIHRoZSByb3dzIGluIGdpdmVuIHtAbGluayBtYXRyaXh9LiBcbiAgICAgKi9cbiAgICBnZXRfY2x1c3RlcnMoKSB7XG4gICAgICAgIGNvbnN0IEsgPSB0aGlzLl9LO1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9IHRoaXMuX2NsdXN0ZXJzO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoSykuZmlsbCgpLm1hcCgoKSA9PiBuZXcgQXJyYXkoKSk7XG4gICAgICAgIGNsdXN0ZXJzLmZvckVhY2goKGMsIGkpID0+IHJlc3VsdFtjXS5wdXNoKGkpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjYW5kaWRhdGVzIFxuICAgICAqL1xuICAgIF9mdXJ0aGVzdF9wb2ludChwb2ludHMsIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX21hdHJpeDtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBsZXQgaSA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGxldCBIID0gSGVhcC5oZWFwaWZ5KFxuICAgICAgICAgICAgY2FuZGlkYXRlcywgXG4gICAgICAgICAgICAoZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IEFkID0gQS5yb3coZClcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gbWV0cmljKEFkLCBwb2ludHNbal0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIFwibWF4XCJcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gSC5wb3AoKS5lbGVtZW50O1xuICAgIH1cblxuICAgIF9nZXRfcmFuZG9tX2NlbnRyb2lkcyhLKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCByYW5kb21pemVyID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX21hdHJpeDtcbiAgICAgICAgY29uc3QgY2x1c3Rlcl9jZW50cm9pZHMgPSBuZXcgQXJyYXkoSykuZmlsbCgpXG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBsaW5zcGFjZSgwLCBOIC0gMSk7XG4gICAgICAgIGNvbnN0IHJhbmRvbV9wb2ludCA9IHJhbmRvbWl6ZXIucmFuZG9tX2ludCAlIChOIC0gMSk7XG4gICAgICAgIGNsdXN0ZXJfY2VudHJvaWRzWzBdID0gQS5yb3cocmFuZG9tX3BvaW50KTtcbiAgICAgICAgY29uc3QgaW5pdF9wb2ludHMgPSBbcmFuZG9tX3BvaW50XTtcbiAgICAgICAgY29uc3Qgc2FtcGxlX3NpemUgPSBNYXRoLmZsb29yKChOIC0gSykgLyBLKTsvLyAvIEtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBLOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHNhbXBsaW5nICsga21lYW5zKysgaW1wcm92ZW1lbnQ/XG4gICAgICAgICAgICBjb25zdCBzYW1wbGUgPSByYW5kb21pemVyLmNob2ljZShpbmRpY2VzLmZpbHRlcihkID0+IGluaXRfcG9pbnRzLmluZGV4T2YoZCkgPT0gLTEpLCBzYW1wbGVfc2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBmdXJ0aGVzdF9wb2ludCA9IHRoaXMuX2Z1cnRoZXN0X3BvaW50KGNsdXN0ZXJfY2VudHJvaWRzLnNsaWNlKDAsIGkpLCBzYW1wbGUpO1xuICAgICAgICAgICAgaW5pdF9wb2ludHMucHVzaChmdXJ0aGVzdF9wb2ludCk7XG4gICAgICAgICAgICBjbHVzdGVyX2NlbnRyb2lkc1tpXSA9IEEucm93KGZ1cnRoZXN0X3BvaW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2x1c3Rlcl9jZW50cm9pZHM7XG4gICAgfVxuXG4gICAgX2l0ZXJhdGlvbihjbHVzdGVyX2NlbnRyb2lkcykge1xuICAgICAgICBjb25zdCBLID0gY2x1c3Rlcl9jZW50cm9pZHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgRCA9IHRoaXMuX0Q7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9tYXRyaXg7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSB0aGlzLl9jbHVzdGVycztcbiAgICAgICAgbGV0IGNsdXN0ZXJzX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gZmluZCBuZWFyZXN0IGNsdXN0ZXIgY2VudHJvaWQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBBaSA9IEEucm93KGkpXG4gICAgICAgICAgICBsZXQgbWluX2Rpc3QgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBtaW5fY2x1c3RlciA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IEs7ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBkID0gbWV0cmljKGNsdXN0ZXJfY2VudHJvaWRzW2pdLCBBaSk7XG4gICAgICAgICAgICAgICAgaWYgKGQgPCBtaW5fZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5fZGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbl9jbHVzdGVyID0gajsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsdXN0ZXJzW2ldICE9PSBtaW5fY2x1c3Rlcikge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXJzX2NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2x1c3RlcnNbaV0gPSBtaW5fY2x1c3RlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgY2x1c3RlciBjZW50cm9pZFxuICAgICAgICAvLyByZXNldCBjbHVzdGVyIGNlbnRyb2lkcyB0byAwXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSzsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjZW50cm9pZCA9IGNsdXN0ZXJfY2VudHJvaWRzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBEOyArK2opIHtcbiAgICAgICAgICAgICAgICBjZW50cm9pZFtqXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcHV0ZSBjZW50cm9pZFxuICAgICAgICB0aGlzLl9jb21wdXRlX2NlbnRyb2lkKGNsdXN0ZXJfY2VudHJvaWRzKTtcblxuICAgICAgICByZXR1cm4geyAgIFxuICAgICAgICAgICAgXCJjbHVzdGVyc19jaGFuZ2VkXCI6IGNsdXN0ZXJzX2NoYW5nZWQsXG4gICAgICAgICAgICBcImNsdXN0ZXJfY2VudHJvaWRzXCI6IGNsdXN0ZXJfY2VudHJvaWRzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgX2NvbXB1dGVfY2VudHJvaWQoY2x1c3Rlcl9jZW50cm9pZHMpIHtcbiAgICAgICAgY29uc3QgSyA9IGNsdXN0ZXJfY2VudHJvaWRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9EO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fbWF0cml4O1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9IHRoaXMuX2NsdXN0ZXJzO1xuICAgICAgICBjb25zdCBjbHVzdGVyX2NvdW50ZXIgPSBuZXcgQXJyYXkoSykuZmlsbCgwKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgQWkgPSBBLnJvdyhpKTtcbiAgICAgICAgICAgIGNvbnN0IGNpID0gY2x1c3RlcnNbaV07XG4gICAgICAgICAgICBjbHVzdGVyX2NvdW50ZXJbY2ldKys7XG4gICAgICAgICAgICBjb25zdCBjZW50cm9pZCA9IGNsdXN0ZXJfY2VudHJvaWRzW2NpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgRDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2VudHJvaWRbal0gKz0gQWlbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBLOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBjbHVzdGVyX2NvdW50ZXJbaV07XG4gICAgICAgICAgICBjbHVzdGVyX2NlbnRyb2lkc1tpXSA9IGNsdXN0ZXJfY2VudHJvaWRzW2ldLm1hcChjID0+IGMgLyBuKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB7QGxpbmsgS30gY2x1c3RlcnMgb3V0IG9mIHRoZSB7QGxpbmsgbWF0cml4fS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gSyAtIG51bWJlciBvZiBjbHVzdGVycy5cbiAgICAgKi9cbiAgICBpbml0KEssIGNsdXN0ZXJfY2VudHJvaWRzKSB7XG4gICAgICAgIGlmICghSykgSyA9IHRoaXMuX0s7XG4gICAgICAgIGlmICghY2x1c3Rlcl9jZW50cm9pZHMpIGNsdXN0ZXJfY2VudHJvaWRzID0gdGhpcy5fZ2V0X3JhbmRvbV9jZW50cm9pZHMoSyk7XG4gICAgICAgIGxldCBjbHVzdGVyc19jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdGlvbl9yZXN1bHQgPSB0aGlzLl9pdGVyYXRpb24oY2x1c3Rlcl9jZW50cm9pZHMpXG4gICAgICAgICAgICBjbHVzdGVyX2NlbnRyb2lkcyA9IGl0ZXJhdGlvbl9yZXN1bHQuY2x1c3Rlcl9jZW50cm9pZHM7XG4gICAgICAgICAgICBjbHVzdGVyc19jaGFuZ2VkID0gaXRlcmF0aW9uX3Jlc3VsdC5jbHVzdGVyc19jaGFuZ2VkO1xuICAgICAgICB9IHdoaWxlIChjbHVzdGVyc19jaGFuZ2VkKVxuICAgIH1cbiAgICBcbn1cbiIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBSYW5kb21pemVyIH0gZnJvbSBcIi4uL3V0aWwvaW5kZXguanNcIjtcbmltcG9ydCB7IGxpbnNwYWNlLCBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBtaW4gfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBLTWVkb2lkc1xuICovXG5leHBvcnQgY2xhc3MgS01lZG9pZHMge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y2x1c3RlcmluZ1xuICAgICAqIEBhbGlhcyBLTWVkb2lkc1xuICAgICAqIEB0b2RvIG5lZWRzIHJlc3RydWN0dXJpbmcuIFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXggLSBkYXRhIG1hdHJpeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyc30gSyAtIG51bWJlciBvZiBjbHVzdGVyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4X2l0ZXI9bnVsbF0gLSBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zLiBEZWZhdWx0IGlzIDEwICogTWF0aC5sb2cxMChOKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gbWV0cmljIGRlZmluaW5nIHRoZSBkaXNzaW1pbGFyaXR5IFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VlZCA9IDEyMTJdIC0gc2VlZCB2YWx1ZSBmb3IgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiAgICAgKiBAcmV0dXJucyB7S01lZG9pZHN9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9saW5rLnNwcmluZ2VyLmNvbS9jaGFwdGVyLzEwLjEwMDcvOTc4LTMtMDMwLTMyMDQ3LThfMTZ9IEZhc3RlciBrLU1lZG9pZHMgQ2x1c3RlcmluZzogSW1wcm92aW5nIHRoZSBQQU0sIENMQVJBLCBhbmQgQ0xBUkFOUyBBbGdvcml0aG1zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF0cml4LCBLLCBtYXhfaXRlcj1udWxsLCBtZXRyaWMgPSBldWNsaWRlYW4sIHNlZWQ9MTIxMikge1xuICAgICAgICB0aGlzLl9tZXRyaWMgPSBtZXRyaWM7XG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeDtcbiAgICAgICAgdGhpcy5fQSA9IHRoaXMuX21hdHJpeC50bzJkQXJyYXk7XG4gICAgICAgIHRoaXMuX0sgPSBLO1xuICAgICAgICBjb25zdCBbTiwgRF0gPSBtYXRyaXguc2hhcGU7XG4gICAgICAgIHRoaXMuX04gPSBOO1xuICAgICAgICB0aGlzLl9EID0gRDtcbiAgICAgICAgdGhpcy5fbWF4X2l0ZXIgPSBtYXhfaXRlciB8fCAxMCAqIE1hdGgubG9nMTAoTikgXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlX21hdHJpeCA9IG5ldyBNYXRyaXgoTiwgTiwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgLyogZm9yIChsZXQgaSA9IDE7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gbWV0cmljKHRoaXMuX0FbaV0sIHRoaXMuX0Fbal0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlX21hdHJpeC5zZXRfZW50cnkoaSwgaiwgZGlzdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VfbWF0cml4LnNldF9lbnRyeShqLCBpLCBkaXN0KVxuICAgICAgICAgICAgfVxuICAgICAgICB9ICovXG4gICAgICAgIGlmIChLID4gTikgSyA9IE47XG4gICAgICAgIHRoaXMuX3JhbmRvbWl6ZXIgPSBuZXcgUmFuZG9taXplcihzZWVkKTtcbiAgICAgICAgdGhpcy5fY2x1c3RlcnMgPSBuZXcgQXJyYXkoTikuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl9jbHVzdGVyX21lZG9pZHMgPSB0aGlzLl9nZXRfcmFuZG9tX21lZG9pZHMoSyk7XG4gICAgICAgIC8vaWYgKGluaXQpIHRoaXMuaW5pdChLLCB0aGlzLl9jbHVzdGVyX21lZG9pZHMpO1xuICAgICAgICB0aGlzLl9pc19pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fSAtIEFycmF5IG9mIGNsdXN0ZXJzIHdpdGggdGhlIGluZGljZXMgb2YgdGhlIHJvd3MgaW4gZ2l2ZW4ge0BsaW5rIG1hdHJpeH0uIFxuICAgICAqL1xuICAgIGdldF9jbHVzdGVycygpIHtcbiAgICAgICAgY29uc3QgSyA9IHRoaXMuX0s7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9BO1xuICAgICAgICBpZiAoIXRoaXMuX2lzX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoSywgdGhpcy5fY2x1c3Rlcl9tZWRvaWRzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoSykuZmlsbCgpLm1hcCgoKSA9PiBuZXcgQXJyYXkoKSk7XG4gICAgICAgIEEuZm9yRWFjaCgoeF9qLCBqKSA9PiB7XG4gICAgICAgICAgICByZXN1bHRbdGhpcy5fbmVhcmVzdF9tZWRvaWQoeF9qLCBqKS5pbmRleF9uZWFyZXN0XS5wdXNoKGopO1xuICAgICAgICB9KVxuICAgICAgICByZXN1bHQubWVkb2lkcyA9IHRoaXMuX2NsdXN0ZXJfbWVkb2lkcztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyogZ2VuZXJhdG9yKCkge1xuICAgICAgICBjb25zdCBtYXhfaXRlciA9IHRoaXMuX21heF9pdGVyO1xuICAgICAgICB5aWVsZCB0aGlzLmdldF9jbHVzdGVycygpXG4gICAgICAgIGxldCBmaW5pc2ggPSBmYWxzZTtcbiAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGZpbmlzaCA9IHRoaXMuX2l0ZXJhdGlvbigpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXRfY2x1c3RlcnMoKTtcbiAgICAgICAgfSB3aGlsZSAoIWZpbmlzaCAmJiArK2kgPCBtYXhfaXRlcilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGdvcml0aG0gMS4gRmFzdFBBTTE6IEltcHJvdmVkIFNXQVAgYWxnb3JpdGhtXG4gICAgICovXG4gICAgLyogX2l0ZXJhdGlvbl8xKCkge1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IEsgPSB0aGlzLl9LO1xuICAgICAgICBjb25zdCBtZWRvaWRzID0gdGhpcy5fY2x1c3Rlcl9tZWRvaWRzO1xuICAgICAgICBsZXQgRGVsdGFURCA9IDA7XG4gICAgICAgIGxldCBtMCA9IG51bGw7XG4gICAgICAgIGxldCB4MCA9IG51bGw7XG4gICAgICAgIEEuZm9yRWFjaCgoeF9qLCBqKSA9PiB7XG4gICAgICAgICAgICBpZiAobWVkb2lkcy5maW5kSW5kZXgobSA9PiBtID09PSBqKSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZWFyZXN0X21lZG9pZCA9IHRoaXMuX25lYXJlc3RfbWVkb2lkKHhfaiwgaik7XG4gICAgICAgICAgICAgICAgY29uc3QgZF9qID0gbmVhcmVzdF9tZWRvaWQuZGlzdGFuY2VfbmVhcmVzdDsgLy8gZGlzdGFuY2UgdG8gY3VycmVudCBtZWRvaWRcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVREID0gbmV3IEFycmF5KEspLmZpbGwoLWRfaik7IC8vIGNoYW5nZSBpZiBtYWtpbmcgaiBhIG1lZG9pZFxuICAgICAgICAgICAgICAgIEEuZm9yRWFjaCgoeF9vLCBvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FuY2UgdG8gbmV3IG1lZG9pZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkX29qID0gdGhpcy5fZ2V0X2Rpc3RhbmNlKG8sIGosIHhfbywgeF9qKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJpbmRleF9uZWFyZXN0XCI6IG4sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRpc3RhbmNlX25lYXJlc3RcIjogZF9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXN0YW5jZV9zZWNvbmRcIjogZF9zLFxuICAgICAgICAgICAgICAgICAgICB9ID0gdGhpcy5fbmVhcmVzdF9tZWRvaWQoeF9vLCBvKTsgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsdXN0ZXJzW29dID0gbjsgLy8gY2FjaGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVREW25dICs9IE1hdGgubWluKGRfb2osIGRfcykgLSBkX247IC8vIGxvc3MgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmIChkX29qIDwgZF9uKSB7IC8vIHJlYXNzaWdubWVudCBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFURC5mb3JFYWNoKChkX2ksIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobiAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVREW2ldID0gZF9pICsgZF9vaiAtIGRfbjsgLy8gdXBkYXRlIGxvc3MgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgYmVzdCBtZWRvaWQgaTtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gZGVsdGFURFxuICAgICAgICAgICAgICAgICAgICAubWFwKChkLCBpKSA9PiBbZCwgaV0pXG4gICAgICAgICAgICAgICAgICAgIC5zb3J0KChkMSwgZDIpID0+IGQxWzBdIC0gZDJbMF0pWzBdWzFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhVERfaSA9IGRlbHRhVERbaV07XG4gICAgICAgICAgICAgICAgLy8gc3RvcmVcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFURF9pIDwgRGVsdGFURCkge1xuICAgICAgICAgICAgICAgICAgICBEZWx0YVREID0gZGVsdGFURF9pO1xuICAgICAgICAgICAgICAgICAgICBtMCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHgwID0gajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChEZWx0YVREID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlIC8vIGJyZWFrIGxvb3AgaWYgRGVsdGFURCA+PSAwXG4gICAgICAgIH1cbiAgICAgICAgLy8gc3dhcCByb2xlcyBvZiBtZWRvaWQgbSBhbmQgbm9uLW1lZG9pZCB4O1xuICAgICAgICBtZWRvaWRzW20wXSA9IHgwO1xuICAgICAgICB0aGlzLl9jbHVzdGVyX21lZG9pZHMgPSBtZWRvaWRzO1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9ICovXG5cbiAgICAvKiogQWxnb3JpdGhtIDIuIEZhc3RQQU0yOiBTV0FQIHdpdGggbXVsdGlwbGUgY2FuZGlkYXRlc1xuICAgICAqIFxuICAgICAqL1xuICAgIF9pdGVyYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9BO1xuICAgICAgICBjb25zdCBLID0gdGhpcy5fSztcbiAgICAgICAgY29uc3QgbWVkb2lkcyA9IHRoaXMuX2NsdXN0ZXJfbWVkb2lkcztcbiAgICAgICAgY29uc3QgY2FjaGUgPSBBLm1hcCgoeF9vLCBvKSA9PiB0aGlzLl9uZWFyZXN0X21lZG9pZCh4X28sIG8pKTtcbiAgICAgICAgLy8gZW1wdHkgYmVzdCBjYW5kaWRhdGVzIGFycmF5XG4gICAgICAgIGNvbnN0IERlbHRhVEQgPSBuZXcgQXJyYXkoSykuZmlsbCgwKTtcbiAgICAgICAgY29uc3QgeHMgPSBuZXcgQXJyYXkoSykuZmlsbChudWxsKTtcbiAgICAgICAgQS5mb3JFYWNoKCh4X2osIGopID0+IHtcbiAgICAgICAgICAgIGlmIChtZWRvaWRzLmZpbmRJbmRleChtID0+IG0gPT09IGopIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRfaiA9IGNhY2hlW2pdLmRpc3RhbmNlX25lYXJlc3Q7IC8vIGRpc3RhbmNlIHRvIGN1cnJlbnQgbWVkb2lkXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFURCA9IG5ldyBBcnJheShLKS5maWxsKC1kX2opOyAvLyBjaGFuZ2UgaWYgbWFraW5nIGogYSBtZWRvaWRcbiAgICAgICAgICAgICAgICBBLmZvckVhY2goKHhfbywgbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gbykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkX29qID0gdGhpcy5fZ2V0X2Rpc3RhbmNlKG8sIGosIHhfbywgeF9qKTsgLy8gZGlzdGFuY2UgdG8gbmV3IG1lZG9pZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7XCJpbmRleF9uZWFyZXN0XCI6IG4sIFwiZGlzdGFuY2VfbmVhcmVzdFwiOiBkX24sIFwiZGlzdGFuY2Vfc2Vjb25kXCI6IGRfc30gPSBjYWNoZVtvXTsgLy8gY2FjaGVkXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhVERbbl0gKz0gTWF0aC5taW4oZF9vaiwgZF9zKSAtIGRfbjsgLy8gbG9zcyBjaGFuZ2UgZm9yIHhfb1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWFzc2lnbm1lbnQgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRfb2ogPCBkX24pIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgbG9zcyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSzsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IG4pIGRlbHRhVERbaV0gKz0gZF9vaiAtIGRfbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIGJlc3Qgc3dhcCBmb3IgaTtcbiAgICAgICAgICAgICAgICBkZWx0YVREXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGQsIGkpID0+IFtkLCBpXSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoW2QsIGldKSA9PiBkIDwgRGVsdGFURFtpXSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goKFtkLCBpXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBEZWx0YVREW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVsdGFURFtpXSA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeHNbaV0gPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAvLyBzdG9wIGlmIG5vIGltcHJvdmVtZW50cyB3ZXJlIGZvdW5kXG4gICAgICAgIGlmIChtaW4oRGVsdGFURCkgPj0gMCkgcmV0dXJuIHRydWU7IFxuXG4gICAgICAgIC8vIGV4ZWN1dGUgYWxsIGltcHJvdmVtZW50c1xuICAgICAgICB3aGlsZSAobWluKERlbHRhVEQpIDwgMCkge1xuICAgICAgICAgICAgLy8gc3dhcCByb2xlcyBvZiBtZWRvaWQgbV9pIGFuZCBub25fbWVkb2lkIHhzX2lcbiAgICAgICAgICAgIGNvbnN0IGkgPSBEZWx0YVREXG4gICAgICAgICAgICAgICAgLm1hcCgoZCwgaSkgPT4gW2QsIGldKVxuICAgICAgICAgICAgICAgIC5zb3J0KChbYV0sIFtiXSkgPT4gYSAtIGIpWzBdWzFdO1xuICAgICAgICAgICAgaWYgKG1lZG9pZHMuZmlsdGVyKG0gPT4gbSA9PSB4c1tpXSkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBtZWRvaWRzW2ldID0geHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkaXNhYmxlIHRoZSBzd2FwIGp1c3QgcGVyZm9ybWVkXG4gICAgICAgICAgICBEZWx0YVREW2ldID0gMDsgXG4gICAgICAgICAgICAvLyByZWNvbXB1dGUgVEQgZm9yIHJlbWFpbmluZyBzd2FwIGNhbmRpZGF0ZXNcbiAgICAgICAgICAgIERlbHRhVERcbiAgICAgICAgICAgICAgICAubWFwKChkX2osIGopID0+IFtkX2osIGpdKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtkX2pdKSA9PiBkX2ogPCAwKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChbXywgal0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeF9qID0gQVtqXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIEEuZm9yRWFjaCgoeF9vLCBvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVkb2lkcy5maW5kSW5kZXgobSA9PiBtICE9IGogJiYgbSA9PSBvKSA+PSAwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBqKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVbb10uaW5kZXhfbmVhcmVzdCA9PT0gbWVkb2lkc1tqXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gKE1hdGgubWluKHRoaXMuX2dldF9kaXN0YW5jZShvLCBqLCB4X28sIHhfaiksIGNhY2hlW29dLmRpc3RhbmNlX3NlY29uZCkgLSBjYWNoZVtvXS5kaXN0YW5jZV9uZWFyZXN0KTsgXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gKE1hdGgubWluKHRoaXMuX2dldF9kaXN0YW5jZShvLCBqLCB4X28sIHhfaikgLSBjYWNoZVtvXS5kaXN0YW5jZV9uZWFyZXN0LCAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBEZWx0YVREW2pdID0gc3VtO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2x1c3Rlcl9tZWRvaWRzID0gbWVkb2lkcztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIF9nZXRfZGlzdGFuY2UoaSwgaiwgeF9pPW51bGwsIHhfaj1udWxsKSB7XG4gICAgICAgIGlmIChpID09PSBqKSByZXR1cm4gMDtcbiAgICAgICAgY29uc3QgRCA9IHRoaXMuX2Rpc3RhbmNlX21hdHJpeDtcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX0E7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgbGV0IGRfaWogPSBELmVudHJ5KGksIGopO1xuICAgICAgICBpZiAoZF9paiA9PT0gMCkge1xuICAgICAgICAgICAgZF9paiA9IG1ldHJpYyh4X2kgfHwgQVtpXSwgeF9qIHx8IEFbal0pO1xuICAgICAgICAgICAgRC5zZXRfZW50cnkoaSwgaiwgZF9paik7XG4gICAgICAgICAgICBELnNldF9lbnRyeShqLCBpLCBkX2lqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZF9pajtcbiAgICB9XG5cbiAgICBfbmVhcmVzdF9tZWRvaWQoeF9qLCBqKSB7XG4gICAgICAgIGNvbnN0IG1lZG9pZHMgPSB0aGlzLl9jbHVzdGVyX21lZG9pZHM7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9BO1xuICAgICAgICBjb25zdCBbbmVhcmVzdCwgc2Vjb25kXSA9IG1lZG9pZHNcbiAgICAgICAgICAgIC5tYXAoKG0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB4X20gPSBBW21dOyBcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMuX2dldF9kaXN0YW5jZShqLCBtLCB4X2osIHhfbSksIGldO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zb3J0KChtMSwgbTIpID0+IG0xWzBdIC0gbTJbMF0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICBcImRpc3RhbmNlX25lYXJlc3RcIjogbmVhcmVzdFswXSwgXG4gICAgICAgICAgICBcImluZGV4X25lYXJlc3RcIjogbmVhcmVzdFsxXSxcbiAgICAgICAgICAgIFwiZGlzdGFuY2Vfc2Vjb25kXCI6IHNlY29uZFswXSxcbiAgICAgICAgICAgIFwiaW5kZXhfc2Vjb25kXCI6IHNlY29uZFsxXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB7QGxpbmsgS30gY2x1c3RlcnMgb3V0IG9mIHRoZSB7QGxpbmsgbWF0cml4fS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gSyAtIG51bWJlciBvZiBjbHVzdGVycy5cbiAgICAgKi9cbiAgICBpbml0KEssIGNsdXN0ZXJfbWVkb2lkcykge1xuICAgICAgICBpZiAoIUspIEsgPSB0aGlzLl9LO1xuICAgICAgICBpZiAoIWNsdXN0ZXJfbWVkb2lkcykgY2x1c3Rlcl9tZWRvaWRzID0gdGhpcy5fZ2V0X3JhbmRvbV9tZWRvaWRzKEspO1xuICAgICAgICBjb25zdCBtYXhfaXRlciA9IHRoaXMuX21heF9pdGVyO1xuICAgICAgICBsZXQgZmluaXNoID0gZmFsc2U7XG4gICAgICAgIGxldCBpID0gMFxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBmaW5pc2ggPSB0aGlzLl9pdGVyYXRpb24oKTtcbiAgICAgICAgfSB3aGlsZSAoIWZpbmlzaCAmJiArK2kgPCBtYXhfaXRlcilcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxnb3JpdGhtIDMuIEZhc3RQQU0gTEFCOiBMaW5lYXIgQXBwcm94aW1hdGUgQlVJTEQgaW5pdGlhbGl6YXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IEsgLSBudW1iZXIgb2YgY2x1c3RlcnNcbiAgICAgKiBcbiAgICAgKi9cbiAgICBfZ2V0X3JhbmRvbV9tZWRvaWRzKEspIHtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9BO1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gbGluc3BhY2UoMCwgTiAtIDEpO1xuICAgICAgICBjb25zdCByYW5kb21pemVyID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKE4sIDEwICsgTWF0aC5jZWlsKE1hdGguc3FydChOKSkpO1xuICAgICAgICBjb25zdCBURCA9IG5ldyBBcnJheShuKS5maWxsKEluZmluaXR5KTtcbiAgICAgICAgY29uc3QgbWVkb2lkcyA9IFtdO1xuICAgICAgICAvLyBmaXJzdCBtZWRvaWRcbiAgICAgICAgbGV0IFREMCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgUyA9IHJhbmRvbWl6ZXIuY2hvaWNlKGluZGljZXMsIG4pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgY29uc3QgU19qID0gU1tqXTtcbiAgICAgICAgICAgIGNvbnN0IHhfaiA9IEFbU19qXTtcbiAgICAgICAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgbjsgKytvKSB7XG4gICAgICAgICAgICAgICAgaWYgKG8gPT09IGopIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhfbyA9IEFbU1tvXV07XG4gICAgICAgICAgICAgICAgVERbal0gKz0gdGhpcy5fZ2V0X2Rpc3RhbmNlKGosIG8sIHhfaiwgeF9vKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChURFtqXSA8IFREMCkge1xuICAgICAgICAgICAgICAgIFREMCA9IFREW2pdOyAvLyBzbWFsbGVzdCBkaXN0YW5jZSBzdW1cbiAgICAgICAgICAgICAgICBtZWRvaWRzLnB1c2goU19qKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlciBtZWRvaWRzXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgSzsgKytpKSB7XG4gICAgICAgICAgICBsZXQgRGVsdGFURCA9IEluZmluaXR5O1xuICAgICAgICAgICAgUyA9IHJhbmRvbWl6ZXIuY2hvaWNlKGluZGljZXMuZmlsdGVyKGluZGV4ID0+IG1lZG9pZHMuZmluZEluZGV4KGQgPT4gZCA9PT0gaW5kZXgpIDwgMCksIG4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVsdGFURCA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgU19qID0gU1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCB4X2ogPSBBW1Nfal07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCBuOyArK28pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPT09IGopIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBTX28gPSBTW29dO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4X28gPSBBW1Nfb107XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWx0YSA9IHRoaXMuX2dldF9kaXN0YW5jZShTX2osIFNfbywgeF9qLCB4X28pIC0gbWluKG1lZG9pZHMubWFwKG0gPT4gdGhpcy5fZ2V0X2Rpc3RhbmNlKFNfbywgbSwgeF9vKSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVREID0gZGVsdGFURCArIGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGJlc3QgcmVkdWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhVEQgPCBEZWx0YVREKSB7XG4gICAgICAgICAgICAgICAgICAgIERlbHRhVEQgPSBkZWx0YVREO1xuICAgICAgICAgICAgICAgICAgICBtZWRvaWRzLnB1c2goU19qKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBURDAgKz0gRGVsdGFURDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVkb2lkcy5zbGljZSgwLCBLKTtcbiAgICB9XG4gICAgXG59XG4iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSGVhcCB9IGZyb20gXCIuLi9kYXRhc3RydWN0dXJlL2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgT1BUSUNTXG4gKi9cbmV4cG9ydCBjbGFzcyBPUFRJQ1Mge1xuICAgIC8qKlxuICAgICAqICoqTyoqcmRlcmluZyAqKlAqKm9pbnRzICoqVCoqbyAqKkkqKmRlbnRpZnkgdGhlICoqQyoqbHVzdGVyaW5nICoqUyoqdHJ1Y3R1cmUuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjbHVzdGVyaW5nXG4gICAgICogQGFsaWFzIE9QVElDU1xuICAgICAqIEB0b2RvIG5lZWRzIHJlc3RydWN0dXJpbmcuIFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXggLSB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZXBzaWxvbiAtIHRoZSBtaW5pbXVtIGRpc3RhbmNlIHdoaWNoIGRlZmluZXMgd2hldGhlciBhIHBvaW50IGlzIGEgbmVpZ2hib3Igb3Igbm90LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5fcG9pbnRzIC0gdGhlIG1pbmltdW0gbnVtYmVyIG9mIHBvaW50cyB3aGljaCBhIHBvaW50IG5lZWRzIHRvIGNyZWF0ZSBhIGNsdXN0ZXIuIChTaG91bGQgYmUgaGlnaGVyIHRoYW4gMSwgZWxzZSBlYWNoIHBvaW50IGNyZWF0ZXMgYSBjbHVzdGVyLilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBkaXN0YW5jZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzIG9mIHRoZSB7QGxpbmsgbWF0cml4fS5cbiAgICAgKiBAcmV0dXJucyB7T1BUSUNTfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmRicy5pZmkubG11LmRlL1B1Ymxpa2F0aW9uZW4vUGFwZXJzL09QVElDUy5wZGZ9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT1BUSUNTX2FsZ29yaXRobX1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIGVwc2lsb24sIG1pbl9wb2ludHMsIG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgICAgICB0aGlzLl9tYXRyaXggPSBtYXRyaXg7XG4gICAgICAgIHRoaXMuX2Vwc2lsb24gPSBlcHNpbG9uO1xuICAgICAgICB0aGlzLl9taW5fcG9pbnRzID0gbWluX3BvaW50cztcbiAgICAgICAgdGhpcy5fbWV0cmljID0gbWV0cmljO1xuXG4gICAgICAgIHRoaXMuX29yZGVyZWRfbGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9jbHVzdGVycyA9IFtdO1xuICAgICAgICB0aGlzLl9EQiA9IG5ldyBBcnJheShtYXRyaXguc2hhcGVbMF0pLmZpbGwoKTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBjbHVzdGVyaW5nLlxuICAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IG9yZGVyZWRfbGlzdCA9IHRoaXMuX29yZGVyZWRfbGlzdDtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuICAgICAgICBjb25zdCBOID0gbWF0cml4LnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBEQiA9IHRoaXMuX0RCO1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9IHRoaXMuX2NsdXN0ZXJzO1xuICAgICAgICBsZXQgY2x1c3Rlcl9pbmRleCA9IHRoaXMuX2NsdXN0ZXJfaW5kZXggPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBEQltpXSA9IHtcbiAgICAgICAgICAgICAgICBcImVsZW1lbnRcIjogbWF0cml4LnJvdyhpKSxcbiAgICAgICAgICAgICAgICBcImluZGV4XCI6IGksXG4gICAgICAgICAgICAgICAgXCJyZWFjaGFiaWxpdHlfZGlzdGFuY2VcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwicHJvY2Vzc2VkXCI6IGZhbHNlLFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBEQikge1xuICAgICAgICAgICAgaWYgKHAucHJvY2Vzc2VkKSBjb250aW51ZTtcbiAgICAgICAgICAgIHAubmVpZ2hib3JzID0gdGhpcy5fZ2V0X25laWdoYm9ycyhwKTtcbiAgICAgICAgICAgIHAucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goW3AuaW5kZXhdKVxuICAgICAgICAgICAgY2x1c3Rlcl9pbmRleCA9IGNsdXN0ZXJzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBvcmRlcmVkX2xpc3QucHVzaChwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3JlX2Rpc3RhbmNlKHApICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZWRzID0gbmV3IEhlYXAobnVsbCwgZCA9PiBkLnJlYWNoYWJpbGl0eV9kaXN0YW5jZSwgXCJtaW5cIilcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUocCwgc2VlZHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZF9jbHVzdGVyKHNlZWRzLCBjbHVzdGVyc1tjbHVzdGVyX2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcCAtIGEgcG9pbnQgb2Yge0BsaW5rIG1hdHJpeH0uXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBjb25zaXN0aW5nIG9mIHRoZSB7QGxpbmsgZXBzaWxvbn0tbmVpZ2hib3Job29kIG9mIHtAbGluayBwfS5cbiAgICAgKi9cbiAgICBfZ2V0X25laWdoYm9ycyhwKSB7XG4gICAgICAgIGlmIChcIm5laWdoYm9yc1wiIGluIHApIHJldHVybiBwLm5laWdoYm9ycztcbiAgICAgICAgY29uc3QgREIgPSB0aGlzLl9EQjtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5fZXBzaWxvbjtcbiAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcSBvZiBEQikge1xuICAgICAgICAgICAgaWYgKHEuaW5kZXggPT0gcC5pbmRleCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAobWV0cmljKHAuZWxlbWVudCwgcS5lbGVtZW50KSA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVpZ2hib3JzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHAgLSBhIHBvaW50IG9mIHtAbGluayBtYXRyaXh9LlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBkaXN0YW5jZSB0byB0aGUge0BsaW5rIG1pbl9wb2ludHN9LXRoIG5lYXJlc3QgcG9pbnQgb2Yge0BsaW5rIHB9LCBvciB1bmRlZmluZWQgaWYgdGhlIHtAbGluayBlcHNpbG9ufS1uZWlnaGJvcmhvb2QgaGFzIGZld2VyIGVsZW1lbnRzIHRoYW4ge0BsaW5rIG1pbl9wb2ludHN9LlxuICAgICAqL1xuICAgIF9jb3JlX2Rpc3RhbmNlKHApIHtcbiAgICAgICAgY29uc3QgbWluX3BvaW50cyA9IHRoaXMuX21pbl9wb2ludHM7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgaWYgKHAubmVpZ2hib3JzICYmIHAubmVpZ2hib3JzLmxlbmd0aCA8PSBtaW5fcG9pbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRyaWMocC5lbGVtZW50LCBwLm5laWdoYm9yc1ttaW5fcG9pbnRzXS5lbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZWFjaGFiaWxpdHkgZGlzdGFuY2Ugb2YgdGhlIHBvaW50cy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwIFxuICAgICAqIEBwYXJhbSB7SGVhcH0gc2VlZHMgXG4gICAgICovXG4gICAgX3VwZGF0ZShwLCBzZWVkcykge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IGNvcmVfZGlzdGFuY2UgPSB0aGlzLl9jb3JlX2Rpc3RhbmNlKHApO1xuICAgICAgICBjb25zdCBuZWlnaGJvcnMgPSB0aGlzLl9nZXRfbmVpZ2hib3JzKHApOy8vcC5uZWlnaGJvcnM7XG4gICAgICAgIGZvciAoY29uc3QgcSBvZiBuZWlnaGJvcnMpIHtcbiAgICAgICAgICAgIGlmIChxLnByb2Nlc3NlZCkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBuZXdfcmVhY2hhYmlsaXR5X2Rpc3RhbmNlID0gTWF0aC5tYXgoY29yZV9kaXN0YW5jZSwgbWV0cmljKHAuZWxlbWVudCwgcS5lbGVtZW50KSk7XG4gICAgICAgICAgICAvL2lmIChxLnJlYWNoYWJpbGl0eV9kaXN0YW5jZSA9PSB1bmRlZmluZWQpIHsgLy8gcSBpcyBub3QgaW4gc2VlZHNcbiAgICAgICAgICAgIGlmIChzZWVkcy5yYXdfZGF0YSgpLmZpbmRJbmRleChkID0+IGQuZWxlbWVudCA9PSBxKSA8IDApIHtcbiAgICAgICAgICAgICAgICBxLnJlYWNoYWJpbGl0eV9kaXN0YW5jZSA9IG5ld19yZWFjaGFiaWxpdHlfZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgc2VlZHMucHVzaChxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHEgaXMgaW4gc2VlZHNcbiAgICAgICAgICAgICAgICBpZiAobmV3X3JlYWNoYWJpbGl0eV9kaXN0YW5jZSA8IHEucmVhY2hhYmlsaXR5X2Rpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHEucmVhY2hhYmlsaXR5X2Rpc3RhbmNlID0gbmV3X3JlYWNoYWJpbGl0eV9kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgc2VlZHMgPSBIZWFwLmhlYXBpZnkoc2VlZHMuZGF0YSgpLCBkID0+IGQucmVhY2hhYmlsaXR5X2Rpc3RhbmNlLCBcIm1pblwiKTsgLy8gc2VlZHMgY2hhbmdlIGtleSA9L1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgdGhlIHtAbGluayBjbHVzdGVyfSB3aXRoIHBvaW50cyBpbiB7QGxpbmsgc2VlZHN9LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIZWFwfSBzZWVkcyBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjbHVzdGVyIFxuICAgICAqL1xuICAgIF9leHBhbmRfY2x1c3RlcihzZWVkcywgY2x1c3Rlcikge1xuICAgICAgICBjb25zdCBvcmRlcmVkX2xpc3QgPSB0aGlzLl9vcmRlcmVkX2xpc3Q7XG4gICAgICAgIHdoaWxlICghc2VlZHMuZW1wdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHEgPSBzZWVkcy5wb3AoKS5lbGVtZW50O1xuICAgICAgICAgICAgcS5uZWlnaGJvcnMgPSB0aGlzLl9nZXRfbmVpZ2hib3JzKHEpO1xuICAgICAgICAgICAgcS5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2x1c3Rlci5wdXNoKHEuaW5kZXgpO1xuICAgICAgICAgICAgb3JkZXJlZF9saXN0LnB1c2gocSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29yZV9kaXN0YW5jZShxKSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUocSwgc2VlZHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZF9jbHVzdGVyKHNlZWRzLCBjbHVzdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgY2x1c3RlcnMuXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gQXJyYXkgb2YgY2x1c3RlcnMgd2l0aCB0aGUgaW5kaWNlcyBvZiB0aGUgcm93cyBpbiBnaXZlbiB7QGxpbmsgbWF0cml4fS5cbiAgICAgKi9cbiAgICBnZXRfY2x1c3RlcnMoKSB7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gW107XG4gICAgICAgIGNvbnN0IG91dGxpZXJzID0gW107XG4gICAgICAgIGNvbnN0IG1pbl9wb2ludHMgPSB0aGlzLl9taW5fcG9pbnRzO1xuICAgICAgICBmb3IgKGNvbnN0IGNsdXN0ZXIgb2YgdGhpcy5fY2x1c3RlcnMpIHtcbiAgICAgICAgICAgIGlmIChjbHVzdGVyLmxlbmd0aCA8IG1pbl9wb2ludHMpIHtcbiAgICAgICAgICAgICAgICBvdXRsaWVycy5wdXNoKC4uLmNsdXN0ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVycy5wdXNoKGNsdXN0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNsdXN0ZXJzLnB1c2gob3V0bGllcnMpO1xuICAgICAgICByZXR1cm4gY2x1c3RlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5LCB3aGVyZSB0aGUgaXRoIGVudHJ5IGRlZmluZXMgdGhlIGNsdXN0ZXIgYWZmaXJtYXRpb24gb2YgdGhlIGl0aCBwb2ludCBvZiB7QGxpbmsgbWF0cml4fS4gKC0xIHN0YW5kcyBmb3Igb3V0bGllcilcbiAgICAgKi9cbiAgICBnZXRfY2x1c3Rlcl9hZmZpcm1hdGlvbigpIHtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX21hdHJpeC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KE4pLmZpbGwoKTtcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSB0aGlzLmdldF9jbHVzdGVycygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGNsdXN0ZXJzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY2x1c3RlciA9IGNsdXN0ZXJzW2ldXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGNsdXN0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gKGkgPCBuIC0gMSkgPyBpIDogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5pbXBvcnQgeyBNRFMgfSBmcm9tIFwiLi9NRFMuanNcIjtcbmltcG9ydCB7IEtNZWRvaWRzIH0gZnJvbSBcIi4uL2NsdXN0ZXJpbmcvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBCYWxsVHJlZSB9IGZyb20gXCIuLi9rbm4vaW5kZXguanNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgTFNQXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgTFNQIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIExlYXN0IFNxdWFyZXMgUHJvamVjdGlvbi5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBMU1BcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLm5laWdoYm9ycyA9IE1hdGgubWF4KE1hdGguZmxvb3IoTiAvIDEwKSwgMildIC0gbnVtYmVyIG9mIG5laWdoYm9ycyB0byBjb25zaWRlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuY29udHJvbF9wb2ludHMgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KE4pKV0gLSBudW1iZXIgb2YgY29udHJvbHBvaW50c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5kID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtZXRlcnMubWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtMU1B9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL2RvY3VtZW50LzQzNzgzNzB9XG4gICAgICogQHRvZG8gYWNjZXB0IHByZWNvbXB1dGVkIGRpc3RhbmNlIG1hdHJpeC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKFgsIHsgbmVpZ2hib3JzOiB1bmRlZmluZWQsIGNvbnRyb2xfcG9pbnRzOiB1bmRlZmluZWQsIGQ6IDIsIG1ldHJpYzogZXVjbGlkZWFuLCBzZWVkOiAxMjEyIH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcIm5laWdoYm9yc1wiLCBNYXRoLm1pbihwYXJhbWV0ZXJzLm5laWdoYm9ycyA/PyBNYXRoLm1heChNYXRoLmZsb29yKHRoaXMuX04gLyAxMCksIDIpLCB0aGlzLl9OIC0gMSkpO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcImNvbnRyb2xfcG9pbnRzXCIsIE1hdGgubWluKHBhcmFtZXRlcnMuY29udHJvbF9wb2ludHMgPz8gTWF0aC5jZWlsKE1hdGguc3FydCh0aGlzLl9OKSksIHRoaXMuX04gLSAxKSk7XG4gICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtEUn0gRFIgLSBtZXRob2QgdXNlZCBmb3IgcG9zaXRpb24gY29udHJvbCBwb2ludHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IERSX3BhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIGZvciB0aGUgRFIgbWV0aG9kIHdoaWNoIHByb2plY3RzIHRoZSBjb250cm9sIHBvaW50c1xuICAgICAqIEByZXR1cm5zIHtMU1B9XG4gICAgICovXG4gICAgaW5pdChEUiA9IE1EUywgRFJfcGFyYW1ldGVycyA9IHt9LCBLTk4gPSBCYWxsVHJlZSkge1xuICAgICAgICBpZiAodGhpcy5faXNfaW5pdGlhbGl6ZWQpIHJldHVybiB0aGlzO1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgSyA9IHRoaXMucGFyYW1ldGVyKFwibmVpZ2hib3JzXCIpO1xuICAgICAgICBjb25zdCBkID0gdGhpcy5wYXJhbWV0ZXIoXCJkXCIpO1xuICAgICAgICBjb25zdCBzZWVkID0gdGhpcy5wYXJhbWV0ZXIoXCJzZWVkXCIpO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLnBhcmFtZXRlcihcIm1ldHJpY1wiKTtcbiAgICAgICAgRFJfcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe2QsIG1ldHJpYywgc2VlZCB9LCBEUl9wYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgbmMgPSB0aGlzLnBhcmFtZXRlcihcImNvbnRyb2xfcG9pbnRzXCIpO1xuICAgICAgICBjb25zdCBjb250cm9sX3BvaW50cyA9IG5ldyBLTWVkb2lkcyhYLCBuYywgbnVsbCwgbWV0cmljKS5nZXRfY2x1c3RlcnMoKS5tZWRvaWRzO1xuICAgICAgICBjb25zdCBDID0gbmV3IE1hdHJpeChuYywgTiwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgY29udHJvbF9wb2ludHMuZm9yRWFjaCgoY19pLCBpKSA9PiB7XG4gICAgICAgICAgICBDLnNldF9lbnRyeShpLCBjX2ksIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgWV9DID0gbmV3IERSKE1hdHJpeC5mcm9tKGNvbnRyb2xfcG9pbnRzLm1hcCgoY19pKSA9PiBYLnJvdyhjX2kpKSksIERSX3BhcmFtZXRlcnMpLnRyYW5zZm9ybSgpO1xuXG4gICAgICAgIGNvbnN0IFhBID0gWC50bzJkQXJyYXk7XG4gICAgICAgIGNvbnN0IGtubiA9IG5ldyBLTk4oWEEsIG1ldHJpYyk7XG4gICAgICAgIGNvbnN0IEwgPSBuZXcgTWF0cml4KE4sIE4sIFwiSVwiKTtcbiAgICAgICAgY29uc3QgYWxwaGEgPSAtMSAvIEs7XG4gICAgICAgIFhBLmZvckVhY2goKHhfaSwgaSkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGluZGV4OiBqIH0gb2Yga25uLnNlYXJjaCh4X2ksIEspLml0ZXJhdGUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBMLnNldF9lbnRyeShpLCBqLCBhbHBoYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBBID0gTC5jb25jYXQoQywgXCJ2ZXJ0aWNhbFwiKTtcblxuICAgICAgICBjb25zdCB6ID0gbmV3IE1hdHJpeChOLCBkLCBcInplcm9zXCIpO1xuICAgICAgICBjb25zdCBiID0gei5jb25jYXQoWV9DLCBcInZlcnRpY2FsXCIpO1xuXG4gICAgICAgIHRoaXMuX0EgPSBBO1xuICAgICAgICB0aGlzLl9iID0gYjtcbiAgICAgICAgdGhpcy5faXNfaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9BO1xuICAgICAgICBjb25zdCBBVCA9IEEuVDtcbiAgICAgICAgY29uc3QgYiA9IHRoaXMuX2I7XG4gICAgICAgIGNvbnN0IEFUQSA9IEFULmRvdChBKTtcbiAgICAgICAgY29uc3QgQVRiID0gQVQuZG90KGIpO1xuICAgICAgICB0aGlzLlkgPSBNYXRyaXguc29sdmVfQ0coQVRBLCBBVGIsIHRoaXMuX3JhbmRvbWl6ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5pbXBvcnQgeyBEaXNqb2ludFNldCB9IGZyb20gXCIuLi9kYXRhc3RydWN0dXJlL2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgVG9wb01hcFxuICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBUb3BvTWFwIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIFRvcG9NYXA6IEEgMC1kaW1lbnNpb25hbCBIb21vbG9neSBQcmVzZXJ2aW5nIFByb2plY3Rpb24gb2YgSGlnaC1EaW1lbnNpb25hbCBEYXRhLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIFRvcG9NYXBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtZXRlcnMubWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtUb3BvTWFwfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXJ4aXYub3JnL3BkZi8yMDA5LjAxNTEyLnBkZn1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKFgsIHsgbWV0cmljOiBldWNsaWRlYW4sIHNlZWQ6IDEyMTIgfSwgcGFyYW1ldGVycyk7XG4gICAgICAgIFt0aGlzLl9OLCB0aGlzLl9EXSA9IHRoaXMuWC5zaGFwZTtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VfbWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLl9OLCB0aGlzLl9OLCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX2xhenlfZGlzdGFuY2VfbWF0cml4KGksIGosIG1ldHJpYykge1xuICAgICAgICBjb25zdCBEID0gdGhpcy5fZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBEX2lqID0gRC5lbnRyeShpLCBqKTtcbiAgICAgICAgaWYgKERfaWogPT09IDApIHtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gbWV0cmljKFgucm93KGkpLCBYLnJvdyhqKSk7XG4gICAgICAgICAgICBELnNldF9lbnRyeShpLCBqLCBkaXN0KTtcbiAgICAgICAgICAgIEQuc2V0X2VudHJ5KGosIGksIGRpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERfaWo7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gc3Bhbm5pbmcgdHJlZSwgdXNpbmcgYSBnaXZlbiBtZXRyaWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldHJpY1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tydXNrYWwlMjdzX2FsZ29yaXRobX1cbiAgICAgKi9cbiAgICBfbWFrZV9taW5pbXVtX3NwYW5uaW5nX3RyZWUobWV0cmljID0gZXVjbGlkZWFuKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBYID0gWy4uLnRoaXMuWF07XG5cbiAgICAgICAgbGV0IGRpc2pvaW50X3NldCA9IG5ldyBEaXNqb2ludFNldChYKTtcbiAgICAgICAgY29uc3QgRiA9IFtdO1xuICAgICAgICBsZXQgRSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgRS5wdXNoKFtpLCBqLCB0aGlzLl9fbGF6eV9kaXN0YW5jZV9tYXRyaXgoaSwgaiwgbWV0cmljKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEUgPSBFLnNvcnQoKGEsIGIpID0+IGFbMl0gLSBiWzJdKTtcblxuICAgICAgICBmb3IgKGNvbnN0IFt1LCB2LCB3XSBvZiBFKSB7XG4gICAgICAgICAgICBjb25zdCBzZXRfdSA9IGRpc2pvaW50X3NldC5maW5kKFhbdV0pO1xuICAgICAgICAgICAgY29uc3Qgc2V0X3YgPSBkaXNqb2ludF9zZXQuZmluZChYW3ZdKTtcbiAgICAgICAgICAgIGlmIChzZXRfdSAhPT0gc2V0X3YpIHtcbiAgICAgICAgICAgICAgICBGLnB1c2goW3UsIHYsIHddKTtcbiAgICAgICAgICAgICAgICBkaXNqb2ludF9zZXQudW5pb24oc2V0X3UsIHNldF92KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBGLnNvcnQoKGEsIGIpID0+IGFbMl0gLSBiWzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplcyBUb3BvTWFwLiBTZXRzIGFsbCBwcm9qY3RlZCBwb2ludHMgdG8gemVybywgYW5kIGNvbXB1dGVzIGEgbWluaW11bSBzcGFubmluZyB0cmVlLlxuICAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0cmljfSA9IHRoaXMuX3BhcmFtZXRlcnNcbiAgICAgICAgdGhpcy5ZID0gbmV3IE1hdHJpeCh0aGlzLl9OLCAyLCAwKTtcbiAgICAgICAgdGhpcy5fRW1zdCA9IHRoaXMuX21ha2VfbWluaW11bV9zcGFubmluZ190cmVlKG1ldHJpYyk7XG4gICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIFBvaW50IEMgaXMgbGVmdCBvZiBsaW5lIEFCLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gUG9pbnRBIC0gUG9pbnQgQSBvZiBsaW5lIEFCXG4gICAgICogQHBhcmFtIHtBcnJheX0gUG9pbnRCIC0gUG9pbnQgQiBvZiBsaW5lIEFCXG4gICAgICogQHBhcmFtIHtBcnJheX0gUG9pbnRDIC0gUG9pbnQgQ1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIF9faHVsbF9jcm9zcyhbYXgsIGF5XSwgW2J4LCBieV0sIFtzeCwgc3ldKSB7XG4gICAgICAgIHJldHVybiAoYnggLSBheCkgKiAoc3kgLSBheSkgLSAoYnkgLSBheSkgKiAoc3ggLSBheCkgPD0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgY29udmV4IGh1bGwgb2YgdGhlIHNldCBvZiBQb2ludHMgU1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gUyAtIFNldCBvZiBQb2ludHMuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQWxnb3JpdGhtX0ltcGxlbWVudGF0aW9uL0dlb21ldHJ5L0NvbnZleF9odWxsL01vbm90b25lX2NoYWluI0phdmFTY3JpcHR9XG4gICAgICogQHJldHVybnMge0FycmF5fSBjb252ZXggaHVsbCBvZiBTLiBTdGFydHMgYXQgdGhlIGJvdHRvbS1tb3N0IHBvaW50IGFuZCBjb250aW51ZXMgY291bnRlci1jbG9ja3dpc2UuXG4gICAgICovXG4gICAgX19odWxsKFMpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gUy5zb3J0KChbeDEsIHkxXSwgW3gyLCB5Ml0pID0+IHkxIC0geTIgfHwgeDEgLSB4Mik7XG4gICAgICAgIGNvbnN0IE4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAoTiA8PSAyKSByZXR1cm4gcG9pbnRzO1xuXG4gICAgICAgIGNvbnN0IGxvd2VyID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICB3aGlsZSAobG93ZXIubGVuZ3RoID49IDIgJiYgdGhpcy5fX2h1bGxfY3Jvc3MobG93ZXJbbG93ZXIubGVuZ3RoIC0gMl0sIGxvd2VyW2xvd2VyLmxlbmd0aCAtIDFdLCBwb2ludHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgbG93ZXIucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb3dlci5wdXNoKHBvaW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBwZXIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IE4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgd2hpbGUgKHVwcGVyLmxlbmd0aCA+PSAyICYmIHRoaXMuX19odWxsX2Nyb3NzKHVwcGVyW3VwcGVyLmxlbmd0aCAtIDJdLCB1cHBlclt1cHBlci5sZW5ndGggLSAxXSwgcG9pbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgIHVwcGVyLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBwZXIucHVzaChwb2ludHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHVwcGVyLnBvcCgpO1xuICAgICAgICBsb3dlci5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyLmNvbmNhdCh1cHBlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGFuZ2xlIHRvIHJvdGF0ZSBQb2ludCBBIGFuZCBCIHRvIGxpZSBvbiBhIGxpbmUgcGFyYWxsZWwgdG8gdGhlIHgtYXhpcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFBvaW50QVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFBvaW50QlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNpbnVzLSBhbmQgY29zaW51cy12YWx1ZXMgZm9yIGEgcm90YXRpb24uXG4gICAgICovXG4gICAgX19maW5kQW5nbGUoW3AxeCwgcDF5XSwgW3AyeCwgcDJ5XSkge1xuICAgICAgICBjb25zdCBuID0gZXVjbGlkZWFuKFtwMXgsIHAxeV0sIFtwMngsIHAyeV0pO1xuICAgICAgICBpZiAobiA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2luOiAwLFxuICAgICAgICAgICAgICAgIGNvczogMSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZlYyA9IFsocDJ4IC0gcDF4KSAvIG4sIChwMnkgLSBwMXkpIC8gbl07XG4gICAgICAgIGNvbnN0IGNvcyA9IHZlY1swXTtcbiAgICAgICAgbGV0IHNpbiA9IE1hdGguc3FydCgxIC0gY29zICogY29zKTtcbiAgICAgICAgc2luID0gdmVjWzFdID49IDAgPyAtc2luIDogc2luO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2luOiBzaW4sXG4gICAgICAgICAgICBjb3M6IGNvcyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGh1bGxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwXG4gICAgICogQHBhcmFtIHtCb29sfSB0b3BFZGdlXG4gICAgICovXG4gICAgX19hbGlnbl9odWxsKGh1bGwsIHAsIHRvcEVkZ2UpIHtcbiAgICAgICAgbGV0IHYgPSAtMTtcbiAgICAgICAgbGV0IGQyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGh1bGwubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBldWNsaWRlYW4oaHVsbFtpXSwgcCk7XG4gICAgICAgICAgICBpZiAodiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkMiA9IGQ7XG4gICAgICAgICAgICAgICAgdiA9IGk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkMiA+IGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZDIgPSBkO1xuICAgICAgICAgICAgICAgICAgICB2ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdjE7XG4gICAgICAgIGxldCB2MjtcbiAgICAgICAgaWYgKHRvcEVkZ2UpIHtcbiAgICAgICAgICAgIHYxID0gaHVsbFt2XTtcbiAgICAgICAgICAgIHYyID0gaHVsbFsodiArIDEpICUgaHVsbC5sZW5ndGhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHYgPT0gMCkgdiA9IGh1bGwubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHYxID0gaHVsbFt2XTtcbiAgICAgICAgICAgIHYyID0gaHVsbFsodiAtIDEpICUgaHVsbC5sZW5ndGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHJhbnNmb3JtYXRpb24gPSB7XG4gICAgICAgICAgICB0eDogLWh1bGxbdl1bMF0sXG4gICAgICAgICAgICB0eTogLWh1bGxbdl1bMV0sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGh1bGwubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2luLCBjb3MgfSA9IHRoaXMuX19maW5kQW5nbGUodjEsIHYyKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uLnNpbiA9IHNpbjtcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uLmNvcyA9IGNvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uLnNpbiA9IDA7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbi5jb3MgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gUG9pbnQgLSBUaGUgcG9pbnQgd2hpY2ggc2hvdWxkIGdldCB0cmFuc2Zvcm1lZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gVHJhbnNmb3JtYXRpb24gLSBjb250YWlucyB0aGUgdmFsdWVzIGZvciB0cmFuc2xhdGlvbiBhbmQgcm90YXRpb24uXG4gICAgICovXG4gICAgX190cmFuc2Zvcm0oW3B4LCBweV0sIHsgdHgsIHR5LCBzaW4sIGNvcyB9KSB7XG4gICAgICAgIGxldCB4ID0gcHggKyB0eDtcbiAgICAgICAgbGV0IHkgPSBweSArIHR5O1xuICAgICAgICBsZXQgeHggPSB4ICogY29zIC0geSAqIHNpbjtcbiAgICAgICAgbGV0IHl5ID0geCAqIHNpbiArIHkgKiBjb3M7XG4gICAgICAgIHJldHVybiBbeHgsIHl5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB7QGxpbmsgX190cmFuc2Zvcm19IGZvciBlYWNoIHBvaW50IGluIFNldCBDXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBDIC0gU2V0IG9mIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdCAtIFRyYW5zZm9ybSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlPZmZzZXQgLSB2YWx1ZSB0byBvZmZzZXQgc2V0IEMuXG4gICAgICovXG4gICAgX190cmFuc2Zvcm1fY29tcG9uZW50KEMsIHQsIHlPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgTiA9IEMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYyA9IENbaV07XG4gICAgICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuX190cmFuc2Zvcm0oYywgdCk7XG4gICAgICAgICAgICBjWzBdID0gY3g7XG4gICAgICAgICAgICBjWzFdID0gY3kgKyB5T2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB1IC0gcG9pbnQgdVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHYgLSBwb2ludCB2XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHcgLSBlZGdlIHdlaWdodCB3XG4gICAgICovXG4gICAgX19hbGlnbl9jb21wb25lbnRzKHUsIHYsIHcpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzX3UgPSBbLi4udS5fX2Rpc2pvaW50X3NldC5jaGlsZHJlbl07XG4gICAgICAgIGNvbnN0IHBvaW50c192ID0gWy4uLnYuX19kaXNqb2ludF9zZXQuY2hpbGRyZW5dO1xuXG4gICAgICAgIGNvbnN0IGh1bGxfdSA9IHRoaXMuX19odWxsKHBvaW50c191KTtcbiAgICAgICAgY29uc3QgaHVsbF92ID0gdGhpcy5fX2h1bGwocG9pbnRzX3YpO1xuXG4gICAgICAgIGNvbnN0IHRfdSA9IHRoaXMuX19hbGlnbl9odWxsKGh1bGxfdSwgdSwgZmFsc2UpO1xuICAgICAgICBjb25zdCB0X3YgPSB0aGlzLl9fYWxpZ25faHVsbChodWxsX3YsIHYsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX190cmFuc2Zvcm1fY29tcG9uZW50KHBvaW50c191LCB0X3UsIDApO1xuICAgICAgICB0aGlzLl9fdHJhbnNmb3JtX2NvbXBvbmVudChwb2ludHNfdiwgdF92LCB3KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuc2lvbmFsaXR5IDIuXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzX2luaXRpYWxpemVkKSB0aGlzLmluaXQoKTtcbiAgICAgICAgY29uc3QgRW1zdCA9IHRoaXMuX0Vtc3Q7XG4gICAgICAgIGNvbnN0IFkgPSB0aGlzLlkudG8yZEFycmF5O1xuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gbmV3IERpc2pvaW50U2V0KFxuICAgICAgICAgICAgWS5tYXAoKHksIGkpID0+IHtcbiAgICAgICAgICAgICAgICB5LmkgPSBpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGNvbnN0IFt1LCB2LCB3XSBvZiBFbXN0KSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRfdSA9IGNvbXBvbmVudHMuZmluZChZW3VdKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudF92ID0gY29tcG9uZW50cy5maW5kKFlbdl0pO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudF91ID09PSBjb21wb25lbnRfdikgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLl9fYWxpZ25fY29tcG9uZW50cyhjb21wb25lbnRfdSwgY29tcG9uZW50X3YsIHcpO1xuICAgICAgICAgICAgY29tcG9uZW50cy51bmlvbihjb21wb25lbnRfdSwgY29tcG9uZW50X3YpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgKmdlbmVyYXRvcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc19pbml0aWFsaXplZCkgdGhpcy5pbml0KCk7XG4gICAgICAgIGNvbnN0IEVtc3QgPSB0aGlzLl9FbXN0O1xuICAgICAgICBjb25zdCBZID0gdGhpcy5ZLnRvMmRBcnJheTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IG5ldyBEaXNqb2ludFNldChcbiAgICAgICAgICAgIFkubWFwKCh5LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgeS5pID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChjb25zdCBbdSwgdiwgd10gb2YgRW1zdCkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50X3UgPSBjb21wb25lbnRzLmZpbmQoWVt1XSk7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRfdiA9IGNvbXBvbmVudHMuZmluZChZW3ZdKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRfdSA9PT0gY29tcG9uZW50X3YpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5fX2FsaWduX2NvbXBvbmVudHMoY29tcG9uZW50X3UsIGNvbXBvbmVudF92LCB3KTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMudW5pb24oY29tcG9uZW50X3UsIGNvbXBvbmVudF92KTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucHJvamVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5pbXBvcnQgeyBQQ0EsIE1EUyB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkaXN0YW5jZV9tYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgU0FNTU9OXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgU0FNTU9OIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIFNBTU1PTidzIE1hcHBpbmdcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBTQU1NT05cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmQgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFwicHJlY29tcHV0ZWRcIn0gW3BhcmFtZXRlcnMubWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7XCJQQ0FcInxcIk1EU1wifFwicmFuZG9tXCJ9IFtwYXJhbWV0ZXJzLmluaXQgPSBcInJhbmRvbVwiXSAtIEVpdGhlciBcIlBDQVwiIG9yIFwiTURTXCIsIHdpdGggd2hpY2ggU0FNTU9OIGluaXRpYWxpYXRlcyB0aGUgcHJvamVjdGlvbi4gV2l0aCBcInJhbmRvbVwiIGEgcmFuZG9tIG1hdHJpeCBnZXRzIHVzZWQgYXMgc3RhcnRpbmcgcG9pbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzLmluaXRfcGFyYW1ldGVyc10gLSBQYXJhbWV0ZXJzIGZvciB0aGUge0BsaW5rIGluaXR9LURSIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuc2VlZCA9IDEyMTJdIC0gdGhlIHNlZWQgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7U0FNTU9OfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXJ4aXYub3JnL3BkZi8yMDA5LjAxNTEyLnBkZn1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKFgsIHsgbWFnaWM6IDAuMSwgZDogMiwgbWV0cmljOiBldWNsaWRlYW4sIHNlZWQ6IDEyMTIsIGluaXRfRFI6IFwicmFuZG9tXCIsIGluaXRfcGFyYW1ldGVyczoge30gfSwgcGFyYW1ldGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemVzIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgeyBkLCBtZXRyaWMsIGluaXRfRFI6IGluaXRfRFIsIGluaXRfcGFyYW1ldGVyczogRFJfcGFyYW1ldGVycyB9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgaWYgKGluaXRfRFIgPT09IFwicmFuZG9tXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbWl6ZXIgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICAgICAgdGhpcy5ZID0gbmV3IE1hdHJpeChOLCBkLCAoKSA9PiByYW5kb21pemVyLnJhbmRvbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoW1wiUENBXCIsIFwiTURTXCJdLmluY2x1ZGVzKGluaXRfRFIpKSB7XG4gICAgICAgICAgICB0aGlzLlkgPSBNYXRyaXguZnJvbShpbml0X0RSID09IFwiUENBXCIgPyBQQ0EudHJhbnNmb3JtKHRoaXMuWCwgRFJfcGFyYW1ldGVycykgOiBNRFMudHJhbnNmb3JtKHRoaXMuWCwgRFJfcGFyYW1ldGVycykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0X0RSIG5lZWRzIHRvIGJlIGVpdGhlciBcInJhbmRvbVwiIG9yIGEgRFIgbWV0aG9kIScpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXN0YW5jZV9tYXRyaXggPSBtZXRyaWMgPT0gXCJwcmVjb21wdXRlZFwiID8gTWF0cml4LmZyb20odGhpcy5YKSA6IGRpc3RhbmNlX21hdHJpeCh0aGlzLlgsIG1ldHJpYyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0ZGF0YSB7QGxpbmsgWH0gdG8gZGltZW5pb25hbGl0eSAyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4X2l0ZXI9MjAwXSAtIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbiBzdGVwcy5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fEFycmF5fSAtIFRoZSBwcm9qZWN0aW9uIG9mIHtAbGluayBYfS5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0obWF4X2l0ZXIgPSAyMDApIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc19pbml0aWFsaXplZCkgdGhpcy5pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF4X2l0ZXI7ICsraikge1xuICAgICAgICAgICAgdGhpcy5fc3RlcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXRkYXRhIHtAbGluayBYfSB0byBkaW1lbmlvbmFsaXR5IDIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhfaXRlcj0yMDBdIC0gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9uIHN0ZXBzLlxuICAgICAqIEByZXR1cm5zIHtHZW5lcmF0b3J9IC0gQSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIGludGVybWVkaWF0ZSBzdGVwcyBvZiB0aGUgcHJvamVjdGlvbiBvZiB7QGxpbmsgWH0uXG4gICAgICovXG4gICAgKmdlbmVyYXRvcihtYXhfaXRlciA9IDIwMCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzX2luaXRpYWxpemVkKSB0aGlzLmluaXQoKTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1heF9pdGVyOyArK2opIHtcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucHJvamVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgX3N0ZXAoKSB7XG4gICAgICAgIGNvbnN0IE1BR0lDID0gdGhpcy5wYXJhbWV0ZXIoXCJtYWdpY1wiKTtcbiAgICAgICAgY29uc3QgRCA9IHRoaXMuZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICBjb25zdCBOID0gdGhpcy5YLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCB7IGQsIG1ldHJpYyB9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgbGV0IFkgPSB0aGlzLlk7XG5cbiAgICAgICAgbGV0IEcgPSBuZXcgTWF0cml4KE4sIGQsIDApO1xuXG4gICAgICAgIGxldCBzdW0gPSBuZXcgRmxvYXQ2NEFycmF5KGQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgbGV0IGUxID0gbmV3IEZsb2F0NjRBcnJheShkKTtcbiAgICAgICAgICAgIGxldCBlMiA9IG5ldyBGbG9hdDY0QXJyYXkoZCk7XG4gICAgICAgICAgICBjb25zdCBZaSA9IFkucm93KGkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaikgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgWWogPSBZLnJvdyhqKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IG5ldyBGbG9hdDY0QXJyYXkoZCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFba10gPSBZaVtrXSAtIFlqW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkWSA9IG1ldHJpYyhZaSwgWWopO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRYID0gRC5lbnRyeShpLCBqKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkcSA9IGRYIC0gZFk7XG4gICAgICAgICAgICAgICAgY29uc3QgZHIgPSBNYXRoLm1heChkWCAqIGRZLCAxZS0yKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGQ7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBlMVtrXSArPSAoZGVsdGFba10gKiBkcSkgLyBkcjtcbiAgICAgICAgICAgICAgICAgICAgZTJba10gKz0gKGRxIC0gKE1hdGgucG93KGRlbHRhW2tdLCAyKSAqICgxICsgZHEgLyBkWSkpIC8gZFkpIC8gZHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkOyArK2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBZLmVudHJ5KGksIGspICsgKChNQUdJQyAqIGUxW2tdKSAvIE1hdGguYWJzKGUyW2tdKSB8fCAwKTtcbiAgICAgICAgICAgICAgICBHLnNldF9lbnRyeShpLCBrLCB2YWwpO1xuICAgICAgICAgICAgICAgIHN1bVtrXSArPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkOyArK2spIHtcbiAgICAgICAgICAgIHN1bVtrXSAvPSBOO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZDsgKytrKSB7XG4gICAgICAgICAgICAgICAgWS5zZXRfZW50cnkoaSwgaywgRy5lbnRyeShpLCBrKSAtIHN1bVtrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbImEiLCJiIiwiTWF0aCIsInNxcnQiLCJldWNsaWRlYW5fc3F1YXJlZCIsInN1bW1hbmRzIiwieSIsInQiLCJuIiwibGVuZ3RoIiwic3VtIiwiY29tcGVuc2F0aW9uIiwiaSIsInN1bW1hbmQiLCJhYnMiLCJzIiwiQXJyYXkiLCJ4IiwibmV1bWFpcl9zdW0iLCJzdW1fYSIsInN1bV9iIiwiYWNvcyIsInJlcyIsInB1c2giLCJtYXgiLCJudW1fbm9uX3plcm8iLCJudW1fZXF1YWwiLCJkaXNhZ3JlZSIsIm51bV9ub3RfZXF1YWwiLCJudW1fdHJ1ZV90cnVlIiwibnVtX3RydWVfZmFsc2UiLCJudW1fZmFsc2VfdHJ1ZSIsIkEiLCJrIiwibWV0cmljIiwiZXVjbGlkZWFuIiwicm93cyIsInNoYXBlIiwiRCIsImRpc3RhbmNlX21hdHJpeCIsIm5OIiwicm93IiwiZnJvbSIsIm1hcCIsImRpc3RhbmNlIiwiY29sIiwiaiIsInNvcnQiLCJzbGljZSIsIk1hdHJpeCIsIkFfaSIsImRpc3QiLCJzZXRfZW50cnkiLCJzdGFydCIsImVuZCIsIm51bWJlciIsInJvdW5kIiwicmVzdWx0IiwidiIsInZlY3RvciIsImNvbHMiLCJFcnJvciIsIkZsb2F0NjRBcnJheSIsInZfbm9ybSIsIm5vcm0iLCJ2YWx1ZSIsIlEiLCJSIiwicSIsInFfZG90X3YiLCJxXyIsInZfIiwiY2xvbmUiLCJ4X25vcm0iLCJ4MCIsImVudHJ5IiwicmhvIiwic2lnbiIsInUxIiwidSIsImRpdmlkZSIsImJldGEiLCJ1X291dGVyX3UiLCJvdXRlciIsIlJfYmxvY2siLCJnZXRfYmxvY2siLCJuZXdfUiIsInN1YiIsImRvdCIsIm11bHQiLCJRX2Jsb2NrIiwibmV3X1EiLCJzZXRfYmxvY2siLCJzZWVkIiwibWF4X2l0ZXJhdGlvbnMiLCJxciIsInFyX2dyYW1zY2htaWR0IiwidG9sIiwicmFuZG9taXplciIsIlJhbmRvbWl6ZXIiLCJyYW5kb20iLCJvbGRRIiwiUVIiLCJ2YWx1ZXMiLCJlaWdlbnZhbHVlcyIsImRpYWciLCJlaWdlbnZlY3RvcnMiLCJ0cmFuc3Bvc2UiLCJ0bzJkQXJyYXkiLCJOIiwiY29uc3RydWN0b3IiLCJ0aGlzIiwiX3Jvd3MiLCJfY29scyIsIl9kYXRhIiwic3RhdGljIiwidHlwZSIsImlzQXJyYXkiLCJtIiwiXyIsImRhdGEiLCJzdWJhcnJheSIsIml0ZXJhdGVfcm93cyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwic2V0X3JvdyIsIm9mZnNldCIsInJlc3VsdF9jb2wiLCJUIiwiaW52ZXJzZSIsIkIiLCJoIiwiaV9tYXgiLCJtYXhfdmFsIiwiSW5maW5pdHkiLCJ2YWwiLCJoX3ZhbCIsImlfdmFsIiwiZiIsIkJfcm93X3JvdyIsIkJfaV9qIiwiam9pbiIsIkkiLCJCX2kiLCJDIiwiZSIsImwiLCJjb25jYXQiLCJyb3dzX0EiLCJjb2xzX0EiLCJyb3dzX0IiLCJjb2xzX0IiLCJYIiwib2Zmc2V0X3JvdyIsIm9mZnNldF9jb2wiLCJzdGFydF9yb3ciLCJzdGFydF9jb2wiLCJlbmRfcm93IiwiZW5kX2NvbCIsIm5ld19yb3ciLCJuZXdfY29sIiwiZ2F0aGVyIiwicm93X2luZGljZXMiLCJjb2xfaW5kaWNlcyIsInJvd19pbmRleCIsImNvbF9pbmRleCIsIl9hcHBseV9hcnJheSIsIl9hcHBseV9yb3d3aXNlX2FycmF5IiwiX2FwcGx5X2NvbHdpc2VfYXJyYXkiLCJfYXBwbHkiLCJ2YWx1ZV9yb3dzIiwidmFsdWVfY29scyIsImFkZCIsImFzQXJyYXkiLCJtaW5fcm93X2NvbCIsIm1pbiIsIm1lYW4iLCJtZWFuUm93cyIsIm1lYW5Db2xzIiwiYl9pIiwiciIsImQiLCJ6IiwiYWxwaGEiLCJyX25leHQiLCJMIiwiVSIsIkxVIiwiTF9kaWFnIiwiVV9kaWFnIiwiZGV0IiwiTSIsIk1UIiwiTXRNIiwiTU10IiwiViIsIlNpZ21hIiwic2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uIiwic2lnbWEiLCJfc2VlZCIsIl9OIiwiX00iLCJfTUFUUklYX0EiLCJfVVBQRVJfTUFTSyIsIl9MT1dFUl9NQVNLIiwiX210IiwiX210aSIsIkRhdGUiLCJnZXRUaW1lIiwibXQiLCJtdGkiLCJyYW5kb21faW50IiwibWFnMDEiLCJrayIsIk5fTSIsIk1fTiIsImNob2ljZSIsInNhbXBsZSIsImluZGV4X2xpc3QiLCJsaW5zcGFjZSIsInJhbmRvbV9pbmRleCIsInNwbGljZSIsInVuZGVmaW5lZCIsIkhlYXAiLCJlbGVtZW50cyIsImFjY2Vzc29yIiwiY29tcGFyYXRvciIsImhlYXBpZnkiLCJfYWNjZXNzb3IiLCJfY29udGFpbmVyIiwiX2NvbXBhcmF0b3IiLCJoZWFwIiwiY29udGFpbmVyIiwiZWxlbWVudCIsImZsb29yIiwiX2hlYXBpZnlfZG93biIsIl9zd2FwIiwiaW5kZXhfYSIsImluZGV4X2IiLCJfaGVhcGlmeV91cCIsImluZGV4IiwicGFyZW50SW5kZXgiLCJub2RlIiwic3RhcnRfaW5kZXgiLCJsZWZ0IiwicmlnaHQiLCJwb3AiLCJpdGVtIiwiZmlyc3QiLCJpdGVyYXRlIiwidG9BcnJheSIsInJhd19kYXRhIiwiZW1wdHkiLCJEaXNqb2ludFNldCIsIl9saXN0IiwiU2V0IiwibWFrZV9zZXQiLCJsaXN0IiwiaGFzIiwiX19kaXNqb2ludF9zZXQiLCJwYXJlbnQiLCJjaGlsZHJlbiIsInNpemUiLCJmaW5kIiwidW5pb24iLCJub2RlX3giLCJub2RlX3kiLCJmb3JFYWNoIiwiQmFsbFRyZWUiLCJfTm9kZSIsInBpdm90IiwiY2hpbGQxIiwiY2hpbGQyIiwicmFkaXVzIiwiX0xlYWYiLCJwb2ludHMiLCJfbWV0cmljIiwiX3Jvb3QiLCJfY29uc3RydWN0IiwiYyIsIl9ncmVhdGVzdF9zcHJlYWQiLCJzb3J0ZWRfZWxlbWVudHMiLCJwX2luZGV4IiwicCIsInNwcmVhZCIsInJlZHVjZSIsImFjYyIsImN1cnJlbnQiLCJzZWFyY2giLCJfc2VhcmNoIiwiS05OIiwiX2VsZW1lbnRzIiwiX0QiLCJkaXN0YW5jZXMiLCJIIiwibmVhcmVzdF9lbGVtZW50X2luZGV4IiwibmVhcmVzdF9kaXN0IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiRFIiLCJkZWZhdWx0X3BhcmFtZXRlcnMiLCJwYXJhbWV0ZXJzIiwiX3BhcmFtZXRlcnMiLCJPYmplY3QiLCJhc3NpZ24iLCJzZWFsIiwiX3R5cGUiLCJfcmFuZG9taXplciIsIl9pc19pbml0aWFsaXplZCIsInBhcmFtZXRlciIsIm5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsInBhcmEiLCJ0cmFuc2Zvcm0iLCJjaGVja19pbml0IiwicHJvamVjdGlvbiIsImdlbmVyYXRvciIsImluaXQiLCJZIiwiYXN5bmMiLCJhcmdzIiwiUENBIiwic3VwZXIiLCJlaWdfYXJncyIsInByaW5jaXBhbF9jb21wb25lbnRzIiwibWVhbnMiLCJYX2NlbnQiLCJNRFMiLCJhaV8iLCJhX2oiLCJhX18iLCJfZF9YIiwic3RyZXNzIiwiZF9YIiwiZF9ZIiwidG9wX3N1bSIsImJvdHRvbV9zdW0iLCJwb3ciLCJJU09NQVAiLCJuZWlnaGJvcnMiLCJrTmVhcmVzdE5laWdoYm9ycyIsIkciLCJvdGhlciIsIkZBU1RNQVAiLCJfY2hvb3NlX2Rpc3RhbnRfb2JqZWN0cyIsImFfaW5kZXgiLCJiX2luZGV4IiwibWF4X2Rpc3QiLCJkX2FpIiwiZF9iaSIsIl9jb2wiLCJvbGRfZGlzdCIsImRfYWIiLCJ5X2kiLCJMREEiLCJsYWJlbHMiLCJ1bmlxdWVfbGFiZWxzIiwibGFiZWxfaWQiLCJjb3VudCIsImlkIiwiWF9tZWFuIiwiVl9tZWFuIiwibGFiZWwiLCJ2X21lYW4iLCJTX2IiLCJTX3ciLCJyb3dfdiIsIkxMRSIsImtfbmVhcmVzdF9uZWlnaGJvcnMiLCJPIiwiVyIsIm5OX3JvdyIsIloiLCJDX3RyYWNlIiwidyIsInNvbHZlX0NHIiwiSVciLCJMVFNBIiwiSV9pIiwiWF9pIiwiZyIsIkdfaV90IiwiV19pIiwiVFNORSIsInBlcnBsZXhpdHkiLCJlcHNpbG9uIiwiX2l0ZXIiLCJIdGFyZ2V0IiwibG9nIiwiRGVsdGEiLCJkcnVpZCIsIlAiLCJfeXN0ZXAiLCJfZ2FpbnMiLCJwcm93IiwiYmV0YW1pbiIsImJldGFtYXgiLCJkb25lIiwibnVtIiwicHN1bSIsInBqIiwiZXhwIiwiSGhlcmUiLCJQb3V0IiwiTjIiLCJfUCIsIml0ZXJhdGlvbnMiLCJuZXh0IiwiaXRlciIsInlzdGVwIiwiZ2FpbnMiLCJkaW0iLCJwbXVsIiwiUXUiLCJxc3VtIiwiZHN1bSIsImRoZXJlIiwicXUiLCJncmFkIiwicHJlbXVsdCIsInltZWFuIiwiZ2lkIiwic2lkIiwiZ2FpbmlkIiwibmV3Z2FpbiIsIm5ld3NpZCIsIm1heF9pdGVyIiwicGZ4IiwiZngiLCJjb252ZXJnZW5jZSIsImZ4aSIsImR4IiwiVU1BUCIsIm5fbmVpZ2hib3JzIiwibG9jYWxfY29ubmVjdGl2aXR5IiwibWluX2Rpc3QiLCJfc3ByZWFkIiwiX3NldF9vcF9taXhfcmF0aW8iLCJfcmVwdWxzaW9uX3N0cmVuZ3RoIiwiX25lZ2F0aXZlX3NhbXBsZV9yYXRlIiwiX25fZXBvY2hzIiwiX2luaXRpYWxfYWxwaGEiLCJfZmluZF9hYl9wYXJhbXMiLCJ4diIsInl2IiwieHZfaSIsInBvd2VsbCIsImVycm9yIiwiX2NvbXB1dGVfbWVtYmVyc2hpcF9zdHJlbmd0aHMiLCJzaWdtYXMiLCJyaG9zIiwiX3Ntb290aF9rbm5fZGlzdCIsImtubiIsIlNNT09USF9LX1RPTEVSQU5DRSIsIk1JTl9LX0RJU1RfU0NBTEUiLCJ0YXJnZXQiLCJsb2cyIiwicmV2ZXJzZSIsInhfaSIsImxvIiwiaGkiLCJtaWQiLCJzZWFyY2hfcmVzdWx0Iiwibm9uX3plcm9fZGlzdCIsImZpbHRlciIsIm5vbl96ZXJvX2Rpc3RfbGVuZ3RoIiwiaW50ZXJwb2xhdGlvbiIsIm1lYW5faXRoZCIsIm1lYW5fZCIsIl9mdXp6eV9zaW1wbGljaWFsX3NldCIsImRpc3RhbmNlc19pIiwidHJhbnNwb3NlZF9yZXN1bHQiLCJwcm9kX21hdHJpeCIsIl9tYWtlX2Vwb2Noc19wZXJfc2FtcGxlIiwibl9lcG9jaHMiLCJ3ZWlnaHRzIiwiX3dlaWdodHMiLCJGbG9hdDMyQXJyYXkiLCJmaWxsIiwid2VpZ2h0c19tYXgiLCJuX3NhbXBsZXMiLCJfdG9jb28iLCJncmFwaCIsInJvd3NfbiIsImNvbHNfbiIsIl9hIiwiX2IiLCJfZ3JhcGgiLCJfaGVhZCIsIl90YWlsIiwiX2Vwb2Noc19wZXJfc2FtcGxlIiwiX2Vwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlIiwiX2Vwb2NoX29mX25leHRfc2FtcGxlIiwiX2Vwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlIiwiX2NsaXAiLCJfb3B0aW1pemVfbGF5b3V0IiwiaGVhZF9lbWJlZGRpbmciLCJ0YWlsX2VtYmVkZGluZyIsImhlYWQiLCJ0YWlsIiwiX2FscGhhIiwiZXBvY2hzX3Blcl9zYW1wbGUiLCJlcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZSIsImVwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlIiwiZXBvY2hfb2ZfbmV4dF9zYW1wbGUiLCJjbGlwIiwidGFpbF9sZW5ndGgiLCJncmFkX2NvZWZmIiwiZ3JhZF9kIiwibyIsIm5fbmVnX3NhbXBsZXMiLCJUcmlNYXAiLCJ3ZWlnaHRfYWRqIiwicGNhIiwibl9pbmxpZXJzIiwibl9vdXRsaWVycyIsIm5fcmFuZG9tIiwidHJpcGxldHMiLCJfZ2VuZXJhdGVfdHJpcGxldHMiLCJsciIsInZlbCIsImdhaW4iLCJuX2V4dHJhIiwibmJycyIsImtubl9kaXN0YW5jZXMiLCJzaWciLCJfZmluZF9wIiwiX3NhbXBsZV9rbm5fdHJpcGxldHMiLCJuX3RyaXBsZXRzIiwib3V0bGllcl9kaXN0YW5jZXMiLCJfZmluZF93ZWlnaHRzIiwicmFuZG9tX3RyaXBsZXRzIiwicmFuZG9tX3dlaWdodHMiLCJfc2FtcGxlX3JhbmRvbV90cmlwbGV0cyIsIm1heF93ZWlnaHQiLCJpc05hTiIsIm1heF93ZWlnaHRfMiIsIm5faSIsInNvcnRfaW5kaWNlcyIsIl9fYXJnc29ydCIsIm5faiIsInNpbSIsInNhbXBsZXMiLCJfcmVqZWN0aW9uX3NhbXBsZSIsIm91dCIsIm1heF9pbnQiLCJyZWplY3RzIiwiaW50ZXJ2YWwiLCJpbmRleE9mIiwicF9zaW0iLCJwX291dCIsImluZGljZXMiLCJfZ3JhZCIsInlfaWoiLCJ5X2lrIiwiZF9paiIsImRfaWsiLCJuX3Zpb2wiLCJsb3NzIiwibl9rbm5fdHJpcGxldHMiLCJZX2lkIiwiWV9qZCIsIllfa2QiLCJncyIsImdvIiwibWF4X2l0ZXJhdGlvbiIsIl9uZXh0IiwiZ2FtbWEiLCJvbGRfQyIsIl91cGRhdGVfZW1iZWRkaW5nIiwibmV3X2dhaW4iLCJIaWVyYXJjaGljYWxfQ2x1c3RlcmluZyIsIm1hdHJpeCIsImxpbmthZ2UiLCJfaWQiLCJfbWF0cml4IiwiX2xpbmthZ2UiLCJyb290IiwiZG8iLCJnZXRfY2x1c3RlcnMiLCJjbHVzdGVycyIsImRlcHRoIiwiX3RyYXZlcnNlIiwibGVhdmVzIiwiX24iLCJkX21pbiIsIl9kX21pbiIsIl9kaXN0YW5jZV9tYXRyaXgiLCJfY2x1c3RlcnMiLCJjX3NpemUiLCJfY19zaXplIiwiVWludDE2QXJyYXkiLCJDbHVzdGVyIiwicF9tYXgiLCJjMSIsIkRfaV9taW4iLCJjMiIsImMxX2NsdXN0ZXIiLCJjMl9jbHVzdGVyIiwiYzFfY2x1c3Rlcl9pbmRpY2VzIiwiaXNMZWFmIiwiYzJfY2x1c3Rlcl9pbmRpY2VzIiwibmV3X2NsdXN0ZXIiLCJ1bnNoaWZ0IiwiRF9jMV9qIiwiRF9jMl9qIiwiY2VudHJvaWQiLCJfY2FsY3VsYXRlX2NlbnRyb2lkIiwibF9zaXplIiwicl9zaXplIiwibF9jZW50cm9pZCIsInJfY2VudHJvaWQiLCJuZXdfY2VudHJvaWQiLCJkZXNjZW5kYW50cyIsImxlZnRfZGVzY2VuZGFudHMiLCJyaWdodF9kZXNjZW5kYW50cyIsIktNZWFucyIsIksiLCJfSyIsIl9jbHVzdGVyX2NlbnRyb2lkcyIsIl9nZXRfcmFuZG9tX2NlbnRyb2lkcyIsIl9mdXJ0aGVzdF9wb2ludCIsImNhbmRpZGF0ZXMiLCJBZCIsImNsdXN0ZXJfY2VudHJvaWRzIiwicmFuZG9tX3BvaW50IiwiaW5pdF9wb2ludHMiLCJzYW1wbGVfc2l6ZSIsImZ1cnRoZXN0X3BvaW50IiwiX2l0ZXJhdGlvbiIsImNsdXN0ZXJzX2NoYW5nZWQiLCJBaSIsIm1pbl9jbHVzdGVyIiwiX2NvbXB1dGVfY2VudHJvaWQiLCJjbHVzdGVyX2NvdW50ZXIiLCJjaSIsIml0ZXJhdGlvbl9yZXN1bHQiLCJLTWVkb2lkcyIsIl9BIiwiX21heF9pdGVyIiwibG9nMTAiLCJfY2x1c3Rlcl9tZWRvaWRzIiwiX2dldF9yYW5kb21fbWVkb2lkcyIsInhfaiIsIl9uZWFyZXN0X21lZG9pZCIsImluZGV4X25lYXJlc3QiLCJtZWRvaWRzIiwiZmluaXNoIiwiY2FjaGUiLCJ4X28iLCJEZWx0YVREIiwieHMiLCJmaW5kSW5kZXgiLCJkX2oiLCJkaXN0YW5jZV9uZWFyZXN0IiwiZGVsdGFURCIsImRfb2oiLCJfZ2V0X2Rpc3RhbmNlIiwiZF9uIiwiZGlzdGFuY2Vfc2Vjb25kIiwiZF9zIiwibmVhcmVzdCIsInNlY29uZCIsInhfbSIsIm0xIiwibTIiLCJpbmRleF9zZWNvbmQiLCJjbHVzdGVyX21lZG9pZHMiLCJjZWlsIiwiVEQiLCJURDAiLCJTIiwiU19qIiwiU19vIiwiZGVsdGEiLCJPUFRJQ1MiLCJtaW5fcG9pbnRzIiwiX2Vwc2lsb24iLCJfbWluX3BvaW50cyIsIl9vcmRlcmVkX2xpc3QiLCJfREIiLCJvcmRlcmVkX2xpc3QiLCJEQiIsImNsdXN0ZXJfaW5kZXgiLCJfY2x1c3Rlcl9pbmRleCIsInJlYWNoYWJpbGl0eV9kaXN0YW5jZSIsInByb2Nlc3NlZCIsIl9nZXRfbmVpZ2hib3JzIiwiX2NvcmVfZGlzdGFuY2UiLCJzZWVkcyIsIl91cGRhdGUiLCJfZXhwYW5kX2NsdXN0ZXIiLCJjb3JlX2Rpc3RhbmNlIiwibmV3X3JlYWNoYWJpbGl0eV9kaXN0YW5jZSIsImNsdXN0ZXIiLCJvdXRsaWVycyIsImdldF9jbHVzdGVyX2FmZmlybWF0aW9uIiwiTFNQIiwiY29udHJvbF9wb2ludHMiLCJEUl9wYXJhbWV0ZXJzIiwibmMiLCJjX2kiLCJZX0MiLCJYQSIsIkFUIiwiQVRBIiwiQVRiIiwiVG9wb01hcCIsIl9fbGF6eV9kaXN0YW5jZV9tYXRyaXgiLCJEX2lqIiwiX21ha2VfbWluaW11bV9zcGFubmluZ190cmVlIiwiZGlzam9pbnRfc2V0IiwiRiIsIkUiLCJzZXRfdSIsInNldF92IiwiX0Vtc3QiLCJfX2h1bGxfY3Jvc3MiLCJheCIsImF5IiwiYngiLCJieSIsInN4Iiwic3kiLCJfX2h1bGwiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImxvd2VyIiwidXBwZXIiLCJfX2ZpbmRBbmdsZSIsInAxeCIsInAxeSIsInAyeCIsInAyeSIsInNpbiIsImNvcyIsInZlYyIsIl9fYWxpZ25faHVsbCIsImh1bGwiLCJ0b3BFZGdlIiwiZDIiLCJ2MSIsInYyIiwidHJhbnNmb3JtYXRpb24iLCJ0eCIsInR5IiwiX190cmFuc2Zvcm0iLCJweCIsInB5IiwiX190cmFuc2Zvcm1fY29tcG9uZW50IiwieU9mZnNldCIsImN4IiwiY3kiLCJfX2FsaWduX2NvbXBvbmVudHMiLCJwb2ludHNfdSIsInBvaW50c192IiwiaHVsbF91IiwiaHVsbF92IiwidF91IiwidF92IiwiRW1zdCIsImNvbXBvbmVudHMiLCJjb21wb25lbnRfdSIsImNvbXBvbmVudF92IiwiU0FNTU9OIiwibWFnaWMiLCJpbml0X0RSIiwiaW5pdF9wYXJhbWV0ZXJzIiwiaW5jbHVkZXMiLCJfc3RlcCIsIk1BR0lDIiwiZTEiLCJlMiIsIllpIiwiWWoiLCJkWSIsImRYIiwiZHEiLCJkciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBU2UsbUJBQVVBLEVBQUdDLEdBQ3hCLE9BQU9DLEtBQUtDLEtBQUtDLGtCQUFrQkosRUFBR0M7Ozs7Ozs7O0dDRjNCLG1CQUFVSSxHQUNyQixJQUdJQyxFQUFHQyxFQUhIQyxFQUFJSCxFQUFTSSxPQUNiQyxFQUFNLEVBQ05DLEVBQWUsRUFHbkIsSUFBSyxJQUFJQyxFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQ3JC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
