// https://renecutura.eu v0.5.0 Copyright 2022 Rene Cutura
/**
 * Computes the euclidean distance (l<sub>2</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias euclidean
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the euclidean distance between {@link a} and {@link b}.
 */
function euclidean(t,e){return Math.sqrt(euclidean_squared(t,e))}
/**
 * Numerical stable summation with the Kahan summation algorithm.
 * @memberof module:numerical
 * @alias kahan_sum
 * @param {Array} summands - Array of values to sum up.
 * @returns {number} The sum.
 * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm}
 */function kahan_sum(t){let e,r,s=t.length,i=0,n=0;for(let o=0;o<s;++o)e=t[o]-n,r=i+e,n=r-i-e,i=r;return i}
/**
 * Numerical stable summation with the Neumair summation algorithm.
 * @memberof module:numerical
 * @alias neumair_sum
 * @param {Array} summands - Array of values to sum up.
 * @returns {number} The sum.
 * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements}
 */function neumair_sum(t){let e=t.length,r=0,s=0;for(let i=0;i<e;++i){let e=t[i],n=r+e;Math.abs(r)>=Math.abs(e)?s+=r-n+e:s+=e-n+r,r=n}return r+s}
/**
 * Computes the squared euclidean distance (l<sub>2</sub><sup>2</sup>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias euclidean_squared
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the squared euclidean distance between {@link a} and {@link b}.
 */function euclidean_squared(t,e){if(t.length!=e.length)return;let r=t.length,s=new Array(r);for(let i=0;i<r;++i){let r=t[i],n=e[i];s[i]=(r-n)*(r-n)}return neumair_sum(s)}
/**
 * Computes the cosine distance (not similarity) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias cosine
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @example
 * druid.cosine([1,0],[1,1]) == 0.7853981633974484 == π/4
 * @returns {Number} The cosine distance between {@link a} and {@link b}.
 */function cosine(t,e){if(t.length!==e.length)return;let r=t.length,s=0,i=0,n=0;for(let o=0;o<r;++o)s+=t[o]*e[o],i+=t[o]*t[o],n+=e[o]*e[o];return Math.acos(s/(Math.sqrt(i)*Math.sqrt(n)))}
/**
 * Computes the manhattan distance (l<sub>1</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias manhattan
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the manhattan distance between {@link a} and {@link b}.
 */function manhattan(t,e){if(t.length!=e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i]);return s}
/**
 * Computes the chebyshev distance (L<sub>∞</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias chebyshev
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the chebyshev distance between {@link a} and {@link b}.
 */function chebyshev(t,e){if(t.length!=e.length)return;let r=t.length,s=[];for(let i=0;i<r;++i)s.push(Math.abs(t[i]-e[i]));return Math.max(...s)}
/**
 * Computes the canberra distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias canberra
 * @param {Array<Number>} a 
 * @param {Array<Number>} b 
 * @returns {Number} The canberra distance between {@link a} and {@link b}.
 * @see {@link https://en.wikipedia.org/wiki/Canberra_distance}
 */function canberra(t,e){if(t.length!==e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i])/(Math.abs(t[i])+Math.abs(e[i]));return s}
/**
 * Computes the jaccard distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias jaccard
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the jaccard distance between {@link a} and {@link b}.
 */function jaccard(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,i=0;for(let n=0;n<r;++n){const r=0!=t[n],o=0!=e[n];s+=r||o,i+=r&&o}return(s-i)/s}
/**
 * Computes the hamming distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias hamming
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the hamming distance between {@link a} and {@link b}.
 */function hamming(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let i=0;i<r;++i){s+=t[i]!=e[i]}return s/r}
/**
 * Computes the Sokal-Michener distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias sokal_michener
 * @param {Array<Number>} a 
 * @param {Array<Number>} b 
 * @returns {Number} the Sokal-Michener distance between {@link a} and {@link b}.  
 */function sokal_michener(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let i=0;i<r;++i){s+=0!=t[i]!=(0!=e[i])}return 2*s/(r+s)}
/**
 * Computes the yule distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias yule
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the yule distance between {@link a} and {@link b}.
 */function yule(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,i=0,n=0;for(let o=0;o<r;++o){const r=0!=t[o],a=0!=e[o];s+=r&&a,i+=r&&!a,n+=!r&&r}return 0==i||0==n?0:2*i*n/(s*(r-s-i-n)+i*n)}
/**
 * Computes the k-nearest neighbors of each row of {@link A}.
 * @memberof module:matrix
 * @alias k_nearest_neigbhors
 * @param {Matrix} A - Either the data matrix, or a distance matrix.
 * @param {Number} k - The number of neighbors to compute.
 * @param {Function|"precomputed"} [metric=euclidean]
 * @returns {Array<Object>} -
 */function k_nearest_neighbors(t,e,r=euclidean){const s=t.shape[0];let i="precomputed"==r?t:distance_matrix(t,r),n=new Array(s);for(let t=0;t<s;++t)n[t]=Array.from(i.row(t)).map(((e,r)=>({i:t,j:r,distance:e}))).sort(((t,e)=>t.distance-e.distance)).slice(1,e+1);return n}
/**
 * Computes the distance matrix of datamatrix {@link A}.
 * @memberof module:matrix
 * @alias distance_matrix
 * @param {Matrix} A - Matrix.
 * @param {Function} [metric=euclidean] - The diistance metric.
 * @returns {Matrix} D - The distance matrix of {@link A}.
 */function distance_matrix(t,e=euclidean){let r=t.shape[0];const s=new Matrix(r,r);for(let i=0;i<r;++i){const n=t.row(i);for(let o=i+1;o<r;++o){const r=e(n,t.row(o));s.set_entry(i,o,r),s.set_entry(o,i,r)}}return s}
/**
 * Creates an Array containing {@link number} numbers from {@link start} to {@link end}.
 * If <code>{@link number} = null</null>.
 * @memberof module:matrix
 * @alias linspace
 * @param {Number} start - Start value.
 * @param {Number} end - End value.
 * @param {Number} [number = null] - Number of number between {@link start} and {@link end}.
 * @returns {Array} - An array with {@link number} entries, beginning at {@link start} ending at {@link end}.
 */function linspace(t,e,r=null){if(r||(r=Math.max(Math.round(e-t)+1,1)),r<2)return 1===r?[t]:[];let s=new Array(r);for(let i=r-=1;i>=0;--i)s[i]=(i*e+(r-i)*t)/r;return s}
//import { neumair_sum } from "../numerical/index";
/**
 * Computes the norm of a vector, by computing its distance to **0**.
 * @memberof module:matrix
 * @alias norm
 * @param {Matrix|Array<Number>|Float64Array} v - Vector. 
 * @param {Function} [metric = euclidean] - Which metric should be used to compute the norm.
 * @returns {Number} - The norm of {@link v}.
 */function norm(t,e=euclidean){let r=null;if(t instanceof Matrix){let[e,s]=t.shape;if(1===e)r=t.row(0);else{if(1!==s)throw new Error("Matrix must be 1d!");r=t.col(0)}}else r=t;const s=r.length;return e(r,Float64Array.from({length:s},(()=>0)))}
/**
 * Normalizes Vector {@link v}.
 * @memberof module:matrix
 * @alias normalize
 * @param {Array<Number>|Float64Array} v - Vector
 * @param {Function} metric 
 * @returns {Array<Number>|Float64Array} - The normalized vector with length 1.
 */function normalize(t,e=euclidean){const r=norm(t,e);return t.map((t=>t/r))}
/**
 * Computes the QR Decomposition of the Matrix {@link A} using Gram-Schmidt process.
 * @memberof module:linear_algebra
 * @alias qr
 * @param {Matrix} A
 * @returns {{R: Matrix, Q: Matrix}}
 * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_the_Gram%E2%80%93Schmidt_process}
 */function qr_gramschmidt(t){const[e,r]=t.shape,s=new Matrix(e,r,"identity"),i=new Matrix(r,r,0);for(let n=0;n<r;++n){let r=t.col(n);for(let t=0;t<n;++t){const e=s.col(t),o=neumair_sum(e.map(((t,e)=>t*r[e])));i.set_entry(t,n,o),r=r.map(((t,r)=>t-o*e[r]))}const o=norm(r,euclidean);for(let t=0;t<e;++t)s.set_entry(t,n,r[t]/o);i.set_entry(n,n,o)}return{R:i,Q:s}}
/**
 * Computes the QR Decomposition of the Matrix {@link A} with householder transformations.
 * @memberof module:linear_algebra
 * @alias qr_householder
 * @param {Matrix} A
 * @returns {{R: Matrix, Q: Matrix}}
 * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections}
 * @see {@link http://mlwiki.org/index.php/Householder_Transformation}
 */function qr_householder(t){const[e,r]=t.shape,s=new Matrix(e,e,"I"),i=t.clone();for(let t=0;t<r;++t){const e=Matrix.from(i.col(t).slice(t)),r=norm(e),n=e.entry(0,0),o=-Math.sign(n),a=n-o*r,h=e.divide(a).set_entry(0,0,1),l=-o*a/r,_=h.outer(h),c=i.get_block(t,0),u=c.sub(_.dot(c).mult(l)),d=s.get_block(0,t),m=d.sub(d.dot(_).mult(l));i.set_block(t,0,u),s.set_block(0,t,m)}return{R:i,Q:s}}
/**
 * Computes the {@link k} biggest Eigenvectors and Eigenvalues from Matrix {@link A} with the QR-Algorithm.
 * @memberof module:linear_algebra
 * @alias simultaneous_poweriteration
 * @param {Matrix} A - The Matrix
 * @param {Number} k - The number of eigenvectors and eigenvalues to compute.
 * @param {Object} parameters - Object containing parameterization of the simultanious poweriteration method.
 * @param {Number} [parameters.max_iterations=100] - The number of maxiumum iterations the algorithm should run.
 * @param {Number|Randomizer} [parameters.seed=1212] - The seed value or a randomizer used in the algorithm.
 * @param {Function} [parameters.qr=qr_gramschmidt] - The QR technique to use.
 * @param {Number} [parameters.tol=1e-8] - Allowed error for stopping criteria
 * @returns {{eigenvalues: Array, eigenvectors: Array}} - The {@link k} biggest eigenvectors and eigenvalues of Matrix {@link A}.
 */function simultaneous_poweriteration(t,e=2,{seed:r=1212,max_iterations:s=100,qr:i=qr_gramschmidt,tol:n=1e-8}={}){const o=r instanceof Randomizer?r:new Randomizer(r);t instanceof Matrix||(t=Matrix.from(t));const a=t.shape[0];let{Q:h,R:l}=i(new Matrix(a,e,(()=>2*(o.random-.5))));for(;s--;){const e=h.clone(),r=i(t.dot(h));h=r.Q,l=r.R;if(euclidean_squared(h.values,e.values)<n)break}return{eigenvalues:l.diag,eigenvectors:h.transpose().to2dArray}}
/**
 * Computes the inner product between two arrays of the same length.
 * @memberof module:linear_algebra
 * @alias inner_product
 * @param {Array|Float64Array} a - Array a
 * @param {Array|Float64Array} b - Array b
 * @returns The inner product between {@link a} and {@link b}
 */function inner_product(t,e){const r=t.length;if(r!=e.length)throw new Error("Array a and b must have the same length!");let s=0;for(let i=0;i<r;++i)s+=t*e;return s}
/**
 * @class
 * @alias Matrix
 * @requires module:numerical/neumair_sum
 */class Matrix{
/**
     * creates a new Matrix. Entries are stored in a Float64Array.
     * @constructor
     * @memberof module:matrix
     * @alias Matrix
     * @param {number} rows - The amount of rows of the matrix.
     * @param {number} cols - The amount of columns of the matrix.
     * @param {(function|string|number)} value=0 - Can be a function with row and col as parameters, a number, or "zeros", "identity" or "I", or "center".
     *  - **function**: for each entry the function gets called with the parameters for the actual row and column.
     *  - **string**: allowed are
     *      - "zero", creates a zero matrix.
     *      - "identity" or "I", creates an identity matrix.
     *      - "center", creates an center matrix.
     *  - **number**: create a matrix filled with the given value.
     * @example
     *
     * let A = new Matrix(10, 10, () => Math.random()); //creates a 10 times 10 random matrix.
     * let B = new Matrix(3, 3, "I"); // creates a 3 times 3 identity matrix.
     * @returns {Matrix} returns a {@link rows} times {@link cols} Matrix filled with {@link value}.
     */
constructor(t=null,e=null,r=null){if(this._rows=t,this._cols=e,this._data=null,t&&e){if(!r)return this._data=new Float64Array(t*e),this;if("function"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}if("string"==typeof r){if("zeros"===r)return new Matrix(t,e,0);if("identity"===r||"I"===r){this._data=new Float64Array(t*e);for(let r=0;r<t;++r)this._data[r*e+r]=1;return this}if("center"===r&&t==e){this._data=new Float64Array(t*e),r=(e,r)=>(e===r?1:0)-1/t;for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}}if("number"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r;return this}}return this}
/**
     * Creates a Matrix out of {@link A}.
     * @param {(Matrix|Array|Float64Array|number)} A - The matrix, array, or number, which should converted to a Matrix.
     * @param {"row"|"col"|"diag"} [type = "row"] - If {@link A} is a Array or Float64Array, then type defines if it is a row- or a column vector.
     * @returns {Matrix}
     *
     * @example
     * let A = Matrix.from([[1, 0], [0, 1]]); //creates a two by two identity matrix.
     * let S = Matrix.from([1, 2, 3], "diag"); // creates a 3 by 3 matrix with 1, 2, 3 on its diagonal. [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
     */static from(t,e="row"){if(t instanceof Matrix)return t.clone();if(!(Array.isArray(t)||t instanceof Float64Array)){if("number"==typeof t)return new Matrix(1,1,t);throw new Error("error")}{let r=t.length;if(0===r)throw new Error("Array is empty");
// 1d
if(!(Array.isArray(t[0])||t[0]instanceof Float64Array)){if("row"===e)return new Matrix(1,r,((e,r)=>t[r]));
// 2d
if("col"===e)return new Matrix(r,1,(e=>t[e]));if("diag"===e)return new Matrix(r,r,((e,r)=>e==r?t[e]:0));throw new Error("1d array has NaN entries")}if(Array.isArray(t[0])||t[0]instanceof Float64Array){let e=t[0].length;for(let s=0;s<r;++s)if(t[s].length!==e)throw new Error("various array lengths");return new Matrix(r,e,((e,r)=>t[e][r]))}}}
/**
     * Returns the {@link row}<sup>th</sup> row from the Matrix.
     * @param {Number} row
     * @returns {Float64Array}
     */row(t){const e=this.values,r=this._cols;return e.subarray(t*r,(t+1)*r)}
/**
     * Returns an generator yielding each row of the Matrix.
     * @yields {Float64Array}
     */*iterate_rows(){const t=this._cols,e=this._rows,r=this.values;for(let s=0;s<e;++s)yield r.subarray(s*t,(s+1)*t)}
/**
     * Makes a {@link Matrix} object an iterable object.
     * @yields {Float64Array}
     */*[Symbol.iterator](){for(const t of this.iterate_rows())yield t}
/**
     * Sets the entries of {@link row}<sup>th</sup> row from the Matrix to the entries from {@link values}.
     * @param {int} row
     * @param {Array} values
     * @returns {Matrix}
     */set_row(t,e){let r=this._cols;if(Array.isArray(e)&&e.length===r){let s=t*r;for(let t=0;t<r;++t)this.values[s+t]=e[t]}else if(e instanceof Matrix&&e.shape[1]===r&&1===e.shape[0]){let s=t*r;for(let t=0;t<r;++t)this.values[s+t]=e._data[t]}return this}
/**
     * Returns the {@link col}<sup>th</sup> column from the Matrix.
     * @param {int} col
     * @returns {Array}
     */col(t){let e=new Float64Array(this._rows);for(let r=0;r<this._rows;++r)e[r]=this.values[r*this._cols+t];return e}
/**
     * Returns the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix.
     * @param {int} row
     * @param {int} col
     * @returns {float64}
     */entry(t,e){return this.values[t*this._cols+e]}
/**
     * Sets the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix to the given {@link value}.
     * @param {int} row
     * @param {int} col
     * @param {float64} value
     * @returns {Matrix}
     */set_entry(t,e,r){return this.values[t*this._cols+e]=r,this}
/**
     * Returns a new transposed Matrix.
     * @returns {Matrix}
     */transpose(){return new Matrix(this._cols,this._rows,((t,e)=>this.entry(e,t)))}
/**
     * Returns a new transposed Matrix. Short-form of {@function transpose}.
     * @returns {Matrix}
     */get T(){return this.transpose()}
/**
     * Returns the inverse of the Matrix.
     * @returns {Matrix}
     */inverse(){const t=this._rows,e=this._cols;let r=new Matrix(t,2*e,((t,r)=>r>=e?t===r-e?1:0:this.entry(t,r))),s=0,i=0;for(;s<t&&i<e;){var n=0;let o=-1/0;for(let e=s;e<t;++e){let t=Math.abs(r.entry(e,i));o<t&&(n=e,o=t)}if(0==r.entry(n,i))i++;else{
// swap rows
for(let t=0;t<2*e;++t){let e=r.entry(s,t),i=r.entry(n,t);r.set_entry(s,t,e),r.set_entry(n,t,i)}for(let n=s+1;n<t;++n){let t=r.entry(n,i)/r.entry(s,i);r.set_entry(n,i,0);for(let o=i+1;o<2*e;++o)r.set_entry(n,o,r.entry(n,o)-r.entry(s,o)*t)}s++,i++}}for(let s=0;s<t;++s){let t=r.entry(s,s);for(let i=s;i<2*e;++i)r.set_entry(s,i,r.entry(s,i)/t)}for(let s=t-1;s>=0;--s){let t=r.entry(s,s);for(let i=0;i<s;i++){let n=r.entry(i,s)/t;for(let t=i;t<2*e;++t){let e=r.entry(i,t);e-=r.entry(s,t)*n,r.set_entry(i,t,e)}}}return new Matrix(t,e,((t,s)=>r.entry(t,s+e)))}
/**
     * Returns the dot product. If {@link B} is an Array or Float64Array then an Array gets returned. If {@link B} is a Matrix then a Matrix gets returned.
     * @param {(Matrix|Array|Float64Array)} B the right side
     * @returns {(Matrix|Array)}
     */dot(t){if(t instanceof Matrix){let e=this;if(e.shape[1]!==t.shape[0])throw new Error(`A.dot(B): A is a ${e.shape.join(" ⨯ ")}-Matrix, B is a ${t.shape.join(" ⨯ ")}-Matrix: \n                A has ${e.shape[1]} cols and B ${t.shape[0]} rows. \n                Must be equal!`);let r=e.shape[1];return new Matrix(e.shape[0],t.shape[1],((s,i)=>{const n=e.row(s),o=t.col(i);let a=0;for(let t=0;t<r;++t)a+=n[t]*o[t];return a}))}if(Array.isArray(t)||t instanceof Float64Array){let e=this._rows;if(t.length!==e)throw new Error(`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`);let r=new Array(e);for(let s=0;s<e;++s)r[s]=neumair_sum(this.row(s).map((e=>e*t[s])));return r}throw new Error("B must be Matrix or Array")}
/**
     * Computes the outer product from {@link this} and {@link B}.
     * @param {Matrix} B
     * @returns {Matrix}
     */outer(t){let e=this,r=e._data.length;if(r!=t._data.length)return;let s=new Matrix;return s.shape=[r,r,(r,i)=>r<=i?e._data[r]*t._data[i]:s.entry(i,r)],s}
/**
     * Appends matrix {@link B} to the matrix.
     * @param {Matrix} B - matrix to append.
     * @param {"horizontal"|"vertical"|"diag"} [type = "horizontal"] - type of concatenation.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 1], [1, 1]]); // 2 by 2 matrix filled with ones.
     * let B = Matrix.from([[2, 2], [2, 2]]); // 2 by 2 matrix filled with twos.
     *
     * A.concat(B, "horizontal"); // 2 by 4 matrix. [[1, 1, 2, 2], [1, 1, 2, 2]]
     * A.concat(B, "vertical"); // 4 by 2 matrix. [[1, 1], [1, 1], [2, 2], [2, 2]]
     * A.concat(B, "diag"); // 4 by 4 matrix. [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 2, 2], [0, 0, 2, 2]]
     */concat(t,e="horizontal"){const r=this,[s,i]=r.shape,[n,o]=t.shape;if("horizontal"==e){if(s!=n)throw new Error(`A.concat(B, "horizontal"): A and B need same number of rows, A has ${s} rows, B has ${n} rows.`);const e=new Matrix(s,i+o,"zeros");return e.set_block(0,0,r),e.set_block(0,i,t),e}if("vertical"==e){if(i!=o)throw new Error(`A.concat(B, "vertical"): A and B need same number of columns, A has ${i} columns, B has ${o} columns.`);const e=new Matrix(s+n,i,"zeros");return e.set_block(0,0,r),e.set_block(s,0,t),e}if("diag"==e){const e=new Matrix(s+n,i+o,"zeros");return e.set_block(0,0,r),e.set_block(s,i,t),e}throw new Error(`type must be "horizontal" or "vertical", but type is ${e}!`)}
/**
     * Writes the entries of B in A at an offset position given by {@link offset_row} and {@link offset_col}.
     * @param {int} offset_row
     * @param {int} offset_col
     * @param {Matrix} B
     * @returns {Matrix}
     */set_block(t,e,r){let[s,i]=r.shape;for(let n=0;n<s;++n)if(!(n>this._rows))for(let s=0;s<i;++s)s>this._cols||this.set_entry(n+t,s+e,r.entry(n,s));return this}
/**
     * Extracts the entries from the {@link start_row}<sup>th</sup> row to the {@link end_row}<sup>th</sup> row, the {@link start_col}<sup>th</sup> column to the {@link end_col}<sup>th</sup> column of the matrix.
     * If {@link end_row} or {@link end_col} is empty, the respective value is set to {@link this.rows} or {@link this.cols}.
     * @param {Number} start_row
     * @param {Number} start_col
     * @param {Number} [end_row = null]
     * @param {Number} [end_col = null]
     * @returns {Matrix} Returns a end_row - start_row times end_col - start_col matrix, with respective entries from the matrix.
     * @example
     *
     * let A = Matrix.from([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); // a 3 by 3 matrix.
     *
     * A.get_block(1, 1); // [[5, 6], [8, 9]]
     * A.get_block(0, 0, 1, 1); // [[1]]
     * A.get_block(1, 1, 2, 2); // [[5]]
     * A.get_block(0, 0, 2, 2); // [[1, 2], [4, 5]]
     */get_block(t,e,r=null,s=null){const[i,n]=this.shape;if(s=s??n,(r=r??i)<=t||s<=e)throw new Error(`\n                end_row must be greater than start_row, and \n                end_col must be greater than start_col, but\n                end_row = ${r}, start_row = ${t}, end_col = ${s}, and start_col = ${e}!`);const o=new Matrix(r-t,s-e,"zeros");for(let i=t,n=0;i<r;++i,++n)for(let t=e,r=0;t<s;++t,++r)o.set_entry(n,r,this.entry(i,t));return o;
//return new Matrix(end_row - start_row, end_col - start_col, (i, j) => this.entry(i + start_row, j + start_col));
}
/**
     * Returns a new array gathering entries defined by the indices given by argument.
     * @param {Array<Number>} row_indices - Array consists of indices of rows for gathering entries of this matrix
     * @param {Array<Number>} col_indices  - Array consists of indices of cols for gathering entries of this matrix
     * @returns {Matrix}
     */gather(t,e){const r=t.length,s=e.length,i=new Matrix(r,s);for(let s=0;s<r;++s){const n=t[s];for(let t=0;t<r;++t){const r=e[t];i.set_entry(s,t,this.entry(n,r))}}return i}
/**
     * Applies a function to each entry of the matrix.
     * @private
     * @param {function} f function takes 2 parameters, the value of the actual entry and a value given by the function {@link v}. The result of {@link f} gets writen to the Matrix.
     * @param {function} v function takes 2 parameters for row and col, and returns a value witch should be applied to the colth entry of the rowth row of the matrix.
     */_apply_array(t,e){const r=this.values,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o;r[i]=t(r[i],e(n,o))}}return this}_apply_rowwise_array(t,e){return this._apply_array(e,((e,r)=>t[r]))}_apply_colwise_array(t,e){const r=this.values,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o;r[i]=e(r[i],t[n])}}return this}_apply(t,e){let r=this.values;if(t instanceof Matrix){let[s,i]=t.shape,[n,o]=this.shape;if(1===s){if(o!==i)throw new Error("cols !== value_cols");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(0,i))}else if(1===i){if(n!==s)throw new Error("rows !== value_rows");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,0))}else{if(n!=s||o!=i)throw new Error("error");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,i))}}else if(Array.isArray(t)){let s=this._rows,i=this._cols;if(t.length===s)for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[n]);else{if(t.length!==i)throw new Error("error");for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[s])}}else for(let s=0,i=this._rows*this._cols;s<i;++s)r[s]=e(r[s],t);return this}
/**
     * Clones the Matrix.
     * @returns {Matrix}
     */clone(){let t=new Matrix;return t._rows=this._rows,t._cols=this._cols,t._data=this.values.slice(0),t}
/**
     * Entrywise multiplication with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.mult(2); // [[2, 4], [6, 8]];
     * A.mult(B); // [[1, 4], [9, 16]];
     */mult(t){return this.clone()._apply(t,((t,e)=>t*e))}
/**
     * Entrywise division with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.divide(2); // [[0.5, 1], [1.5, 2]];
     * A.divide(B); // [[1, 1], [1, 1]];
     */divide(t){return this.clone()._apply(t,((t,e)=>t/e))}
/**
     * Entrywise addition with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.add(2); // [[3, 4], [5, 6]];
     * A.add(B); // [[2, 4], [6, 8]];
     */add(t){return this.clone()._apply(t,((t,e)=>t+e))}
/**
     * Entrywise subtraction with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.sub(2); // [[-1, 0], [1, 2]];
     * A.sub(B); // [[0, 0], [0, 0]];
     */sub(t){return this.clone()._apply(t,((t,e)=>t-e))}
/**
     * Returns the number of rows and columns of the Matrix.
     * @returns {Array} An Array in the form [rows, columns].
     */get shape(){return[this._rows,this._cols]}
/**
     * Returns the matrix in the given shape with the given function which returns values for the entries of the matrix.
     * @param {Array} parameter - takes an Array in the form [rows, cols, value], where rows and cols are the number of rows and columns of the matrix, and value is a function which takes two parameters (row and col) which has to return a value for the colth entry of the rowth row.
     * @returns {Matrix}
     */set shape([t,e,r=(()=>0)]){this._rows=t,this._cols=e,this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}
/**
     * Returns the Matrix as a Array of Float64Arrays.
     * @returns {Array<Float64Array>}
     */get to2dArray(){const t=[];for(const e of this.iterate_rows())t.push(e);return t}
/**
     * Returns the Matrix as a Array of Arrays.
     * @returns {Array<Array>}
     */get asArray(){const t=[];for(const e of this.iterate_rows())t.push(Array.from(e));return t}
/**
     * Returns the diagonal of the Matrix.
     * @returns {Float64Array}
     */get diag(){const t=this._rows,e=this._cols,r=Math.min(t,e);let s=new Float64Array(r);for(let t=0;t<r;++t)s[t]=this.entry(t,t);return s}
/**
     * Returns the mean of all entries of the Matrix.
     * @returns {Number}
     */get mean(){return this.sum/(this._rows*this._cols)}
/**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Number}
     */get sum(){return neumair_sum(this.values)}
/**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Float64Array}
     */get values(){return this._data}
/**
     * Returns the mean of each row of the matrix.
     * @returns {Float64Array}
     */get meanRows(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:e});for(let i=0;i<e;++i){s[i]=0;for(let e=0;e<r;++e)s[i]+=t[i*r+e];s[i]/=r}return s}
/** Returns the mean of each column of the matrix.
     * @returns {Float64Array}
     */get meanCols(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:r});for(let i=0;i<r;++i){s[i]=0;for(let n=0;n<e;++n)s[i]+=t[n*r+i];s[i]/=e}return s}
/**
     * Solves the equation {@link A}x = {@link b} using the conjugate gradient method. Returns the result x.
     * @param {Matrix} A - Matrix
     * @param {Matrix} b - Matrix
     * @param {Randomizer} [randomizer=null]
     * @param {Number} [tol=1e-3]
     * @returns {Matrix}
     */static solve_CG(t,e,r,s=.001){null===r&&(r=new Randomizer);const i=t.shape[0],n=e.shape[1];let o=new Matrix(i,0);for(let a=0;a<n;++a){const n=Matrix.from(e.col(a)).T;let h=new Matrix(i,1,(()=>r.random)),l=n.sub(t.dot(h)),_=l.clone();do{const e=t.dot(_),r=l.T.dot(l).entry(0,0)/_.T.dot(e).entry(0,0);h=h.add(_.mult(r));const s=l.sub(e.mult(r)),i=s.T.dot(s).entry(0,0)/l.T.dot(l).entry(0,0);_=s.add(_.mult(i)),l=s}while(Math.abs(l.mean)>s);o=o.concat(h,"horizontal")}return o}
/**
     * Solves the equation {@link A}x = {@link b}. Returns the result x.
     * @param {Matrix} A - Matrix or LU Decomposition
     * @param {Matrix} b - Matrix
     * @returns {Matrix}
     */static solve(t,e){let{L:r,U:s}="L"in t&&"U"in t?t:Matrix.LU(t),i=r.shape[0],n=e.clone();
// forward
for(let t=0;t<i;++t){for(let e=0;e<t-1;++e)n.set_entry(0,t,n.entry(0,t)-r.entry(t,e)*n.entry(1,e));n.set_entry(0,t,n.entry(0,t)/r.entry(t,t))}
// backward
for(let t=i-1;t>=0;--t){for(let e=i-1;e>t;--e)n.set_entry(0,t,n.entry(0,t)-s.entry(t,e)*n.entry(0,e));n.set_entry(0,t,n.entry(0,t)/s.entry(t,t))}return n}
/**
     * {@link L}{@link U} decomposition of the Matrix {@link A}. Creates two matrices, so that the dot product LU equals A.
     * @param {Matrix} A
     * @returns {{L: Matrix, U: Matrix}} result - Returns the left triangle matrix {@link L} and the upper triangle matrix {@link U}.
     */static LU(t){const e=t.shape[0],r=new Matrix(e,e,"zeros"),s=new Matrix(e,e,"identity");for(let i=0;i<e;++i){for(let n=i;n<e;++n){let e=0;for(let t=0;t<i;++t)e+=r.entry(n,t)*s.entry(t,i);r.set_entry(n,i,t.entry(n,i)-e)}for(let n=i;n<e;++n){if(0===r.entry(i,i))return;let e=0;for(let t=0;t<i;++t)e+=r.entry(i,t)*s.entry(t,n);s.set_entry(i,n,(t.entry(i,n)-e)/r.entry(i,i))}}return{L:r,U:s}}
/**
     * Computes the determinante of {@link A}, by using the LU decomposition of {@link A}.
     * @param {Matrix} A
     * @returns {Number} det - Returns the determinate of the Matrix {@link A}.
     */static det(t){const e=t.shape[0],{L:r,U:s}=Matrix.LU(t),i=r.diag,n=s.diag;let o=i[0]*n[0];for(let t=1;t<e;++t)o*=i[t]*n[t];return o}
/**
     * Computes the {@link k} components of the SVD decomposition of the matrix {@link M}
     * @param {Matrix} M
     * @param {int} [k=2]
     * @returns {{U: Matrix, Sigma: Matrix, V: Matrix}}
     */static SVD(t,e=2){const r=t.T;let s=r.dot(t),i=t.dot(r),{eigenvectors:n,eigenvalues:o}=simultaneous_poweriteration(s,e),{eigenvectors:a}=simultaneous_poweriteration(i,e);return{U:a,Sigma:o.map((t=>Math.sqrt(t))),V:n};
//Algorithm 1a: Householder reduction to bidiagonal form:
/* const [m, n] = A.shape;
        let U = new Matrix(m, n, (i, j) => i == j ? 1 : 0);
        console.log(U.to2dArray)
        let V = new Matrix(n, m, (i, j) => i == j ? 1 : 0);
        console.log(V.to2dArray)
        let B = Matrix.bidiagonal(A.clone(), U, V);
        console.log(U,V,B)
        return { U: U, "Sigma": B, V: V }; */}}
/**
 * @class
 * @memberof module:utils
 * @alias Randomizer
 */class Randomizer{
/**
     * Mersenne Twister random number generator.
     * @constructor
     * @param {Number} [_seed=new Date().getTime()] - The seed for the random number generator. If <code>_seed == null</code> then the actual time gets used as seed.
     * @see https://github.com/bmurray7/mersenne-twister-examples/blob/master/javascript-mersenne-twister.js
     */
constructor(t){return this._N=624,this._M=397,this._MATRIX_A=2567483615,this._UPPER_MASK=2147483648,this._LOWER_MASK=2147483647,this._mt=new Array(this._N),this._mti=this.N+1,this.seed=t||(new Date).getTime(),this}set seed(t){this._seed=t;let e=this._mt;for(e[0]=t>>>0,this._mti=1;this._mti<this._N;this._mti+=1){let t=this._mti,r=e[t-1]^e[t-1]>>>30;e[t]=(1812433253*((4294901760&r)>>>16)<<16)+1812433253*(65535&r)+t,e[t]>>>=0}}
/**
     * Returns the seed of the random number generator.
     * @returns {Number} - The seed.
     */get seed(){return this._seed}
/**
     * Returns a float between 0 and 1.
     * @returns {Number} - A random number between [0, 1]
     */get random(){return this.random_int*(1/4294967296)}
/**
     * Returns an integer between 0 and MAX_INTEGER.
     * @returns {Integer} - A random integer.
     */get random_int(){let t,e=new Array(0,this._MATRIX_A);if(this._mti>=this._N){let r,s=this._N-this._M,i=this._M-this._N;
/* if (this._mti == this._N + 1) {
                this.seed = 5489;
            } */for(r=0;r<s;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+this._M]^t>>>1^e[1&t];for(;r<this._N-1;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+i]^t>>>1^e[1&t];t=this._mt[this._N-1]&this._UPPER_MASK|this._mt[0]&this._LOWER_MASK,this._mt[this._N-1]=this._mt[this._M-1]^t>>>1^e[1&t],this._mti=0}return t=this._mt[this._mti+=1],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,t^=t>>>18,t>>>0}
/**
     * Returns samples from an input Matrix or Array.
     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.
     * @param {Number} n - The number of samples.
     * @returns {Array} - A random selection form {@link A} of {@link n} samples.
     */choice(t,e){if(t instanceof Matrix){let r=t.shape[0];if(e>r)throw new Error("n bigger than A!");let s=new Array(e),i=linspace(0,r-1);for(let t=0,r=i.length;t<e;++t,--r){let e=this.random_int%r;s[t]=i.splice(e,1)[0]}return s.map((e=>t.row(e)))}if(Array.isArray(t)||t instanceof Float64Array){let r=t.length;if(e>r)throw new Error("n bigger than A!");let s=new Array(e),i=linspace(0,r-1);for(let t=0,r=i.length;t<e;++t,--r){let e=this.random_int%r;s[t]=i.splice(e,1)[0]}return s.map((e=>t[e]))}}
/**
     * @static
     * Returns samples from an input Matrix or Array.
     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.
     * @param {Number} n - The number of samples.
     * @param {Number} seed - The seed for the random number generator.
     * @returns {Array} - A random selection form {@link A} of {@link n} samples.
     */static choice(t,e,r=1212){return new Randomizer(r).choice(t,e);
/* let rows = A.shape[0];
        if (n > rows) {
            throw new Error("n bigger than A!");
        }
        let rand = new Randomizer(seed);
        let sample = new Array(n);
        let index_list = linspace(0, rows - 1);
        for (let i = 0, l = index_list.length; i < n; ++i, --l) {
            let random_index = rand.random_int % l;
            sample[i] = index_list.splice(random_index, 1)[0];
        }
        //return result;
        //return new Matrix(n, cols, (row, col) => A.entry(sample[row], col))
        return sample.map((d) => A.row(d)); */}}
/**
 * Returns maximum in Array {@link values}.
 * @memberof module:utils
 * @alias max
 * @param {Array} values 
 * @returns {Number}
 */function max(t){let e;for(const r of t)null!=r&&(e<r||void 0===e&&r>=r)&&(e=r);return e}
/**
 * Returns maximum in Array {@link values}.
 * @memberof module:utils
 * @alias min
 * @param {Array} values
 * @returns {Number}
 */function min(t){let e;for(const r of t)null!=r&&(e>r||void 0===e&&r<=r)&&(e=r);return e}
/**
 * @class
 * @alias Heap
 */class Heap{
/**
     * A heap is a datastructure holding its elements in a specific way, so that the top element would be the first entry of an ordered list.
     * @constructor
     * @memberof module:datastructure
     * @alias Heap
     * @param {Array=} elements - Contains the elements for the Heap. {@link elements} can be null.
     * @param {Function} [accessor = (d) => d] - Function returns the value of the element.
     * @param {("min"|"max"|Function)} [comparator = "min"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. ("min" for a Min-Heap, "max" for a Max_heap)
     * @returns {Heap}
     * @see {@link https://en.wikipedia.org/wiki/Binary_heap}
     */
constructor(t=null,e=(t=>t),r="min"){return t?Heap.heapify(t,e,r):(this._accessor=e,this._container=[],this._comparator="min"==r?(t,e)=>t<e:"max"==r?(t,e)=>t>e:r,this)}
/**
     * Creates a Heap from an Array
     * @param {Array|Set} elements - Contains the elements for the Heap.
     * @param {Function=} [accessor = (d) => d] - Function returns the value of the element.
     * @param {(String=|Function)} [comparator = "min"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. ("min" for a Min-Heap, "max" for a Max_heap)
     * @returns {Heap}
     */static heapify(t,e=(t=>t),r="min"){const s=new Heap(null,e,r),i=s._container;for(const r of t)i.push({element:r,value:e(r)});for(let e=Math.floor(t.length/2-1);e>=0;--e)s._heapify_down(e);return s}
/**
     * Swaps elements of container array.
     * @private
     * @param {Number} index_a 
     * @param {Number} index_b 
     */_swap(t,e){const r=this._container;[r[e],r[t]]=[r[t],r[e]]}
/**
     * @private
     */_heapify_up(){const t=this._container;let e=t.length-1;for(;e>0;){let r=Math.floor((e-1)/2);if(!this._comparator(t[e].value,t[r].value))break;this._swap(r,e),e=r}}
/**
     * Pushes the element to the heap.
     * @param {} element
     * @returns {Heap}
     */push(t){const e={element:t,value:this._accessor(t)};
//const node = new Node(element, value);
return this._container.push(e),this._heapify_up(),this}
/**
     * @private
     * @param {Number} [start_index = 0] 
     */_heapify_down(t=0){const e=this._container,r=this._comparator,s=e.length;let i=2*t+1,n=2*t+2,o=t;if(o>s)throw"index higher than length";i<s&&r(e[i].value,e[o].value)&&(o=i),n<s&&r(e[n].value,e[o].value)&&(o=n),o!==t&&(this._swap(t,o),this._heapify_down(o))}
/**
     * Removes and returns the top entry of the heap.
     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).
     */pop(){const t=this._container;if(0===t.length)return null;if(1===t.length)return t.pop();this._swap(0,t.length-1);const e=t.pop();return this._heapify_down(),e}
/**
     * Returns the top entry of the heap without removing it.
     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).
     */get first(){return this._container.length>0?this._container[0]:null}
/**
     * Yields the raw data
     * @yields {Object} Object consists of the element and its value (computed by {@link accessor}).
     */*iterate(){for(let t=0,e=this._container.length;t<e;++t)yield this._container[t].element}
/**
     * Returns the heap as ordered array.
     * @returns {Array} Array consisting the elements ordered by {@link comparator}.
     */toArray(){return this.data().sort(((t,e)=>this._comparator(t,e)?-1:0))}
/**
     * Returns elements of container array.
     * @returns {Array} Array consisting the elements.
     */data(){return this._container.map((t=>t.element))}
/**
     * Returns the container array.
     * @returns {Array} The container array.
     */raw_data(){return this._container}
/**
     * The size of the heap.
     * @returns {Number}
     */get length(){return this._container.length}
/**
     * Returns false if the the heap has entries, true if the heap has no entries.
     * @returns {Boolean}
     */get empty(){return 0===this.length}}
/**
 * @class
 * @alias DisjointSet
 * @see {@link https://en.wikipedia.org/wiki/Disjoint-set_data_structure}
 */class DisjointSet{
/**
     * @constructor
     * @alias DisjointSet
     * @memberof module:datastructure
     * @param {Array=} elements 
     * @returns {DisjointSet}
     */
constructor(t=null){if(this._list=new Set,t)for(const e of t)this.make_set(e);return this}make_set(t){const e=this._list;return e.has(t)||(e.add(t),t.__disjoint_set={},t.__disjoint_set.parent=t,t.__disjoint_set.children=new Set([t]),t.__disjoint_set.size=1),this}find(t){return this._list.has(t)?t.__disjoint_set.parent!==t?(t.__disjoint_set.children.add(...t),t.__disjoint_set.parent=this.find(t.__disjoint_set.parent),t.__disjoint_set.parent):t:null}union(t,e){let r=this.find(t),s=this.find(e);return r===s||(r.__disjoint_set.size<s.__disjoint_set.size&&([r,s]=[s,r]),s.__disjoint_set.parent=r,
// keep track of children?
s.__disjoint_set.children.forEach(r.__disjoint_set.children.add,r.__disjoint_set.children),r.__disjoint_set.size+=s.__disjoint_set.size),this}}
/**
 * @class
 * @alias BallTree
 */class BallTree{
/**
     * Generates a BallTree with given {@link elements}.
     * @constructor
     * @memberof module:knn
     * @alias BallTree
     * @param {Array=} elements - Elements which should be added to the BallTree
     * @param {Function} [metric = euclidean] metric to use: (a, b) => distance
     * @see {@link https://en.wikipedia.org/wiki/Ball_tree}
     * @see {@link https://github.com/invisal/noobjs/blob/master/src/tree/BallTree.js}
     * @returns {BallTree}
     */
constructor(t=null,e=euclidean){return this._Node=class{constructor(t,e=null,r=null,s=null){this.pivot=t,this.child1=e,this.child2=r,this.radius=s}},this._Leaf=class{constructor(t){this.points=t}},this._metric=e,t&&this.add(t),this}
/**
     * 
     * @param {Array<*>} elements - new elements.
     * @returns {BallTree}
     */add(t){return t=t.map(((t,e)=>({index:e,element:t}))),this._root=this._construct(t),this}
/**
     * @private
     * @param {Array<*>} elements 
     * @returns {Node} root of balltree.
     */_construct(t){if(1===t.length)return new this._Leaf(t);{let e,r=this._greatest_spread(t),s=t.sort(((t,e)=>t.element[r]-e.element[r])),i=s.length,n=Math.floor(i/2),o=t[n],a=s.slice(0,n),h=s.slice(n,i),l=Math.max(...t.map((t=>this._metric(o.element,t.element))));return e=a.length>0&&h.length>0?new this._Node(o,this._construct(a),this._construct(h),l):new this._Leaf(t),e}}
/**
     * @private
     * @param {Node} B 
     * @returns {Number}
     */_greatest_spread(t){let e=t[0].element.length,r=new Array(e);for(let t=0;t<e;++t)r[t]=[1/0,-1/0];let s=t.reduce(((t,r)=>{for(let s=0;s<e;++s)t[s][0]=Math.min(t[s][0],r.element[s]),t[s][1]=Math.max(t[s][1],r.element[s]);return t}),r);s=s.map((t=>t[1]-t[0]));let i=0;for(let t=0;t<e;++t)i=s[t]>s[i]?t:i;return i}
/**
     * 
     * @param {*} t - query element.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.
     */search(t,e=5){return this._search(t,e,new Heap(null,(e=>this._metric(e.element,t)),"max"),this._root)}
/**
     * @private
     * @param {*} t - query element.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @param {Heap} Q - Heap consists of the currently found {@link k} nearest neighbors.
     * @param {Node|Leaf} B 
     */_search(t,e,r,s){
// B is Node
if(r.length>=e&&s.pivot&&s.radius&&this._metric(t,s.pivot.element)-s.radius>=r.first.value)return r;
// B is leaf
if(s.child1&&this._search(t,e,r,s.child1),s.child2&&this._search(t,e,r,s.child2),s.points)for(let t=0,i=s.points.length;t<i;++t){let i=s.points[t];e>r.length?r.push(i):(r.push(i),r.pop())}return r}}
/**
 * @class
 * @alias KNN
 */class KNN{
/**
     * Generates a KNN list with given {@link elements}.
     * @constructor
     * @memberof module:knn
     * @alias KNN
     * @param {Array=} elements - Elements which should be added to the KNN list
     * @param {Function|"precomputed"} [metric = euclidean] metric is either precomputed or a function to use: (a, b) => distance
     * @returns {KNN}
     */
constructor(t=null,e=euclidean){this._metric=e,this._elements=t instanceof Matrix?t:Matrix.from(t);const r=this._elements.shape[0];this._D="precomputed"===e?this._elements.clone():distance_matrix(this._elements,e),this.KNN=[];for(let t=0;t<r;++t){const e=this._D.row(t),s=new Heap(null,(t=>t.value),"min");for(let t=0;t<r;++t)s.push({value:e[t],index:t});this.KNN.push(s)}}
/**
     * 
     * @param {Array|Number} t - query element or index.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.
     */search(t,e=5){const r=this._metric,s=this.KNN;let i;if(Array.isArray(t)){if("precomputed"==this._metric)throw"Search by query element is only possible when not using a precomputed distance matrix!";const e=this._elements,n=s.length;let o=null,a=1/0;for(let s=0;s<n;++s){const i=r(t,e.row(s));i<a&&(o=s,a=i)}i=s[o]}else Number.isInteger(t)&&(i=s[t]);let n=[];for(let t=0;t<e;++t)n.push(i.pop());return n.forEach((t=>i.push(t.element))),n}}
/**
 * @class
 * @alias DR
 * @borrows DR#parameter as DR#para
 * @borrows DR#parameter as DR#p
 */class DR{
/**
     * Takes the default parameters and seals them, remembers the type of input {@link X}, and initializes the random number generator.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias DR
     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed value for the random number generator.
     * @returns {DR}
     */
constructor(t,e,r){if(this._parameters=Object.assign(Object.seal(e),r),Array.isArray(t))this._type="array",this.X=Matrix.from(t);else{if(!(t instanceof Matrix))throw new Error("No valid type for X!");this._type="matrix",this.X=t}return[this._N,this._D]=this.X.shape,this._randomizer=new Randomizer(this._parameters.seed),this._is_initialized=!1,this}
/**
     * Set and get parameters
     * @param {String} name - name of the parameter.
     * @param {any} [value = null] - value of the parameter to set.
     * @returns {DR|any} - On setting a parameter, this function returns the DR object. If <code>value == null</code> then return actual parameter value.
     * @example
     * const DR = new druid.TSNE(X, {d: 3}); // creates a new DR object, with parameter for <code>d</code> = 3.
     * DR.parameter("d"); // returns 3,
     * DR.parameter("d", 2); // sets parameter <code>d</code> to 2 and returns <code>DR</code>.
     */parameter(t,e=null){if(!this._parameters.hasOwnProperty(t))throw new Error(`${t} is not a valid parameter!`);return e?(this._parameters[t]=e,this._is_initialized=!1,this):this._parameters[t]}para(t,e=null){return this.parameter(t,e)}p(t,e=null){return this.parameter(t,e)}
/**
     * Computes the projection.
     * @returns {Matrix} - Returns the projection.
     */transform(){return this.check_init(),this.projection}
/**
     * Computes the projection.
     * @returns {Generator} - A generator yielding the intermediate steps of the dimensionality reduction method.
     */*generator(){return this.transform()}
/**
     * If the respective DR method has an <code>init</code> function, call it before <code>transform</code>.
     * @returns {DR}
     */check_init(){return this._is_initialized||"function"!=typeof this.init||(this.init(),this._is_initialized=!0),this}
/**
     * @returns {Matrix|Array} Returns the projection.
     */get projection(){if(this.hasOwnProperty("Y"))return this.check_init(),"matrix"===this._type?this.Y:this.Y.to2dArray;throw new Error("The dataset is not transformed yet!")}
/**
     *
     * @param  {...any} args - Arguments the transform method of the respective DR method takes.
     * @returns {Promise} - A promise yielding the dimensionality reduced dataset.
     */async transform_async(...t){return this.transform(...t)}
/**
     * @static
     * @param  {...any} args - Takes the same arguments of the constructor of the respective DR method.
     * @returns {Matrix|Array} - The dimensionality reduced dataset.
     */static transform(...t){return new this(...t).transform()}
/**
     * @static
     * @param  {...any} args - Takes the same arguments of the constructor of the respective DR method.
     * @returns {Promise} - A promise yielding the dimensionality reduced dataset.
     */static async transform_async(...t){return this.transform(...t)}
/**
     * @static
     * @param  {...any} args - Takes the same arguments of the constructor of the respective DR method.
     * @returns {Generator} - A generator yielding the intermediate steps of the dimensionality reduction method.
     */static*generator(...t){const e=new this(...t).generator();for(const t of e)yield t}}
/**
 * @class
 * @alias PCA
 * @augments DR
 */class PCA extends DR{
/**
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias PCA
     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @returns {PCA}
     */
constructor(t,e){return super(t,{d:2,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Transforms the inputdata {@link X} to dimensionality {@link d}. If parameter {@link A} is given, then project {@link A} with the principal components of {@link X}.
     * @param {null|Matrix|Array} [A = null] - If given, the data to project.
     * @returns {Matrix|Array} - The projected data.
     */transform(t=null){const e=this.principal_components();if(null==t){const t=this.X;return this.Y=t.dot(e),this.projection}if(Array.isArray(t))return Matrix.from(t).dot(e).asArray;if(t instanceof Matrix)return t.dot(e);throw new Error("No valid type for A!")}
/**
     * Computes the {@link d} principal components of Matrix {@link X}.
     * @returns {Matrix}
     */principal_components(){if(this.V)return this.V;const{d:t,eig_args:e}=this._parameters,r=this.X,s=Matrix.from(r.meanCols),i=r.sub(s),n=i.transpose().dot(i),{eigenvectors:o}=simultaneous_poweriteration(n,t,e);return this.V=Matrix.from(o).transpose(),this.V}static principal_components(t,e){return new this(t,e).principal_components()}}
/**
 * @class
 * @alias MDS
 * @extends DR
 */class MDS extends DR{
/**
     * Classical MDS.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias MDS
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     */
constructor(t,e){return super(t,{d:2,metric:euclidean,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Transforms the inputdata {@link X} to dimensionality {@link d}.
     * @returns {Matrix|Array}
     */transform(){const t=this.X,e=t.shape[0],{d:r,metric:s,eig_args:i}=this._parameters,n="precomputed"===s?t:distance_matrix(t,s),o=n.meanCols,a=n.meanRows,h=n.mean;this._d_X=n;const l=new Matrix(e,e,((t,e)=>n.entry(t,e)-o[t]-a[e]+h)),{eigenvectors:_}=simultaneous_poweriteration(l,r,i);return this.Y=Matrix.from(_).transpose(),this.projection}
/**
     * @returns {Number} - the stress of the projection.
     */stress(){const t=this.X.shape[0],e=this.Y,r=this._d_X,s=new Matrix;s.shape=[t,t,(t,r)=>t<r?euclidean(e.row(t),e.row(r)):s.entry(r,t)];let i=0,n=0;for(let e=0;e<t;++e)for(let o=e+1;o<t;++o)i+=Math.pow(r.entry(e,o)-s.entry(e,o),2),n+=Math.pow(r.entry(e,o),2);return Math.sqrt(i/n)}}
/**
 * @class
 * @alias ISOMAP
 * @extends DR
 */class ISOMAP extends DR{
/**
     * Isometric feature mapping (ISOMAP).
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias ISOMAP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} parameters.neighbors - the number of neighbors {@link ISOMAP} should use to project the data.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://doi.org/10.1126/science.290.5500.2319}
     */
constructor(t,e){return super(t,{neighbors:void 0,d:2,metric:euclidean,seed:1212,eig_args:{}},e),this.parameter("neighbors",Math.min(this._parameters.neighbors??Math.max(Math.floor(this.X.shape[0]/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */transform(){this.check_init();const t=this.X,e=this._N,{d:r,metric:s,eig_args:i,neighbors:n}=this._parameters,o=new Matrix;o.shape=[e,e,(e,r)=>e<=r?s(t.row(e),t.row(r)):o.entry(r,e)];const a=[];for(let t=0;t<e;++t){const r=[];for(let s=0;s<e;++s)r.push({index:s,distance:o.entry(t,s)});const s=new Heap(r,(t=>t.distance),"min");a.push(s.toArray().slice(1,n+1))}
/*D = dijkstra(kNearestNeighbors);*/
// compute shortest paths
// TODO: make extern
/** @see {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm} */const h=new Matrix(e,e,((t,e)=>{const r=a[t].find((t=>t.index===e));return r?r.distance:1/0}));for(let t=0;t<e;++t)for(let r=0;r<e;++r)for(let s=0;s<e;++s)h.set_entry(t,r,Math.min(h.entry(t,r),h.entry(t,s)+h.entry(s,r)));let l=new Float64Array(e),_=new Float64Array(e),c=0;const u=new Matrix(e,e,((t,e)=>{let r=h.entry(t,e);return r=r===1/0?0:r,l[t]+=r,_[e]+=r,c+=r,r}));l=l.map((t=>t/e)),_=_.map((t=>t/e)),c/=e**2;const d=new Matrix(e,e,((t,e)=>u.entry(t,e)-l[t]-_[e]+c)),{eigenvectors:m}=simultaneous_poweriteration(d,r,i);
// compute d eigenvectors
// return embedding
return this.Y=Matrix.from(m).transpose(),this.projection}}
/**
 * @class
 * @alias FASTMAP
 * @extends DR
 */class FASTMAP extends DR{
/**
     * FastMap: a fast algorithm for indexing, data-mining and visualization of traditional and multimedia datasets
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias FASTMAP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the dimensionality of the projection.
     * @returns {FASTMAP}
     * @see {@link https://doi.org/10.1145/223784.223812}
     */
constructor(t,e){return super(t,{d:2,metric:euclidean,seed:1212},e),this}
/**
     * Chooses two points which are the most distant in the actual projection.
     * @private
     * @param {Function} dist
     * @returns {Array} An array consisting of first index, second index, and distance between the two points.
     */_choose_distant_objects(t){const e=this.X.shape[0];let r=this._randomizer.random_int%e-1,s=null,i=-1/0;for(let n=0;n<e;++n){const e=t(r,n);e>i&&(i=e,s=n)}i=-1/0;for(let n=0;n<e;++n){const e=t(s,n);e>i&&(i=e,r=n)}return[r,s,i]}
/**
     * Computes the projection.
     * @returns {Matrix} The {@link d}-dimensional projection of the data matrix {@link X}.
     */transform(){const t=this.X,e=t.shape[0],{d:r,metric:s}=this._parameters,i=new Matrix(e,r,0);let dist=(e,r)=>s(t.row(e),t.row(r));for(let t=0;t<r;++t){let r=dist;
// choose pivot objects
const[s,n,o]=this._choose_distant_objects(dist);if(0!==o){
// project the objects on the line (O_a, O_b)
for(let r=0;r<e;++r){const e=(dist(s,r)**2+o**2-dist(n,r)**2)/(2*o);i.set_entry(r,t,e)}
// consider the projections of the objects on a
// hyperplane perpendicluar to the line (a, b);
// the distance function D'() between two
// projections is given by Eq.4
dist=(e,s)=>Math.sqrt(r(e,s)**2-(i.entry(e,t)-i.entry(s,t))**2)}}
// return embedding.
return this.Y=i,this.projection}}
/**
 * @class
 * @alias LDA
 * @extends DR
 */class LDA extends DR{
/**
     * Linear Discriminant Analysis.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LDA
     * @param {Matrix} X - The high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Array} parameters.labels - The labels / classes for each data point.
     * @param {number} [parameters.d = 2] - The dimensionality of the projection.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://onlinelibrary.wiley.com/doi/10.1111/j.1469-1809.1936.tb02137.x}
     */
constructor(t,e){return super(t,{labels:null,d:2,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,[e,r]=t.shape,{d:s,labels:i,eig_args:n}=this._parameters;if(null===i||i.length!=e)throw new Error("LDA needs parameter label to every datapoint to work!");const o={};let a=0;i.forEach(((e,r)=>{e in o?(o[e].count++,o[e].rows.push(t.row(r))):o[e]={id:a++,count:1,rows:[t.row(r)]}}));
// create X_mean and vector means;
const h=t.mean,l=new Matrix(a,r);for(const t in o){const e=Matrix.from(o[t].rows).meanCols;for(let s=0;s<r;++s)l.set_entry(o[t].id,s,e[s])}
// scatter_between
let _=new Matrix(r,r);for(const t in o){const e=l.row(o[t].id),s=new Matrix(r,1,(t=>e[t]-h)),i=o[t].count;_=_.add(s.dot(s.transpose()).mult(i))}
// scatter_within
let c=new Matrix(r,r);for(const t in o){const e=l.row(o[t].id),s=new Matrix(r,1,(t=>e[t])),i=o[t].rows;for(let e=0,n=o[t].count;e<n;++e){const t=new Matrix(r,1,((t,r)=>i[e][t]-s.entry(t,0)));c=c.add(t.dot(t.transpose()))}}let{eigenvectors:u}=simultaneous_poweriteration(c.inverse().dot(_),s,n);
// return embedding
return u=Matrix.from(u).transpose(),this.Y=t.dot(u),this.projection}}
/**
 * @class
 * @alias LLE
 * @extends DR
 */class LLE extends DR{
/**
     * Locally Linear Embedding.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LLE
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} neighbors - the label / class of each data point.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://doi.org/10.1126/science.290.5500.2323}
     */
constructor(t,e){return super(t,{neighbors:void 0,d:2,metric:euclidean,seed:1212,eig_args:{}},e),this.parameter("neighbors",Math.min(e.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,e=this._N,r=this._D,{neighbors:s,d:i,eig_args:n,metric:o}=this._parameters,a=k_nearest_neighbors(t,s,o),h=new Matrix(s,1,1),l=new Matrix(e,e);for(let i=0;i<e;++i){const e=a[i],n=new Matrix(s,r,((r,s)=>t.entry(e[r].j,s)-t.entry(i,s))),o=n.dot(n.T);if(s>r){const t=neumair_sum(o.diag)/1e3;for(let e=0;e<s;++e)o.set_entry(e,e,o.entry(e,e)+t)}
// reconstruct;
let _=Matrix.solve_CG(o,h,this._randomizer);_=_.divide(_.sum);for(let t=0;t<s;++t)l.set_entry(i,e[t].j,_.entry(t,0))}
// comp embedding
const _=new Matrix(e,e,"identity").sub(l),c=_.T.dot(_),{eigenvectors:u}=simultaneous_poweriteration(c.T.inverse(),i+1,n);
// return embedding
return this.Y=Matrix.from(u.slice(1,1+i)).T,this.projection}}
/**
 * @class
 * @alias LTSA
 * @extends DR
 */class LTSA extends DR{
/**
     * Local Tangent Space Alignment
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LTSA
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} parameters.neighbors - the number of neighbors {@link LTSA} should use to project the data.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://epubs.siam.org/doi/abs/10.1137/S1064827502419154}
     */
constructor(t,e){if(super(t,{neighbors:void 0,d:2,metric:euclidean,seed:1212,eig_args:{}},e),this.parameter("neighbors",Math.min(e.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this._D<=this.parameter("d"))throw new Error(`Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${this.parameter("d")})!`);return this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,[e,r]=t.shape,{d:s,neighbors:i,metric:n,eig_args:o}=this._parameters,a=k_nearest_neighbors(t,i,n),h=new Matrix(r,r,"center"),l=new Matrix(e,e,0);for(let r=0;r<e;++r){
// 1.2 compute the d largest eigenvectors of the correlation matrix
const e=[r,...a[r].map((t=>t.j))];let n=Matrix.from(e.map((e=>t.row(e))));
// center X_i
n=n.dot(h);
// correlation matrix
const _=n.dot(n.transpose()),{eigenvectors:c}=simultaneous_poweriteration(_,s,o),u=Matrix.from(c),d=u.transpose().dot(u).add(1/Math.sqrt(i+1));for(let t=0;t<i+1;++t)for(let r=0;r<i+1;++r)l.set_entry(e[t],e[r],l.entry(e[t],e[r])-(t===r?1:0)+d.entry(t,r))}
// 3. Aligning global coordinates
const{eigenvectors:_}=simultaneous_poweriteration(l,s+1,o);
// return embedding
return this.Y=Matrix.from(_.slice(1)).transpose(),this.projection}}
/**
 * @class
 * @alias TSNE
 * @extends DR
 */class TSNE extends DR{
/**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TSNE
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.perplexity = 50] - perplexity.
     * @param {Number} [parameters.epsilon = 10] - learning parameter.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {TSNE}
     */
constructor(t,e){return super(t,{perplexity:50,epsilon:10,d:2,metric:euclidean,seed:1212},e),[this._N,this._D]=this.X.shape,this._iter=0,this.Y=new Matrix(this._N,this.parameter("d"),(()=>this._randomizer.random)),this}
/**
     *
     * @param {Matrix} distance_matrix - accepts a precomputed distance matrix
     * @returns {TSNE}
     */init(){
// init
const t=Math.log(this.parameter("perplexity")),e=this._N,r=this._D,{metric:s}=this._parameters,i=this.X;let n;if("precomputed"==s)n=druid.Matrix.from(i);else{n=new Matrix(e,e);for(let t=0;t<e;++t){const r=i.row(t);for(let o=t+1;o<e;++o){const e=s(r,i.row(o));n.set_entry(t,o,e),n.set_entry(o,t,e)}}}const o=new Matrix(e,e,"zeros");this._ystep=new Matrix(e,r,"zeros"),this._gains=new Matrix(e,r,1);
// search for fitting sigma
let a=new Float64Array(e);for(let r=0;r<e;++r){let s=-1/0,i=1/0,h=1,l=!1,_=0;for(;!l;){let o=0;for(let t=0;t<e;++t){let e=Math.exp(-n.entry(r,t)*h);r===t&&(e=0),a[t]=e,o+=e}let c=0;for(let t=0;t<e;++t){let e=0===o?0:a[t]/o;a[t]=e,e>1e-7&&(c-=e*Math.log(e))}c>t?(s=h,h=i===1/0?2*h:(h+i)/2):(i=h,h=s===-1/0?h/2:(h+s)/2),++_,Math.abs(c-t)<1e-4&&(l=!0),_>=50&&(l=!0)}for(let t=0;t<e;++t)o.set_entry(r,t,a[t])}
//compute probabilities
const h=new Matrix(e,e,"zeros"),l=2*e;for(let t=0;t<e;++t)for(let r=t;r<e;++r){const e=Math.max((o.entry(t,r)+o.entry(r,t))/l,1e-100);h.set_entry(t,r,e),h.set_entry(r,t,e)}return this._P=h,this}
/**
     *
     * @param {Number} [iterations=500] - number of iterations.
     * @yields {Matrix|Array<Array>} - the projection.
     */transform(t=500){this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}
/**
     *
     * @param {Number} [iterations=500] - number of iterations.
     * @yields {Matrix|Array<Array>} - the projection.
     */*generator(t=500){this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}
/**
     * performs a optimization step
     * @private
     * @returns {Matrix}
     */next(){const t=++this._iter,e=this._P,r=this._ystep,s=this._gains,i=this._N,{d:n,epsilon:o}=this._parameters;let a=this.Y;
//calc cost gradient;
const h=t<100?4:1,l=new Matrix(i,i,"zeros");
// compute Q dist (unnormalized)
let _=0;for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){let r=0;for(let s=0;s<n;++s){const i=a.entry(t,s)-a.entry(e,s);r+=i*i}const s=1/(1+r);l.set_entry(t,e,s),l.set_entry(e,t,s),_+=2*s}
// normalize Q dist
const c=new Matrix(i,i,0);for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){const r=Math.max(l.entry(t,e)/_,1e-100);c.set_entry(t,e,r),c.set_entry(e,t,r)}const u=new Matrix(i,n,"zeros");for(let t=0;t<i;++t)for(let r=0;r<i;++r){const s=4*(h*e.entry(t,r)-c.entry(t,r))*l.entry(t,r);for(let e=0;e<n;++e)u.set_entry(t,e,u.entry(t,e)+s*(a.entry(t,e)-a.entry(r,e)))}
// perform gradient step
let d=new Float64Array(n);for(let e=0;e<i;++e)for(let i=0;i<n;++i){const n=u.entry(e,i),h=r.entry(e,i),l=s.entry(e,i);let _=Math.sign(n)===Math.sign(h)?.8*l:l+.2;_<.01&&(_=.01),s.set_entry(e,i,_);const c=(t<250?.5:.8)*h-o*_*n;r.set_entry(e,i,c),a.set_entry(e,i,a.entry(e,i)+c),d[i]+=a.entry(e,i)}for(let t=0;t<i;++t)for(let e=0;e<2;++e)a.set_entry(t,e,a.entry(t,e)-d[e]/i);return this.Y}}
/**
 *
 * @memberof module:optimization
 * @alias powell
 * @param {Function} f
 * @param {Array} x0
 * @param {Number} [max_iter = 300]
 * @returns {Array}
 * @see http://optimization-js.github.io/optimization-js/optimization.js.html#line438
 */function powell(t,e,r=300){const s=e.length;let i=.001,n=1e4,o=e.slice(),a=t(o),h=!1;for(;r-- >=0&&!h;){h=!0;for(let e=0;e<s;++e){o[e]+=1e-6;let r=t(o);o[e]-=1e-6;let s=(r-a)/1e-6;Math.abs(s)>.01&&(h=!1),o[e]-=i*s,a=t(o)}i*=n>=a?1.05:.4,n=a}return o}
/**
 * @class
 * @alias UMAP
 * @extends DR
 */class UMAP extends DR{
/**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias UMAP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.n_neighbors = 15] - size of the local neighborhood.
     * @param {Number} [parameters.local_connectivity = 1] - number of nearest neighbors connected in the local neighborhood.
     * @param {Number} [parameters.min_dist = 1] - controls how tightly points get packed together.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points in the high-dimensional space.
     * @param {Number} [parameters._spread = 1] - The effective scale of embedded points. (In combination with {@link parameters.min_dist})
     * @param {Number} [parameters._set_op_mix_ratio = 1] - Interpolate between union and intersection.
     * @param {Number} [parameters._repulsion_strength = 1]  - Weighting applied to negative samples.
     * @param {Number} [parameters._negative_sample_rate = 5] - The number of negative samples per positive sample.
     * @param {Number} [parameters._n_epochs = 350] - The number of training epochs.
     * @param {Number} [parameter._initial_alpha = 1] - The initial learning rate for the optimization.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {UMAP}
     */
constructor(t,e){super(t,{n_neighbors:15,local_connectivity:1,min_dist:1,d:2,metric:euclidean,seed:1212,_spread:1,_set_op_mix_ratio:1,_repulsion_strength:1,_negative_sample_rate:5,_n_epochs:350,_initial_alpha:1},e),[this._N,this._D]=this.X.shape;let r=Math.min(this._N-1,this.parameter("n_neighbors"));this.parameter("n_neighbors",r),this.parameter("local_connectivity",Math.min(this.parameter("local_connectivity"),r-1)),this._iter=0;const s=this._randomizer;return this.Y=new Matrix(this._N,this.parameter("d"),(()=>s.random)),this}
/**
     * @private
     * @param {Number} spread
     * @param {Number} min_dist
     * @returns {Array}
     */_find_ab_params(t,e){const r=linspace(0,3*t,300),s=linspace(0,3*t,300);for(let i=0,n=r.length;i<n;++i){const n=r[i];s[i]=n<e?1:Math.exp(-(n-e)/t)}return powell((t=>{const e=linspace(1,300).map(((e,i)=>{return s[i]-(n=r[i],o=t[0],a=t[1],1/(1+o*Math.pow(n,2*a)));var n,o,a}));return Math.sqrt(neumair_sum(e.map((t=>t*t))))}),[1,1])}
/**
     * @private
     * @param {Array<Array>} distances
     * @param {Array<Number>} sigmas
     * @param {Array<Number>} rhos
     * @returns {Array}
     */_compute_membership_strengths(t,e,r){for(let s=0,i=t.length;s<i;++s)for(let i=0,n=t[s].length;i<n;++i){const n=t[s][i].value-r[s];t[s][i].value=n>0?Math.exp(-n/e[s]):1}return t}
/**
     * @private
     * @param {KNN|BallTree} knn
     * @param {Number} k
     * @returns {Object}
     */_smooth_knn_dist(t,e){const r=1e-5,s=.001,{local_connectivity:i,metric:n}=this._parameters,o=Math.log2(e),a=[],h=[],l=this.X,_=l.shape[0],c=[];if("precomputed"===n)for(let r=0;r<_;++r)c.push(t.search(r,e).reverse());else for(const r of l)c.push(t.search(r,e).raw_data().reverse());for(let t=0;t<_;++t){let n=0,l=1/0,_=1;const u=c[t],d=u.filter((t=>t.value>0)),m=d.length;if(m>=i){const e=Math.floor(i),s=i-e;e>0?(a.push(d[e-1]),s>r&&(a[t].value+=s*(d[e].value-d[e-1]))):a[t].value=s*d[0].value}else m>0&&(a[t]=d[m-1].value);for(let s=0;s<64;++s){let s=0;for(let r=0;r<e;++r){const e=u[r].value-a[t];s+=e>0?Math.exp(-e/_):1}if(Math.abs(s-o)<r)break;s>o?[l,_]=[_,(n+l)/2]:[n,_]=l===1/0?[_,2*_]:[_,(n+l)/2]}h[t]=_;const p=u.reduce(((t,e)=>t+e.value),0)/u.length;
//let mean_d = null;
if(a[t]>0)h[t]<s*p&&(h[t]=s*p);else{const e=c.reduce(((t,e)=>t+e.reduce(((t,e)=>t+e.value),0)/e.length));h[t]>s*e&&(h[t]=s*e)}}return{distances:c,sigmas:h,rhos:a}}
/**
     * @private
     * @param {Matrix} X
     * @param {Number} n_neighbors
     * @returns {Matrix}
     */_fuzzy_simplicial_set(t,e){const r=t.shape[0],{metric:s}=this._parameters,i="precomputed"===s?new KNN(t,"precomputed"):new BallTree(t.to2dArray,s);let{distances:n,sigmas:o,rhos:a}=this._smooth_knn_dist(i,e);n=this._compute_membership_strengths(n,o,a);const h=new Matrix(r,r,"zeros");for(let t=0;t<r;++t){const e=n[t];for(let r=0;r<e.length;++r)h.set_entry(t,e[r].element.index,e[r].value)}const l=h.T,_=h.mult(l);return h.add(l).sub(_).mult(this._set_op_mix_ratio).add(_.mult(1-this.parameter("_set_op_mix_ratio")))}
/**
     * @private
     * @param {Number} n_epochs
     * @returns {Array}
     */_make_epochs_per_sample(t){const e=this._weights,r=new Float32Array(e.length).fill(-1),s=max(e),i=e.map((e=>t*(e/s)));for(let e=0;e<r.length;++e)i[e]>0&&(r[e]=Math.round(t/i[e]));return r}
/**
     * @private
     * @param {Matrix} graph
     * @returns {Object}
     */_tocoo(t){const e=[],r=[],s=[],[i,n]=t.shape;for(let o=0;o<i;++o)for(let i=0;i<n;++i){const n=t.entry(o,i);0!==n&&(e.push(o),r.push(i),s.push(n))}return{rows:e,cols:r,data:s}}
/**
     * Computes all necessary
     * @returns {UMAP}
     */init(){const{_spread:t,min_dist:e,n_neighbors:r,_n_epochs:s,_negative_sample_rate:i}=this._parameters,[n,o]=this._find_ab_params(t,e);this._a=n,this._b=o,this._graph=this._fuzzy_simplicial_set(this.X,r);const{rows:a,cols:h,data:l}=this._tocoo(this._graph);return this._head=a,this._tail=h,this._weights=l,this._epochs_per_sample=this._make_epochs_per_sample(s),this._epochs_per_negative_sample=this._epochs_per_sample.map((t=>t*i)),this._epoch_of_next_sample=this._epochs_per_sample.slice(),this._epoch_of_next_negative_sample=this._epochs_per_negative_sample.slice(),this}graph(){return this.check_init(),{cols:this._head,rows:this._tail,weights:this._weights}}
/**
     *
     * @param {Number} [iterations=350] - number of iterations.
     * @returns {Matrix|Array}
     */transform(t=350){this.parameter("_n_epochs")!=t&&(this.parameter("_n_epochs",t),this.init()),this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}
/**
     *
     * @param {Number} [iterations=350] - number of iterations.
     * @returns {Matrix|Array}
     */*generator(t=350){this.parameter("_n_epochs")!=t&&(this.parameter("_n_epochs",t),this.init()),this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}
/**
     * @private
     * @param {Number} x
     * @returns {Number}
     */_clip(t){return t>4?4:t<-4?-4:t}
/**
     * performs the optimization step.
     * @private
     * @param {Matrix} head_embedding
     * @param {Matrix} tail_embedding
     * @param {Matrix} head
     * @param {Matrix} tail
     * @returns {Matrix}
     */_optimize_layout(t,e,r,s){const{_d:i,_alpha:n,_repulsion_strength:o,_a:a,_b:h,_epochs_per_sample:l,_epochs_per_negative_sample:_,_epoch_of_next_negative_sample:c,_epoch_of_next_sample:u,_clip:d}=this,m=s.length;for(let p=0,f=l.length;p<f;++p)if(u[p]<=this._iter){const f=r[p],y=s[p],w=t.row(f),g=e.row(y),M=euclidean_squared(w,g);let x=0;M>0&&(x=-2*a*h*Math.pow(M,h-1)/(a*Math.pow(M,h)+1));for(let r=0;r<i;++r){const s=d(x*(w[r]-g[r]))*n,i=w[r]+s,o=g[r]-s;w[r]=i,g[r]=o,t.set_entry(f,r,i),e.set_entry(y,r,o)}u[p]+=l[p];const A=(this._iter-c[p])/_[p];for(let r=0;r<A;++r){const r=Math.floor(this._randomizer.random*m),l=e.row(s[r]),_=euclidean_squared(w,l);let c=0;if(_>0)c=2*o*h/((.01+_)*(a*Math.pow(_,h)+1));else if(f===r)continue;for(let o=0;o<i;++o){const i=d(c*(w[o]-l[o]))*n,a=w[o]+i,h=l[o]-i;w[o]=a,l[o]=h,t.set_entry(f,o,a),e.set_entry(s[r],o,h)}}c[p]+=A*_[p]}return t}
/**
     * @private
     * @returns {Matrix}
     */next(){let t=++this._iter,e=this.Y;return this._alpha=this.parameter("_initial_alpha")*(1-t/this.parameter("_n_epochs")),this.Y=this._optimize_layout(e,e,this._head,this._tail),this.Y}}
/**
 * @class
 * @alias TriMap
 * @extends DR
 */class TriMap extends DR{
/**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TriMap
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.weight_adj = 500] - scaling factor.
     * @param {Number} [parameters.c = 5] - number of triplets multiplier.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Number} [parameters.tol = 1e-8] -
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {TriMap}
     * @see {@link https://arxiv.org/pdf/1910.00204v1.pdf}
     * @see {@link https://github.com/eamid/trimap}
     */
constructor(t,e){return super(t,{weight_adj:500,c:5,d:2,metric:euclidean,tol:1e-8,seed:1212},e),this}
/**
     *
     * @param {Matrix} [pca = null] - Initial Embedding (if null then PCA gets used).
     * @param {KNN} [knn = null] - KNN Object (if null then BallTree gets used).
     */init(t=null,e=null){const r=this.X,s=r.shape[0],{d:i,metric:n,c:o}=this._parameters;this.n_inliers=2*o,this.n_outliers=1*o,this.n_random=1*o,this.Y=t||new PCA(r,i).transform(),this.knn=e||new BallTree(r.to2dArray,n);const{triplets:a,weights:h}=this._generate_triplets(this.n_inliers,this.n_outliers,this.n_random);return this.triplets=a,this.weights=h,this.lr=1e3*s/a.shape[0],this.C=1/0,this.vel=new Matrix(s,i,0),this.gain=new Matrix(s,i,1),this}
/**
     * Generates {@link n_inliers} x {@link n_outliers} x {@link n_random} triplets.
     * @param {Number} n_inliers
     * @param {Number} n_outliers
     * @param {Number} n_random
     */_generate_triplets(t,e,r){const{metric:s,weight_adj:i}=this._parameters,n=this.X,o=n.shape[0],a=this.knn,h=Math.min(t+20,o),l=new Matrix(o,h),_=new Matrix(o,h);for(let t=0;t<o;++t)a.search(n.row(t),h+1).raw_data().filter((t=>0!=t.value)).sort(((t,e)=>t.value-e.value)).forEach(((e,r)=>{l.set_entry(t,r,e.element.index),_.set_entry(t,r,e.value)}));
// scale parameter
const c=new Float64Array(o);for(let t=0;t<o;++t)c[t]=Math.max((_.entry(t,3)+_.entry(t,4)+_.entry(t,5)+_.entry(t,6))/4,1e-10);const u=this._find_p(_,c,l);let d=this._sample_knn_triplets(u,l,t,e),m=d.shape[0];const p=new Float64Array(m);for(let t=0;t<m;++t){const e=d.entry(t,0),r=d.entry(t,2);p[t]=s(n.row(e),n.row(r))}let f=this._find_weights(d,u,l,p,c);if(r>0){const{random_triplets:t,random_weights:e}=this._sample_random_triplets(n,r,c);d=d.concat(t,"vertical"),f=Float64Array.from([...f,...e])}m=d.shape[0];let y=-1/0;for(let t=0;t<m;++t)isNaN(f[t])&&(f[t]=0),y<f[t]&&(y=f[t]);let w=-1/0;for(let t=0;t<m;++t)f[t]/=y,f[t]+=1e-4,f[t]=Math.log(1+i*f[t]),w<f[t]&&(w=f[t]);for(let t=0;t<m;++t)f[t]/=w;return{triplets:d,weights:f}}
/**
     * Calculates the similarity matrix P
     * @private
     * @param {Matrix} knn_distances - matrix of pairwise knn distances
     * @param {Float64Array} sig - scaling factor for the distances
     * @param {Matrix} nbrs - nearest neighbors
     * @returns {Matrix} pairwise similarity matrix
     */_find_p(t,e,r){const[s,i]=t.shape;return new Matrix(s,i,((s,i)=>Math.exp(-(t.entry(s,i)**2)/e[s]/e[r.entry(s,i)])))}
/**
     * Sample nearest neighbors triplets based on the similarity values given in P.
     * @private
     * @param {Matrix} P - Matrix of pairwise similarities between each point and its neighbors given in matrix nbrs.
     * @param {Matrix} nbrs - Nearest neighbors indices for each point. The similarity values are given in matrix {@link P}. Row i corresponds to the i-th point.
     * @param {Number} n_inliers - Number of inlier points.
     * @param {Number} n_outliers - Number of outlier points.
     *
     */_sample_knn_triplets(t,e,r,s){const i=e.shape[0],n=new Matrix(i*r*s,3);for(let o=0;o<i;++o){let a=o*r*s;const h=this.__argsort(t.row(o).map((t=>-t)));for(let t=0;t<r;++t){let r=t*s;const l=e.entry(o,h[t]),_=this._rejection_sample(s,i,h.slice(0,t+1));for(let t=0;t<s;++t){const e=a+r+t,s=_[t];n.set_entry(e,0,o),n.set_entry(e,1,l),n.set_entry(e,2,s)}}}return n}
/**
     * Should do the same as np.argsort()
     * @private
     * @param {Array} A
     */__argsort(t){return t.map(((t,e)=>({d:t,i:e}))).sort(((t,e)=>t.d-e.d)).map((t=>t.i))}
/**
     * Samples {@link n_samples} integers from a given interval [0, {@link max_int}] while rejection the values that are in the {@link rejects}.
     * @private
     * @param {*} n_samples
     * @param {*} max_int
     * @param {*} rejects
     */_rejection_sample(t,e,r){const s=this._randomizer,i=linspace(0,e-1).filter((t=>r.indexOf(t)<0));return s.choice(i,Math.min(t,i.length-2))}
/**
     * Calculates the weights for the sampled nearest neighbors triplets
     * @private
     * @param {Matrix} triplets - Sampled Triplets.
     * @param {Matrix} P - Pairwise similarity matrix.
     * @param {Matrix} nbrs - nearest Neighbors
     * @param {Float64Array} outlier_distances - Matrix of pairwise outlier distances
     * @param {Float64Array} sig - scaling factor for the distances.
     */_find_weights(t,e,r,s,i){const n=t.shape[0],o=new Float64Array(n);for(let a=0;a<n;++a){const n=t.entry(a,0),h=r.row(n).indexOf(t.entry(a,1)),l=e.entry(n,h);let _=Math.exp(-(s[a]**2)/(i[n]*i[t.entry(a,2)]));_<1e-20&&(_=1e-20),o[a]=l/_}return o}
/**
     * Sample uniformly ranom triplets
     * @private
     * @param {Matrix} X - Data matrix.
     * @param {Number} n_random - Number of random triplets per point
     * @param {Float64Array} sig - Scaling factor for the distances
     */_sample_random_triplets(t,e,r){const s=this.parameter("metric"),i=this._randomizer,n=t.shape[0],o=new Matrix(n*e,3),a=new Float64Array(n*e);for(let h=0;h<n;++h){const l=h*e,_=[...linspace(0,h-1),...linspace(h+1,n-1)];for(let n=0;n<e;++n){let[e,c]=i.choice(_,2),u=Math.exp(-(s(t.row(h),t.row(e))**2)/(r[h]*r[e]));u<1e-20&&(u=1e-20);let d=Math.exp(-(s(t.row(h),t.row(c))**2)/(r[h]*r[c]));d<1e-20&&(d=1e-20),u<d&&([e,c]=[c,e],[u,d]=[d,u]);const m=l+n;o.set_entry(m,0,h),o.set_entry(m,1,e),o.set_entry(m,2,c),a[m]=u/d}}return{random_triplets:o,random_weights:a}}
/**
     * Computes the gradient for updating the embedding.
     * @param {Matrix} Y - The embedding
     */_grad(t){const e=this.n_inliers,r=this.n_outliers,s=this.triplets,i=this.weights,[n,o]=t.shape,a=s.shape[0],h=new Matrix(n,o,0);let l=new Float64Array(o),_=new Float64Array(o),c=1,u=1,d=0,m=0;const p=n*e*r;for(let e=0;e<a;++e){const[n,a,f]=s.row(e);
// update y_ij, y_ik, d_ij, d_ik
if(e%r==0||e>=p){c=1,u=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(a,e),i=t.entry(f,e);l[e]=r-s,_[e]=r-i,c+=l[e]**2,u+=_[e]**2}
// update y_ik and d_ik only
}else{u=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(f,e);_[e]=r-s,u+=_[e]**2}}c>u&&++d,m+=i[e]/(1+u/c);const y=(i[e]/(c+u))**2;for(let t=0;t<o;++t){const e=l[t]*u*y,r=_[t]*c*y;h.set_entry(n,t,h.entry(n,t)+e-r),h.set_entry(a,t,h.entry(a,t)-e),h.set_entry(f,t,h.entry(f,t)+r)}}return{grad:h,loss:m,n_viol:d}}
/**
     *
     * @param {Number} max_iteration
     */transform(t=400){this.check_init();for(let e=0;e<t;++e)this._next(e);return this.projection}
/**
     * @param {Number} max_iteration
     * @yields {Matrix}
     * @returns {Matrix}
     */*generator(t=800){this.check_init();for(let e=0;e<t;++e)this._next(e),yield this.projection;return this.projection}
/**
     * Does the iteration step.
     * @private
     * @param {Number} iter
     */_next(t){const e=t>150?.5:.3,r=this.C,s=this.vel,i=this.Y.add(s.mult(e)),{grad:n,loss:o,n_viol:a}=this._grad(i);return this.C=o,this.Y=this._update_embedding(i,t,n),this.lr*=r>o+this._parameters.tol?1.01:.9,this.Y}
/**
     * Updates the embedding.
     * @private
     * @param {Matrix} Y
     * @param {Number} iter
     * @param {Matrix} grad
     */_update_embedding(t,e,r){const[s,i]=t.shape,n=e>150?.9:.5,o=this.gain,a=this.vel,h=this.lr;for(let e=0;e<s;++e)for(let s=0;s<i;++s){const i=Math.sign(a.entry(e,s))!=Math.sign(r.entry(e,s))?o.entry(e,s)+.2:Math.max(.8*o.entry(e,s),.01);o.set_entry(e,s,i),a.set_entry(e,s,n*a.entry(e,s)-h*o.entry(e,s)*r.entry(e,s)),t.set_entry(e,s,t.entry(e,s)+a.entry(e,s))}return t}}
/**
 * @class
 * @alias Hierarchical_Clustering
 */class Hierarchical_Clustering{
/**
     * @constructor
     * @memberof module:clustering
     * @alias Hierarchical_Clustering
     * @todo needs restructuring.
     * @param {Matrix} - Data or distance matrix if metric is 'precomputed'
     * @param {("single"|"complete"|"average")} [linkage = "complete"]
     * @param {Function|"precomputed"} [metric = euclidean]
     * @returns {Hierarchical_Clustering}
     */
constructor(t,e="complete",r=euclidean){if(this._id=0,this._matrix=t instanceof Matrix?t:Matrix.from(t),this._metric=r,this._linkage=e,"precomputed"===r&&this._matrix.shape[0]!==this._matrix.shape[1])throw new Error("If metric is 'precomputed', then matrix has to be square!");return this.init(),this.root=this.do(),this}
/**
     *
     * @param {Number} value - value where to cut the tree.
     * @param {("distance"|"depth")} [type = "distance"] - type of value.
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}.
     */get_clusters(t,e="distance"){let r,s=[];switch(e){case"distance":r=t=>t.dist;break;case"depth":r=t=>t.depth;break;default:throw new Error("invalid type")}return this._traverse(this.root,r,t,s),s}
/**
     * @private
     * @param {} node
     * @param {*} f
     * @param {*} value
     * @param {*} result
     */_traverse(t,e,r,s){e(t)<=r?s.push(t.leaves()):(this._traverse(t.left,e,r,s),this._traverse(t.right,e,r,s))}
/**
     * computes the tree.
     */init(){const t=this._metric,e=this._matrix,r=this._n=e.shape[0],s=this._d_min=new Float64Array(r);let i;if("precomputed"!==t){i=new Matrix(r,r,0);//new Array(n);
for(let n=0;n<r;++n){s[n]=0;
//distance_matrix[i] = new Float64Array(n);
for(let o=0;o<r;++o)i.set_entry(n,o,n===o?1/0:t(e.row(n),e.row(o))),i.entry(n,s[n])>i.entry(n,o)&&(s[n]=o)}}else{i=this._matrix.clone();for(let t=0;t<r;++t)for(let e=0;e<r;++e)t===e?i.set_entry(t,e,1/0):i.entry(t,s[t])>i.entry(t,e)&&(s[t]=e)}this._distance_matrix=i;const n=this._clusters=new Array(r),o=this._c_size=new Uint16Array(r);for(let t=0;t<r;++t)n[t]=[],n[t][0]=new Cluster(this._id++,null,null,0,e.row(t),t,1,0),o[t]=1;return this}
/**
     * computes the tree.
     */do(){const t=this._n,e=this._d_min,r=this._distance_matrix,s=this._clusters,i=this._c_size,n=this._linkage;let o=null;for(let a=0,h=t-1;a<h;++a){let a=0;for(let s=0;s<t;++s){let i=r.entry(s,e[s]);for(let n=s+1;n<t;++n)i>r.entry(s,n)&&(e[s]=n,i=r.entry(s,e[s]))}for(let s=0;s<t;++s)r.entry(s,e[s])<r.entry(a,e[a])&&(a=s);let h=e[a],l=s[a][0],_=s[h][0],c=l.isLeaf?[l.index]:l.index,u=_.isLeaf?[_.index]:_.index,d=c.concat(u),m=new Cluster(this._id++,l,_,r.entry(a,h),null,d);l.parent=m,_.parent=m,s[a].unshift(m),i[a]+=i[h];for(let e=0;e<t;++e){const t=r.entry(a,e),s=r.entry(h,e);let o;switch(n){case"single":o=Math.min(t,s);break;case"complete":o=Math.max(t,s);break;case"average":o=(i[a]*t+i[h]*s)/(i[a]+i[e])}r.set_entry(e,a,o),r.set_entry(a,e,o)}r.set_entry(a,a,1/0);for(let e=0;e<t;++e)r.set_entry(e,h,1/0),r.set_entry(h,e,1/0);
/* for (let j = 0; j < n; ++j) {
                if (d_min[j] === c2) {
                    d_min[j] = c1;
                }
                if (D.entry(c1, j) < D.entry(c1, d_min[c1])) {
                    d_min[c1] = j;
                }
            } */o=m}return o}}class Cluster{constructor(t,e,r,s,i,n,o,a){return this.id=t,this.left=e,this.right=r,this.dist=s,this.index=n,this.size=o??e.size+r.size,this.depth=a??1+Math.max(e.depth,r.depth),this.centroid=i??this._calculate_centroid(e,r),this.parent=null,this}_calculate_centroid(t,e){const r=t.size,s=e.size,i=t.centroid,n=e.centroid,o=this.size,a=t.centroid.length,h=new Float64Array(a);for(let t=0;t<a;++t)h[t]=(r*i[t]+s*n[t])/o;return h}get isLeaf(){return 0===this.depth}leaves(){if(this.isLeaf)return[this];const t=this.left,e=this.right;return(t.isLeaf?[t]:t.leaves()).concat(e.isLeaf?[e]:e.leaves())}descendants(){if(this.isLeaf)return[this];const t=this.left.descendants(),e=this.right.descendants();return t.concat(e).concat([this])}}
/**
 * @class
 * @alias KMeans
 */class KMeans{
/**
     * @constructor
     * @memberof module:clustering
     * @alias KMeans
     * @todo needs restructuring. 
     * @param {Matrix} matrix 
     * @param {Numbers} K 
     * @param {Function} [metric = euclidean] 
     * @param {Number} [seed = 1987]
     * @param {Boolean} [init = true]
     * @returns {KMeans}
     */
constructor(t,e,r=euclidean,s=1987,i=!0){this._metric=r,this._matrix=t,this._K=e;const[n,o]=t.shape;return this._N=n,this._D=o,e>n&&(e=n),this._randomizer=new Randomizer(s),this._clusters=new Array(n).fill(void 0),this._cluster_centroids=this._get_random_centroids(e),i&&this.init(e,this._cluster_centroids),this}
/**
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. 
     */get_clusters(){const t=this._K,e=this._clusters,r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>r[t].push(e))),r}
/**
     * @private
     * @param {Array} points 
     * @param {Array} candidates 
     */_furthest_point(t,e){const r=this._matrix,s=this._metric;let i=t.length;return Heap.heapify(e,(e=>{const n=r.row(e);let o=0;for(let e=0;e<i;++e)o+=s(n,t[e]);return o}),"max").pop().element}_get_random_centroids(t){const e=this._N,r=this._randomizer,s=this._matrix,i=new Array(t).fill(),n=linspace(0,e-1),o=r.random_int%(e-1);i[0]=s.row(o);const a=[o],h=Math.floor((e-t)/t);// / K
for(let e=1;e<t;++e){
// sampling + kmeans++ improvement?
const t=r.choice(n.filter((t=>-1==a.indexOf(t))),h),o=this._furthest_point(i.slice(0,e),t);a.push(o),i[e]=s.row(o)}return i}_iteration(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._metric,o=this._clusters;let a=!1;
// find nearest cluster centroid.
for(let s=0;s<r;++s){const r=i.row(s);let h=1/0,l=null;for(let s=0;s<e;++s){let e=n(t[s],r);e<h&&(h=e,l=s)}o[s]!==l&&(a=!0),o[s]=l}
// update cluster centroid
// reset cluster centroids to 0
for(let r=0;r<e;++r){const e=t[r];for(let t=0;t<s;++t)e[t]=0}
// compute centroid
return this._compute_centroid(t),{clusters_changed:a,cluster_centroids:t}}_compute_centroid(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._clusters,o=new Array(e).fill(0);for(let e=0;e<r;++e){const r=i.row(e),a=n[e];o[a]++;const h=t[a];for(let t=0;t<s;++t)h[t]+=r[t]}for(let r=0;r<e;++r){const e=o[r];t[r]=t[r].map((t=>t/e))}}
/**
     * Computes {@link K} clusters out of the {@link matrix}.
     * @param {Number} K - number of clusters.
     */init(t,e){t||(t=this._K),e||(e=this._get_random_centroids(t));let r=!1;do{const t=this._iteration(e);e=t.cluster_centroids,r=t.clusters_changed}while(r)}}
/**
 * @class
 * @alias KMedoids
 */class KMedoids{
/**
     * @constructor
     * @memberof module:clustering
     * @alias KMedoids
     * @todo needs restructuring. 
     * @param {Matrix} matrix - data matrix
     * @param {Numbers} K - number of clusters
     * @param {number} [max_iter=null] - maximum number of iterations. Default is 10 * Math.log10(N)
     * @param {Function} [metric = euclidean] - metric defining the dissimilarity 
     * @param {Number} [seed = 1212] - seed value for random number generator
     * @returns {KMedoids}
     * @see {@link https://link.springer.com/chapter/10.1007/978-3-030-32047-8_16} Faster k-Medoids Clustering: Improving the PAM, CLARA, and CLARANS Algorithms
     */
constructor(t,e,r=null,s=euclidean,i=1212){this._metric=s,this._matrix=t,this._A=this._matrix.to2dArray,this._K=e;const[n,o]=t.shape;return this._N=n,this._D=o,this._max_iter=r||10*Math.log10(n),this._distance_matrix=new Matrix(n,n,"zeros"),
/* for (let i = 1; i < N; ++i) {
            for (let j = i + 1; j < N; ++j) {
                let dist = metric(this._A[i], this._A[j]);
                this._distance_matrix.set_entry(i, j, dist);
                this._distance_matrix.set_entry(j, i, dist)
            }
        } */
e>n&&(e=n),this._randomizer=new Randomizer(i),this._clusters=new Array(n).fill(void 0),this._cluster_medoids=this._get_random_medoids(e),
//if (init) this.init(K, this._cluster_medoids);
this._is_initialized=!1,this}
/**
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. 
     */get_clusters(){const t=this._K,e=this._A;this._is_initialized||this.init(t,this._cluster_medoids);const r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>{r[this._nearest_medoid(t,e).index_nearest].push(e)})),r.medoids=this._cluster_medoids,r}async*generator(){const t=this._max_iter;yield this.get_clusters();let e=!1,r=0;do{e=this._iteration(),yield this.get_clusters()}while(!e&&++r<t)}
/**
     * Algorithm 1. FastPAM1: Improved SWAP algorithm
     */
/* _iteration_1() {
        const A = this._A;
        const N = this._N;
        const K = this._K;
        const medoids = this._cluster_medoids;
        let DeltaTD = 0;
        let m0 = null;
        let x0 = null;
        A.forEach((x_j, j) => {
            if (medoids.findIndex(m => m === j) < 0) {
                const nearest_medoid = this._nearest_medoid(x_j, j);
                const d_j = nearest_medoid.distance_nearest; // distance to current medoid
                const deltaTD = new Array(K).fill(-d_j); // change if making j a medoid
                A.forEach((x_o, o) => {
                    // disance to new medoid
                    const d_oj = this._get_distance(o, j, x_o, x_j);
                    const {
                        "index_nearest": n,
                        "distance_nearest": d_n,
                        "distance_second": d_s,
                    } = this._nearest_medoid(x_o, o); 
                    this._clusters[o] = n; // cached values
                    deltaTD[n] += Math.min(d_oj, d_s) - d_n; // loss change
                    if (d_oj < d_n) { // reassignment check
                        deltaTD.forEach((d_i, i) => {
                            if (n !== i) {
                                deltaTD[i] = d_i + d_oj - d_n; // update loss change
                            }
                        });
                    }
                });
                // choose best medoid i;
                const i = deltaTD
                    .map((d, i) => [d, i])
                    .sort((d1, d2) => d1[0] - d2[0])[0][1];
                const deltaTD_i = deltaTD[i];
                // store
                if (deltaTD_i < DeltaTD) {
                    DeltaTD = deltaTD_i;
                    m0 = i;
                    x0 = j;
                }
            }
        });

        if (DeltaTD >= 0) {
            return true // break loop if DeltaTD >= 0
        }
        // swap roles of medoid m and non-medoid x;
        medoids[m0] = x0;
        this._cluster_medoids = medoids;
        return false
    } */
/** Algorithm 2. FastPAM2: SWAP with multiple candidates
     * 
     */_iteration(){const t=this._A,e=this._K,r=this._cluster_medoids,s=t.map(((t,e)=>this._nearest_medoid(t,e))),i=new Array(e).fill(0),n=new Array(e).fill(null);
// stop if no improvements were found
if(t.forEach(((o,a)=>{if(r.findIndex((t=>t===a))<0){const r=s[a].distance_nearest,h=new Array(e).fill(-r);// distance to current medoid
// change if making j a medoid
t.forEach(((t,r)=>{if(a===r)return;const i=this._get_distance(r,a,t,o),{index_nearest:n,distance_nearest:l,distance_second:_}=s[r];// distance to new medoid
// loss change for x_o
// Reassignment check
if(// cached
h[n]+=Math.min(i,_)-l,i<l)
// update loss change
for(let t=0;t<e;++t)t!==n&&(h[t]+=i-l)})),
// remember best swap for i;
h.map(((t,e)=>[t,e])).filter((([t,e])=>t<i[e])).forEach((([t,e])=>{t<i[e]&&(i[e]=t,n[e]=a)}))}})),min(i)>=0)return!0;
// execute all improvements
for(;min(i)<0;){
// swap roles of medoid m_i and non_medoid xs_i
const e=i.map(((t,e)=>[t,e])).sort((([t],[e])=>t-e))[0][1];0==r.filter((t=>t==n[e])).length&&(r[e]=n[e]),
// disable the swap just performed
i[e]=0,
// recompute TD for remaining swap candidates
i.map(((t,e)=>[t,e])).filter((([t])=>t<0)).forEach((([n,o])=>{const a=t[o];let h=0;t.forEach(((t,i)=>{r.findIndex((t=>t!=o&&t==i))>=0||e!=o&&(s[i].index_nearest===r[o]?h+=Math.min(this._get_distance(i,o,t,a),s[i].distance_second)-s[i].distance_nearest:h+=Math.min(this._get_distance(i,o,t,a)-s[i].distance_nearest,0))})),i[o]=h}))}return this._cluster_medoids=r,!1}_get_distance(t,e,r=null,s=null){if(t===e)return 0;const i=this._distance_matrix,n=this._A,o=this._metric;let a=i.entry(t,e);return 0===a&&(a=o(r||n[t],s||n[e]),i.set_entry(t,e,a),i.set_entry(e,t,a)),a}_nearest_medoid(t,e){const r=this._cluster_medoids,s=this._A,[i,n]=r.map(((r,i)=>{const n=s[r];return[this._get_distance(e,r,t,n),i]})).sort(((t,e)=>t[0]-e[0]));return{distance_nearest:i[0],index_nearest:i[1],distance_second:n[0],index_second:n[1]}}
/**
     * Computes {@link K} clusters out of the {@link matrix}.
     * @param {Number} K - number of clusters.
     */init(t,e){t||(t=this._K),e||(e=this._get_random_medoids(t));const r=this._max_iter;let s=!1,i=0;do{s=this._iteration()}while(!s&&++i<r);return this}
/**
     * Algorithm 3. FastPAM LAB: Linear Approximate BUILD initialization.
     * @param {number} K - number of clusters
     * 
     */_get_random_medoids(t){const e=this._N,r=this._A,s=linspace(0,e-1),i=this._randomizer,n=Math.min(e,10+Math.ceil(Math.sqrt(e))),o=new Array(n).fill(1/0),a=[];
// first medoid
let h=1/0,l=i.choice(s,n);for(let t=0;t<n;++t){const e=l[t],s=r[e];for(let e=0;e<n;++e){if(e===t)continue;const i=r[l[e]];o[t]+=this._get_distance(t,e,s,i)}o[t]<h&&(h=o[t],// smallest distance sum
a.push(e))}
// other medoids
for(let e=1;e<t;++e){let t=1/0;l=i.choice(s.filter((t=>a.findIndex((e=>e===t))<0)),n);for(let e=0;e<n;++e){let s=0;const i=l[e],o=r[i];for(let t=0;t<n;++t){if(t===e)continue;const n=l[t],h=r[n];let _=this._get_distance(i,n,o,h)-min(a.map((t=>this._get_distance(n,t,h))));_<0&&(s+=_)}
// best reduction
s<t&&(t=s,a.push(i))}h+=t}return a.slice(0,t)}}
/**
 * @class
 * @alias OPTICS
 */class OPTICS{
/**
     * **O**rdering **P**oints **T**o **I**dentify the **C**lustering **S**tructure.
     * @constructor
     * @memberof module:clustering
     * @alias OPTICS
     * @todo needs restructuring. 
     * @param {Matrix} matrix - the data.
     * @param {Number} epsilon - the minimum distance which defines whether a point is a neighbor or not.
     * @param {Number} min_points - the minimum number of points which a point needs to create a cluster. (Should be higher than 1, else each point creates a cluster.)
     * @param {Function} [metric = euclidean] - the distance metric which defines the distance between two points of the {@link matrix}.
     * @returns {OPTICS}
     * @see {@link https://www.dbs.ifi.lmu.de/Publikationen/Papers/OPTICS.pdf}
     * @see {@link https://en.wikipedia.org/wiki/OPTICS_algorithm}
     */
constructor(t,e,r,s=euclidean){return this._matrix=t,this._epsilon=e,this._min_points=r,this._metric=s,this._ordered_list=[],this._clusters=[],this._DB=new Array(t.shape[0]).fill(),this.init(),this}
/**
     * Computes the clustering.
     */init(){const t=this._ordered_list,e=this._matrix,r=e.shape[0],s=this._DB,i=this._clusters;let n=this._cluster_index=0;for(let t=0;t<r;++t)s[t]={element:e.row(t),index:t,reachability_distance:void 0,processed:!1};for(const e of s)if(!e.processed&&(e.neighbors=this._get_neighbors(e),e.processed=!0,i.push([e.index]),n=i.length-1,t.push(e),null!=this._core_distance(e))){const t=new Heap(null,(t=>t.reachability_distance),"min");this._update(e,t),this._expand_cluster(t,i[n])}return this}
/**
     * 
     * @private
     * @param {Object} p - a point of {@link matrix}.
     * @returns {Array} An array consisting of the {@link epsilon}-neighborhood of {@link p}.
     */_get_neighbors(t){if("neighbors"in t)return t.neighbors;const e=this._DB,r=this._metric,s=this._epsilon,i=[];for(const n of e)n.index!=t.index&&r(t.element,n.element)<s&&i.push(n);return i}
/**
     * 
     * @private
     * @param {Object} p - a point of {@link matrix}.
     * @returns {Number} The distance to the {@link min_points}-th nearest point of {@link p}, or undefined if the {@link epsilon}-neighborhood has fewer elements than {@link min_points}.
     */_core_distance(t){const e=this._min_points,r=this._metric;if(!(t.neighbors&&t.neighbors.length<=e))return r(t.element,t.neighbors[e].element)}
/**
     * Updates the reachability distance of the points.
     * @private
     * @param {Object} p 
     * @param {Heap} seeds 
     */_update(t,e){const r=this._metric,s=this._core_distance(t),i=this._get_neighbors(t);//p.neighbors;
for(const n of i){if(n.processed)continue;const i=Math.max(s,r(t.element,n.element));
//if (q.reachability_distance == undefined) { // q is not in seeds
e.raw_data().findIndex((t=>t.element==n))<0?(n.reachability_distance=i,e.push(n)):// q is in seeds
i<n.reachability_distance&&(n.reachability_distance=i,e=Heap.heapify(e.data(),(t=>t.reachability_distance),"min"))}}
/**
     * Expands the {@link cluster} with points in {@link seeds}.
     * @private
     * @param {Heap} seeds 
     * @param {Array} cluster 
     */_expand_cluster(t,e){const r=this._ordered_list;for(;!t.empty;){const s=t.pop().element;s.neighbors=this._get_neighbors(s),s.processed=!0,e.push(s.index),r.push(s),null!=this._core_distance(s)&&(this._update(s,t),this._expand_cluster(t,e))}}
/**
     * Returns an array of clusters.
     * @returns {Array<Array>} Array of clusters with the indices of the rows in given {@link matrix}.
     */get_clusters(){const t=[],e=[],r=this._min_points;for(const s of this._clusters)s.length<r?e.push(...s):t.push(s);return t.push(e),t}
/**
     * @returns {Array} Returns an array, where the ith entry defines the cluster affirmation of the ith point of {@link matrix}. (-1 stands for outlier)
     */get_cluster_affirmation(){const t=this._matrix.shape[0],e=new Array(t).fill(),r=this.get_clusters();for(let t=0,s=r.length;t<s;++t){const i=r[t];for(const r of i)e[r]=t<s-1?t:-1}return e}}
/**
 * @class
 * @alias LSP
 * @extends DR
 */class LSP extends DR{
/**
     * Least Squares Projection.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LSP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.neighbors = Math.max(Math.floor(N / 10), 2)] - number of neighbors to consider.
     * @param {Number} [parameters.control_points = Math.ceil(Math.sqrt(N))] - number of controlpoints
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {LSP}
     * @see {@link https://ieeexplore.ieee.org/document/4378370}
     * @todo accept precomputed distance matrix.
     */
constructor(t,e){return super(t,{neighbors:void 0,control_points:void 0,d:2,metric:euclidean,seed:1212},e),this.parameter("neighbors",Math.min(e.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this.parameter("control_points",Math.min(e.control_points??Math.ceil(Math.sqrt(this._N)),this._N-1)),this._is_initialized=!1,this}
/**
     *
     * @param {DR} DR - method used for position control points.
     * @param {Object} DR_parameters - Object containing parameters for the DR method which projects the control points
     * @returns {LSP}
     */init(t=MDS,e={},r=BallTree){if(this._is_initialized)return this;const s=this.X,i=this._N,n=this.parameter("neighbors"),o=this.parameter("d"),a=this.parameter("seed"),h=this.parameter("metric");e=Object.assign({d:o,metric:h,seed:a},e);const l=this.parameter("control_points"),_=new KMedoids(s,l,null,h).get_clusters().medoids,c=new Matrix(l,i,"zeros");_.forEach(((t,e)=>{c.set_entry(e,t,1)}));const u=new t(Matrix.from(_.map((t=>s.row(t)))),e).transform(),d=s.to2dArray,m=new r(d,h),p=new Matrix(i,i,"I"),f=-1/n;d.forEach(((t,e)=>{for(const{index:r}of m.search(t,n).iterate())e!==r&&p.set_entry(e,r,f)}));const y=p.concat(c,"vertical"),w=new Matrix(i,o,"zeros").concat(u,"vertical");return this._A=y,this._b=w,this._is_initialized=!0,this}
/**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */transform(){this.check_init();const t=this._A,e=t.T,r=this._b,s=e.dot(t),i=e.dot(r);return this.Y=Matrix.solve_CG(s,i,this._randomizer),this.projection}}
/**
 * @class
 * @alias TopoMap
 * @memberof module:dimensionality_reduction
 * @extends DR
 */class TopoMap extends DR{
/**
     * TopoMap: A 0-dimensional Homology Preserving Projection of High-Dimensional Data.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TopoMap
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {TopoMap}
     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}
     */
constructor(t,e){return super(t,{metric:euclidean,seed:1212},e),[this._N,this._D]=this.X.shape,this._distance_matrix=new Matrix(this._N,this._N,0),this}
/**
     * @private
     */__lazy_distance_matrix(t,e,r){const s=this._distance_matrix,i=this.X,n=s.entry(t,e);if(0===n){let n=r(i.row(t),i.row(e));return s.set_entry(t,e,n),s.set_entry(e,t,n),n}return n}
/**
     * Computes the minimum spanning tree, using a given metric
     * @private
     * @param {Function} metric
     * @see {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}
     */_make_minimum_spanning_tree(t=euclidean){const e=this._N,r=[...this.X];let s=new DisjointSet(r);const i=[];let n=[];for(let r=0;r<e;++r)for(let s=r+1;s<e;++s)n.push([r,s,this.__lazy_distance_matrix(r,s,t)]);n=n.sort(((t,e)=>t[2]-e[2]));for(const[t,e,o]of n){const n=s.find(r[t]),a=s.find(r[e]);n!==a&&(i.push([t,e,o]),s.union(n,a))}return i.sort(((t,e)=>t[2]-e[2]))}
/**
     * initializes TopoMap. Sets all projcted points to zero, and computes a minimum spanning tree.
     */init(){const{metric:t}=this._parameters;return this.Y=new Matrix(this._N,2,0),this._Emst=this._make_minimum_spanning_tree(t),this._is_initialized=!0,this}
/**
     * Returns true if Point C is left of line AB.
     * @private
     * @param {Array} PointA - Point A of line AB
     * @param {Array} PointB - Point B of line AB
     * @param {Array} PointC - Point C
     * @returns {Boolean}
     */__hull_cross([t,e],[r,s],[i,n]){return(r-t)*(n-e)-(s-e)*(i-t)<=0}
/**
     * Computes the convex hull of the set of Points S
     * @private
     * @param {Array} S - Set of Points.
     * @see {@link https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript}
     * @returns {Array} convex hull of S. Starts at the bottom-most point and continues counter-clockwise.
     */__hull(t){const e=t.sort((([t,e],[r,s])=>e-s||t-r)),r=e.length;if(r<=2)return e;const s=[];for(let t=0;t<r;++t){for(;s.length>=2&&this.__hull_cross(s[s.length-2],s[s.length-1],e[t]);)s.pop();s.push(e[t])}const i=[];for(let t=r-1;t>=0;--t){for(;i.length>=2&&this.__hull_cross(i[i.length-2],i[i.length-1],e[t]);)i.pop();i.push(e[t])}return i.pop(),s.pop(),s.concat(i)}
/**
     * Finds the angle to rotate Point A and B to lie on a line parallel to the x-axis.
     * @private
     * @param {Array} PointA
     * @param {Array} PointB
     * @return {Object} Object containing the sinus- and cosinus-values for a rotation.
     */__findAngle([t,e],[r,s]){const i=euclidean([t,e],[r,s]);if(0===i)return{sin:0,cos:1};const n=[(r-t)/i,(s-e)/i],o=n[0];let a=Math.sqrt(1-o*o);return a=n[1]>=0?-a:a,{sin:a,cos:o}}
/**
     * @private
     * @param {Array} hull
     * @param {Array} p
     * @param {Bool} topEdge
     */__align_hull(t,e,r){let s,i,n,o=-1;for(let r=0;r<t.length;++r){const i=euclidean(t[r],e);(-1===o||s>i)&&(s=i,o=r)}r?(i=t[o],n=t[(o+1)%t.length]):(0==o&&(o=t.length-1),i=t[o],n=t[(o-1)%t.length]);const a={tx:-t[o][0],ty:-t[o][1]};if(t.length>=2){const{sin:t,cos:e}=this.__findAngle(i,n);a.sin=t,a.cos=e}else a.sin=0,a.cos=1;return a}
/**
     * @private
     * @param {Array} Point - The point which should get transformed.
     * @param {Object} Transformation - contains the values for translation and rotation.
     */__transform([t,e],{tx:r,ty:s,sin:i,cos:n}){let o=t+r,a=e+s;return[o*n-a*i,o*i+a*n]}
/**
     * Calls {@link __transform} for each point in Set C
     * @private
     * @param {Array} C - Set of points.
     * @param {Object} t - Transform object.
     * @param {Number} yOffset - value to offset set C.
     */__transform_component(t,e,r){const s=t.length;for(let i=0;i<s;++i){const s=t[i],[n,o]=this.__transform(s,e);s[0]=n,s[1]=o+r}}
/**
     * @private
     * @param {Array} u - point u
     * @param {Array} v - point v
     * @param {Number} w - edge weight w
     */__align_components(t,e,r){const s=[...t.__disjoint_set.children],i=[...e.__disjoint_set.children],n=this.__hull(s),o=this.__hull(i),a=this.__align_hull(n,t,!1),h=this.__align_hull(o,e,!0);this.__transform_component(s,a,0),this.__transform_component(i,h,r)}
/**
     * Transforms the inputdata {@link X} to dimensionality 2.
     */transform(){this._is_initialized||this.init();const t=this._Emst,e=this.Y.to2dArray,r=new DisjointSet(e.map(((t,e)=>(t.i=e,t))));for(const[s,i,n]of t){const t=r.find(e[s]),o=r.find(e[i]);t!==o&&(this.__align_components(t,o,n),r.union(t,o))}return this.projection}*generator(){this._is_initialized||this.init();const t=this._Emst,e=this.Y.to2dArray,r=new DisjointSet(e.map(((t,e)=>(t.i=e,t))));for(const[s,i,n]of t){const t=r.find(e[s]),o=r.find(e[i]);t!==o&&(this.__align_components(t,o,n),r.union(t,o),yield this.projection)}return this.projection}}
/**
 * @class
 * @alias SAMMON
 * @extends DR
 */class SAMMON extends DR{
/**
     * SAMMON's Mapping
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias SAMMON
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {"PCA"|"MDS"|"random"} [parameters.init = "random"] - Either "PCA" or "MDS", with which SAMMON initialiates the projection. With "random" a random matrix gets used as starting point.
     * @param {Object} [parameters.init_parameters] - Parameters for the {@link init}-DR method.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {SAMMON}
     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}
     */
constructor(t,e){return super(t,{magic:.1,d:2,metric:euclidean,seed:1212,init_DR:"random",init_parameters:{}},e),this}
/**
     * initializes the projection.
     * @private
     */init(){const t=this.X.shape[0],{d:e,metric:r,init_DR:s,init_parameters:i}=this._parameters;if("random"===s){const r=this._randomizer;this.Y=new Matrix(t,e,(()=>r.random))}else{if(!["PCA","MDS"].includes(s))throw new Error('init_DR needs to be either "random" or a DR method!');this.Y=Matrix.from("PCA"==s?PCA.transform(this.X,i):MDS.transform(this.X,i))}return this.distance_matrix="precomputed"==r?Matrix.from(this.X):distance_matrix(this.X,r),this}
/**
     * Transforms the inputdata {@link X} to dimenionality 2.
     * @param {Number} [max_iter=200] - Maximum number of iteration steps.
     * @returns {Matrix|Array} - The projection of {@link X}.
     */transform(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step();return this.projection}
/**
     * Transforms the inputdata {@link X} to dimenionality 2.
     * @param {Number} [max_iter=200] - Maximum number of iteration steps.
     * @returns {Generator} - A generator yielding the intermediate steps of the projection of {@link X}.
     */*generator(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step(),yield this.projection;return this.projection}_step(){const t=this.parameter("magic"),e=this.distance_matrix,r=this.X.shape[0],{d:s,metric:i}=this._parameters;let n=this.Y,o=new Matrix(r,s,0),a=new Float64Array(s);for(let h=0;h<r;++h){let l=new Float64Array(s),_=new Float64Array(s);const c=n.row(h);for(let t=0;t<r;++t){if(h===t)continue;const r=n.row(t),o=new Float64Array(s);for(let t=0;t<s;++t)o[t]=c[t]-r[t];const a=i(c,r),u=e.entry(h,t),d=u-a,m=Math.max(u*a,.01);for(let t=0;t<s;++t)l[t]+=o[t]*d/m,_[t]+=(d-Math.pow(o[t],2)*(1+d/a)/a)/m}for(let e=0;e<s;++e){const r=n.entry(h,e)+(t*l[e]/Math.abs(_[e])||0);o.set_entry(h,e,r),a[e]+=r}}for(let t=0;t<s;++t)a[t]/=r;for(let t=0;t<r;++t)for(let e=0;e<s;++e)n.set_entry(t,e,o.entry(t,e)-a[e]);return n}}var t="0.5.0";export{BallTree,DisjointSet,FASTMAP,Heap,Hierarchical_Clustering,ISOMAP,KMeans,KMedoids,KNN,LDA,LLE,LSP,LTSA,MDS,Matrix,OPTICS,PCA,Randomizer,SAMMON,TSNE,TopoMap,TriMap,UMAP,canberra,chebyshev,cosine,distance_matrix,euclidean,euclidean_squared,hamming,inner_product,jaccard,k_nearest_neighbors,kahan_sum,linspace,manhattan,max,min,neumair_sum,norm,normalize,powell,qr_gramschmidt as qr,qr_householder,simultaneous_poweriteration,sokal_michener,t as version,yule};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJ1aWQuZXNtLmpzIiwic291cmNlcyI6WyIuLi9tZXRyaWNzL2V1Y2xpZGVhbi5qcyIsIi4uL251bWVyaWNhbC9rYWhhbl9zdW0uanMiLCIuLi9udW1lcmljYWwvbmV1bWFpcl9zdW0uanMiLCIuLi9tZXRyaWNzL2V1Y2xpZGVhbl9zcXVhcmVkLmpzIiwiLi4vbWV0cmljcy9jb3NpbmUuanMiLCIuLi9tZXRyaWNzL21hbmhhdHRhbi5qcyIsIi4uL21ldHJpY3MvY2hlYnlzaGV2LmpzIiwiLi4vbWV0cmljcy9jYW5iZXJyYS5qcyIsIi4uL21ldHJpY3MvamFjY2FyZC5qcyIsIi4uL21ldHJpY3MvaGFtbWluZy5qcyIsIi4uL21ldHJpY3Mvc29rYWxfbWljaGVuZXIuanMiLCIuLi9tZXRyaWNzL3l1bGUuanMiLCIuLi9tYXRyaXgva19uZWFyZXN0X25laWdoYm9ycy5qcyIsIi4uL21hdHJpeC9kaXN0YW5jZV9tYXRyaXguanMiLCIuLi9tYXRyaXgvbGluc3BhY2UuanMiLCIuLi9tYXRyaXgvbm9ybS5qcyIsIi4uL21hdHJpeC9ub3JtYWxpemUuanMiLCIuLi9saW5lYXJfYWxnZWJyYS9xci5qcyIsIi4uL2xpbmVhcl9hbGdlYnJhL3FyX2hvdXNlaG9sZGVyLmpzIiwiLi4vbGluZWFyX2FsZ2VicmEvc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uLmpzIiwiLi4vbGluZWFyX2FsZ2VicmEvaW5uZXJfcHJvZHVjdC5qcyIsIi4uL21hdHJpeC9NYXRyaXguanMiLCIuLi91dGlsL3JhbmRvbWl6ZXIuanMiLCIuLi91dGlsL21heC5qcyIsIi4uL3V0aWwvbWluLmpzIiwiLi4vZGF0YXN0cnVjdHVyZS9IZWFwLmpzIiwiLi4vZGF0YXN0cnVjdHVyZS9EaXNqb2ludFNldC5qcyIsIi4uL2tubi9CYWxsVHJlZS5qcyIsIi4uL2tubi9LTk4uanMiLCIuLi9kaW1yZWQvRFIuanMiLCIuLi9kaW1yZWQvUENBLmpzIiwiLi4vZGltcmVkL01EUy5qcyIsIi4uL2RpbXJlZC9JU09NQVAuanMiLCIuLi9kaW1yZWQvRkFTVE1BUC5qcyIsIi4uL2RpbXJlZC9MREEuanMiLCIuLi9kaW1yZWQvTExFLmpzIiwiLi4vZGltcmVkL0xUU0EuanMiLCIuLi9kaW1yZWQvVFNORS5qcyIsIi4uL29wdGltaXphdGlvbi9wb3dlbGwuanMiLCIuLi9kaW1yZWQvVU1BUC5qcyIsIi4uL2RpbXJlZC9UcmlNYXAuanMiLCIuLi9jbHVzdGVyaW5nL0hpZXJhcmNoaWNhbF9DbHVzdGVyaW5nLmpzIiwiLi4vY2x1c3RlcmluZy9LTWVhbnMuanMiLCIuLi9jbHVzdGVyaW5nL0tNZWRvaWRzLmpzIiwiLi4vY2x1c3RlcmluZy9PUFRJQ1MuanMiLCIuLi9kaW1yZWQvTFNQLmpzIiwiLi4vZGltcmVkL1RvcG9NYXAuanMiLCIuLi9kaW1yZWQvU0FNTU9OLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV1Y2xpZGVhbl9zcXVhcmVkIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIGV1Y2xpZGVhbiBkaXN0YW5jZSAobDxzdWI+Mjwvc3ViPikgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGV1Y2xpZGVhblxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGV1Y2xpZGVhbl9zcXVhcmVkKGEsIGIpKTtcbn1cbiIsIi8qKlxuICogTnVtZXJpY2FsIHN0YWJsZSBzdW1tYXRpb24gd2l0aCB0aGUgS2FoYW4gc3VtbWF0aW9uIGFsZ29yaXRobS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bnVtZXJpY2FsXG4gKiBAYWxpYXMga2FoYW5fc3VtXG4gKiBAcGFyYW0ge0FycmF5fSBzdW1tYW5kcyAtIEFycmF5IG9mIHZhbHVlcyB0byBzdW0gdXAuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3VtLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2FoYW5fc3VtbWF0aW9uX2FsZ29yaXRobX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN1bW1hbmRzKSB7XG4gICAgbGV0IG4gPSBzdW1tYW5kcy5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IGNvbXBlbnNhdGlvbiA9IDA7XG4gICAgbGV0IHksIHQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICB5ID0gc3VtbWFuZHNbaV0gLSBjb21wZW5zYXRpb247XG4gICAgICAgIHQgPSBzdW0gKyB5O1xuICAgICAgICBjb21wZW5zYXRpb24gPSB0IC0gc3VtIC0geTtcbiAgICAgICAgc3VtID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cbiIsIi8qKlxuICogTnVtZXJpY2FsIHN0YWJsZSBzdW1tYXRpb24gd2l0aCB0aGUgTmV1bWFpciBzdW1tYXRpb24gYWxnb3JpdGhtLlxuICogQG1lbWJlcm9mIG1vZHVsZTpudW1lcmljYWxcbiAqIEBhbGlhcyBuZXVtYWlyX3N1bVxuICogQHBhcmFtIHtBcnJheX0gc3VtbWFuZHMgLSBBcnJheSBvZiB2YWx1ZXMgdG8gc3VtIHVwLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIHN1bS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0thaGFuX3N1bW1hdGlvbl9hbGdvcml0aG0jRnVydGhlcl9lbmhhbmNlbWVudHN9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzdW1tYW5kcykge1xuICAgIGxldCBuID0gc3VtbWFuZHMubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGxldCBjb21wZW5zYXRpb24gPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbGV0IHN1bW1hbmQgPSBzdW1tYW5kc1tpXTtcbiAgICAgICAgbGV0IHQgPSBzdW0gKyBzdW1tYW5kO1xuICAgICAgICBpZiAoTWF0aC5hYnMoc3VtKSA+PSBNYXRoLmFicyhzdW1tYW5kKSkge1xuICAgICAgICAgICAgY29tcGVuc2F0aW9uICs9IHN1bSAtIHQgKyBzdW1tYW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcGVuc2F0aW9uICs9IHN1bW1hbmQgLSB0ICsgc3VtO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHQ7XG4gICAgfVxuICAgIHJldHVybiBzdW0gKyBjb21wZW5zYXRpb247XG59XG4iLCJpbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkZWFuIGRpc3RhbmNlIChsPHN1Yj4yPC9zdWI+PHN1cD4yPC9zdXA+KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgZXVjbGlkZWFuX3NxdWFyZWRcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgc3F1YXJlZCBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgcyA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBsZXQgeCA9IGFbaV07XG4gICAgICAgIGxldCB5ID0gYltpXTtcbiAgICAgICAgc1tpXSA9ICh4IC0geSkgKiAoeCAtIHkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV1bWFpcl9zdW0ocyk7XG59XG4iLCIvKipcbiAqIENvbXB1dGVzIHRoZSBjb3NpbmUgZGlzdGFuY2UgKG5vdCBzaW1pbGFyaXR5KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgY29zaW5lXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYlxuICogQGV4YW1wbGVcbiAqIGRydWlkLmNvc2luZShbMSwwXSxbMSwxXSkgPT0gMC43ODUzOTgxNjMzOTc0NDg0ID09IM+ALzRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBjb3NpbmUgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IHN1bV9hID0gMDtcbiAgICBsZXQgc3VtX2IgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHN1bSArPSBhW2ldICogYltpXTtcbiAgICAgICAgc3VtX2EgKz0gYVtpXSAqIGFbaV07XG4gICAgICAgIHN1bV9iICs9IGJbaV0gKiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5hY29zKHN1bSAvIChNYXRoLnNxcnQoc3VtX2EpICogTWF0aC5zcXJ0KHN1bV9iKSkpO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgbWFuaGF0dGFuIGRpc3RhbmNlIChsPHN1Yj4xPC9zdWI+KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgbWFuaGF0dGFuXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYlxuICogQHJldHVybnMge051bWJlcn0gdGhlIG1hbmhhdHRhbiBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovIFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBzdW0gKz0gTWF0aC5hYnMoYVtpXSAtIGJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgY2hlYnlzaGV2IGRpc3RhbmNlIChMPHN1Yj7iiJ48L3N1Yj4pIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1ldHJpY3NcbiAqIEBhbGlhcyBjaGVieXNoZXZcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY2hlYnlzaGV2IGRpc3RhbmNlIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKE1hdGguYWJzKGFbaV0gLSBiW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCguLi5yZXMpO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgY2FuYmVycmEgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGNhbmJlcnJhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGEgXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGIgXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgY2FuYmVycmEgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbmJlcnJhX2Rpc3RhbmNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgbiA9IGEubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHN1bSArPSAoTWF0aC5hYnMoYVtpXSAtIGJbaV0pIC8gKE1hdGguYWJzKGFbaV0pICsgTWF0aC5hYnMoYltpXSkpKVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufSIsIi8qKlxuICogQ29tcHV0ZXMgdGhlIGphY2NhcmQgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGphY2NhcmRcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgamFjY2FyZCBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IG51bV9ub25femVybyA9IDA7XG4gICAgbGV0IG51bV9lcXVhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY29uc3QgeCA9IGFbaV0gIT0gMDtcbiAgICAgICAgY29uc3QgeSA9IGJbaV0gIT0gMDtcbiAgICAgICAgbnVtX25vbl96ZXJvICs9IHggfHwgeTtcbiAgICAgICAgbnVtX2VxdWFsICs9IHggJiYgeTtcbiAgICB9XG4gICAgcmV0dXJuIChudW1fbm9uX3plcm8gLSBudW1fZXF1YWwpIC8gbnVtX25vbl96ZXJvO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgaGFtbWluZyBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgaGFtbWluZ1xuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBoYW1taW5nIGRpc3RhbmNlIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgZGlzYWdyZWUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IHggPSBhW2ldO1xuICAgICAgICBjb25zdCB5ID0gYltpXTtcbiAgICAgICAgZGlzYWdyZWUgKz0geCAhPSB5O1xuICAgIH1cbiAgICByZXR1cm4gZGlzYWdyZWUgLyBuO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgU29rYWwtTWljaGVuZXIgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIHNva2FsX21pY2hlbmVyXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGEgXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGIgXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgU29rYWwtTWljaGVuZXIgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS4gIFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgY29uc3QgbiA9IGEubGVuZ3RoO1xuICAgIGxldCBudW1fbm90X2VxdWFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCB4ID0gYVtpXSAhPSAwO1xuICAgICAgICBjb25zdCB5ID0gYltpXSAhPSAwO1xuICAgICAgICBudW1fbm90X2VxdWFsICs9IHggIT0geTtcbiAgICB9XG4gICAgcmV0dXJuICgyICogbnVtX25vdF9lcXVhbCkgLyAobiArIG51bV9ub3RfZXF1YWwpO1xufSIsIi8qKlxuICogQ29tcHV0ZXMgdGhlIHl1bGUgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIHl1bGVcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgeXVsZSBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IG51bV90cnVlX3RydWUgPSAwO1xuICAgIGxldCBudW1fdHJ1ZV9mYWxzZSA9IDA7XG4gICAgbGV0IG51bV9mYWxzZV90cnVlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCB4ID0gYVtpXSAhPSAwO1xuICAgICAgICBjb25zdCB5ID0gYltpXSAhPSAwO1xuICAgICAgICBudW1fdHJ1ZV90cnVlICs9IHggJiYgeTtcbiAgICAgICAgbnVtX3RydWVfZmFsc2UgKz0geCAmJiAheTtcbiAgICAgICAgbnVtX2ZhbHNlX3RydWUgKz0gIXggJiYgeDtcbiAgICB9XG4gICAgY29uc3QgbnVtX2ZhbHNlX2ZhbHNlID0gbiAtIG51bV90cnVlX3RydWUgLSBudW1fdHJ1ZV9mYWxzZSAtIG51bV9mYWxzZV90cnVlO1xuICAgIHJldHVybiBudW1fdHJ1ZV9mYWxzZSA9PSAwIHx8IG51bV9mYWxzZV90cnVlID09IDAgPyAwIDogKDIgKiBudW1fdHJ1ZV9mYWxzZSAqIG51bV9mYWxzZV90cnVlKSAvIChudW1fdHJ1ZV90cnVlICogbnVtX2ZhbHNlX2ZhbHNlICsgbnVtX3RydWVfZmFsc2UgKiBudW1fZmFsc2VfdHJ1ZSk7XG59XG4iLCJpbXBvcnQgeyBkaXN0YW5jZV9tYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBrLW5lYXJlc3QgbmVpZ2hib3JzIG9mIGVhY2ggcm93IG9mIHtAbGluayBBfS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWF0cml4XG4gKiBAYWxpYXMga19uZWFyZXN0X25laWdiaG9yc1xuICogQHBhcmFtIHtNYXRyaXh9IEEgLSBFaXRoZXIgdGhlIGRhdGEgbWF0cml4LCBvciBhIGRpc3RhbmNlIG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBrIC0gVGhlIG51bWJlciBvZiBuZWlnaGJvcnMgdG8gY29tcHV0ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbbWV0cmljPWV1Y2xpZGVhbl1cbiAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSAtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChBLCBrLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICBjb25zdCByb3dzID0gQS5zaGFwZVswXTtcbiAgICBsZXQgRCA9IG1ldHJpYyA9PSBcInByZWNvbXB1dGVkXCIgPyBBIDogZGlzdGFuY2VfbWF0cml4KEEsIG1ldHJpYyk7XG4gICAgbGV0IG5OID0gbmV3IEFycmF5KHJvd3MpO1xuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgIG5OW3Jvd10gPSBBcnJheS5mcm9tKEQucm93KHJvdykpXG4gICAgICAgICAgICAubWFwKChkaXN0YW5jZSwgY29sKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaTogcm93LFxuICAgICAgICAgICAgICAgICAgICBqOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZSlcbiAgICAgICAgICAgIC5zbGljZSgxLCBrICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBuTjtcbn1cbiIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBtYXRyaXggb2YgZGF0YW1hdHJpeCB7QGxpbmsgQX0uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1hdHJpeFxuICogQGFsaWFzIGRpc3RhbmNlX21hdHJpeFxuICogQHBhcmFtIHtNYXRyaXh9IEEgLSBNYXRyaXguXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljPWV1Y2xpZGVhbl0gLSBUaGUgZGlpc3RhbmNlIG1ldHJpYy5cbiAqIEByZXR1cm5zIHtNYXRyaXh9IEQgLSBUaGUgZGlzdGFuY2UgbWF0cml4IG9mIHtAbGluayBBfS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKEEsIG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgIGxldCBuID0gQS5zaGFwZVswXTtcbiAgICBjb25zdCBEID0gbmV3IE1hdHJpeChuLCBuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCBBX2kgPSBBLnJvdyhpKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gbWV0cmljKEFfaSwgQS5yb3coaikpO1xuICAgICAgICAgICAgRC5zZXRfZW50cnkoaSwgaiwgZGlzdCk7XG4gICAgICAgICAgICBELnNldF9lbnRyeShqLCBpLCBkaXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRDtcbn1cbiIsIi8qKlxuICogQ3JlYXRlcyBhbiBBcnJheSBjb250YWluaW5nIHtAbGluayBudW1iZXJ9IG51bWJlcnMgZnJvbSB7QGxpbmsgc3RhcnR9IHRvIHtAbGluayBlbmR9LlxuICogSWYgPGNvZGU+e0BsaW5rIG51bWJlcn0gPSBudWxsPC9udWxsPi5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWF0cml4XG4gKiBAYWxpYXMgbGluc3BhY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCAtIFN0YXJ0IHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCAtIEVuZCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbnVtYmVyID0gbnVsbF0gLSBOdW1iZXIgb2YgbnVtYmVyIGJldHdlZW4ge0BsaW5rIHN0YXJ0fSBhbmQge0BsaW5rIGVuZH0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgd2l0aCB7QGxpbmsgbnVtYmVyfSBlbnRyaWVzLCBiZWdpbm5pbmcgYXQge0BsaW5rIHN0YXJ0fSBlbmRpbmcgYXQge0BsaW5rIGVuZH0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBudW1iZXIgPSBudWxsKSB7XG4gICAgaWYgKCFudW1iZXIpIHtcbiAgICAgICAgbnVtYmVyID0gTWF0aC5tYXgoTWF0aC5yb3VuZChlbmQgLSBzdGFydCkgKyAxLCAxKTtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDIpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlciA9PT0gMSA/IFtzdGFydF0gOiBbXTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBBcnJheShudW1iZXIpO1xuICAgIG51bWJlciAtPSAxO1xuICAgIGZvciAobGV0IGkgPSBudW1iZXI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IChpICogZW5kICsgKG51bWJlciAtIGkpICogc3RhcnQpIC8gbnVtYmVyO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbi8vaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4XCI7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG5vcm0gb2YgYSB2ZWN0b3IsIGJ5IGNvbXB1dGluZyBpdHMgZGlzdGFuY2UgdG8gKiowKiouXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1hdHJpeFxuICogQGFsaWFzIG5vcm1cbiAqIEBwYXJhbSB7TWF0cml4fEFycmF5PE51bWJlcj58RmxvYXQ2NEFycmF5fSB2IC0gVmVjdG9yLiBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gV2hpY2ggbWV0cmljIHNob3VsZCBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIG5vcm0uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBub3JtIG9mIHtAbGluayB2fS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHYsIG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgIGxldCB2ZWN0b3IgPSBudWxsO1xuICAgIGlmICh2IGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgIGxldCBbcm93cywgY29sc10gPSB2LnNoYXBlO1xuICAgICAgICBpZiAocm93cyA9PT0gMSkgdmVjdG9yID0gdi5yb3coMCk7XG4gICAgICAgIGVsc2UgaWYgKGNvbHMgPT09IDEpIHZlY3RvciA9IHYuY29sKDApO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIk1hdHJpeCBtdXN0IGJlIDFkIVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2ZWN0b3IgPSB2O1xuICAgIH1cbiAgICBjb25zdCBuID0gdmVjdG9yLmxlbmd0aDtcbiAgICBjb25zdCB6ZXJvcyA9IEZsb2F0NjRBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sICgpID0+IDApO1xuICAgIHJldHVybiBtZXRyaWModmVjdG9yLCB6ZXJvcyk7XG59XG4iLCJpbXBvcnQgeyBub3JtIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5cbi8qKlxuICogTm9ybWFsaXplcyBWZWN0b3Ige0BsaW5rIHZ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptYXRyaXhcbiAqIEBhbGlhcyBub3JtYWxpemVcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPnxGbG9hdDY0QXJyYXl9IHYgLSBWZWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldHJpYyBcbiAqIEByZXR1cm5zIHtBcnJheTxOdW1iZXI+fEZsb2F0NjRBcnJheX0gLSBUaGUgbm9ybWFsaXplZCB2ZWN0b3Igd2l0aCBsZW5ndGggMS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odiwgbWV0cmljID0gZXVjbGlkZWFuKSAge1xuICAgIGNvbnN0IHZfbm9ybSA9IG5vcm0odiwgbWV0cmljKTtcbiAgICByZXR1cm4gdi5tYXAodmFsdWUgPT4gdmFsdWUgLyB2X25vcm0pO1xufSIsImltcG9ydCB7IE1hdHJpeCwgbm9ybSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUVIgRGVjb21wb3NpdGlvbiBvZiB0aGUgTWF0cml4IHtAbGluayBBfSB1c2luZyBHcmFtLVNjaG1pZHQgcHJvY2Vzcy5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bGluZWFyX2FsZ2VicmFcbiAqIEBhbGlhcyBxclxuICogQHBhcmFtIHtNYXRyaXh9IEFcbiAqIEByZXR1cm5zIHt7UjogTWF0cml4LCBROiBNYXRyaXh9fVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUVJfZGVjb21wb3NpdGlvbiNVc2luZ190aGVfR3JhbSVFMiU4MCU5M1NjaG1pZHRfcHJvY2Vzc31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKEEpIHtcbiAgICBjb25zdCBbcm93cywgY29sc10gPSBBLnNoYXBlO1xuICAgIGNvbnN0IFEgPSBuZXcgTWF0cml4KHJvd3MsIGNvbHMsIFwiaWRlbnRpdHlcIik7XG4gICAgY29uc3QgUiA9IG5ldyBNYXRyaXgoY29scywgY29scywgMCk7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7ICsraikge1xuICAgICAgICBsZXQgdiA9IEEuY29sKGopO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGo7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcSA9IFEuY29sKGkpO1xuICAgICAgICAgICAgY29uc3QgcV9kb3RfdiA9IG5ldW1haXJfc3VtKHEubWFwKChxXywgaykgPT4gcV8gKiB2W2tdKSk7XG4gICAgICAgICAgICBSLnNldF9lbnRyeShpLCBqLCBxX2RvdF92KTtcbiAgICAgICAgICAgIHYgPSB2Lm1hcCgodl8sIGspID0+IHZfIC0gcV9kb3RfdiAqIHFba10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZfbm9ybSA9IG5vcm0odiwgZXVjbGlkZWFuKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3dzOyArK2spIHtcbiAgICAgICAgICAgIFEuc2V0X2VudHJ5KGssIGosIHZba10gLyB2X25vcm0pO1xuICAgICAgICB9XG4gICAgICAgIFIuc2V0X2VudHJ5KGosIGosIHZfbm9ybSk7XG4gICAgfVxuICAgIHJldHVybiB7IFIsIFEgfTtcbn1cbiIsImltcG9ydCB7IE1hdHJpeCwgbm9ybSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUVIgRGVjb21wb3NpdGlvbiBvZiB0aGUgTWF0cml4IHtAbGluayBBfSB3aXRoIGhvdXNlaG9sZGVyIHRyYW5zZm9ybWF0aW9ucy5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bGluZWFyX2FsZ2VicmFcbiAqIEBhbGlhcyBxcl9ob3VzZWhvbGRlclxuICogQHBhcmFtIHtNYXRyaXh9IEFcbiAqIEByZXR1cm5zIHt7UjogTWF0cml4LCBROiBNYXRyaXh9fVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUVJfZGVjb21wb3NpdGlvbiNVc2luZ19Ib3VzZWhvbGRlcl9yZWZsZWN0aW9uc31cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9tbHdpa2kub3JnL2luZGV4LnBocC9Ib3VzZWhvbGRlcl9UcmFuc2Zvcm1hdGlvbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKEEpIHtcbiAgICBjb25zdCBbcm93cywgY29sc10gPSBBLnNoYXBlO1xuICAgIGNvbnN0IFEgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIFwiSVwiKTtcbiAgICBjb25zdCBSID0gQS5jbG9uZSgpO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcbiAgICAgICAgY29uc3QgeCA9IE1hdHJpeC5mcm9tKFIuY29sKGopLnNsaWNlKGopKTtcbiAgICAgICAgY29uc3QgeF9ub3JtID0gbm9ybSh4KTtcbiAgICAgICAgY29uc3QgeDAgPSB4LmVudHJ5KDAsIDApO1xuICAgICAgICBjb25zdCByaG8gPSAtTWF0aC5zaWduKHgwKTtcbiAgICAgICAgY29uc3QgdTEgPSB4MCAtIHJobyAqIHhfbm9ybTtcbiAgICAgICAgY29uc3QgdSA9IHguZGl2aWRlKHUxKS5zZXRfZW50cnkoMCwgMCwgMSk7XG4gICAgICAgIGNvbnN0IGJldGEgPSAoLXJobyAqIHUxKSAvIHhfbm9ybTtcblxuICAgICAgICBjb25zdCB1X291dGVyX3UgPSB1Lm91dGVyKHUpO1xuICAgICAgICBjb25zdCBSX2Jsb2NrID0gUi5nZXRfYmxvY2soaiwgMCk7XG4gICAgICAgIGNvbnN0IG5ld19SID0gUl9ibG9jay5zdWIodV9vdXRlcl91LmRvdChSX2Jsb2NrKS5tdWx0KGJldGEpKTtcbiAgICAgICAgY29uc3QgUV9ibG9jayA9IFEuZ2V0X2Jsb2NrKDAsIGopO1xuICAgICAgICBjb25zdCBuZXdfUSA9IFFfYmxvY2suc3ViKFFfYmxvY2suZG90KHVfb3V0ZXJfdSkubXVsdChiZXRhKSk7XG4gICAgICAgIFIuc2V0X2Jsb2NrKGosIDAsIG5ld19SKTtcbiAgICAgICAgUS5zZXRfYmxvY2soMCwgaiwgbmV3X1EpO1xuICAgIH1cbiAgICByZXR1cm4geyBSLCBRIH07XG59XG4iLCJpbXBvcnQgeyBxciBhcyBxcl9ncmFtc2NobWlkdCB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBSYW5kb21pemVyIH0gZnJvbSBcIi4uL3V0aWwvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbl9zcXVhcmVkIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUge0BsaW5rIGt9IGJpZ2dlc3QgRWlnZW52ZWN0b3JzIGFuZCBFaWdlbnZhbHVlcyBmcm9tIE1hdHJpeCB7QGxpbmsgQX0gd2l0aCB0aGUgUVItQWxnb3JpdGhtLlxuICogQG1lbWJlcm9mIG1vZHVsZTpsaW5lYXJfYWxnZWJyYVxuICogQGFsaWFzIHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvblxuICogQHBhcmFtIHtNYXRyaXh9IEEgLSBUaGUgTWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gayAtIFRoZSBudW1iZXIgb2YgZWlnZW52ZWN0b3JzIGFuZCBlaWdlbnZhbHVlcyB0byBjb21wdXRlLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBzaW11bHRhbmlvdXMgcG93ZXJpdGVyYXRpb24gbWV0aG9kLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLm1heF9pdGVyYXRpb25zPTEwMF0gLSBUaGUgbnVtYmVyIG9mIG1heGl1bXVtIGl0ZXJhdGlvbnMgdGhlIGFsZ29yaXRobSBzaG91bGQgcnVuLlxuICogQHBhcmFtIHtOdW1iZXJ8UmFuZG9taXplcn0gW3BhcmFtZXRlcnMuc2VlZD0xMjEyXSAtIFRoZSBzZWVkIHZhbHVlIG9yIGEgcmFuZG9taXplciB1c2VkIGluIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1ldGVycy5xcj1xcl9ncmFtc2NobWlkdF0gLSBUaGUgUVIgdGVjaG5pcXVlIHRvIHVzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy50b2w9MWUtOF0gLSBBbGxvd2VkIGVycm9yIGZvciBzdG9wcGluZyBjcml0ZXJpYVxuICogQHJldHVybnMge3tlaWdlbnZhbHVlczogQXJyYXksIGVpZ2VudmVjdG9yczogQXJyYXl9fSAtIFRoZSB7QGxpbmsga30gYmlnZ2VzdCBlaWdlbnZlY3RvcnMgYW5kIGVpZ2VudmFsdWVzIG9mIE1hdHJpeCB7QGxpbmsgQX0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChBLCBrID0gMiwge3NlZWQgPSAxMjEyLCBtYXhfaXRlcmF0aW9ucyA9IDEwMCwgcXIgPSBxcl9ncmFtc2NobWlkdCwgdG9sID0gMWUtOH0gPSB7fSkge1xuICAgIGNvbnN0IHJhbmRvbWl6ZXIgPSBzZWVkIGluc3RhbmNlb2YgUmFuZG9taXplciA/IHNlZWQgOiBuZXcgUmFuZG9taXplcihzZWVkKTtcbiAgICBpZiAoIShBIGluc3RhbmNlb2YgTWF0cml4KSkgQSA9IE1hdHJpeC5mcm9tKEEpO1xuICAgIGNvbnN0IG4gPSBBLnNoYXBlWzBdO1xuICAgIGxldCB7IFEsIFIgfSA9IHFyKG5ldyBNYXRyaXgobiwgaywgKCkgPT4gKHJhbmRvbWl6ZXIucmFuZG9tIC0gLjUpICogMikpO1xuICAgIHdoaWxlIChtYXhfaXRlcmF0aW9ucy0tKSB7XG4gICAgICAgIGNvbnN0IG9sZFEgPSBRLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IFogPSBBLmRvdChRKTtcbiAgICAgICAgY29uc3QgUVIgPSBxcihaKTtcbiAgICAgICAgUSA9IFFSLlE7XG4gICAgICAgIFIgPSBRUi5SO1xuICAgICAgICBjb25zdCBlcnJvciA9IGV1Y2xpZGVhbl9zcXVhcmVkKFEudmFsdWVzLCBvbGRRLnZhbHVlcyk7XG4gICAgICAgIGlmIChlcnJvciA8IHRvbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlaWdlbnZhbHVlcyA9IFIuZGlhZztcbiAgICBjb25zdCBlaWdlbnZlY3RvcnMgPSBRLnRyYW5zcG9zZSgpLnRvMmRBcnJheTtcbiAgICByZXR1cm4geyBlaWdlbnZhbHVlcywgZWlnZW52ZWN0b3JzIH07XG59XG4iLCJpbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgaW5uZXIgcHJvZHVjdCBiZXR3ZWVuIHR3byBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoLlxuICogQG1lbWJlcm9mIG1vZHVsZTpsaW5lYXJfYWxnZWJyYVxuICogQGFsaWFzIGlubmVyX3Byb2R1Y3RcbiAqIEBwYXJhbSB7QXJyYXl8RmxvYXQ2NEFycmF5fSBhIC0gQXJyYXkgYVxuICogQHBhcmFtIHtBcnJheXxGbG9hdDY0QXJyYXl9IGIgLSBBcnJheSBiXG4gKiBAcmV0dXJucyBUaGUgaW5uZXIgcHJvZHVjdCBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgY29uc3QgTiA9IGEubGVuZ3RoO1xuICAgIGlmIChOICE9IGIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5IGEgYW5kIGIgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCFcIilcbiAgICB9XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgc3VtICs9IGEgKiBiO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuIiwiaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IFJhbmRvbWl6ZXIgfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBNYXRyaXhcbiAqIEByZXF1aXJlcyBtb2R1bGU6bnVtZXJpY2FsL25ldW1haXJfc3VtXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRyaXgge1xuICAgIC8qKlxuICAgICAqIGNyZWF0ZXMgYSBuZXcgTWF0cml4LiBFbnRyaWVzIGFyZSBzdG9yZWQgaW4gYSBGbG9hdDY0QXJyYXkuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTptYXRyaXhcbiAgICAgKiBAYWxpYXMgTWF0cml4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgLSBUaGUgYW1vdW50IG9mIHJvd3Mgb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29scyAtIFRoZSBhbW91bnQgb2YgY29sdW1ucyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9ufHN0cmluZ3xudW1iZXIpfSB2YWx1ZT0wIC0gQ2FuIGJlIGEgZnVuY3Rpb24gd2l0aCByb3cgYW5kIGNvbCBhcyBwYXJhbWV0ZXJzLCBhIG51bWJlciwgb3IgXCJ6ZXJvc1wiLCBcImlkZW50aXR5XCIgb3IgXCJJXCIsIG9yIFwiY2VudGVyXCIuXG4gICAgICogIC0gKipmdW5jdGlvbioqOiBmb3IgZWFjaCBlbnRyeSB0aGUgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgd2l0aCB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIGFjdHVhbCByb3cgYW5kIGNvbHVtbi5cbiAgICAgKiAgLSAqKnN0cmluZyoqOiBhbGxvd2VkIGFyZVxuICAgICAqICAgICAgLSBcInplcm9cIiwgY3JlYXRlcyBhIHplcm8gbWF0cml4LlxuICAgICAqICAgICAgLSBcImlkZW50aXR5XCIgb3IgXCJJXCIsIGNyZWF0ZXMgYW4gaWRlbnRpdHkgbWF0cml4LlxuICAgICAqICAgICAgLSBcImNlbnRlclwiLCBjcmVhdGVzIGFuIGNlbnRlciBtYXRyaXguXG4gICAgICogIC0gKipudW1iZXIqKjogY3JlYXRlIGEgbWF0cml4IGZpbGxlZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBuZXcgTWF0cml4KDEwLCAxMCwgKCkgPT4gTWF0aC5yYW5kb20oKSk7IC8vY3JlYXRlcyBhIDEwIHRpbWVzIDEwIHJhbmRvbSBtYXRyaXguXG4gICAgICogbGV0IEIgPSBuZXcgTWF0cml4KDMsIDMsIFwiSVwiKTsgLy8gY3JlYXRlcyBhIDMgdGltZXMgMyBpZGVudGl0eSBtYXRyaXguXG4gICAgICogQHJldHVybnMge01hdHJpeH0gcmV0dXJucyBhIHtAbGluayByb3dzfSB0aW1lcyB7QGxpbmsgY29sc30gTWF0cml4IGZpbGxlZCB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm93cyA9IG51bGwsIGNvbHMgPSBudWxsLCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuX2NvbHMgPSBjb2xzO1xuICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKHJvd3MgJiYgY29scykge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IHZhbHVlKHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiemVyb3NcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChyb3dzLCBjb2xzLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcImlkZW50aXR5XCIgfHwgdmFsdWUgPT09IFwiSVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbcm93ICogY29scyArIHJvd10gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiY2VudGVyXCIgJiYgcm93cyA9PSBjb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoaSwgaikgPT4gKGkgPT09IGogPyAxIDogMCkgLSAxIC8gcm93cztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IHZhbHVlKHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkocm93cyAqIGNvbHMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1hdHJpeCBvdXQgb2Yge0BsaW5rIEF9LlxuICAgICAqIEBwYXJhbSB7KE1hdHJpeHxBcnJheXxGbG9hdDY0QXJyYXl8bnVtYmVyKX0gQSAtIFRoZSBtYXRyaXgsIGFycmF5LCBvciBudW1iZXIsIHdoaWNoIHNob3VsZCBjb252ZXJ0ZWQgdG8gYSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtcInJvd1wifFwiY29sXCJ8XCJkaWFnXCJ9IFt0eXBlID0gXCJyb3dcIl0gLSBJZiB7QGxpbmsgQX0gaXMgYSBBcnJheSBvciBGbG9hdDY0QXJyYXksIHRoZW4gdHlwZSBkZWZpbmVzIGlmIGl0IGlzIGEgcm93LSBvciBhIGNvbHVtbiB2ZWN0b3IuXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDBdLCBbMCwgMV1dKTsgLy9jcmVhdGVzIGEgdHdvIGJ5IHR3byBpZGVudGl0eSBtYXRyaXguXG4gICAgICogbGV0IFMgPSBNYXRyaXguZnJvbShbMSwgMiwgM10sIFwiZGlhZ1wiKTsgLy8gY3JlYXRlcyBhIDMgYnkgMyBtYXRyaXggd2l0aCAxLCAyLCAzIG9uIGl0cyBkaWFnb25hbC4gW1sxLCAwLCAwXSwgWzAsIDIsIDBdLCBbMCwgMCwgM11dXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oQSwgdHlwZSA9IFwicm93XCIpIHtcbiAgICAgICAgaWYgKEEgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBBLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShBKSB8fCBBIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSB7XG4gICAgICAgICAgICBsZXQgbSA9IEEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG0gPT09IDApIHRocm93IG5ldyBFcnJvcihcIkFycmF5IGlzIGVtcHR5XCIpO1xuICAgICAgICAgICAgLy8gMWRcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShBWzBdKSAmJiAhKEFbMF0gaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicm93XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoMSwgbSwgKF8sIGopID0+IEFbal0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb2xcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtLCAxLCAoaSkgPT4gQVtpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRpYWdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtLCBtLCAoaSwgaikgPT4gKGkgPT0gaiA/IEFbaV0gOiAwKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiMWQgYXJyYXkgaGFzIE5hTiBlbnRyaWVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAyZFxuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEFbMF0pIHx8IEFbMF0gaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbiA9IEFbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG07ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBW3Jvd10ubGVuZ3RoICE9PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YXJpb3VzIGFycmF5IGxlbmd0aHNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgobSwgbiwgKGksIGopID0+IEFbaV1bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBBID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCgxLCAxLCBBKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVycm9yXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIHJvd308c3VwPnRoPC9zdXA+IHJvdyBmcm9tIHRoZSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgICAqIEByZXR1cm5zIHtGbG9hdDY0QXJyYXl9XG4gICAgICovXG4gICAgcm93KHJvdykge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICByZXR1cm4gZGF0YS5zdWJhcnJheShyb3cgKiBjb2xzLCAocm93ICsgMSkgKiBjb2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGdlbmVyYXRvciB5aWVsZGluZyBlYWNoIHJvdyBvZiB0aGUgTWF0cml4LlxuICAgICAqIEB5aWVsZHMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICAqaXRlcmF0ZV9yb3dzKCkge1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIHlpZWxkIGRhdGEuc3ViYXJyYXkocm93ICogY29scywgKHJvdyArIDEpICogY29scyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIHtAbGluayBNYXRyaXh9IG9iamVjdCBhbiBpdGVyYWJsZSBvYmplY3QuXG4gICAgICogQHlpZWxkcyB7RmxvYXQ2NEFycmF5fVxuICAgICAqL1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5pdGVyYXRlX3Jvd3MoKSkge1xuICAgICAgICAgICAgeWllbGQgcm93O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZW50cmllcyBvZiB7QGxpbmsgcm93fTxzdXA+dGg8L3N1cD4gcm93IGZyb20gdGhlIE1hdHJpeCB0byB0aGUgZW50cmllcyBmcm9tIHtAbGluayB2YWx1ZXN9LlxuICAgICAqIEBwYXJhbSB7aW50fSByb3dcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHNldF9yb3cocm93LCB2YWx1ZXMpIHtcbiAgICAgICAgbGV0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmIHZhbHVlcy5sZW5ndGggPT09IGNvbHMpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlc1tvZmZzZXQgKyBjb2xdID0gdmFsdWVzW2NvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWVzIGluc3RhbmNlb2YgTWF0cml4ICYmIHZhbHVlcy5zaGFwZVsxXSA9PT0gY29scyAmJiB2YWx1ZXMuc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlc1tvZmZzZXQgKyBjb2xdID0gdmFsdWVzLl9kYXRhW2NvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIGNvbH08c3VwPnRoPC9zdXA+IGNvbHVtbiBmcm9tIHRoZSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtpbnR9IGNvbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBjb2woY29sKSB7XG4gICAgICAgIGxldCByZXN1bHRfY29sID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLl9yb3dzKTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5fcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIHJlc3VsdF9jb2xbcm93XSA9IHRoaXMudmFsdWVzW3JvdyAqIHRoaXMuX2NvbHMgKyBjb2xdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRfY29sO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBjb2x9PHN1cD50aDwvc3VwPiBlbnRyeSBmcm9tIHRoZSB7QGxpbmsgcm93fTxzdXA+dGg8L3N1cD4gcm93IG9mIHRoZSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtpbnR9IHJvd1xuICAgICAqIEBwYXJhbSB7aW50fSBjb2xcbiAgICAgKiBAcmV0dXJucyB7ZmxvYXQ2NH1cbiAgICAgKi9cbiAgICBlbnRyeShyb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbcm93ICogdGhpcy5fY29scyArIGNvbF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUge0BsaW5rIGNvbH08c3VwPnRoPC9zdXA+IGVudHJ5IGZyb20gdGhlIHtAbGluayByb3d9PHN1cD50aDwvc3VwPiByb3cgb2YgdGhlIE1hdHJpeCB0byB0aGUgZ2l2ZW4ge0BsaW5rIHZhbHVlfS5cbiAgICAgKiBAcGFyYW0ge2ludH0gcm93XG4gICAgICogQHBhcmFtIHtpbnR9IGNvbFxuICAgICAqIEBwYXJhbSB7ZmxvYXQ2NH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHNldF9lbnRyeShyb3csIGNvbCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNbcm93ICogdGhpcy5fY29scyArIGNvbF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyB0cmFuc3Bvc2VkIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHRyYW5zcG9zZSgpIHtcbiAgICAgICAgbGV0IEIgPSBuZXcgTWF0cml4KHRoaXMuX2NvbHMsIHRoaXMuX3Jvd3MsIChyb3csIGNvbCkgPT4gdGhpcy5lbnRyeShjb2wsIHJvdykpO1xuICAgICAgICByZXR1cm4gQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHRyYW5zcG9zZWQgTWF0cml4LiBTaG9ydC1mb3JtIG9mIHtAZnVuY3Rpb24gdHJhbnNwb3NlfS5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIGdldCBUKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3Bvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBpbnZlcnNlKCkge1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgIGxldCBCID0gbmV3IE1hdHJpeChyb3dzLCAyICogY29scywgKGksIGopID0+IHtcbiAgICAgICAgICAgIGlmIChqID49IGNvbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA9PT0gaiAtIGNvbHMgPyAxIDogMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50cnkoaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaCA9IDA7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgd2hpbGUgKGggPCByb3dzICYmIGsgPCBjb2xzKSB7XG4gICAgICAgICAgICB2YXIgaV9tYXggPSAwO1xuICAgICAgICAgICAgbGV0IG1heF92YWwgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gaDsgaSA8IHJvd3M7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBNYXRoLmFicyhCLmVudHJ5KGksIGspKTtcbiAgICAgICAgICAgICAgICBpZiAobWF4X3ZhbCA8IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpX21heCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIG1heF92YWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEIuZW50cnkoaV9tYXgsIGspID09IDApIHtcbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgcm93c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMiAqIGNvbHM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaF92YWwgPSBCLmVudHJ5KGgsIGopO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaV92YWwgPSBCLmVudHJ5KGlfbWF4LCBqKTtcbiAgICAgICAgICAgICAgICAgICAgQi5zZXRfZW50cnkoaCwgaiwgaF92YWwpO1xuICAgICAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShpX21heCwgaiwgaV92YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaCArIDE7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGYgPSBCLmVudHJ5KGksIGspIC8gQi5lbnRyeShoLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgQi5zZXRfZW50cnkoaSwgaywgMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBrICsgMTsgaiA8IDIgKiBjb2xzOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEIuc2V0X2VudHJ5KGksIGosIEIuZW50cnkoaSwgaikgLSBCLmVudHJ5KGgsIGopICogZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaCsrO1xuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBsZXQgZiA9IEIuZW50cnkocm93LCByb3cpO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gcm93OyBjb2wgPCAyICogY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShyb3csIGNvbCwgQi5lbnRyeShyb3csIGNvbCkgLyBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IHJvd3MgLSAxOyByb3cgPj0gMDsgLS1yb3cpIHtcbiAgICAgICAgICAgIGxldCBCX3Jvd19yb3cgPSBCLmVudHJ5KHJvdywgcm93KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgQl9pX3JvdyA9IEIuZW50cnkoaSwgcm93KTtcbiAgICAgICAgICAgICAgICBsZXQgZiA9IEJfaV9yb3cgLyBCX3Jvd19yb3c7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCAyICogY29sczsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBCX2lfaiA9IEIuZW50cnkoaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBCX3Jvd19qID0gQi5lbnRyeShyb3csIGopO1xuICAgICAgICAgICAgICAgICAgICBCX2lfaiA9IEJfaV9qIC0gQl9yb3dfaiAqIGY7XG4gICAgICAgICAgICAgICAgICAgIEIuc2V0X2VudHJ5KGksIGosIEJfaV9qKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChyb3dzLCBjb2xzLCAoaSwgaikgPT4gQi5lbnRyeShpLCBqICsgY29scykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0LiBJZiB7QGxpbmsgQn0gaXMgYW4gQXJyYXkgb3IgRmxvYXQ2NEFycmF5IHRoZW4gYW4gQXJyYXkgZ2V0cyByZXR1cm5lZC4gSWYge0BsaW5rIEJ9IGlzIGEgTWF0cml4IHRoZW4gYSBNYXRyaXggZ2V0cyByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0geyhNYXRyaXh8QXJyYXl8RmxvYXQ2NEFycmF5KX0gQiB0aGUgcmlnaHQgc2lkZVxuICAgICAqIEByZXR1cm5zIHsoTWF0cml4fEFycmF5KX1cbiAgICAgKi9cbiAgICBkb3QoQikge1xuICAgICAgICBpZiAoQiBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IEEgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKEEuc2hhcGVbMV0gIT09IEIuc2hhcGVbMF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEuZG90KEIpOiBBIGlzIGEgJHtBLnNoYXBlLmpvaW4oXCIg4qivIFwiKX0tTWF0cml4LCBCIGlzIGEgJHtCLnNoYXBlLmpvaW4oXCIg4qivIFwiKX0tTWF0cml4OiBcbiAgICAgICAgICAgICAgICBBIGhhcyAke0Euc2hhcGVbMV19IGNvbHMgYW5kIEIgJHtCLnNoYXBlWzBdfSByb3dzLiBcbiAgICAgICAgICAgICAgICBNdXN0IGJlIGVxdWFsIWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IEkgPSBBLnNoYXBlWzFdO1xuICAgICAgICAgICAgbGV0IEMgPSBuZXcgTWF0cml4KEEuc2hhcGVbMF0sIEIuc2hhcGVbMV0sIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IEFfaSA9IEEucm93KHJvdyk7XG4gICAgICAgICAgICAgICAgY29uc3QgQl9pID0gQi5jb2woY29sKTtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gQV9pW2ldICogQl9pW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gQztcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEIpIHx8IEIgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgICAgIGlmIChCLmxlbmd0aCAhPT0gcm93cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQS5kb3QoQik6IEEgaGFzICR7cm93c30gY29scyBhbmQgQiBoYXMgJHtCLmxlbmd0aH0gcm93cy4gTXVzdCBiZSBlcXVhbCFgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBDID0gbmV3IEFycmF5KHJvd3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICBDW3Jvd10gPSBuZXVtYWlyX3N1bSh0aGlzLnJvdyhyb3cpLm1hcCgoZSkgPT4gZSAqIEJbcm93XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEIgbXVzdCBiZSBNYXRyaXggb3IgQXJyYXlgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBvdXRlciBwcm9kdWN0IGZyb20ge0BsaW5rIHRoaXN9IGFuZCB7QGxpbmsgQn0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEJcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIG91dGVyKEIpIHtcbiAgICAgICAgbGV0IEEgPSB0aGlzO1xuICAgICAgICBsZXQgbCA9IEEuX2RhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgciA9IEIuX2RhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobCAhPSByKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgQyA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgQy5zaGFwZSA9IFtcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgKGksIGopID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBLl9kYXRhW2ldICogQi5fZGF0YVtqXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQy5lbnRyeShqLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gQztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIG1hdHJpeCB7QGxpbmsgQn0gdG8gdGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQiAtIG1hdHJpeCB0byBhcHBlbmQuXG4gICAgICogQHBhcmFtIHtcImhvcml6b250YWxcInxcInZlcnRpY2FsXCJ8XCJkaWFnXCJ9IFt0eXBlID0gXCJob3Jpem9udGFsXCJdIC0gdHlwZSBvZiBjb25jYXRlbmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAxXSwgWzEsIDFdXSk7IC8vIDIgYnkgMiBtYXRyaXggZmlsbGVkIHdpdGggb25lcy5cbiAgICAgKiBsZXQgQiA9IE1hdHJpeC5mcm9tKFtbMiwgMl0sIFsyLCAyXV0pOyAvLyAyIGJ5IDIgbWF0cml4IGZpbGxlZCB3aXRoIHR3b3MuXG4gICAgICpcbiAgICAgKiBBLmNvbmNhdChCLCBcImhvcml6b250YWxcIik7IC8vIDIgYnkgNCBtYXRyaXguIFtbMSwgMSwgMiwgMl0sIFsxLCAxLCAyLCAyXV1cbiAgICAgKiBBLmNvbmNhdChCLCBcInZlcnRpY2FsXCIpOyAvLyA0IGJ5IDIgbWF0cml4LiBbWzEsIDFdLCBbMSwgMV0sIFsyLCAyXSwgWzIsIDJdXVxuICAgICAqIEEuY29uY2F0KEIsIFwiZGlhZ1wiKTsgLy8gNCBieSA0IG1hdHJpeC4gW1sxLCAxLCAwLCAwXSwgWzEsIDEsIDAsIDBdLCBbMCwgMCwgMiwgMl0sIFswLCAwLCAyLCAyXV1cbiAgICAgKi9cbiAgICBjb25jYXQoQiwgdHlwZSA9IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzO1xuICAgICAgICBjb25zdCBbcm93c19BLCBjb2xzX0FdID0gQS5zaGFwZTtcbiAgICAgICAgY29uc3QgW3Jvd3NfQiwgY29sc19CXSA9IEIuc2hhcGU7XG4gICAgICAgIGlmICh0eXBlID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICBpZiAocm93c19BICE9IHJvd3NfQikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQS5jb25jYXQoQiwgXCJob3Jpem9udGFsXCIpOiBBIGFuZCBCIG5lZWQgc2FtZSBudW1iZXIgb2Ygcm93cywgQSBoYXMgJHtyb3dzX0F9IHJvd3MsIEIgaGFzICR7cm93c19CfSByb3dzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgWCA9IG5ldyBNYXRyaXgocm93c19BLCBjb2xzX0EgKyBjb2xzX0IsIFwiemVyb3NcIik7XG4gICAgICAgICAgICBYLnNldF9ibG9jaygwLCAwLCBBKTtcbiAgICAgICAgICAgIFguc2V0X2Jsb2NrKDAsIGNvbHNfQSwgQik7XG4gICAgICAgICAgICByZXR1cm4gWDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgaWYgKGNvbHNfQSAhPSBjb2xzX0IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEuY29uY2F0KEIsIFwidmVydGljYWxcIik6IEEgYW5kIEIgbmVlZCBzYW1lIG51bWJlciBvZiBjb2x1bW5zLCBBIGhhcyAke2NvbHNfQX0gY29sdW1ucywgQiBoYXMgJHtjb2xzX0J9IGNvbHVtbnMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBYID0gbmV3IE1hdHJpeChyb3dzX0EgKyByb3dzX0IsIGNvbHNfQSwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgICAgIFguc2V0X2Jsb2NrKDAsIDAsIEEpO1xuICAgICAgICAgICAgWC5zZXRfYmxvY2socm93c19BLCAwLCBCKTtcbiAgICAgICAgICAgIHJldHVybiBYO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJkaWFnXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IFggPSBuZXcgTWF0cml4KHJvd3NfQSArIHJvd3NfQiwgY29sc19BICsgY29sc19CLCBcInplcm9zXCIpO1xuICAgICAgICAgICAgWC5zZXRfYmxvY2soMCwgMCwgQSk7XG4gICAgICAgICAgICBYLnNldF9ibG9jayhyb3dzX0EsIGNvbHNfQSwgQik7XG4gICAgICAgICAgICByZXR1cm4gWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdHlwZSBtdXN0IGJlIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIiwgYnV0IHR5cGUgaXMgJHt0eXBlfSFgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyaXRlcyB0aGUgZW50cmllcyBvZiBCIGluIEEgYXQgYW4gb2Zmc2V0IHBvc2l0aW9uIGdpdmVuIGJ5IHtAbGluayBvZmZzZXRfcm93fSBhbmQge0BsaW5rIG9mZnNldF9jb2x9LlxuICAgICAqIEBwYXJhbSB7aW50fSBvZmZzZXRfcm93XG4gICAgICogQHBhcmFtIHtpbnR9IG9mZnNldF9jb2xcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc2V0X2Jsb2NrKG9mZnNldF9yb3csIG9mZnNldF9jb2wsIEIpIHtcbiAgICAgICAgbGV0IFtyb3dzLCBjb2xzXSA9IEIuc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBpZiAocm93ID4gdGhpcy5fcm93cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sID4gdGhpcy5fY29scykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfZW50cnkocm93ICsgb2Zmc2V0X3JvdywgY29sICsgb2Zmc2V0X2NvbCwgQi5lbnRyeShyb3csIGNvbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBlbnRyaWVzIGZyb20gdGhlIHtAbGluayBzdGFydF9yb3d9PHN1cD50aDwvc3VwPiByb3cgdG8gdGhlIHtAbGluayBlbmRfcm93fTxzdXA+dGg8L3N1cD4gcm93LCB0aGUge0BsaW5rIHN0YXJ0X2NvbH08c3VwPnRoPC9zdXA+IGNvbHVtbiB0byB0aGUge0BsaW5rIGVuZF9jb2x9PHN1cD50aDwvc3VwPiBjb2x1bW4gb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBJZiB7QGxpbmsgZW5kX3Jvd30gb3Ige0BsaW5rIGVuZF9jb2x9IGlzIGVtcHR5LCB0aGUgcmVzcGVjdGl2ZSB2YWx1ZSBpcyBzZXQgdG8ge0BsaW5rIHRoaXMucm93c30gb3Ige0BsaW5rIHRoaXMuY29sc30uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0X3Jvd1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydF9jb2xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZF9yb3cgPSBudWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kX2NvbCA9IG51bGxdXG4gICAgICogQHJldHVybnMge01hdHJpeH0gUmV0dXJucyBhIGVuZF9yb3cgLSBzdGFydF9yb3cgdGltZXMgZW5kX2NvbCAtIHN0YXJ0X2NvbCBtYXRyaXgsIHdpdGggcmVzcGVjdGl2ZSBlbnRyaWVzIGZyb20gdGhlIG1hdHJpeC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDIsIDNdLCBbNCwgNSwgNl0sIFs3LCA4LCA5XV0pOyAvLyBhIDMgYnkgMyBtYXRyaXguXG4gICAgICpcbiAgICAgKiBBLmdldF9ibG9jaygxLCAxKTsgLy8gW1s1LCA2XSwgWzgsIDldXVxuICAgICAqIEEuZ2V0X2Jsb2NrKDAsIDAsIDEsIDEpOyAvLyBbWzFdXVxuICAgICAqIEEuZ2V0X2Jsb2NrKDEsIDEsIDIsIDIpOyAvLyBbWzVdXVxuICAgICAqIEEuZ2V0X2Jsb2NrKDAsIDAsIDIsIDIpOyAvLyBbWzEsIDJdLCBbNCwgNV1dXG4gICAgICovXG4gICAgZ2V0X2Jsb2NrKHN0YXJ0X3Jvdywgc3RhcnRfY29sLCBlbmRfcm93ID0gbnVsbCwgZW5kX2NvbCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgW3Jvd3MsIGNvbHNdID0gdGhpcy5zaGFwZTtcbiAgICAgICAgZW5kX3JvdyA9IGVuZF9yb3cgPz8gcm93cztcbiAgICAgICAgZW5kX2NvbCA9IGVuZF9jb2wgPz8gY29scztcbiAgICAgICAgaWYgKGVuZF9yb3cgPD0gc3RhcnRfcm93IHx8IGVuZF9jb2wgPD0gc3RhcnRfY29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgICAgICAgICAgIGVuZF9yb3cgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RhcnRfcm93LCBhbmQgXG4gICAgICAgICAgICAgICAgZW5kX2NvbCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdGFydF9jb2wsIGJ1dFxuICAgICAgICAgICAgICAgIGVuZF9yb3cgPSAke2VuZF9yb3d9LCBzdGFydF9yb3cgPSAke3N0YXJ0X3Jvd30sIGVuZF9jb2wgPSAke2VuZF9jb2x9LCBhbmQgc3RhcnRfY29sID0gJHtzdGFydF9jb2x9IWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFggPSBuZXcgTWF0cml4KGVuZF9yb3cgLSBzdGFydF9yb3csIGVuZF9jb2wgLSBzdGFydF9jb2wsIFwiemVyb3NcIik7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IHN0YXJ0X3JvdywgbmV3X3JvdyA9IDA7IHJvdyA8IGVuZF9yb3c7ICsrcm93LCArK25ld19yb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHN0YXJ0X2NvbCwgbmV3X2NvbCA9IDA7IGNvbCA8IGVuZF9jb2w7ICsrY29sLCArK25ld19jb2wpIHtcbiAgICAgICAgICAgICAgICBYLnNldF9lbnRyeShuZXdfcm93LCBuZXdfY29sLCB0aGlzLmVudHJ5KHJvdywgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFg7XG4gICAgICAgIC8vcmV0dXJuIG5ldyBNYXRyaXgoZW5kX3JvdyAtIHN0YXJ0X3JvdywgZW5kX2NvbCAtIHN0YXJ0X2NvbCwgKGksIGopID0+IHRoaXMuZW50cnkoaSArIHN0YXJ0X3JvdywgaiArIHN0YXJ0X2NvbCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgZ2F0aGVyaW5nIGVudHJpZXMgZGVmaW5lZCBieSB0aGUgaW5kaWNlcyBnaXZlbiBieSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHJvd19pbmRpY2VzIC0gQXJyYXkgY29uc2lzdHMgb2YgaW5kaWNlcyBvZiByb3dzIGZvciBnYXRoZXJpbmcgZW50cmllcyBvZiB0aGlzIG1hdHJpeFxuICAgICAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gY29sX2luZGljZXMgIC0gQXJyYXkgY29uc2lzdHMgb2YgaW5kaWNlcyBvZiBjb2xzIGZvciBnYXRoZXJpbmcgZW50cmllcyBvZiB0aGlzIG1hdHJpeFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgZ2F0aGVyKHJvd19pbmRpY2VzLCBjb2xfaW5kaWNlcykge1xuICAgICAgICBjb25zdCBOID0gcm93X2luZGljZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBEID0gY29sX2luZGljZXMubGVuZ3RoO1xuXG4gICAgICAgIGNvbnN0IFIgPSBuZXcgTWF0cml4KE4sIEQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgcm93X2luZGV4ID0gcm93X2luZGljZXNbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbF9pbmRleCA9IGNvbF9pbmRpY2VzW2pdO1xuICAgICAgICAgICAgICAgIFIuc2V0X2VudHJ5KGksIGosIHRoaXMuZW50cnkocm93X2luZGV4LCBjb2xfaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXguXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmIGZ1bmN0aW9uIHRha2VzIDIgcGFyYW1ldGVycywgdGhlIHZhbHVlIG9mIHRoZSBhY3R1YWwgZW50cnkgYW5kIGEgdmFsdWUgZ2l2ZW4gYnkgdGhlIGZ1bmN0aW9uIHtAbGluayB2fS4gVGhlIHJlc3VsdCBvZiB7QGxpbmsgZn0gZ2V0cyB3cml0ZW4gdG8gdGhlIE1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB2IGZ1bmN0aW9uIHRha2VzIDIgcGFyYW1ldGVycyBmb3Igcm93IGFuZCBjb2wsIGFuZCByZXR1cm5zIGEgdmFsdWUgd2l0Y2ggc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIGNvbHRoIGVudHJ5IG9mIHRoZSByb3d0aCByb3cgb2YgdGhlIG1hdHJpeC5cbiAgICAgKi9cbiAgICBfYXBwbHlfYXJyYXkoZiwgdikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IFtyb3dzLCBjb2xzXSA9IHRoaXMuc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gb2Zmc2V0ICsgY29sO1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBmKGRhdGFbaV0sIHYocm93LCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfYXBwbHlfcm93d2lzZV9hcnJheSh2YWx1ZXMsIGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5X2FycmF5KGYsIChfLCBqKSA9PiB2YWx1ZXNbal0pO1xuICAgIH1cblxuICAgIF9hcHBseV9jb2x3aXNlX2FycmF5KHZhbHVlcywgZikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IFtyb3dzLCBjb2xzXSA9IHRoaXMuc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gb2Zmc2V0ICsgY29sO1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBmKGRhdGFbaV0sIHZhbHVlc1tyb3ddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfYXBwbHkodmFsdWUsIGYpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgW3ZhbHVlX3Jvd3MsIHZhbHVlX2NvbHNdID0gdmFsdWUuc2hhcGU7XG4gICAgICAgICAgICBsZXQgW3Jvd3MsIGNvbHNdID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZV9yb3dzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHMgIT09IHZhbHVlX2NvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb2xzICE9PSB2YWx1ZV9jb2xzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gZihkYXRhW3JvdyAqIGNvbHMgKyBjb2xdLCB2YWx1ZS5lbnRyeSgwLCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVfY29scyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3dzICE9PSB2YWx1ZV9yb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcm93cyAhPT0gdmFsdWVfcm93c2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWUuZW50cnkocm93LCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJvd3MgPT0gdmFsdWVfcm93cyAmJiBjb2xzID09IHZhbHVlX2NvbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWUuZW50cnkocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgICAgICBsZXQgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSByb3dzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbcm93ICogY29scyArIGNvbF0gPSBmKGRhdGFbcm93ICogY29scyArIGNvbF0sIHZhbHVlW3Jvd10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IGNvbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWVbY29sXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXJyb3JgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fcm93cyAqIHRoaXMuX2NvbHM7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2ldID0gZihkYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgbGV0IEIgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIEIuX3Jvd3MgPSB0aGlzLl9yb3dzO1xuICAgICAgICBCLl9jb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgQi5fZGF0YSA9IHRoaXMudmFsdWVzLnNsaWNlKDApO1xuICAgICAgICByZXR1cm4gQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnRyeXdpc2UgbXVsdGlwbGljYXRpb24gd2l0aCB7QGxpbmsgdmFsdWV9LlxuICAgICAqIEBwYXJhbSB7TWF0cml4fEFycmF5fE51bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBsZXQgQSA9IE1hdHJpeC5mcm9tKFtbMSwgMl0sIFszLCA0XV0pOyAvLyBhIDIgYnkgMiBtYXRyaXguXG4gICAgICogbGV0IEIgPSBBLmNsb25lKCk7IC8vIEIgPT0gQTtcbiAgICAgKlxuICAgICAqIEEubXVsdCgyKTsgLy8gW1syLCA0XSwgWzYsIDhdXTtcbiAgICAgKiBBLm11bHQoQik7IC8vIFtbMSwgNF0sIFs5LCAxNl1dO1xuICAgICAqL1xuICAgIG11bHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYXBwbHkodmFsdWUsIChhLCBiKSA9PiBhICogYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW50cnl3aXNlIGRpdmlzaW9uIHdpdGgge0BsaW5rIHZhbHVlfS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeHxBcnJheXxOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDJdLCBbMywgNF1dKTsgLy8gYSAyIGJ5IDIgbWF0cml4LlxuICAgICAqIGxldCBCID0gQS5jbG9uZSgpOyAvLyBCID09IEE7XG4gICAgICpcbiAgICAgKiBBLmRpdmlkZSgyKTsgLy8gW1swLjUsIDFdLCBbMS41LCAyXV07XG4gICAgICogQS5kaXZpZGUoQik7IC8vIFtbMSwgMV0sIFsxLCAxXV07XG4gICAgICovXG4gICAgZGl2aWRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2FwcGx5KHZhbHVlLCAoYSwgYikgPT4gYSAvIGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudHJ5d2lzZSBhZGRpdGlvbiB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAyXSwgWzMsIDRdXSk7IC8vIGEgMiBieSAyIG1hdHJpeC5cbiAgICAgKiBsZXQgQiA9IEEuY2xvbmUoKTsgLy8gQiA9PSBBO1xuICAgICAqXG4gICAgICogQS5hZGQoMik7IC8vIFtbMywgNF0sIFs1LCA2XV07XG4gICAgICogQS5hZGQoQik7IC8vIFtbMiwgNF0sIFs2LCA4XV07XG4gICAgICovXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2FwcGx5KHZhbHVlLCAoYSwgYikgPT4gYSArIGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudHJ5d2lzZSBzdWJ0cmFjdGlvbiB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAyXSwgWzMsIDRdXSk7IC8vIGEgMiBieSAyIG1hdHJpeC5cbiAgICAgKiBsZXQgQiA9IEEuY2xvbmUoKTsgLy8gQiA9PSBBO1xuICAgICAqXG4gICAgICogQS5zdWIoMik7IC8vIFtbLTEsIDBdLCBbMSwgMl1dO1xuICAgICAqIEEuc3ViKEIpOyAvLyBbWzAsIDBdLCBbMCwgMF1dO1xuICAgICAqL1xuICAgIHN1Yih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9hcHBseSh2YWx1ZSwgKGEsIGIpID0+IGEgLSBiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgTWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gQXJyYXkgaW4gdGhlIGZvcm0gW3Jvd3MsIGNvbHVtbnNdLlxuICAgICAqL1xuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl9yb3dzLCB0aGlzLl9jb2xzXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRyaXggaW4gdGhlIGdpdmVuIHNoYXBlIHdpdGggdGhlIGdpdmVuIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdmFsdWVzIGZvciB0aGUgZW50cmllcyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtZXRlciAtIHRha2VzIGFuIEFycmF5IGluIHRoZSBmb3JtIFtyb3dzLCBjb2xzLCB2YWx1ZV0sIHdoZXJlIHJvd3MgYW5kIGNvbHMgYXJlIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgbWF0cml4LCBhbmQgdmFsdWUgaXMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gcGFyYW1ldGVycyAocm93IGFuZCBjb2wpIHdoaWNoIGhhcyB0byByZXR1cm4gYSB2YWx1ZSBmb3IgdGhlIGNvbHRoIGVudHJ5IG9mIHRoZSByb3d0aCByb3cuXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzZXQgc2hhcGUoW3Jvd3MsIGNvbHMsIHZhbHVlID0gKCkgPT4gMF0pIHtcbiAgICAgICAgdGhpcy5fcm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuX2NvbHMgPSBjb2xzO1xuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0NjRBcnJheShyb3dzICogY29scyk7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbcm93ICogY29scyArIGNvbF0gPSB2YWx1ZShyb3csIGNvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTWF0cml4IGFzIGEgQXJyYXkgb2YgRmxvYXQ2NEFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8RmxvYXQ2NEFycmF5Pn1cbiAgICAgKi9cbiAgICBnZXQgdG8yZEFycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5pdGVyYXRlX3Jvd3MoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE1hdHJpeCBhcyBhIEFycmF5IG9mIEFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fVxuICAgICAqL1xuICAgIGdldCBhc0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5pdGVyYXRlX3Jvd3MoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goQXJyYXkuZnJvbShyb3cpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpYWdvbmFsIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgZGlhZygpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICBjb25zdCBtaW5fcm93X2NvbCA9IE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEZsb2F0NjRBcnJheShtaW5fcm93X2NvbCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluX3Jvd19jb2w7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5lbnRyeShpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1lYW4gb2YgYWxsIGVudHJpZXMgb2YgdGhlIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBtZWFuKCkge1xuICAgICAgICBjb25zdCBzdW0gPSB0aGlzLnN1bTtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX3Jvd3MgKiB0aGlzLl9jb2xzO1xuICAgICAgICByZXR1cm4gc3VtIC8gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb29mIGFsbCBlbnRyaWVzIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3VtKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIHJldHVybiBuZXVtYWlyX3N1bShkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb29mIGFsbCBlbnRyaWVzIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWVhbiBvZiBlYWNoIHJvdyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtGbG9hdDY0QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IG1lYW5Sb3dzKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0aGlzLl9yb3dzO1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRmxvYXQ2NEFycmF5LmZyb20oeyBsZW5ndGg6IHJvd3MgfSk7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICByZXN1bHRbcm93XSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyb3ddICs9IGRhdGFbcm93ICogY29scyArIGNvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbcm93XSAvPSBjb2xzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgdGhlIG1lYW4gb2YgZWFjaCBjb2x1bW4gb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7RmxvYXQ2NEFycmF5fVxuICAgICAqL1xuICAgIGdldCBtZWFuQ29scygpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMudmFsdWVzO1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEZsb2F0NjRBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb2xzIH0pO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgcmVzdWx0W2NvbF0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY29sXSArPSBkYXRhW3JvdyAqIGNvbHMgKyBjb2xdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2NvbF0gLz0gcm93cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNvbHZlcyB0aGUgZXF1YXRpb24ge0BsaW5rIEF9eCA9IHtAbGluayBifSB1c2luZyB0aGUgY29uanVnYXRlIGdyYWRpZW50IG1ldGhvZC4gUmV0dXJucyB0aGUgcmVzdWx0IHguXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEEgLSBNYXRyaXhcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gYiAtIE1hdHJpeFxuICAgICAqIEBwYXJhbSB7UmFuZG9taXplcn0gW3JhbmRvbWl6ZXI9bnVsbF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RvbD0xZS0zXVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc3RhdGljIHNvbHZlX0NHKEEsIGIsIHJhbmRvbWl6ZXIsIHRvbCA9IDFlLTMpIHtcbiAgICAgICAgaWYgKHJhbmRvbWl6ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJhbmRvbWl6ZXIgPSBuZXcgUmFuZG9taXplcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvd3MgPSBBLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBjb2xzID0gYi5zaGFwZVsxXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBNYXRyaXgocm93cywgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sczsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBiX2kgPSBNYXRyaXguZnJvbShiLmNvbChpKSkuVDtcbiAgICAgICAgICAgIGxldCB4ID0gbmV3IE1hdHJpeChyb3dzLCAxLCAoKSA9PiByYW5kb21pemVyLnJhbmRvbSk7XG4gICAgICAgICAgICBsZXQgciA9IGJfaS5zdWIoQS5kb3QoeCkpO1xuICAgICAgICAgICAgbGV0IGQgPSByLmNsb25lKCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IEEuZG90KGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscGhhID0gci5ULmRvdChyKS5lbnRyeSgwLCAwKSAvIGQuVC5kb3QoeikuZW50cnkoMCwgMCk7XG4gICAgICAgICAgICAgICAgeCA9IHguYWRkKGQubXVsdChhbHBoYSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJfbmV4dCA9IHIuc3ViKHoubXVsdChhbHBoYSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJldGEgPSByX25leHQuVC5kb3Qocl9uZXh0KS5lbnRyeSgwLCAwKSAvIHIuVC5kb3QocikuZW50cnkoMCwgMCk7XG4gICAgICAgICAgICAgICAgZCA9IHJfbmV4dC5hZGQoZC5tdWx0KGJldGEpKTtcbiAgICAgICAgICAgICAgICByID0gcl9uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAoTWF0aC5hYnMoci5tZWFuKSA+IHRvbCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHgsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNvbHZlcyB0aGUgZXF1YXRpb24ge0BsaW5rIEF9eCA9IHtAbGluayBifS4gUmV0dXJucyB0aGUgcmVzdWx0IHguXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEEgLSBNYXRyaXggb3IgTFUgRGVjb21wb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBiIC0gTWF0cml4XG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzdGF0aWMgc29sdmUoQSwgYikge1xuICAgICAgICBsZXQgeyBMOiBMLCBVOiBVIH0gPSBcIkxcIiBpbiBBICYmIFwiVVwiIGluIEEgPyBBIDogTWF0cml4LkxVKEEpO1xuICAgICAgICBsZXQgcm93cyA9IEwuc2hhcGVbMF07XG4gICAgICAgIGxldCB4ID0gYi5jbG9uZSgpO1xuXG4gICAgICAgIC8vIGZvcndhcmRcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHJvdyAtIDE7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgeC5zZXRfZW50cnkoMCwgcm93LCB4LmVudHJ5KDAsIHJvdykgLSBMLmVudHJ5KHJvdywgY29sKSAqIHguZW50cnkoMSwgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4LnNldF9lbnRyeSgwLCByb3csIHguZW50cnkoMCwgcm93KSAvIEwuZW50cnkocm93LCByb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJhY2t3YXJkXG4gICAgICAgIGZvciAobGV0IHJvdyA9IHJvd3MgLSAxOyByb3cgPj0gMDsgLS1yb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHJvd3MgLSAxOyBjb2wgPiByb3c7IC0tY29sKSB7XG4gICAgICAgICAgICAgICAgeC5zZXRfZW50cnkoMCwgcm93LCB4LmVudHJ5KDAsIHJvdykgLSBVLmVudHJ5KHJvdywgY29sKSAqIHguZW50cnkoMCwgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4LnNldF9lbnRyeSgwLCByb3csIHguZW50cnkoMCwgcm93KSAvIFUuZW50cnkocm93LCByb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHtAbGluayBMfXtAbGluayBVfSBkZWNvbXBvc2l0aW9uIG9mIHRoZSBNYXRyaXgge0BsaW5rIEF9LiBDcmVhdGVzIHR3byBtYXRyaWNlcywgc28gdGhhdCB0aGUgZG90IHByb2R1Y3QgTFUgZXF1YWxzIEEuXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEFcbiAgICAgKiBAcmV0dXJucyB7e0w6IE1hdHJpeCwgVTogTWF0cml4fX0gcmVzdWx0IC0gUmV0dXJucyB0aGUgbGVmdCB0cmlhbmdsZSBtYXRyaXgge0BsaW5rIEx9IGFuZCB0aGUgdXBwZXIgdHJpYW5nbGUgbWF0cml4IHtAbGluayBVfS5cbiAgICAgKi9cbiAgICBzdGF0aWMgTFUoQSkge1xuICAgICAgICBjb25zdCByb3dzID0gQS5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgTCA9IG5ldyBNYXRyaXgocm93cywgcm93cywgXCJ6ZXJvc1wiKTtcbiAgICAgICAgY29uc3QgVSA9IG5ldyBNYXRyaXgocm93cywgcm93cywgXCJpZGVudGl0eVwiKTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd3M7ICsraikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGo7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGo7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gTC5lbnRyeShpLCBrKSAqIFUuZW50cnkoaywgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEwuc2V0X2VudHJ5KGksIGosIEEuZW50cnkoaSwgaikgLSBzdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGo7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoTC5lbnRyeShqLCBqKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGo7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gTC5lbnRyeShqLCBrKSAqIFUuZW50cnkoaywgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFUuc2V0X2VudHJ5KGosIGksIChBLmVudHJ5KGosIGkpIC0gc3VtKSAvIEwuZW50cnkoaiwgaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgTDogTCwgVTogVSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkZXRlcm1pbmFudGUgb2Yge0BsaW5rIEF9LCBieSB1c2luZyB0aGUgTFUgZGVjb21wb3NpdGlvbiBvZiB7QGxpbmsgQX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEFcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBkZXQgLSBSZXR1cm5zIHRoZSBkZXRlcm1pbmF0ZSBvZiB0aGUgTWF0cml4IHtAbGluayBBfS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGV0KEEpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IEEuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHsgTCwgVSB9ID0gTWF0cml4LkxVKEEpO1xuICAgICAgICBjb25zdCBMX2RpYWcgPSBMLmRpYWc7XG4gICAgICAgIGNvbnN0IFVfZGlhZyA9IFUuZGlhZztcbiAgICAgICAgbGV0IGRldCA9IExfZGlhZ1swXSAqIFVfZGlhZ1swXTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMTsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGRldCAqPSBMX2RpYWdbcm93XSAqIFVfZGlhZ1tyb3ddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHtAbGluayBrfSBjb21wb25lbnRzIG9mIHRoZSBTVkQgZGVjb21wb3NpdGlvbiBvZiB0aGUgbWF0cml4IHtAbGluayBNfVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBNXG4gICAgICogQHBhcmFtIHtpbnR9IFtrPTJdXG4gICAgICogQHJldHVybnMge3tVOiBNYXRyaXgsIFNpZ21hOiBNYXRyaXgsIFY6IE1hdHJpeH19XG4gICAgICovXG4gICAgc3RhdGljIFNWRChNLCBrID0gMikge1xuICAgICAgICBjb25zdCBNVCA9IE0uVDtcbiAgICAgICAgbGV0IE10TSA9IE1ULmRvdChNKTtcbiAgICAgICAgbGV0IE1NdCA9IE0uZG90KE1UKTtcbiAgICAgICAgbGV0IHsgZWlnZW52ZWN0b3JzOiBWLCBlaWdlbnZhbHVlczogU2lnbWEgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihNdE0sIGspO1xuICAgICAgICBsZXQgeyBlaWdlbnZlY3RvcnM6IFUgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihNTXQsIGspO1xuICAgICAgICByZXR1cm4geyBVOiBVLCBTaWdtYTogU2lnbWEubWFwKChzaWdtYSkgPT4gTWF0aC5zcXJ0KHNpZ21hKSksIFY6IFYgfTtcblxuICAgICAgICAvL0FsZ29yaXRobSAxYTogSG91c2Vob2xkZXIgcmVkdWN0aW9uIHRvIGJpZGlhZ29uYWwgZm9ybTpcbiAgICAgICAgLyogY29uc3QgW20sIG5dID0gQS5zaGFwZTtcbiAgICAgICAgbGV0IFUgPSBuZXcgTWF0cml4KG0sIG4sIChpLCBqKSA9PiBpID09IGogPyAxIDogMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFUudG8yZEFycmF5KVxuICAgICAgICBsZXQgViA9IG5ldyBNYXRyaXgobiwgbSwgKGksIGopID0+IGkgPT0gaiA/IDEgOiAwKTtcbiAgICAgICAgY29uc29sZS5sb2coVi50bzJkQXJyYXkpXG4gICAgICAgIGxldCBCID0gTWF0cml4LmJpZGlhZ29uYWwoQS5jbG9uZSgpLCBVLCBWKTtcbiAgICAgICAgY29uc29sZS5sb2coVSxWLEIpXG4gICAgICAgIHJldHVybiB7IFU6IFUsIFwiU2lnbWFcIjogQiwgVjogViB9OyAqL1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGxpbnNwYWNlLCBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnV0aWxzXG4gKiBAYWxpYXMgUmFuZG9taXplclxuICovXG5leHBvcnQgY2xhc3MgUmFuZG9taXplciB7XG4gICAgLyoqXG4gICAgICogTWVyc2VubmUgVHdpc3RlciByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW19zZWVkPW5ldyBEYXRlKCkuZ2V0VGltZSgpXSAtIFRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuIElmIDxjb2RlPl9zZWVkID09IG51bGw8L2NvZGU+IHRoZW4gdGhlIGFjdHVhbCB0aW1lIGdldHMgdXNlZCBhcyBzZWVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JtdXJyYXk3L21lcnNlbm5lLXR3aXN0ZXItZXhhbXBsZXMvYmxvYi9tYXN0ZXIvamF2YXNjcmlwdC1tZXJzZW5uZS10d2lzdGVyLmpzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX3NlZWQpIHtcbiAgICAgICAgdGhpcy5fTiA9IDYyNDtcbiAgICAgICAgdGhpcy5fTSA9IDM5NztcbiAgICAgICAgdGhpcy5fTUFUUklYX0EgPSAweDk5MDhiMGRmO1xuICAgICAgICB0aGlzLl9VUFBFUl9NQVNLID0gMHg4MDAwMDAwMDtcbiAgICAgICAgdGhpcy5fTE9XRVJfTUFTSyA9IDB4N2ZmZmZmZmY7XG4gICAgICAgIHRoaXMuX210ID0gbmV3IEFycmF5KHRoaXMuX04pO1xuICAgICAgICB0aGlzLl9tdGkgPSB0aGlzLk4gKyAxO1xuXG4gICAgICAgIHRoaXMuc2VlZCA9IF9zZWVkIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXQgc2VlZChfc2VlZCkge1xuICAgICAgICB0aGlzLl9zZWVkID0gX3NlZWQ7XG4gICAgICAgIGxldCBtdCA9IHRoaXMuX210O1xuXG4gICAgICAgIG10WzBdID0gX3NlZWQgPj4+IDA7XG4gICAgICAgIGZvciAodGhpcy5fbXRpID0gMTsgdGhpcy5fbXRpIDwgdGhpcy5fTjsgdGhpcy5fbXRpICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBtdGkgPSB0aGlzLl9tdGk7XG4gICAgICAgICAgICBsZXQgcyA9IG10W210aSAtIDFdIF4gKG10W210aSAtIDFdID4+PiAzMCk7XG4gICAgICAgICAgICBtdFttdGldID0gKCgoKHMgJiAweGZmZmYwMDAwKSA+Pj4gMTYpICogMTgxMjQzMzI1MykgPDwgMTYpICsgKHMgJiAweDAwMDBmZmZmKSAqIDE4MTI0MzMyNTMgKyBtdGk7XG4gICAgICAgICAgICBtdFttdGldID4+Pj0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlZWQgb2YgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIHNlZWQuXG4gICAgICovXG4gICAgZ2V0IHNlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybnMge051bWJlcn0gLSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBbMCwgMV1cbiAgICAgKi9cbiAgICBnZXQgcmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5kb21faW50ICogKDEuMCAvIDQyOTQ5NjcyOTYuMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgTUFYX0lOVEVHRVIuXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9IC0gQSByYW5kb20gaW50ZWdlci5cbiAgICAgKi9cbiAgICBnZXQgcmFuZG9tX2ludCgpIHtcbiAgICAgICAgbGV0IHksXG4gICAgICAgICAgICBtYWcwMSA9IG5ldyBBcnJheSgweDAsIHRoaXMuX01BVFJJWF9BKTtcbiAgICAgICAgaWYgKHRoaXMuX210aSA+PSB0aGlzLl9OKSB7XG4gICAgICAgICAgICBsZXQga2s7XG5cbiAgICAgICAgICAgIC8qIGlmICh0aGlzLl9tdGkgPT0gdGhpcy5fTiArIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlZWQgPSA1NDg5O1xuICAgICAgICAgICAgfSAqL1xuXG4gICAgICAgICAgICBsZXQgTl9NID0gdGhpcy5fTiAtIHRoaXMuX007XG4gICAgICAgICAgICBsZXQgTV9OID0gdGhpcy5fTSAtIHRoaXMuX047XG5cbiAgICAgICAgICAgIGZvciAoa2sgPSAwOyBrayA8IE5fTTsgKytraykge1xuICAgICAgICAgICAgICAgIHkgPSAodGhpcy5fbXRba2tdICYgdGhpcy5fVVBQRVJfTUFTSykgfCAodGhpcy5fbXRba2sgKyAxXSAmIHRoaXMuX0xPV0VSX01BU0spO1xuICAgICAgICAgICAgICAgIHRoaXMuX210W2trXSA9IHRoaXMuX210W2trICsgdGhpcy5fTV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyBrayA8IHRoaXMuX04gLSAxOyArK2trKSB7XG4gICAgICAgICAgICAgICAgeSA9ICh0aGlzLl9tdFtra10gJiB0aGlzLl9VUFBFUl9NQVNLKSB8ICh0aGlzLl9tdFtrayArIDFdICYgdGhpcy5fTE9XRVJfTUFTSyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbXRba2tdID0gdGhpcy5fbXRba2sgKyBNX05dIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHkgPSAodGhpcy5fbXRbdGhpcy5fTiAtIDFdICYgdGhpcy5fVVBQRVJfTUFTSykgfCAodGhpcy5fbXRbMF0gJiB0aGlzLl9MT1dFUl9NQVNLKTtcbiAgICAgICAgICAgIHRoaXMuX210W3RoaXMuX04gLSAxXSA9IHRoaXMuX210W3RoaXMuX00gLSAxXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdO1xuXG4gICAgICAgICAgICB0aGlzLl9tdGkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgeSA9IHRoaXMuX210Wyh0aGlzLl9tdGkgKz0gMSldO1xuICAgICAgICB5IF49IHkgPj4+IDExO1xuICAgICAgICB5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcbiAgICAgICAgeSBePSAoeSA8PCAxNSkgJiAweGVmYzYwMDAwO1xuICAgICAgICB5IF49IHkgPj4+IDE4O1xuXG4gICAgICAgIHJldHVybiB5ID4+PiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2FtcGxlcyBmcm9tIGFuIGlucHV0IE1hdHJpeCBvciBBcnJheS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeHxBcnJheXxGbG9hdDY0QXJyYXl9IEEgLSBUaGUgaW5wdXQgTWF0cml4IG9yIEFycmF5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSBBIHJhbmRvbSBzZWxlY3Rpb24gZm9ybSB7QGxpbmsgQX0gb2Yge0BsaW5rIG59IHNhbXBsZXMuXG4gICAgICovXG4gICAgY2hvaWNlKEEsIG4pIHtcbiAgICAgICAgaWYgKEEgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gQS5zaGFwZVswXTtcbiAgICAgICAgICAgIGlmIChuID4gcm93cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm4gYmlnZ2VyIHRoYW4gQSFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2FtcGxlID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgbGV0IGluZGV4X2xpc3QgPSBsaW5zcGFjZSgwLCByb3dzIC0gMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGluZGV4X2xpc3QubGVuZ3RoOyBpIDwgbjsgKytpLCAtLWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZG9tX2luZGV4ID0gdGhpcy5yYW5kb21faW50ICUgbDtcbiAgICAgICAgICAgICAgICBzYW1wbGVbaV0gPSBpbmRleF9saXN0LnNwbGljZShyYW5kb21faW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZS5tYXAoKGQpID0+IEEucm93KGQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEEpIHx8IEEgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gQS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobiA+IHJvd3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuIGJpZ2dlciB0aGFuIEEhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNhbXBsZSA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGxldCBpbmRleF9saXN0ID0gbGluc3BhY2UoMCwgcm93cyAtIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpbmRleF9saXN0Lmxlbmd0aDsgaSA8IG47ICsraSwgLS1sKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmRvbV9pbmRleCA9IHRoaXMucmFuZG9tX2ludCAlIGw7XG4gICAgICAgICAgICAgICAgc2FtcGxlW2ldID0gaW5kZXhfbGlzdC5zcGxpY2UocmFuZG9tX2luZGV4LCAxKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYW1wbGUubWFwKChkKSA9PiBBW2RdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBSZXR1cm5zIHNhbXBsZXMgZnJvbSBhbiBpbnB1dCBNYXRyaXggb3IgQXJyYXkuXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8RmxvYXQ2NEFycmF5fSBBIC0gVGhlIGlucHV0IE1hdHJpeCBvciBBcnJheS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiAtIFRoZSBudW1iZXIgb2Ygc2FtcGxlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VlZCAtIFRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIEEgcmFuZG9tIHNlbGVjdGlvbiBmb3JtIHtAbGluayBBfSBvZiB7QGxpbmsgbn0gc2FtcGxlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY2hvaWNlKEEsIG4sIHNlZWQgPSAxMjEyKSB7XG4gICAgICAgIGNvbnN0IFIgPSBuZXcgUmFuZG9taXplcihzZWVkKTtcbiAgICAgICAgcmV0dXJuIFIuY2hvaWNlKEEsIG4pO1xuICAgICAgICAvKiBsZXQgcm93cyA9IEEuc2hhcGVbMF07XG4gICAgICAgIGlmIChuID4gcm93cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibiBiaWdnZXIgdGhhbiBBIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZCA9IG5ldyBSYW5kb21pemVyKHNlZWQpO1xuICAgICAgICBsZXQgc2FtcGxlID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBsZXQgaW5kZXhfbGlzdCA9IGxpbnNwYWNlKDAsIHJvd3MgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpbmRleF9saXN0Lmxlbmd0aDsgaSA8IG47ICsraSwgLS1sKSB7XG4gICAgICAgICAgICBsZXQgcmFuZG9tX2luZGV4ID0gcmFuZC5yYW5kb21faW50ICUgbDtcbiAgICAgICAgICAgIHNhbXBsZVtpXSA9IGluZGV4X2xpc3Quc3BsaWNlKHJhbmRvbV9pbmRleCwgMSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy9yZXR1cm4gcmVzdWx0O1xuICAgICAgICAvL3JldHVybiBuZXcgTWF0cml4KG4sIGNvbHMsIChyb3csIGNvbCkgPT4gQS5lbnRyeShzYW1wbGVbcm93XSwgY29sKSlcbiAgICAgICAgcmV0dXJuIHNhbXBsZS5tYXAoKGQpID0+IEEucm93KGQpKTsgKi9cbiAgICB9XG59XG4iLCIvKipcbiAqIFJldHVybnMgbWF4aW11bSBpbiBBcnJheSB7QGxpbmsgdmFsdWVzfS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dXRpbHNcbiAqIEBhbGlhcyBtYXhcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICBsZXQgbWF4O1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbn0iLCIvKipcbiAqIFJldHVybnMgbWF4aW11bSBpbiBBcnJheSB7QGxpbmsgdmFsdWVzfS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dXRpbHNcbiAqIEBhbGlhcyBtaW5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIGxldCBtaW47XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA8PSB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluO1xufSIsIi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSGVhcFxuICovXG5leHBvcnQgY2xhc3MgSGVhcCB7XG4gICAgLyoqXG4gICAgICogQSBoZWFwIGlzIGEgZGF0YXN0cnVjdHVyZSBob2xkaW5nIGl0cyBlbGVtZW50cyBpbiBhIHNwZWNpZmljIHdheSwgc28gdGhhdCB0aGUgdG9wIGVsZW1lbnQgd291bGQgYmUgdGhlIGZpcnN0IGVudHJ5IG9mIGFuIG9yZGVyZWQgbGlzdC5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRhdGFzdHJ1Y3R1cmVcbiAgICAgKiBAYWxpYXMgSGVhcFxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBlbGVtZW50cyAtIENvbnRhaW5zIHRoZSBlbGVtZW50cyBmb3IgdGhlIEhlYXAuIHtAbGluayBlbGVtZW50c30gY2FuIGJlIG51bGwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2FjY2Vzc29yID0gKGQpID0+IGRdIC0gRnVuY3Rpb24gcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHsoXCJtaW5cInxcIm1heFwifEZ1bmN0aW9uKX0gW2NvbXBhcmF0b3IgPSBcIm1pblwiXSAtIEZ1bmN0aW9uIHJldHVybmluZyB0cnVlIG9yIGZhbHNlIGRlZmluaW5nIHRoZSB3aXNoZWQgb3JkZXIgb2YgdGhlIEhlYXAsIG9yIFN0cmluZyBmb3IgcHJlZGVmaW5lZCBmdW5jdGlvbi4gKFwibWluXCIgZm9yIGEgTWluLUhlYXAsIFwibWF4XCIgZm9yIGEgTWF4X2hlYXApXG4gICAgICogQHJldHVybnMge0hlYXB9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmluYXJ5X2hlYXB9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMgPSBudWxsLCBhY2Nlc3NvciA9IGQgPT4gZCwgY29tcGFyYXRvciA9IFwibWluXCIpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gSGVhcC5oZWFwaWZ5KGVsZW1lbnRzLCBhY2Nlc3NvciwgY29tcGFyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hY2Nlc3NvciA9IGFjY2Vzc29yO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gW107XG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvciA9PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IChhLCBiKSA9PiBhIDwgYjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGFyYXRvciA9PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IChhLCBiKSA9PiBhID4gYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEhlYXAgZnJvbSBhbiBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl8U2V0fSBlbGVtZW50cyAtIENvbnRhaW5zIHRoZSBlbGVtZW50cyBmb3IgdGhlIEhlYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbj19IFthY2Nlc3NvciA9IChkKSA9PiBkXSAtIEZ1bmN0aW9uIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7KFN0cmluZz18RnVuY3Rpb24pfSBbY29tcGFyYXRvciA9IFwibWluXCJdIC0gRnVuY3Rpb24gcmV0dXJuaW5nIHRydWUgb3IgZmFsc2UgZGVmaW5pbmcgdGhlIHdpc2hlZCBvcmRlciBvZiB0aGUgSGVhcCwgb3IgU3RyaW5nIGZvciBwcmVkZWZpbmVkIGZ1bmN0aW9uLiAoXCJtaW5cIiBmb3IgYSBNaW4tSGVhcCwgXCJtYXhcIiBmb3IgYSBNYXhfaGVhcClcbiAgICAgKiBAcmV0dXJucyB7SGVhcH1cbiAgICAgKi9cbiAgICBzdGF0aWMgaGVhcGlmeShlbGVtZW50cywgYWNjZXNzb3IgPSBkID0+IGQsIGNvbXBhcmF0b3IgPSBcIm1pblwiKSB7XG4gICAgICAgIGNvbnN0IGhlYXAgPSBuZXcgSGVhcChudWxsLCBhY2Nlc3NvciwgY29tcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGhlYXAuX2NvbnRhaW5lcjtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb250YWluZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgXCJlbGVtZW50XCI6IGUsXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBhY2Nlc3NvcihlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLmZsb29yKChlbGVtZW50cy5sZW5ndGggLyAyKSAtIDEpOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaGVhcC5faGVhcGlmeV9kb3duKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGVsZW1lbnRzIG9mIGNvbnRhaW5lciBhcnJheS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleF9hIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleF9iIFxuICAgICAqL1xuICAgIF9zd2FwKGluZGV4X2EsIGluZGV4X2IpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBbY29udGFpbmVyW2luZGV4X2JdLCBjb250YWluZXJbaW5kZXhfYV1dID0gW2NvbnRhaW5lcltpbmRleF9hXSwgY29udGFpbmVyW2luZGV4X2JdXTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hlYXBpZnlfdXAoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgbGV0IGluZGV4ID0gY29udGFpbmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRJbmRleCA9IE1hdGguZmxvb3IoKGluZGV4IC0gMSkgLyAyKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29tcGFyYXRvcihjb250YWluZXJbaW5kZXhdLnZhbHVlLCBjb250YWluZXJbcGFyZW50SW5kZXhdLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N3YXAocGFyZW50SW5kZXgsIGluZGV4KVxuICAgICAgICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1c2hlcyB0aGUgZWxlbWVudCB0byB0aGUgaGVhcC5cbiAgICAgKiBAcGFyYW0ge30gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtIZWFwfVxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2FjY2Vzc29yKGVsZW1lbnQpO1xuICAgICAgICAvL2NvbnN0IG5vZGUgPSBuZXcgTm9kZShlbGVtZW50LCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB7XCJlbGVtZW50XCI6IGVsZW1lbnQsIFwidmFsdWVcIjogdmFsdWV9O1xuICAgICAgICB0aGlzLl9jb250YWluZXIucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5faGVhcGlmeV91cCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRfaW5kZXggPSAwXSBcbiAgICAgKi9cbiAgICBfaGVhcGlmeV9kb3duKHN0YXJ0X2luZGV4PTApIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBjb25zdCBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY29udGFpbmVyLmxlbmd0aDtcbiAgICAgICAgbGV0IGxlZnQgPSAyICogc3RhcnRfaW5kZXggKyAxO1xuICAgICAgICBsZXQgcmlnaHQgPSAyICogc3RhcnRfaW5kZXggKyAyO1xuICAgICAgICBsZXQgaW5kZXggPSBzdGFydF9pbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoKSB0aHJvdyBcImluZGV4IGhpZ2hlciB0aGFuIGxlbmd0aFwiXG4gICAgICAgIGlmIChsZWZ0IDwgbGVuZ3RoICYmIGNvbXBhcmF0b3IoY29udGFpbmVyW2xlZnRdLnZhbHVlLCBjb250YWluZXJbaW5kZXhdLnZhbHVlKSkge1xuICAgICAgICAgICAgaW5kZXggPSBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCA8IGxlbmd0aCAmJiBjb21wYXJhdG9yKGNvbnRhaW5lcltyaWdodF0udmFsdWUsIGNvbnRhaW5lcltpbmRleF0udmFsdWUpKSB7XG4gICAgICAgICAgICBpbmRleCA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPT0gc3RhcnRfaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N3YXAoc3RhcnRfaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX2hlYXBpZnlfZG93bihpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSB0b3AgZW50cnkgb2YgdGhlIGhlYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IGNvbnNpc3RzIG9mIHRoZSBlbGVtZW50IGFuZCBpdHMgdmFsdWUgKGNvbXB1dGVkIGJ5IHtAbGluayBhY2Nlc3Nvcn0pLlxuICAgICAqL1xuICAgIHBvcCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zd2FwKDAsIGNvbnRhaW5lci5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgaXRlbSA9IGNvbnRhaW5lci5wb3AoKTtcbiAgICAgICAgdGhpcy5faGVhcGlmeV9kb3duKCk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvcCBlbnRyeSBvZiB0aGUgaGVhcCB3aXRob3V0IHJlbW92aW5nIGl0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb25zaXN0cyBvZiB0aGUgZWxlbWVudCBhbmQgaXRzIHZhbHVlIChjb21wdXRlZCBieSB7QGxpbmsgYWNjZXNzb3J9KS5cbiAgICAgKi9cbiAgICBnZXQgZmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXIubGVuZ3RoID4gMCA/IHRoaXMuX2NvbnRhaW5lclswXSA6IG51bGw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBZaWVsZHMgdGhlIHJhdyBkYXRhXG4gICAgICogQHlpZWxkcyB7T2JqZWN0fSBPYmplY3QgY29uc2lzdHMgb2YgdGhlIGVsZW1lbnQgYW5kIGl0cyB2YWx1ZSAoY29tcHV0ZWQgYnkge0BsaW5rIGFjY2Vzc29yfSkuXG4gICAgICovXG4gICAgKiBpdGVyYXRlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NvbnRhaW5lci5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX2NvbnRhaW5lcltpXS5lbGVtZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVhcCBhcyBvcmRlcmVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgY29uc2lzdGluZyB0aGUgZWxlbWVudHMgb3JkZXJlZCBieSB7QGxpbmsgY29tcGFyYXRvcn0uXG4gICAgICovXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpXG4gICAgICAgICAgICAuc29ydCgoYSxiKSA9PiB0aGlzLl9jb21wYXJhdG9yKGEsIGIpID8gLTEgOiAwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZWxlbWVudHMgb2YgY29udGFpbmVyIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgY29uc2lzdGluZyB0aGUgZWxlbWVudHMuXG4gICAgICovXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lclxuICAgICAgICAgICAgLm1hcChkID0+IGQuZWxlbWVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250YWluZXIgYXJyYXkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgY29udGFpbmVyIGFycmF5LlxuICAgICAqL1xuICAgIHJhd19kYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSBoZWFwLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lci5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmYWxzZSBpZiB0aGUgdGhlIGhlYXAgaGFzIGVudHJpZXMsIHRydWUgaWYgdGhlIGhlYXAgaGFzIG5vIGVudHJpZXMuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gICAgfVxufSIsIi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgRGlzam9pbnRTZXRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc2pvaW50LXNldF9kYXRhX3N0cnVjdHVyZX1cbiAqL1xuZXhwb3J0IGNsYXNzIERpc2pvaW50U2V0IHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgRGlzam9pbnRTZXRcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRhdGFzdHJ1Y3R1cmVcbiAgICAgKiBAcGFyYW0ge0FycmF5PX0gZWxlbWVudHMgXG4gICAgICogQHJldHVybnMge0Rpc2pvaW50U2V0fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9saXN0ID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMubWFrZV9zZXQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbWFrZV9zZXQoeCkge1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgaWYgKCFsaXN0Lmhhcyh4KSkge1xuICAgICAgICAgICAgbGlzdC5hZGQoeCk7XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0ID0ge307XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0LnBhcmVudCA9IHg7XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuID0gbmV3IFNldChbeF0pO1xuICAgICAgICAgICAgeC5fX2Rpc2pvaW50X3NldC5zaXplID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmaW5kKHgpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIGlmIChsaXN0Lmhhcyh4KSkge1xuICAgICAgICAgICAgaWYgKHguX19kaXNqb2ludF9zZXQucGFyZW50ICE9PSB4KSB7XG4gICAgICAgICAgICAgICAgeC5fX2Rpc2pvaW50X3NldC5jaGlsZHJlbi5hZGQoLi4ueCk7XG4gICAgICAgICAgICAgICAgeC5fX2Rpc2pvaW50X3NldC5wYXJlbnQgPSB0aGlzLmZpbmQoeC5fX2Rpc2pvaW50X3NldC5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB4Ll9fZGlzam9pbnRfc2V0LnBhcmVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuaW9uKHgsIHkpIHtcbiAgICAgICAgbGV0IG5vZGVfeCA9IHRoaXMuZmluZCh4KTtcbiAgICAgICAgbGV0IG5vZGVfeSA9IHRoaXMuZmluZCh5KTtcblxuICAgICAgICBpZiAobm9kZV94ID09PSBub2RlX3kpIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAobm9kZV94Ll9fZGlzam9pbnRfc2V0LnNpemUgPCBub2RlX3kuX19kaXNqb2ludF9zZXQuc2l6ZSkgW25vZGVfeCwgbm9kZV95XSA9IFtub2RlX3ksIG5vZGVfeF07XG5cbiAgICAgICAgbm9kZV95Ll9fZGlzam9pbnRfc2V0LnBhcmVudCA9IG5vZGVfeDtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbj9cbiAgICAgICAgbm9kZV95Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuLmZvckVhY2gobm9kZV94Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuLmFkZCwgbm9kZV94Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuKTtcbiAgICAgICAgbm9kZV94Ll9fZGlzam9pbnRfc2V0LnNpemUgKz0gbm9kZV95Ll9fZGlzam9pbnRfc2V0LnNpemU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBIZWFwIH0gZnJvbSBcIi4uL2RhdGFzdHJ1Y3R1cmUvaW5kZXguanNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgQmFsbFRyZWVcbiAqL1xuZXhwb3J0IGNsYXNzIEJhbGxUcmVlIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBCYWxsVHJlZSB3aXRoIGdpdmVuIHtAbGluayBlbGVtZW50c30uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTprbm5cbiAgICAgKiBAYWxpYXMgQmFsbFRyZWVcbiAgICAgKiBAcGFyYW0ge0FycmF5PX0gZWxlbWVudHMgLSBFbGVtZW50cyB3aGljaCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIEJhbGxUcmVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gbWV0cmljIHRvIHVzZTogKGEsIGIpID0+IGRpc3RhbmNlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFsbF90cmVlfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbnZpc2FsL25vb2Jqcy9ibG9iL21hc3Rlci9zcmMvdHJlZS9CYWxsVHJlZS5qc31cbiAgICAgKiBAcmV0dXJucyB7QmFsbFRyZWV9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMgPSBudWxsLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICAgICAgdGhpcy5fTm9kZSA9IGNsYXNzIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBpdm90LCBjaGlsZDE9bnVsbCwgY2hpbGQyPW51bGwsIHJhZGl1cz1udWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waXZvdCA9IHBpdm90O1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQxID0gY2hpbGQxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQyID0gY2hpbGQyO1xuICAgICAgICAgICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX0xlYWYgPSBjbGFzcyB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcihwb2ludHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZXRyaWMgPSBtZXRyaWM7XG4gICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5hZGQoZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXk8Kj59IGVsZW1lbnRzIC0gbmV3IGVsZW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtCYWxsVHJlZX1cbiAgICAgKi9cbiAgICBhZGQoZWxlbWVudHMpIHtcbiAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cy5tYXAoKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpbmRleCwgZWxlbWVudDogZWxlbWVudH1cbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX2NvbnN0cnVjdChlbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gZWxlbWVudHMgXG4gICAgICogQHJldHVybnMge05vZGV9IHJvb3Qgb2YgYmFsbHRyZWUuXG4gICAgICovXG4gICAgX2NvbnN0cnVjdChlbGVtZW50cykge1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuX0xlYWYoZWxlbWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGMgPSB0aGlzLl9ncmVhdGVzdF9zcHJlYWQoZWxlbWVudHMpO1xuICAgICAgICAgICAgbGV0IHNvcnRlZF9lbGVtZW50cyA9IGVsZW1lbnRzLnNvcnQoKGEsIGIpID0+IGEuZWxlbWVudFtjXSAtIGIuZWxlbWVudFtjXSk7XG4gICAgICAgICAgICBsZXQgbiA9IHNvcnRlZF9lbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcF9pbmRleCA9IE1hdGguZmxvb3IobiAvIDIpO1xuICAgICAgICAgICAgbGV0IHAgPSBlbGVtZW50c1twX2luZGV4XTtcbiAgICAgICAgICAgIGxldCBMID0gc29ydGVkX2VsZW1lbnRzLnNsaWNlKDAsIHBfaW5kZXgpO1xuICAgICAgICAgICAgbGV0IFIgPSBzb3J0ZWRfZWxlbWVudHMuc2xpY2UocF9pbmRleCwgbik7XG4gICAgICAgICAgICBsZXQgcmFkaXVzID0gTWF0aC5tYXgoLi4uZWxlbWVudHMubWFwKGQgPT4gdGhpcy5fbWV0cmljKHAuZWxlbWVudCwgZC5lbGVtZW50KSkpO1xuICAgICAgICAgICAgbGV0IEJcbiAgICAgICAgICAgIGlmIChMLmxlbmd0aCA+IDAgJiYgUi5sZW5ndGggPiAwKSB7ICAgICAgICAgXG4gICAgICAgICAgICAgICAgQiA9IG5ldyB0aGlzLl9Ob2RlKHAsIHRoaXMuX2NvbnN0cnVjdChMKSwgdGhpcy5fY29uc3RydWN0KFIpLCByYWRpdXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBCID0gbmV3IHRoaXMuX0xlYWYoZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gQiBcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIF9ncmVhdGVzdF9zcHJlYWQoQikge1xuICAgICAgICBsZXQgZCA9IEJbMF0uZWxlbWVudC5sZW5ndGg7XG4gICAgICAgIGxldCBzdGFydCA9IG5ldyBBcnJheShkKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQ7ICsraSkge1xuICAgICAgICAgICAgc3RhcnRbaV0gPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3ByZWFkID0gQi5yZWR1Y2UoKGFjYywgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkOyArK2kpIHtcbiAgICAgICAgICAgICAgICBhY2NbaV1bMF0gPSBNYXRoLm1pbihhY2NbaV1bMF0sIGN1cnJlbnQuZWxlbWVudFtpXSk7XG4gICAgICAgICAgICAgICAgYWNjW2ldWzFdID0gTWF0aC5tYXgoYWNjW2ldWzFdLCBjdXJyZW50LmVsZW1lbnRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgc3RhcnQpO1xuICAgICAgICBzcHJlYWQgPSBzcHJlYWQubWFwKGQgPT4gZFsxXSAtIGRbMF0pO1xuICAgICAgICBcbiAgICAgICAgbGV0IGMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQ7ICsraSkge1xuICAgICAgICAgICAgYyA9IHNwcmVhZFtpXSA+IHNwcmVhZFtjXSA/IGkgOiBjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Kn0gdCAtIHF1ZXJ5IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtrID0gNV0gLSBudW1iZXIgb2YgbmVhcmVzdCBuZWlnaGJvcnMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtIZWFwfSAtIEhlYXAgY29uc2lzdHMgb2YgdGhlIHtAbGluayBrfSBuZWFyZXN0IG5laWdoYm9ycy5cbiAgICAgKi9cbiAgICBzZWFyY2godCwgayA9IDUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaCh0LCBrLCBuZXcgSGVhcChudWxsLCBkID0+IHRoaXMuX21ldHJpYyhkLmVsZW1lbnQsIHQpLCBcIm1heFwiKSwgdGhpcy5fcm9vdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHQgLSBxdWVyeSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbayA9IDVdIC0gbnVtYmVyIG9mIG5lYXJlc3QgbmVpZ2hib3JzIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0ge0hlYXB9IFEgLSBIZWFwIGNvbnNpc3RzIG9mIHRoZSBjdXJyZW50bHkgZm91bmQge0BsaW5rIGt9IG5lYXJlc3QgbmVpZ2hib3JzLlxuICAgICAqIEBwYXJhbSB7Tm9kZXxMZWFmfSBCIFxuICAgICAqL1xuICAgIF9zZWFyY2godCwgaywgUSwgQikge1xuICAgICAgICAvLyBCIGlzIE5vZGVcbiAgICAgICAgaWYgKFEubGVuZ3RoID49IGsgJiYgQi5waXZvdCAmJiBCLnJhZGl1cyAmJiB0aGlzLl9tZXRyaWModCwgQi5waXZvdC5lbGVtZW50KSAtIEIucmFkaXVzID49IFEuZmlyc3QudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9IFxuICAgICAgICBpZiAoQi5jaGlsZDEpIHRoaXMuX3NlYXJjaCh0LCBrLCBRLCBCLmNoaWxkMSk7XG4gICAgICAgIGlmIChCLmNoaWxkMikgdGhpcy5fc2VhcmNoKHQsIGssIFEsIEIuY2hpbGQyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEIgaXMgbGVhZlxuICAgICAgICBpZiAoQi5wb2ludHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gQi5wb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHAgPSBCLnBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoayA+IFEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIFEucHVzaChwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBRLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIFEucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBRO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSGVhcCB9IGZyb20gXCIuLi9kYXRhc3RydWN0dXJlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkaXN0YW5jZV9tYXRyaXgsIE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBLTk5cbiAqL1xuZXhwb3J0IGNsYXNzIEtOTiB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgS05OIGxpc3Qgd2l0aCBnaXZlbiB7QGxpbmsgZWxlbWVudHN9LlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6a25uXG4gICAgICogQGFsaWFzIEtOTlxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBlbGVtZW50cyAtIEVsZW1lbnRzIHdoaWNoIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgS05OIGxpc3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFwicHJlY29tcHV0ZWRcIn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gbWV0cmljIGlzIGVpdGhlciBwcmVjb21wdXRlZCBvciBhIGZ1bmN0aW9uIHRvIHVzZTogKGEsIGIpID0+IGRpc3RhbmNlXG4gICAgICogQHJldHVybnMge0tOTn1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cz1udWxsLCBtZXRyaWM9ZXVjbGlkZWFuKSB7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBlbGVtZW50cyBpbnN0YW5jZW9mIE1hdHJpeCA/IGVsZW1lbnRzIDogTWF0cml4LmZyb20oZWxlbWVudHMpO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fZWxlbWVudHMuc2hhcGVbMF07XG4gICAgICAgIGlmIChtZXRyaWMgPT09IFwicHJlY29tcHV0ZWRcIikge1xuICAgICAgICAgICAgdGhpcy5fRCA9IHRoaXMuX2VsZW1lbnRzLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9EID0gZGlzdGFuY2VfbWF0cml4KHRoaXMuX2VsZW1lbnRzLCBtZXRyaWMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuS05OID0gW107XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IE47ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSB0aGlzLl9ELnJvdyhyb3cpO1xuICAgICAgICAgICAgY29uc3QgSCA9IG5ldyBIZWFwKG51bGwsIGQgPT4gZC52YWx1ZSwgXCJtaW5cIik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIEgucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkaXN0YW5jZXNbal0sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBqLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5LTk4ucHVzaChIKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSB0IC0gcXVlcnkgZWxlbWVudCBvciBpbmRleC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2sgPSA1XSAtIG51bWJlciBvZiBuZWFyZXN0IG5laWdoYm9ycyB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0hlYXB9IC0gSGVhcCBjb25zaXN0cyBvZiB0aGUge0BsaW5rIGt9IG5lYXJlc3QgbmVpZ2hib3JzLlxuICAgICAqL1xuICAgIHNlYXJjaCh0LCBrID0gNSkge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IEtOTiA9IHRoaXMuS05OO1xuICAgICAgICBsZXQgSDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZXRyaWMgPT0gXCJwcmVjb21wdXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJTZWFyY2ggYnkgcXVlcnkgZWxlbWVudCBpcyBvbmx5IHBvc3NpYmxlIHdoZW4gbm90IHVzaW5nIGEgcHJlY29tcHV0ZWQgZGlzdGFuY2UgbWF0cml4IVwiXG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cztcbiAgICAgICAgICAgIGNvbnN0IE4gPSBLTk4ubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG5lYXJlc3RfZWxlbWVudF9pbmRleCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbmVhcmVzdF9kaXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50cy5yb3coaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IG1ldHJpYyh0LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG5lYXJlc3RfZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0X2VsZW1lbnRfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0X2Rpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEggPSBLTk5bbmVhcmVzdF9lbGVtZW50X2luZGV4XTtcbiAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHQpKSB7XG4gICAgICAgICAgICBIID0gS05OW3RdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0ID0gW11cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKEgucG9wKCkpXG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmZvckVhY2gocmVzID0+IEgucHVzaChyZXMuZWxlbWVudCkpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9ICAgIFxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IFJhbmRvbWl6ZXIgfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIERSXG4gKiBAYm9ycm93cyBEUiNwYXJhbWV0ZXIgYXMgRFIjcGFyYVxuICogQGJvcnJvd3MgRFIjcGFyYW1ldGVyIGFzIERSI3BcbiAqL1xuZXhwb3J0IGNsYXNzIERSIHtcbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzIGFuZCBzZWFscyB0aGVtLCByZW1lbWJlcnMgdGhlIHR5cGUgb2YgaW5wdXQge0BsaW5rIFh9LCBhbmQgaW5pdGlhbGl6ZXMgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIERSXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXk8QXJyYXk8TnVtYmVyPj59IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5kID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtZXRlcnMubWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCB2YWx1ZSBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtEUn1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBkZWZhdWx0X3BhcmFtZXRlcnMsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LnNlYWwoZGVmYXVsdF9wYXJhbWV0ZXJzKSwgcGFyYW1ldGVycyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KFgpKSB7XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gXCJhcnJheVwiO1xuICAgICAgICAgICAgdGhpcy5YID0gTWF0cml4LmZyb20oWCk7XG4gICAgICAgIH0gZWxzZSBpZiAoWCBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IFwibWF0cml4XCI7XG4gICAgICAgICAgICB0aGlzLlggPSBYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgdHlwZSBmb3IgWCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgW3RoaXMuX04sIHRoaXMuX0RdID0gdGhpcy5YLnNoYXBlO1xuICAgICAgICB0aGlzLl9yYW5kb21pemVyID0gbmV3IFJhbmRvbWl6ZXIodGhpcy5fcGFyYW1ldGVycy5zZWVkKTtcbiAgICAgICAgdGhpcy5faXNfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGFuZCBnZXQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7YW55fSBbdmFsdWUgPSBudWxsXSAtIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtEUnxhbnl9IC0gT24gc2V0dGluZyBhIHBhcmFtZXRlciwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBEUiBvYmplY3QuIElmIDxjb2RlPnZhbHVlID09IG51bGw8L2NvZGU+IHRoZW4gcmV0dXJuIGFjdHVhbCBwYXJhbWV0ZXIgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBEUiA9IG5ldyBkcnVpZC5UU05FKFgsIHtkOiAzfSk7IC8vIGNyZWF0ZXMgYSBuZXcgRFIgb2JqZWN0LCB3aXRoIHBhcmFtZXRlciBmb3IgPGNvZGU+ZDwvY29kZT4gPSAzLlxuICAgICAqIERSLnBhcmFtZXRlcihcImRcIik7IC8vIHJldHVybnMgMyxcbiAgICAgKiBEUi5wYXJhbWV0ZXIoXCJkXCIsIDIpOyAvLyBzZXRzIHBhcmFtZXRlciA8Y29kZT5kPC9jb2RlPiB0byAyIGFuZCByZXR1cm5zIDxjb2RlPkRSPC9jb2RlPi5cbiAgICAgKi9cbiAgICBwYXJhbWV0ZXIobmFtZSwgdmFsdWUgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlciFgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtZXRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJzW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFyYShuYW1lLCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVyKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBwKG5hbWUsIHZhbHVlID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXIobmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IC0gUmV0dXJucyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtHZW5lcmF0b3J9IC0gQSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIGludGVybWVkaWF0ZSBzdGVwcyBvZiB0aGUgZGltZW5zaW9uYWxpdHkgcmVkdWN0aW9uIG1ldGhvZC5cbiAgICAgKi9cbiAgICAqZ2VuZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcmVzcGVjdGl2ZSBEUiBtZXRob2QgaGFzIGFuIDxjb2RlPmluaXQ8L2NvZGU+IGZ1bmN0aW9uLCBjYWxsIGl0IGJlZm9yZSA8Y29kZT50cmFuc2Zvcm08L2NvZGU+LlxuICAgICAqIEByZXR1cm5zIHtEUn1cbiAgICAgKi9cbiAgICBjaGVja19pbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzX2luaXRpYWxpemVkICYmIHR5cGVvZiB0aGlzLmluaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLl9pc19pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge01hdHJpeHxBcnJheX0gUmV0dXJucyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgcHJvamVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoXCJZXCIpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlID09PSBcIm1hdHJpeFwiID8gdGhpcy5ZIDogdGhpcy5ZLnRvMmRBcnJheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhc2V0IGlzIG5vdCB0cmFuc2Zvcm1lZCB5ZXQhXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgLSBBcmd1bWVudHMgdGhlIHRyYW5zZm9ybSBtZXRob2Qgb2YgdGhlIHJlc3BlY3RpdmUgRFIgbWV0aG9kIHRha2VzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB5aWVsZGluZyB0aGUgZGltZW5zaW9uYWxpdHkgcmVkdWNlZCBkYXRhc2V0LlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybV9hc3luYyguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSguLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIC0gVGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIG9mIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcmVzcGVjdGl2ZSBEUiBtZXRob2QuXG4gICAgICogQHJldHVybnMge01hdHJpeHxBcnJheX0gLSBUaGUgZGltZW5zaW9uYWxpdHkgcmVkdWNlZCBkYXRhc2V0LlxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2Zvcm0oLi4uYXJncykge1xuICAgICAgICBsZXQgZHIgPSBuZXcgdGhpcyguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIGRyLnRyYW5zZm9ybSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgLSBUYWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgb2YgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSByZXNwZWN0aXZlIERSIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBBIHByb21pc2UgeWllbGRpbmcgdGhlIGRpbWVuc2lvbmFsaXR5IHJlZHVjZWQgZGF0YXNldC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgdHJhbnNmb3JtX2FzeW5jKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgLSBUYWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgb2YgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSByZXNwZWN0aXZlIERSIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7R2VuZXJhdG9yfSAtIEEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSBpbnRlcm1lZGlhdGUgc3RlcHMgb2YgdGhlIGRpbWVuc2lvbmFsaXR5IHJlZHVjdGlvbiBtZXRob2QuXG4gICAgICovXG4gICAgc3RhdGljICpnZW5lcmF0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBkciA9IG5ldyB0aGlzKC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBkci5nZW5lcmF0b3IoKTtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICB5aWVsZCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBQQ0FcbiAqIEBhdWdtZW50cyBEUlxuICovXG5leHBvcnQgY2xhc3MgUENBIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIFBDQVxuICAgICAqIEBwYXJhbSB7TWF0cml4fEFycmF5PEFycmF5PE51bWJlcj4+fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcml6YXRpb24gb2YgdGhlIERSIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5laWdfYXJnc10gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZWlnZW5kZWNvbXBvc2l0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcmV0dXJucyB7UENBfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBkOiAyLCBzZWVkOiAxMjEyLCBlaWdfYXJnczoge30gfSwgcGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghdGhpcy5fcGFyYW1ldGVycy5laWdfYXJncy5oYXNPd25Qcm9wZXJ0eShcInNlZWRcIikpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtZXRlcnMuZWlnX2FyZ3Muc2VlZCA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXRkYXRhIHtAbGluayBYfSB0byBkaW1lbnNpb25hbGl0eSB7QGxpbmsgZH0uIElmIHBhcmFtZXRlciB7QGxpbmsgQX0gaXMgZ2l2ZW4sIHRoZW4gcHJvamVjdCB7QGxpbmsgQX0gd2l0aCB0aGUgcHJpbmNpcGFsIGNvbXBvbmVudHMgb2Yge0BsaW5rIFh9LlxuICAgICAqIEBwYXJhbSB7bnVsbHxNYXRyaXh8QXJyYXl9IFtBID0gbnVsbF0gLSBJZiBnaXZlbiwgdGhlIGRhdGEgdG8gcHJvamVjdC5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fEFycmF5fSAtIFRoZSBwcm9qZWN0ZWQgZGF0YS5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oQSA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgViA9IHRoaXMucHJpbmNpcGFsX2NvbXBvbmVudHMoKTtcbiAgICAgICAgaWYgKEEgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgICAgIHRoaXMuWSA9IFguZG90KFYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEEpKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0cml4LmZyb20oQSkuZG90KFYpLmFzQXJyYXk7XG4gICAgICAgIH0gZWxzZSBpZiAoQSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgcmV0dXJuIEEuZG90KFYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgdHlwZSBmb3IgQSFcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUge0BsaW5rIGR9IHByaW5jaXBhbCBjb21wb25lbnRzIG9mIE1hdHJpeCB7QGxpbmsgWH0uXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBwcmluY2lwYWxfY29tcG9uZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMuVikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGQsIGVpZ19hcmdzIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBtZWFucyA9IE1hdHJpeC5mcm9tKFgubWVhbkNvbHMpO1xuICAgICAgICBjb25zdCBYX2NlbnQgPSBYLnN1YihtZWFucyk7XG4gICAgICAgIGNvbnN0IEMgPSBYX2NlbnQudHJhbnNwb3NlKCkuZG90KFhfY2VudCk7XG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBWIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oQywgZCwgZWlnX2FyZ3MpO1xuICAgICAgICB0aGlzLlYgPSBNYXRyaXguZnJvbShWKS50cmFuc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuVjtcbiAgICB9XG5cbiAgICBzdGF0aWMgcHJpbmNpcGFsX2NvbXBvbmVudHMoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBkciA9IG5ldyB0aGlzKFgsIHBhcmFtZXRlcnMpO1xuICAgICAgICByZXR1cm4gZHIucHJpbmNpcGFsX2NvbXBvbmVudHMoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IGRpc3RhbmNlX21hdHJpeCwgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBNRFNcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBNRFMgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogQ2xhc3NpY2FsIE1EUy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBNRFNcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmQgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFwicHJlY29tcHV0ZWRcIn0gW3BhcmFtZXRlcnMubWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5laWdfYXJnc10gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZWlnZW5kZWNvbXBvc2l0aW9uIGFsZ29yaXRobS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKFgsIHsgZDogMiwgbWV0cmljOiBldWNsaWRlYW4sIHNlZWQ6IDEyMTIsIGVpZ19hcmdzOiB7fSB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLmhhc093blByb3BlcnR5KFwic2VlZFwiKSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVycy5laWdfYXJncy5zZWVkID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuc2lvbmFsaXR5IHtAbGluayBkfS5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fEFycmF5fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3Qgcm93cyA9IFguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHsgZCwgbWV0cmljLCBlaWdfYXJncyB9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgY29uc3QgQSA9IG1ldHJpYyA9PT0gXCJwcmVjb21wdXRlZFwiID8gWCA6IGRpc3RhbmNlX21hdHJpeChYLCBtZXRyaWMpO1xuICAgICAgICBjb25zdCBhaV8gPSBBLm1lYW5Db2xzO1xuICAgICAgICBjb25zdCBhX2ogPSBBLm1lYW5Sb3dzO1xuICAgICAgICBjb25zdCBhX18gPSBBLm1lYW47XG5cbiAgICAgICAgdGhpcy5fZF9YID0gQTtcbiAgICAgICAgY29uc3QgQiA9IG5ldyBNYXRyaXgocm93cywgcm93cywgKGksIGopID0+IEEuZW50cnkoaSwgaikgLSBhaV9baV0gLSBhX2pbal0gKyBhX18pO1xuXG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBWIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oQiwgZCwgZWlnX2FyZ3MpO1xuICAgICAgICB0aGlzLlkgPSBNYXRyaXguZnJvbShWKS50cmFuc3Bvc2UoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gdGhlIHN0cmVzcyBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICBzdHJlc3MoKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLlguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IFkgPSB0aGlzLlk7XG4gICAgICAgIGNvbnN0IGRfWCA9IHRoaXMuX2RfWDtcbiAgICAgICAgY29uc3QgZF9ZID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBkX1kuc2hhcGUgPSBbXG4gICAgICAgICAgICBOLFxuICAgICAgICAgICAgTixcbiAgICAgICAgICAgIChpLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPCBqID8gZXVjbGlkZWFuKFkucm93KGkpLCBZLnJvdyhqKSkgOiBkX1kuZW50cnkoaiwgaSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICBsZXQgdG9wX3N1bSA9IDA7XG4gICAgICAgIGxldCBib3R0b21fc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIHRvcF9zdW0gKz0gTWF0aC5wb3coZF9YLmVudHJ5KGksIGopIC0gZF9ZLmVudHJ5KGksIGopLCAyKTtcbiAgICAgICAgICAgICAgICBib3R0b21fc3VtICs9IE1hdGgucG93KGRfWC5lbnRyeShpLCBqKSwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0b3Bfc3VtIC8gYm90dG9tX3N1bSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uIH0gZnJvbSBcIi4uL2xpbmVhcl9hbGdlYnJhL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBIZWFwIH0gZnJvbSBcIi4uL2RhdGFzdHJ1Y3R1cmUvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcbmltcG9ydCBldWNsaWRlYW4gZnJvbSBcIi4uL21ldHJpY3MvZXVjbGlkZWFuLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSVNPTUFQXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgSVNPTUFQIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIElzb21ldHJpYyBmZWF0dXJlIG1hcHBpbmcgKElTT01BUCkuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgSVNPTUFQXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbWV0ZXJzLm5laWdoYm9ycyAtIHRoZSBudW1iZXIgb2YgbmVpZ2hib3JzIHtAbGluayBJU09NQVB9IHNob3VsZCB1c2UgdG8gcHJvamVjdCB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbWV0ZXJzLm1ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuc2VlZCA9IDEyMTJdIC0gdGhlIHNlZWQgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZWlnX2FyZ3NdIC0gUGFyYW1ldGVycyBmb3IgdGhlIGVpZ2VuZGVjb21wb3NpdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2kub3JnLzEwLjExMjYvc2NpZW5jZS4yOTAuNTUwMC4yMzE5fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBuZWlnaGJvcnM6IHVuZGVmaW5lZCwgZDogMiwgbWV0cmljOiBldWNsaWRlYW4sIHNlZWQ6IDEyMTIsIGVpZ19hcmdzOiB7fSB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJuZWlnaGJvcnNcIiwgTWF0aC5taW4odGhpcy5fcGFyYW1ldGVycy5uZWlnaGJvcnMgPz8gTWF0aC5tYXgoTWF0aC5mbG9vcih0aGlzLlguc2hhcGVbMF0gLyAxMCksIDIpLCB0aGlzLl9OIC0gMSkpO1xuICAgICAgICBpZiAoIXRoaXMuX3BhcmFtZXRlcnMuZWlnX2FyZ3MuaGFzT3duUHJvcGVydHkoXCJzZWVkXCIpKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLnNlZWQgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IFJldHVybnMgdGhlIHByb2plY3Rpb24uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IHsgZCwgbWV0cmljLCBlaWdfYXJncywgbmVpZ2hib3JzIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICAvLyBUT0RPOiBtYWtlIGtubiBleHRlcm4gYW5kIHBhcmFtZXRlciBmb3IgY29uc3RydWN0b3Igb3IgdHJhbnNmb3JtP1xuICAgICAgICBjb25zdCBEID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBELnNoYXBlID0gW3Jvd3MsIHJvd3MsIChpLCBqKSA9PiAoaSA8PSBqID8gbWV0cmljKFgucm93KGkpLCBYLnJvdyhqKSkgOiBELmVudHJ5KGosIGkpKV07XG4gICAgICAgIGNvbnN0IGtOZWFyZXN0TmVpZ2hib3JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93czsgKytqKSB7XG4gICAgICAgICAgICAgICAgcm93LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogaixcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IEQuZW50cnkoaSwgaiksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBIID0gbmV3IEhlYXAocm93LCAoZCkgPT4gZC5kaXN0YW5jZSwgXCJtaW5cIik7XG4gICAgICAgICAgICBrTmVhcmVzdE5laWdoYm9ycy5wdXNoKEgudG9BcnJheSgpLnNsaWNlKDEsIG5laWdoYm9ycyArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qRCA9IGRpamtzdHJhKGtOZWFyZXN0TmVpZ2hib3JzKTsqL1xuICAgICAgICAvLyBjb21wdXRlIHNob3J0ZXN0IHBhdGhzXG4gICAgICAgIC8vIFRPRE86IG1ha2UgZXh0ZXJuXG4gICAgICAgIC8qKiBAc2VlIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZCVFMiU4MCU5M1dhcnNoYWxsX2FsZ29yaXRobX0gKi9cbiAgICAgICAgY29uc3QgRyA9IG5ldyBNYXRyaXgocm93cywgcm93cywgKGksIGopID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0ga05lYXJlc3ROZWlnaGJvcnNbaV0uZmluZCgobikgPT4gbi5pbmRleCA9PT0gaik7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPyBvdGhlci5kaXN0YW5jZSA6IEluZmluaXR5O1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dzOyArK2opIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJvd3M7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBHLnNldF9lbnRyeShpLCBqLCBNYXRoLm1pbihHLmVudHJ5KGksIGopLCBHLmVudHJ5KGksIGspICsgRy5lbnRyeShrLCBqKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhaV8gPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MpO1xuICAgICAgICBsZXQgYV9qID0gbmV3IEZsb2F0NjRBcnJheShyb3dzKTtcbiAgICAgICAgbGV0IGFfXyA9IDA7XG4gICAgICAgIGNvbnN0IEEgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIChpLCBqKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsID0gRy5lbnRyeShpLCBqKTtcbiAgICAgICAgICAgIHZhbCA9IHZhbCA9PT0gSW5maW5pdHkgPyAwIDogdmFsO1xuICAgICAgICAgICAgYWlfW2ldICs9IHZhbDtcbiAgICAgICAgICAgIGFfaltqXSArPSB2YWw7XG4gICAgICAgICAgICBhX18gKz0gdmFsO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWlfID0gYWlfLm1hcCgodikgPT4gdiAvIHJvd3MpO1xuICAgICAgICBhX2ogPSBhX2oubWFwKCh2KSA9PiB2IC8gcm93cyk7XG4gICAgICAgIGFfXyAvPSByb3dzICoqIDI7XG4gICAgICAgIGNvbnN0IEIgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIChpLCBqKSA9PiBBLmVudHJ5KGksIGopIC0gYWlfW2ldIC0gYV9qW2pdICsgYV9fKTtcblxuICAgICAgICAvLyBjb21wdXRlIGQgZWlnZW52ZWN0b3JzXG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBWIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oQiwgZCwgZWlnX2FyZ3MpO1xuICAgICAgICB0aGlzLlkgPSBNYXRyaXguZnJvbShWKS50cmFuc3Bvc2UoKTtcbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZ1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEZBU1RNQVBcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBGQVNUTUFQIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIEZhc3RNYXA6IGEgZmFzdCBhbGdvcml0aG0gZm9yIGluZGV4aW5nLCBkYXRhLW1pbmluZyBhbmQgdmlzdWFsaXphdGlvbiBvZiB0cmFkaXRpb25hbCBhbmQgbXVsdGltZWRpYSBkYXRhc2V0c1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIEZBU1RNQVBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmQgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1ldGVycy5tZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RkFTVE1BUH1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvaS5vcmcvMTAuMTE0NS8yMjM3ODQuMjIzODEyfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hvb3NlcyB0d28gcG9pbnRzIHdoaWNoIGFyZSB0aGUgbW9zdCBkaXN0YW50IGluIHRoZSBhY3R1YWwgcHJvamVjdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgZmlyc3QgaW5kZXgsIHNlY29uZCBpbmRleCwgYW5kIGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXG4gICAgICovXG4gICAgX2Nob29zZV9kaXN0YW50X29iamVjdHMoZGlzdCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgbGV0IGFfaW5kZXggPSAodGhpcy5fcmFuZG9taXplci5yYW5kb21faW50ICUgTikgLSAxO1xuICAgICAgICBsZXQgYl9pbmRleCA9IG51bGw7XG4gICAgICAgIGxldCBtYXhfZGlzdCA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGRfYWkgPSBkaXN0KGFfaW5kZXgsIGkpO1xuICAgICAgICAgICAgaWYgKGRfYWkgPiBtYXhfZGlzdCkge1xuICAgICAgICAgICAgICAgIG1heF9kaXN0ID0gZF9haTtcbiAgICAgICAgICAgICAgICBiX2luZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXhfZGlzdCA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGRfYmkgPSBkaXN0KGJfaW5kZXgsIGkpO1xuICAgICAgICAgICAgaWYgKGRfYmkgPiBtYXhfZGlzdCkge1xuICAgICAgICAgICAgICAgIG1heF9kaXN0ID0gZF9iaTtcbiAgICAgICAgICAgICAgICBhX2luZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FfaW5kZXgsIGJfaW5kZXgsIG1heF9kaXN0XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSBUaGUge0BsaW5rIGR9LWRpbWVuc2lvbmFsIHByb2plY3Rpb24gb2YgdGhlIGRhdGEgbWF0cml4IHtAbGluayBYfS5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IE4gPSBYLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCB7IGQsIG1ldHJpYyB9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgY29uc3QgWSA9IG5ldyBNYXRyaXgoTiwgZCwgMCk7XG4gICAgICAgIGxldCBkaXN0ID0gKGEsIGIpID0+IG1ldHJpYyhYLnJvdyhhKSwgWC5yb3coYikpO1xuXG4gICAgICAgIGZvciAobGV0IF9jb2wgPSAwOyBfY29sIDwgZDsgKytfY29sKSB7XG4gICAgICAgICAgICBsZXQgb2xkX2Rpc3QgPSBkaXN0O1xuICAgICAgICAgICAgLy8gY2hvb3NlIHBpdm90IG9iamVjdHNcbiAgICAgICAgICAgIGNvbnN0IFthX2luZGV4LCBiX2luZGV4LCBkX2FiXSA9IHRoaXMuX2Nob29zZV9kaXN0YW50X29iamVjdHMoZGlzdCk7XG4gICAgICAgICAgICBpZiAoZF9hYiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHByb2plY3QgdGhlIG9iamVjdHMgb24gdGhlIGxpbmUgKE9fYSwgT19iKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRfYWkgPSBkaXN0KGFfaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkX2JpID0gZGlzdChiX2luZGV4LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeV9pID0gKGRfYWkgKiogMiArIGRfYWIgKiogMiAtIGRfYmkgKiogMikgLyAoMiAqIGRfYWIpO1xuICAgICAgICAgICAgICAgICAgICBZLnNldF9lbnRyeShpLCBfY29sLCB5X2kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgcHJvamVjdGlvbnMgb2YgdGhlIG9iamVjdHMgb24gYVxuICAgICAgICAgICAgICAgIC8vIGh5cGVycGxhbmUgcGVycGVuZGljbHVhciB0byB0aGUgbGluZSAoYSwgYik7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGRpc3RhbmNlIGZ1bmN0aW9uIEQnKCkgYmV0d2VlbiB0d29cbiAgICAgICAgICAgICAgICAvLyBwcm9qZWN0aW9ucyBpcyBnaXZlbiBieSBFcS40XG4gICAgICAgICAgICAgICAgZGlzdCA9IChhLCBiKSA9PiBNYXRoLnNxcnQob2xkX2Rpc3QoYSwgYikgKiogMiAtIChZLmVudHJ5KGEsIF9jb2wpIC0gWS5lbnRyeShiLCBfY29sKSkgKiogMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZy5cbiAgICAgICAgdGhpcy5ZID0gWTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBMREFcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBMREEgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogTGluZWFyIERpc2NyaW1pbmFudCBBbmFseXNpcy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBMREFcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIFRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1ldGVycy5sYWJlbHMgLSBUaGUgbGFiZWxzIC8gY2xhc3NlcyBmb3IgZWFjaCBkYXRhIHBvaW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1ldGVycy5kID0gMl0gLSBUaGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmVpZ19hcmdzXSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBlaWdlbmRlY29tcG9zaXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vb25saW5lbGlicmFyeS53aWxleS5jb20vZG9pLzEwLjExMTEvai4xNDY5LTE4MDkuMTkzNi50YjAyMTM3Lnh9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IGxhYmVsczogbnVsbCwgZDogMiwgc2VlZDogMTIxMiwgZWlnX2FyZ3M6IHt9IH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3BhcmFtZXRlcnMuZWlnX2FyZ3MuaGFzT3duUHJvcGVydHkoXCJzZWVkXCIpKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLnNlZWQgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0ZGF0YSB7QGxpbmsgWH0gdG8gZGltZW5pb25hbGl0eSB7QGxpbmsgZH0uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBbcm93cywgY29sc10gPSBYLnNoYXBlO1xuICAgICAgICBjb25zdCB7IGQsIGxhYmVscywgZWlnX2FyZ3MgfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGlmIChsYWJlbHMgPT09IG51bGwgfHwgbGFiZWxzLmxlbmd0aCAhPSByb3dzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMREEgbmVlZHMgcGFyYW1ldGVyIGxhYmVsIHRvIGV2ZXJ5IGRhdGFwb2ludCB0byB3b3JrIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bmlxdWVfbGFiZWxzID0ge307XG4gICAgICAgIGxldCBsYWJlbF9pZCA9IDA7XG4gICAgICAgIGxhYmVscy5mb3JFYWNoKChsLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAobCBpbiB1bmlxdWVfbGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlX2xhYmVsc1tsXS5jb3VudCsrO1xuICAgICAgICAgICAgICAgIHVuaXF1ZV9sYWJlbHNbbF0ucm93cy5wdXNoKFgucm93KGkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlX2xhYmVsc1tsXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGxhYmVsX2lkKyssXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICByb3dzOiBbWC5yb3coaSldLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBYX21lYW4gYW5kIHZlY3RvciBtZWFucztcbiAgICAgICAgY29uc3QgWF9tZWFuID0gWC5tZWFuO1xuICAgICAgICBjb25zdCBWX21lYW4gPSBuZXcgTWF0cml4KGxhYmVsX2lkLCBjb2xzKTtcbiAgICAgICAgZm9yIChjb25zdCBsYWJlbCBpbiB1bmlxdWVfbGFiZWxzKSB7XG4gICAgICAgICAgICBjb25zdCBWID0gTWF0cml4LmZyb20odW5pcXVlX2xhYmVsc1tsYWJlbF0ucm93cyk7XG4gICAgICAgICAgICBjb25zdCB2X21lYW4gPSBWLm1lYW5Db2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcbiAgICAgICAgICAgICAgICBWX21lYW4uc2V0X2VudHJ5KHVuaXF1ZV9sYWJlbHNbbGFiZWxdLmlkLCBqLCB2X21lYW5bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNjYXR0ZXJfYmV0d2VlblxuICAgICAgICBsZXQgU19iID0gbmV3IE1hdHJpeChjb2xzLCBjb2xzKTtcbiAgICAgICAgZm9yIChjb25zdCBsYWJlbCBpbiB1bmlxdWVfbGFiZWxzKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gVl9tZWFuLnJvdyh1bmlxdWVfbGFiZWxzW2xhYmVsXS5pZCk7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3IE1hdHJpeChjb2xzLCAxLCAoaikgPT4gdltqXSAtIFhfbWVhbik7XG4gICAgICAgICAgICBjb25zdCBOID0gdW5pcXVlX2xhYmVsc1tsYWJlbF0uY291bnQ7XG4gICAgICAgICAgICBTX2IgPSBTX2IuYWRkKG0uZG90KG0udHJhbnNwb3NlKCkpLm11bHQoTikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2NhdHRlcl93aXRoaW5cbiAgICAgICAgbGV0IFNfdyA9IG5ldyBNYXRyaXgoY29scywgY29scyk7XG4gICAgICAgIGZvciAoY29uc3QgbGFiZWwgaW4gdW5pcXVlX2xhYmVscykge1xuICAgICAgICAgICAgY29uc3QgdiA9IFZfbWVhbi5yb3codW5pcXVlX2xhYmVsc1tsYWJlbF0uaWQpO1xuICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXgoY29scywgMSwgKGopID0+IHZbal0pO1xuICAgICAgICAgICAgY29uc3QgUiA9IHVuaXF1ZV9sYWJlbHNbbGFiZWxdLnJvd3M7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHVuaXF1ZV9sYWJlbHNbbGFiZWxdLmNvdW50OyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93X3YgPSBuZXcgTWF0cml4KGNvbHMsIDEsIChqLCBfKSA9PiBSW2ldW2pdIC0gbS5lbnRyeShqLCAwKSk7XG4gICAgICAgICAgICAgICAgU193ID0gU193LmFkZChyb3dfdi5kb3Qocm93X3YudHJhbnNwb3NlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB7IGVpZ2VudmVjdG9yczogViB9ID0gc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uKFNfdy5pbnZlcnNlKCkuZG90KFNfYiksIGQsIGVpZ19hcmdzKTtcbiAgICAgICAgViA9IE1hdHJpeC5mcm9tKFYpLnRyYW5zcG9zZSgpO1xuICAgICAgICB0aGlzLlkgPSBYLmRvdChWKTtcblxuICAgICAgICAvLyByZXR1cm4gZW1iZWRkaW5nXG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbiB9IGZyb20gXCIuLi9saW5lYXJfYWxnZWJyYS9pbmRleC5qc1wiO1xuaW1wb3J0IHsga19uZWFyZXN0X25laWdoYm9ycyB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IG5ldW1haXJfc3VtIH0gZnJvbSBcIi4uL251bWVyaWNhbC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIExMRVxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIExMRSBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKiBMb2NhbGx5IExpbmVhciBFbWJlZGRpbmcuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgTExFXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuZWlnaGJvcnMgLSB0aGUgbGFiZWwgLyBjbGFzcyBvZiBlYWNoIGRhdGEgcG9pbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZWlnX2FyZ3NdIC0gUGFyYW1ldGVycyBmb3IgdGhlIGVpZ2VuZGVjb21wb3NpdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2kub3JnLzEwLjExMjYvc2NpZW5jZS4yOTAuNTUwMC4yMzIzfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBuZWlnaGJvcnM6IHVuZGVmaW5lZCwgZDogMiwgbWV0cmljOiBldWNsaWRlYW4sIHNlZWQ6IDEyMTIsIGVpZ19hcmdzOiB7fSB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJuZWlnaGJvcnNcIiwgTWF0aC5taW4ocGFyYW1ldGVycy5uZWlnaGJvcnMgPz8gTWF0aC5tYXgoTWF0aC5mbG9vcih0aGlzLl9OIC8gMTApLCAyKSwgdGhpcy5fTiAtIDEpKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLmhhc093blByb3BlcnR5KFwic2VlZFwiKSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVycy5laWdfYXJncy5zZWVkID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuaW9uYWxpdHkge0BsaW5rIGR9LlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9EO1xuICAgICAgICBjb25zdCB7IG5laWdoYm9ycywgZCwgZWlnX2FyZ3MsIG1ldHJpYyB9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgbk4gPSBrX25lYXJlc3RfbmVpZ2hib3JzKFgsIG5laWdoYm9ycywgbWV0cmljKTtcbiAgICAgICAgY29uc3QgTyA9IG5ldyBNYXRyaXgobmVpZ2hib3JzLCAxLCAxKTtcbiAgICAgICAgY29uc3QgVyA9IG5ldyBNYXRyaXgocm93cywgcm93cyk7XG5cbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IG5OX3JvdyA9IG5OW3Jvd107XG4gICAgICAgICAgICBjb25zdCBaID0gbmV3IE1hdHJpeChuZWlnaGJvcnMsIGNvbHMsIChpLCBqKSA9PiBYLmVudHJ5KG5OX3Jvd1tpXS5qLCBqKSAtIFguZW50cnkocm93LCBqKSk7XG4gICAgICAgICAgICBjb25zdCBDID0gWi5kb3QoWi5UKTtcbiAgICAgICAgICAgIGlmIChuZWlnaGJvcnMgPiBjb2xzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgQ190cmFjZSA9IG5ldW1haXJfc3VtKEMuZGlhZykgLyAxMDAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmVpZ2hib3JzOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgQy5zZXRfZW50cnkoaiwgaiwgQy5lbnRyeShqLCBqKSArIENfdHJhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlY29uc3RydWN0O1xuICAgICAgICAgICAgbGV0IHcgPSBNYXRyaXguc29sdmVfQ0coQywgTywgdGhpcy5fcmFuZG9taXplcik7XG4gICAgICAgICAgICB3ID0gdy5kaXZpZGUody5zdW0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuZWlnaGJvcnM7ICsraikge1xuICAgICAgICAgICAgICAgIFcuc2V0X2VudHJ5KHJvdywgbk5fcm93W2pdLmosIHcuZW50cnkoaiwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXAgZW1iZWRkaW5nXG4gICAgICAgIGNvbnN0IEkgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIFwiaWRlbnRpdHlcIik7XG4gICAgICAgIGNvbnN0IElXID0gSS5zdWIoVyk7XG4gICAgICAgIGNvbnN0IE0gPSBJVy5ULmRvdChJVyk7XG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBWIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oTS5ULmludmVyc2UoKSwgZCArIDEsIGVpZ19hcmdzKTtcbiAgICAgICAgdGhpcy5ZID0gTWF0cml4LmZyb20oVi5zbGljZSgxLCAxICsgZCkpLlQ7XG5cbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZ1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE1hdHJpeCwga19uZWFyZXN0X25laWdoYm9ycyB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBMVFNBXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgTFRTQSBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKiBMb2NhbCBUYW5nZW50IFNwYWNlIEFsaWdubWVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIExUU0FcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtZXRlcnMubmVpZ2hib3JzIC0gdGhlIG51bWJlciBvZiBuZWlnaGJvcnMge0BsaW5rIExUU0F9IHNob3VsZCB1c2UgdG8gcHJvamVjdCB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbWV0ZXJzLm1ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuc2VlZCA9IDEyMTJdIC0gdGhlIHNlZWQgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZWlnX2FyZ3NdIC0gUGFyYW1ldGVycyBmb3IgdGhlIGVpZ2VuZGVjb21wb3NpdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lcHVicy5zaWFtLm9yZy9kb2kvYWJzLzEwLjExMzcvUzEwNjQ4Mjc1MDI0MTkxNTR9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IG5laWdoYm9yczogdW5kZWZpbmVkLCBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiwgZWlnX2FyZ3M6IHt9IH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcIm5laWdoYm9yc1wiLCBNYXRoLm1pbihwYXJhbWV0ZXJzLm5laWdoYm9ycyA/PyBNYXRoLm1heChNYXRoLmZsb29yKHRoaXMuX04gLyAxMCksIDIpLCB0aGlzLl9OIC0gMSkpO1xuICAgICAgICBpZiAoIXRoaXMuX3BhcmFtZXRlcnMuZWlnX2FyZ3MuaGFzT3duUHJvcGVydHkoXCJzZWVkXCIpKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLnNlZWQgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9EIDw9IHRoaXMucGFyYW1ldGVyKFwiZFwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaW1lbnNpb25hbGl0eSBvZiBYIChEID0gJHt0aGlzLl9EfSkgbXVzdCBiZSBncmVhdGVyIHRoYW4gdGhlIHJlcXVpcmVkIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSByZXN1bHQgKGQgPSAke3RoaXMucGFyYW1ldGVyKFwiZFwiKX0pIWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0ZGF0YSB7QGxpbmsgWH0gdG8gZGltZW5pb25hbGl0eSB7QGxpbmsgZH0uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBbcm93cywgRF0gPSBYLnNoYXBlO1xuICAgICAgICBjb25zdCB7IGQsIG5laWdoYm9ycywgbWV0cmljLCBlaWdfYXJncyB9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgLy8gMS4xIGRldGVybWluZSBrIG5lYXJlc3QgbmVpZ2hib3JzXG4gICAgICAgIGNvbnN0IG5OID0ga19uZWFyZXN0X25laWdoYm9ycyhYLCBuZWlnaGJvcnMsIG1ldHJpYyk7XG4gICAgICAgIC8vIGNlbnRlciBtYXRyaXhcbiAgICAgICAgY29uc3QgTyA9IG5ldyBNYXRyaXgoRCwgRCwgXCJjZW50ZXJcIik7XG4gICAgICAgIGNvbnN0IEIgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIDApO1xuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAvLyAxLjIgY29tcHV0ZSB0aGUgZCBsYXJnZXN0IGVpZ2VudmVjdG9ycyBvZiB0aGUgY29ycmVsYXRpb24gbWF0cml4XG4gICAgICAgICAgICBjb25zdCBJX2kgPSBbcm93LCAuLi5uTltyb3ddLm1hcCgobikgPT4gbi5qKV07XG4gICAgICAgICAgICBsZXQgWF9pID0gTWF0cml4LmZyb20oSV9pLm1hcCgobikgPT4gWC5yb3cobikpKTtcbiAgICAgICAgICAgIC8vIGNlbnRlciBYX2lcbiAgICAgICAgICAgIFhfaSA9IFhfaS5kb3QoTyk7XG4gICAgICAgICAgICAvLyBjb3JyZWxhdGlvbiBtYXRyaXhcbiAgICAgICAgICAgIGNvbnN0IEMgPSBYX2kuZG90KFhfaS50cmFuc3Bvc2UoKSk7XG4gICAgICAgICAgICBjb25zdCB7IGVpZ2VudmVjdG9yczogZyB9ID0gc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uKEMsIGQsIGVpZ19hcmdzKTtcbiAgICAgICAgICAgIC8vZy5wdXNoKGxpbnNwYWNlKDAsIGspLm1hcChfID0+IDEgLyBNYXRoLnNxcnQoayArIDEpKSk7XG4gICAgICAgICAgICBjb25zdCBHX2lfdCA9IE1hdHJpeC5mcm9tKGcpO1xuICAgICAgICAgICAgLy8gMi4gQ29uc3RydWN0aW5nIGFsaWdubWVudCBtYXRyaXhcbiAgICAgICAgICAgIGNvbnN0IFdfaSA9IEdfaV90LnRyYW5zcG9zZSgpXG4gICAgICAgICAgICAgICAgLmRvdChHX2lfdClcbiAgICAgICAgICAgICAgICAuYWRkKDEgLyBNYXRoLnNxcnQobmVpZ2hib3JzICsgMSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnMgKyAxOyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5laWdoYm9ycyArIDE7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShJX2lbaV0sIElfaVtqXSwgQi5lbnRyeShJX2lbaV0sIElfaVtqXSkgLSAoaSA9PT0gaiA/IDEgOiAwKSArIFdfaS5lbnRyeShpLCBqKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gQWxpZ25pbmcgZ2xvYmFsIGNvb3JkaW5hdGVzXG4gICAgICAgIGNvbnN0IHsgZWlnZW52ZWN0b3JzOiBZIH0gPSBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24oQiwgZCArIDEsIGVpZ19hcmdzKTtcbiAgICAgICAgdGhpcy5ZID0gTWF0cml4LmZyb20oWS5zbGljZSgxKSkudHJhbnNwb3NlKCk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZ1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgVFNORVxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIFRTTkUgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBUU05FXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5wZXJwbGV4aXR5ID0gNTBdIC0gcGVycGxleGl0eS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZXBzaWxvbiA9IDEwXSAtIGxlYXJuaW5nIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbcGFyYW1ldGVycy5tZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge1RTTkV9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IHBlcnBsZXhpdHk6IDUwLCBlcHNpbG9uOiAxMCwgZDogMiwgbWV0cmljOiBldWNsaWRlYW4sIHNlZWQ6IDEyMTIgfSwgcGFyYW1ldGVycyk7XG4gICAgICAgIFt0aGlzLl9OLCB0aGlzLl9EXSA9IHRoaXMuWC5zaGFwZTtcbiAgICAgICAgdGhpcy5faXRlciA9IDA7XG4gICAgICAgIHRoaXMuWSA9IG5ldyBNYXRyaXgodGhpcy5fTiwgdGhpcy5wYXJhbWV0ZXIoXCJkXCIpLCAoKSA9PiB0aGlzLl9yYW5kb21pemVyLnJhbmRvbSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGRpc3RhbmNlX21hdHJpeCAtIGFjY2VwdHMgYSBwcmVjb21wdXRlZCBkaXN0YW5jZSBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB7VFNORX1cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICAvLyBpbml0XG4gICAgICAgIGNvbnN0IEh0YXJnZXQgPSBNYXRoLmxvZyh0aGlzLnBhcmFtZXRlcihcInBlcnBsZXhpdHlcIikpO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgRCA9IHRoaXMuX0Q7XG4gICAgICAgIGNvbnN0IHttZXRyaWN9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgbGV0IERlbHRhO1xuICAgICAgICBpZiAobWV0cmljID09XCJwcmVjb21wdXRlZFwiKSB7XG4gICAgICAgICAgICBEZWx0YSA9IGRydWlkLk1hdHJpeC5mcm9tKFgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRGVsdGEgPSBuZXcgTWF0cml4KE4sIE4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBYX2kgPSBYLnJvdyhpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBtZXRyaWMoWF9pLCBYLnJvdyhqKSk7XG4gICAgICAgICAgICAgICAgICAgIERlbHRhLnNldF9lbnRyeShpLCBqLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIERlbHRhLnNldF9lbnRyeShqLCBpLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgUCA9IG5ldyBNYXRyaXgoTiwgTiwgXCJ6ZXJvc1wiKTtcblxuICAgICAgICB0aGlzLl95c3RlcCA9IG5ldyBNYXRyaXgoTiwgRCwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgdGhpcy5fZ2FpbnMgPSBuZXcgTWF0cml4KE4sIEQsIDEpO1xuXG4gICAgICAgIC8vIHNlYXJjaCBmb3IgZml0dGluZyBzaWdtYVxuICAgICAgICBsZXQgcHJvdyA9IG5ldyBGbG9hdDY0QXJyYXkoTilcbiAgICAgICAgY29uc3QgdG9sID0gMWUtNDtcbiAgICAgICAgY29uc3QgbWF4dHJpZXMgPSA1MDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBiZXRhbWluID0gLUluZmluaXR5O1xuICAgICAgICAgICAgbGV0IGJldGFtYXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBiZXRhID0gMTtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGxldCBudW0gPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaiA9IE1hdGguZXhwKC1EZWx0YS5lbnRyeShpLCBqKSAqIGJldGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaikgcGogPSAwO1xuICAgICAgICAgICAgICAgICAgICBwcm93W2pdID0gcGo7XG4gICAgICAgICAgICAgICAgICAgIHBzdW0gKz0gcGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBIaGVyZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBqID0gcHN1bSA9PT0gMCA/IDAgOiBwcm93W2pdIC8gcHN1bTtcbiAgICAgICAgICAgICAgICAgICAgcHJvd1tqXSA9IHBqO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGogPiAxZS03KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBIaGVyZSAtPSBwaiAqIE1hdGgubG9nKHBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoSGhlcmUgPiBIdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJldGFtaW4gPSBiZXRhO1xuICAgICAgICAgICAgICAgICAgICBiZXRhID0gYmV0YW1heCA9PT0gSW5maW5pdHkgPyBiZXRhICogMiA6IChiZXRhICsgYmV0YW1heCkgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJldGFtYXggPSBiZXRhO1xuICAgICAgICAgICAgICAgICAgICBiZXRhID0gYmV0YW1pbiA9PT0gLUluZmluaXR5ID8gYmV0YSAvIDIgOiAoYmV0YSArIGJldGFtaW4pIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytudW07XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKEhoZXJlIC0gSHRhcmdldCkgPCB0b2wpIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChudW0gPj0gbWF4dHJpZXMpIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIFAuc2V0X2VudHJ5KGksIGosIHByb3dbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9jb21wdXRlIHByb2JhYmlsaXRpZXNcbiAgICAgICAgY29uc3QgUG91dCA9IG5ldyBNYXRyaXgoTiwgTiwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgY29uc3QgTjIgPSBOICogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IE1hdGgubWF4KChQLmVudHJ5KGksIGopICsgUC5lbnRyeShqLCBpKSkgLyBOMiwgMWUtMTAwKTtcbiAgICAgICAgICAgICAgICBQb3V0LnNldF9lbnRyeShpLCBqLCBwKTtcbiAgICAgICAgICAgICAgICBQb3V0LnNldF9lbnRyeShqLCBpLCBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9QID0gUG91dDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2l0ZXJhdGlvbnM9NTAwXSAtIG51bWJlciBvZiBpdGVyYXRpb25zLlxuICAgICAqIEB5aWVsZHMge01hdHJpeHxBcnJheTxBcnJheT59IC0gdGhlIHByb2plY3Rpb24uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKGl0ZXJhdGlvbnMgPSA1MDApIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpdGVyYXRpb25zPTUwMF0gLSBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAgICAgKiBAeWllbGRzIHtNYXRyaXh8QXJyYXk8QXJyYXk+fSAtIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgICpnZW5lcmF0b3IoaXRlcmF0aW9ucyA9IDUwMCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGVyZm9ybXMgYSBvcHRpbWl6YXRpb24gc3RlcFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyID0gKyt0aGlzLl9pdGVyO1xuICAgICAgICBjb25zdCBQID0gdGhpcy5fUDtcbiAgICAgICAgY29uc3QgeXN0ZXAgPSB0aGlzLl95c3RlcDtcbiAgICAgICAgY29uc3QgZ2FpbnMgPSB0aGlzLl9nYWlucztcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IHsgZDogZGltLCBlcHNpbG9ufSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGxldCBZID0gdGhpcy5ZO1xuXG4gICAgICAgIC8vY2FsYyBjb3N0IGdyYWRpZW50O1xuICAgICAgICBjb25zdCBwbXVsID0gaXRlciA8IDEwMCA/IDQgOiAxO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgUSBkaXN0ICh1bm5vcm1hbGl6ZWQpXG4gICAgICAgIGNvbnN0IFF1ID0gbmV3IE1hdHJpeChOLCBOLCBcInplcm9zXCIpO1xuICAgICAgICBsZXQgcXN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgZHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaGVyZSA9IFkuZW50cnkoaSwgZCkgLSBZLmVudHJ5KGosIGQpO1xuICAgICAgICAgICAgICAgICAgICBkc3VtICs9IGRoZXJlICogZGhlcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHF1ID0gMSAvICgxICsgZHN1bSk7XG4gICAgICAgICAgICAgICAgUXUuc2V0X2VudHJ5KGksIGosIHF1KTtcbiAgICAgICAgICAgICAgICBRdS5zZXRfZW50cnkoaiwgaSwgcXUpO1xuICAgICAgICAgICAgICAgIHFzdW0gKz0gMiAqIHF1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIFEgZGlzdFxuICAgICAgICBjb25zdCBRID0gbmV3IE1hdHJpeChOLCBOLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IE1hdGgubWF4KFF1LmVudHJ5KGksIGopIC8gcXN1bSwgMWUtMTAwKTtcbiAgICAgICAgICAgICAgICBRLnNldF9lbnRyeShpLCBqLCB2YWwpO1xuICAgICAgICAgICAgICAgIFEuc2V0X2VudHJ5KGosIGksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBncmFkID0gbmV3IE1hdHJpeChOLCBkaW0sIFwiemVyb3NcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZW11bHQgPSA0ICogKHBtdWwgKiBQLmVudHJ5KGksIGopIC0gUS5lbnRyeShpLCBqKSkgKiBRdS5lbnRyeShpLCBqKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWQuc2V0X2VudHJ5KGksIGQsIGdyYWQuZW50cnkoaSwgZCkgKyBwcmVtdWx0ICogKFkuZW50cnkoaSwgZCkgLSBZLmVudHJ5KGosIGQpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVyZm9ybSBncmFkaWVudCBzdGVwXG4gICAgICAgIGxldCB5bWVhbiA9IG5ldyBGbG9hdDY0QXJyYXkoZGltKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnaWQgPSBncmFkLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZCA9IHlzdGVwLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhaW5pZCA9IGdhaW5zLmVudHJ5KGksIGQpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG5ld2dhaW4gPSBNYXRoLnNpZ24oZ2lkKSA9PT0gTWF0aC5zaWduKHNpZCkgPyBnYWluaWQgKiAwLjggOiBnYWluaWQgKyAwLjI7XG4gICAgICAgICAgICAgICAgaWYgKG5ld2dhaW4gPCAwLjAxKSBuZXdnYWluID0gMC4wMTtcbiAgICAgICAgICAgICAgICBnYWlucy5zZXRfZW50cnkoaSwgZCwgbmV3Z2Fpbik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtb212YWwgPSBpdGVyIDwgMjUwID8gMC41IDogMC44O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld3NpZCA9IG1vbXZhbCAqIHNpZCAtIGVwc2lsb24gKiBuZXdnYWluICogZ2lkO1xuICAgICAgICAgICAgICAgIHlzdGVwLnNldF9lbnRyeShpLCBkLCBuZXdzaWQpO1xuXG4gICAgICAgICAgICAgICAgWS5zZXRfZW50cnkoaSwgZCwgWS5lbnRyeShpLCBkKSArIG5ld3NpZCk7XG4gICAgICAgICAgICAgICAgeW1lYW5bZF0gKz0gWS5lbnRyeShpLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDI7ICsrZCkge1xuICAgICAgICAgICAgICAgIFkuc2V0X2VudHJ5KGksIGQsIFkuZW50cnkoaSwgZCkgLSB5bWVhbltkXSAvIE4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuWTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm9wdGltaXphdGlvblxuICogQGFsaWFzIHBvd2VsbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHtBcnJheX0geDBcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4X2l0ZXIgPSAzMDBdXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAc2VlIGh0dHA6Ly9vcHRpbWl6YXRpb24tanMuZ2l0aHViLmlvL29wdGltaXphdGlvbi1qcy9vcHRpbWl6YXRpb24uanMuaHRtbCNsaW5lNDM4XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChmLCB4MCwgbWF4X2l0ZXIgPSAzMDApIHtcbiAgICBjb25zdCBlcHNpbG9uID0gMWUtMjtcbiAgICBjb25zdCBuID0geDAubGVuZ3RoO1xuICAgIGxldCBhbHBoYSA9IDFlLTM7XG4gICAgbGV0IHBmeCA9IDEwMDAwO1xuICAgIGxldCB4ID0geDAuc2xpY2UoKTtcbiAgICBsZXQgZnggPSBmKHgpO1xuICAgIGxldCBjb252ZXJnZW5jZSA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKG1heF9pdGVyLS0gPj0gMCAmJiAhY29udmVyZ2VuY2UpIHtcbiAgICAgICAgY29udmVyZ2VuY2UgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgeFtpXSArPSAxZS02O1xuICAgICAgICAgICAgbGV0IGZ4aSA9IGYoeCk7XG4gICAgICAgICAgICB4W2ldIC09IDFlLTY7XG4gICAgICAgICAgICBsZXQgZHggPSAoZnhpIC0gZngpIC8gMWUtNjtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeCkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgY29udmVyZ2VuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhbaV0gLT0gYWxwaGEgKiBkeDtcbiAgICAgICAgICAgIGZ4ID0gZih4KTtcbiAgICAgICAgfVxuICAgICAgICBhbHBoYSAqPSBwZnggPj0gZnggPyAxLjA1IDogMC40O1xuICAgICAgICBwZnggPSBmeDtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4sIGV1Y2xpZGVhbl9zcXVhcmVkIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IEJhbGxUcmVlIH0gZnJvbSBcIi4uL2tubi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBsaW5zcGFjZSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IHBvd2VsbCB9IGZyb20gXCIuLi9vcHRpbWl6YXRpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBLTk4gfSBmcm9tIFwiLi4va25uL2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgVU1BUFxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIFVNQVAgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBVTUFQXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5uX25laWdoYm9ycyA9IDE1XSAtIHNpemUgb2YgdGhlIGxvY2FsIG5laWdoYm9yaG9vZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMubG9jYWxfY29ubmVjdGl2aXR5ID0gMV0gLSBudW1iZXIgb2YgbmVhcmVzdCBuZWlnaGJvcnMgY29ubmVjdGVkIGluIHRoZSBsb2NhbCBuZWlnaGJvcmhvb2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLm1pbl9kaXN0ID0gMV0gLSBjb250cm9scyBob3cgdGlnaHRseSBwb2ludHMgZ2V0IHBhY2tlZCB0b2dldGhlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbWV0ZXJzLm1ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBpbiB0aGUgaGlnaC1kaW1lbnNpb25hbCBzcGFjZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuX3NwcmVhZCA9IDFdIC0gVGhlIGVmZmVjdGl2ZSBzY2FsZSBvZiBlbWJlZGRlZCBwb2ludHMuIChJbiBjb21iaW5hdGlvbiB3aXRoIHtAbGluayBwYXJhbWV0ZXJzLm1pbl9kaXN0fSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuX3NldF9vcF9taXhfcmF0aW8gPSAxXSAtIEludGVycG9sYXRlIGJldHdlZW4gdW5pb24gYW5kIGludGVyc2VjdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuX3JlcHVsc2lvbl9zdHJlbmd0aCA9IDFdICAtIFdlaWdodGluZyBhcHBsaWVkIHRvIG5lZ2F0aXZlIHNhbXBsZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLl9uZWdhdGl2ZV9zYW1wbGVfcmF0ZSA9IDVdIC0gVGhlIG51bWJlciBvZiBuZWdhdGl2ZSBzYW1wbGVzIHBlciBwb3NpdGl2ZSBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLl9uX2Vwb2NocyA9IDM1MF0gLSBUaGUgbnVtYmVyIG9mIHRyYWluaW5nIGVwb2Nocy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlci5faW5pdGlhbF9hbHBoYSA9IDFdIC0gVGhlIGluaXRpYWwgbGVhcm5pbmcgcmF0ZSBmb3IgdGhlIG9wdGltaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuc2VlZCA9IDEyMTJdIC0gdGhlIHNlZWQgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7VU1BUH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKFgsIHsgbl9uZWlnaGJvcnM6IDE1LCBsb2NhbF9jb25uZWN0aXZpdHk6IDEsIG1pbl9kaXN0OiAxLCBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiwgXG4gICAgICAgICAgICBfc3ByZWFkOiAxLCBfc2V0X29wX21peF9yYXRpbzogMSwgX3JlcHVsc2lvbl9zdHJlbmd0aDogMSwgX25lZ2F0aXZlX3NhbXBsZV9yYXRlOiA1LCBfbl9lcG9jaHM6IDM1MCwgX2luaXRpYWxfYWxwaGE6IDEgfSwgcGFyYW1ldGVycyk7XG4gICAgICAgIFt0aGlzLl9OLCB0aGlzLl9EXSA9IHRoaXMuWC5zaGFwZTtcbiAgICAgICAgbGV0IG5fbmVpZ2hib3JzID0gTWF0aC5taW4odGhpcy5fTiAtIDEsIHRoaXMucGFyYW1ldGVyKFwibl9uZWlnaGJvcnNcIikpO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcIm5fbmVpZ2hib3JzXCIsIG5fbmVpZ2hib3JzKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJsb2NhbF9jb25uZWN0aXZpdHlcIiwgTWF0aC5taW4odGhpcy5wYXJhbWV0ZXIoXCJsb2NhbF9jb25uZWN0aXZpdHlcIiksIG5fbmVpZ2hib3JzIC0gMSkpO1xuICAgICAgICB0aGlzLl9pdGVyID0gMDtcbiAgICAgICAgY29uc3QgcmFuZG9taXplciA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIHRoaXMuWSA9IG5ldyBNYXRyaXgodGhpcy5fTiwgdGhpcy5wYXJhbWV0ZXIoXCJkXCIpLCAoKSA9PiByYW5kb21pemVyLnJhbmRvbSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwcmVhZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5fZGlzdFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBfZmluZF9hYl9wYXJhbXMoc3ByZWFkLCBtaW5fZGlzdCkge1xuICAgICAgICBjb25zdCBjdXJ2ZSA9ICh4LCBhLCBiKSA9PiAxIC8gKDEgKyBhICogTWF0aC5wb3coeCwgMiAqIGIpKTtcbiAgICAgICAgY29uc3QgeHYgPSBsaW5zcGFjZSgwLCBzcHJlYWQgKiAzLCAzMDApO1xuICAgICAgICBjb25zdCB5diA9IGxpbnNwYWNlKDAsIHNwcmVhZCAqIDMsIDMwMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB4di5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHh2X2kgPSB4dltpXTtcbiAgICAgICAgICAgIHl2W2ldID0geHZfaSA8IG1pbl9kaXN0ID8gMSA6IE1hdGguZXhwKC0oeHZfaSAtIG1pbl9kaXN0KSAvIHNwcmVhZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcnIgPSAocCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBsaW5zcGFjZSgxLCAzMDApLm1hcCgoXywgaSkgPT4geXZbaV0gLSBjdXJ2ZSh4dltpXSwgcFswXSwgcFsxXSkpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChuZXVtYWlyX3N1bShlcnJvci5tYXAoKGUpID0+IGUgKiBlKSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBwb3dlbGwoZXJyLCBbMSwgMV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IGRpc3RhbmNlc1xuICAgICAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gc2lnbWFzXG4gICAgICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSByaG9zXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIF9jb21wdXRlX21lbWJlcnNoaXBfc3RyZW5ndGhzKGRpc3RhbmNlcywgc2lnbWFzLCByaG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gZGlzdGFuY2VzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIG0gPSBkaXN0YW5jZXNbaV0ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IGRpc3RhbmNlc1tpXVtqXS52YWx1ZSAtIHJob3NbaV07XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzW2ldW2pdLnZhbHVlID0gdiA+IDAgPyBNYXRoLmV4cCgtdiAvIHNpZ21hc1tpXSkgOiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXN0YW5jZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0tOTnxCYWxsVHJlZX0ga25uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIF9zbW9vdGhfa25uX2Rpc3Qoa25uLCBrKSB7XG4gICAgICAgIGNvbnN0IFNNT09USF9LX1RPTEVSQU5DRSA9IDFlLTU7XG4gICAgICAgIGNvbnN0IE1JTl9LX0RJU1RfU0NBTEUgPSAxZS0zO1xuICAgICAgICBjb25zdCBuX2l0ZXIgPSA2NDtcbiAgICAgICAgY29uc3QgeyBsb2NhbF9jb25uZWN0aXZpdHksIG1ldHJpYyB9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gTWF0aC5sb2cyKGspO1xuICAgICAgICBjb25zdCByaG9zID0gW107XG4gICAgICAgIGNvbnN0IHNpZ21hcyA9IFtdO1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgLy9jb25zdCBkaXN0YW5jZXMgPSBbLi4uWF0ubWFwKHhfaSA9PiBrbm4uc2VhcmNoKHhfaSwgaykucmF3X2RhdGEoKS5yZXZlcnNlKCkpO1xuXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IFtdO1xuICAgICAgICBpZiAobWV0cmljID09PSBcInByZWNvbXB1dGVkXCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzLnB1c2goa25uLnNlYXJjaChpLCBrKS5yZXZlcnNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCB4X2kgb2YgWCkge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlcy5wdXNoKGtubi5zZWFyY2goeF9pLCBrKS5yYXdfZGF0YSgpLnJldmVyc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgbGV0IGxvID0gMDtcbiAgICAgICAgICAgIGxldCBoaSA9IEluZmluaXR5O1xuICAgICAgICAgICAgbGV0IG1pZCA9IDE7XG5cbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaF9yZXN1bHQgPSBkaXN0YW5jZXNbaV07XG4gICAgICAgICAgICBjb25zdCBub25femVyb19kaXN0ID0gc2VhcmNoX3Jlc3VsdC5maWx0ZXIoKGQpID0+IGQudmFsdWUgPiAwKTtcbiAgICAgICAgICAgIGNvbnN0IG5vbl96ZXJvX2Rpc3RfbGVuZ3RoID0gbm9uX3plcm9fZGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobm9uX3plcm9fZGlzdF9sZW5ndGggPj0gbG9jYWxfY29ubmVjdGl2aXR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKGxvY2FsX2Nvbm5lY3Rpdml0eSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IGxvY2FsX2Nvbm5lY3Rpdml0eSAtIGluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmhvcy5wdXNoKG5vbl96ZXJvX2Rpc3RbaW5kZXggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uID4gU01PT1RIX0tfVE9MRVJBTkNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaG9zW2ldLnZhbHVlICs9IGludGVycG9sYXRpb24gKiAobm9uX3plcm9fZGlzdFtpbmRleF0udmFsdWUgLSBub25femVyb19kaXN0W2luZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmhvc1tpXS52YWx1ZSA9IGludGVycG9sYXRpb24gKiBub25femVyb19kaXN0WzBdLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9uX3plcm9fZGlzdF9sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmhvc1tpXSA9IG5vbl96ZXJvX2Rpc3Rbbm9uX3plcm9fZGlzdF9sZW5ndGggLSAxXS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbl9pdGVyOyArK3gpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZCA9IHNlYXJjaF9yZXN1bHRbal0udmFsdWUgLSByaG9zW2ldO1xuICAgICAgICAgICAgICAgICAgICBwc3VtICs9IGQgPiAwID8gTWF0aC5leHAoLShkIC8gbWlkKSkgOiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocHN1bSAtIHRhcmdldCkgPCBTTU9PVEhfS19UT0xFUkFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwc3VtID4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIFtoaSwgbWlkXSA9IFttaWQsIChsbyArIGhpKSAvIDJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtsbywgbWlkXSA9IFttaWQsIG1pZCAqIDJdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2xvLCBtaWRdID0gW21pZCwgKGxvICsgaGkpIC8gMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWdtYXNbaV0gPSBtaWQ7XG5cbiAgICAgICAgICAgIGNvbnN0IG1lYW5faXRoZCA9IHNlYXJjaF9yZXN1bHQucmVkdWNlKChhLCBiKSA9PiBhICsgYi52YWx1ZSwgMCkgLyBzZWFyY2hfcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIC8vbGV0IG1lYW5fZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmhvc1tpXSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbWFzW2ldIDwgTUlOX0tfRElTVF9TQ0FMRSAqIG1lYW5faXRoZCkge1xuICAgICAgICAgICAgICAgICAgICBzaWdtYXNbaV0gPSBNSU5fS19ESVNUX1NDQUxFICogbWVhbl9pdGhkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVhbl9kID0gZGlzdGFuY2VzLnJlZHVjZSgoYWNjLCByZXMpID0+IGFjYyArIHJlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLnZhbHVlLCAwKSAvIHJlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChzaWdtYXNbaV0gPiBNSU5fS19ESVNUX1NDQUxFICogbWVhbl9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ21hc1tpXSA9IE1JTl9LX0RJU1RfU0NBTEUgKiBtZWFuX2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXN0YW5jZXM6IGRpc3RhbmNlcyxcbiAgICAgICAgICAgIHNpZ21hczogc2lnbWFzLFxuICAgICAgICAgICAgcmhvczogcmhvcyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5fbmVpZ2hib3JzXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBfZnV6enlfc2ltcGxpY2lhbF9zZXQoWCwgbl9uZWlnaGJvcnMpIHtcbiAgICAgICAgY29uc3QgTiA9IFguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHsgbWV0cmljIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBrbm4gPSBtZXRyaWMgPT09IFwicHJlY29tcHV0ZWRcIiA/IG5ldyBLTk4oWCwgXCJwcmVjb21wdXRlZFwiKSA6IG5ldyBCYWxsVHJlZShYLnRvMmRBcnJheSwgbWV0cmljKTtcbiAgICAgICAgbGV0IHsgZGlzdGFuY2VzLCBzaWdtYXMsIHJob3MgfSA9IHRoaXMuX3Ntb290aF9rbm5fZGlzdChrbm4sIG5fbmVpZ2hib3JzKTtcbiAgICAgICAgZGlzdGFuY2VzID0gdGhpcy5fY29tcHV0ZV9tZW1iZXJzaGlwX3N0cmVuZ3RocyhkaXN0YW5jZXMsIHNpZ21hcywgcmhvcyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgoTiwgTiwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlc19pID0gZGlzdGFuY2VzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaXN0YW5jZXNfaS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRfZW50cnkoaSwgZGlzdGFuY2VzX2lbal0uZWxlbWVudC5pbmRleCwgZGlzdGFuY2VzX2lbal0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zcG9zZWRfcmVzdWx0ID0gcmVzdWx0LlQ7XG4gICAgICAgIGNvbnN0IHByb2RfbWF0cml4ID0gcmVzdWx0Lm11bHQodHJhbnNwb3NlZF9yZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICAuYWRkKHRyYW5zcG9zZWRfcmVzdWx0KVxuICAgICAgICAgICAgLnN1Yihwcm9kX21hdHJpeClcbiAgICAgICAgICAgIC5tdWx0KHRoaXMuX3NldF9vcF9taXhfcmF0aW8pXG4gICAgICAgICAgICAuYWRkKHByb2RfbWF0cml4Lm11bHQoMSAtIHRoaXMucGFyYW1ldGVyKFwiX3NldF9vcF9taXhfcmF0aW9cIikpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX2Vwb2Noc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBfbWFrZV9lcG9jaHNfcGVyX3NhbXBsZShuX2Vwb2Nocykge1xuICAgICAgICBjb25zdCB3ZWlnaHRzID0gdGhpcy5fd2VpZ2h0cztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSh3ZWlnaHRzLmxlbmd0aCkuZmlsbCgtMSk7XG4gICAgICAgIGNvbnN0IHdlaWdodHNfbWF4ID0gbWF4KHdlaWdodHMpO1xuICAgICAgICBjb25zdCBuX3NhbXBsZXMgPSB3ZWlnaHRzLm1hcCgodykgPT4gbl9lcG9jaHMgKiAodyAvIHdlaWdodHNfbWF4KSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSBpZiAobl9zYW1wbGVzW2ldID4gMCkgcmVzdWx0W2ldID0gTWF0aC5yb3VuZChuX2Vwb2NocyAvIG5fc2FtcGxlc1tpXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gZ3JhcGhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIF90b2NvbyhncmFwaCkge1xuICAgICAgICBjb25zdCByb3dzID0gW107XG4gICAgICAgIGNvbnN0IGNvbHMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBjb25zdCBbcm93c19uLCBjb2xzX25dID0gZ3JhcGguc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3NfbjsgKytyb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHNfbjsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGdyYXBoLmVudHJ5KHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbHMucHVzaChjb2wpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93czogcm93cyxcbiAgICAgICAgICAgIGNvbHM6IGNvbHMsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGFsbCBuZWNlc3NhcnlcbiAgICAgKiBAcmV0dXJucyB7VU1BUH1cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCB7IF9zcHJlYWQsIG1pbl9kaXN0LCBuX25laWdoYm9ycywgX25fZXBvY2hzLCBfbmVnYXRpdmVfc2FtcGxlX3JhdGV9ID0gdGhpcy5fcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCBbYSwgYl0gPSB0aGlzLl9maW5kX2FiX3BhcmFtcyhfc3ByZWFkLCBtaW5fZGlzdCk7XG4gICAgICAgIHRoaXMuX2EgPSBhO1xuICAgICAgICB0aGlzLl9iID0gYjtcbiAgICAgICAgdGhpcy5fZ3JhcGggPSB0aGlzLl9mdXp6eV9zaW1wbGljaWFsX3NldCh0aGlzLlgsIG5fbmVpZ2hib3JzKTtcbiAgICAgICAgY29uc3QgeyByb3dzLCBjb2xzLCBkYXRhOiB3ZWlnaHRzIH0gPSB0aGlzLl90b2Nvbyh0aGlzLl9ncmFwaCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSByb3dzO1xuICAgICAgICB0aGlzLl90YWlsID0gY29scztcbiAgICAgICAgdGhpcy5fd2VpZ2h0cyA9IHdlaWdodHM7XG4gICAgICAgIHRoaXMuX2Vwb2Noc19wZXJfc2FtcGxlID0gdGhpcy5fbWFrZV9lcG9jaHNfcGVyX3NhbXBsZShfbl9lcG9jaHMpO1xuICAgICAgICB0aGlzLl9lcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZSA9IHRoaXMuX2Vwb2Noc19wZXJfc2FtcGxlLm1hcCgoZCkgPT4gZCAqIF9uZWdhdGl2ZV9zYW1wbGVfcmF0ZSk7XG4gICAgICAgIHRoaXMuX2Vwb2NoX29mX25leHRfc2FtcGxlID0gdGhpcy5fZXBvY2hzX3Blcl9zYW1wbGUuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5fZXBvY2hfb2ZfbmV4dF9uZWdhdGl2ZV9zYW1wbGUgPSB0aGlzLl9lcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBncmFwaCgpIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIHJldHVybiB7IGNvbHM6IHRoaXMuX2hlYWQsIHJvd3M6IHRoaXMuX3RhaWwsIHdlaWdodHM6IHRoaXMuX3dlaWdodHMgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaXRlcmF0aW9ucz0zNTBdIC0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gICAgICogQHJldHVybnMge01hdHJpeHxBcnJheX1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oaXRlcmF0aW9ucyA9IDM1MCkge1xuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXIoXCJfbl9lcG9jaHNcIikgIT0gaXRlcmF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJfbl9lcG9jaHNcIiwgaXRlcmF0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2l0ZXJhdGlvbnM9MzUwXSAtIG51bWJlciBvZiBpdGVyYXRpb25zLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh8QXJyYXl9XG4gICAgICovXG4gICAgKmdlbmVyYXRvcihpdGVyYXRpb25zID0gMzUwKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcihcIl9uX2Vwb2Noc1wiKSAhPSBpdGVyYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcihcIl9uX2Vwb2Noc1wiLCBpdGVyYXRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnByb2plY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBfY2xpcCh4KSB7XG4gICAgICAgIGlmICh4ID4gNCkgcmV0dXJuIDQ7XG4gICAgICAgIGlmICh4IDwgLTQpIHJldHVybiAtNDtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGVyZm9ybXMgdGhlIG9wdGltaXphdGlvbiBzdGVwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGhlYWRfZW1iZWRkaW5nXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IHRhaWxfZW1iZWRkaW5nXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGhlYWRcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gdGFpbFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgX29wdGltaXplX2xheW91dChoZWFkX2VtYmVkZGluZywgdGFpbF9lbWJlZGRpbmcsIGhlYWQsIHRhaWwpIHtcbiAgICAgICAgY29uc3QgeyBfZDogZGltLCBfYWxwaGE6IGFscGhhLCBfcmVwdWxzaW9uX3N0cmVuZ3RoOiByZXB1bHNpb25fc3RyZW5ndGgsIF9hOiBhLCBfYjogYiwgX2Vwb2Noc19wZXJfc2FtcGxlOiBlcG9jaHNfcGVyX3NhbXBsZSwgX2Vwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlOiBlcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZSwgX2Vwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlOiBlcG9jaF9vZl9uZXh0X25lZ2F0aXZlX3NhbXBsZSwgX2Vwb2NoX29mX25leHRfc2FtcGxlOiBlcG9jaF9vZl9uZXh0X3NhbXBsZSwgX2NsaXA6IGNsaXAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRhaWxfbGVuZ3RoID0gdGFpbC5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBlcG9jaHNfcGVyX3NhbXBsZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChlcG9jaF9vZl9uZXh0X3NhbXBsZVtpXSA8PSB0aGlzLl9pdGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaiA9IGhlYWRbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgayA9IHRhaWxbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGhlYWRfZW1iZWRkaW5nLnJvdyhqKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlciA9IHRhaWxfZW1iZWRkaW5nLnJvdyhrKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gZXVjbGlkZWFuX3NxdWFyZWQoY3VycmVudCwgb3RoZXIpO1xuICAgICAgICAgICAgICAgIGxldCBncmFkX2NvZWZmID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZF9jb2VmZiA9ICgtMiAqIGEgKiBiICogTWF0aC5wb3coZGlzdCwgYiAtIDEpKSAvIChhICogTWF0aC5wb3coZGlzdCwgYikgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBncmFkX2QgPSBjbGlwKGdyYWRfY29lZmYgKiAoY3VycmVudFtkXSAtIG90aGVyW2RdKSkgKiBhbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGN1cnJlbnRbZF0gKyBncmFkX2Q7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBvdGhlcltkXSAtIGdyYWRfZDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFtkXSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyW2RdID0gbztcbiAgICAgICAgICAgICAgICAgICAgaGVhZF9lbWJlZGRpbmcuc2V0X2VudHJ5KGosIGQsIGMpO1xuICAgICAgICAgICAgICAgICAgICB0YWlsX2VtYmVkZGluZy5zZXRfZW50cnkoaywgZCwgbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVwb2NoX29mX25leHRfc2FtcGxlW2ldICs9IGVwb2Noc19wZXJfc2FtcGxlW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5fbmVnX3NhbXBsZXMgPSAodGhpcy5faXRlciAtIGVwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlW2ldKSAvIGVwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbl9uZWdfc2FtcGxlczsgKytwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGsgPSBNYXRoLmZsb29yKHRoaXMuX3JhbmRvbWl6ZXIucmFuZG9tICogdGFpbF9sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlciA9IHRhaWxfZW1iZWRkaW5nLnJvdyh0YWlsW2tdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IGV1Y2xpZGVhbl9zcXVhcmVkKGN1cnJlbnQsIG90aGVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGdyYWRfY29lZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRfY29lZmYgPSAoMiAqIHJlcHVsc2lvbl9zdHJlbmd0aCAqIGIpIC8gKCgwLjAxICsgZGlzdCkgKiAoYSAqIE1hdGgucG93KGRpc3QsIGIpICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGogPT09IGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyYWRfZCA9IGNsaXAoZ3JhZF9jb2VmZiAqIChjdXJyZW50W2RdIC0gb3RoZXJbZF0pKSAqIGFscGhhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGN1cnJlbnRbZF0gKyBncmFkX2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvID0gb3RoZXJbZF0gLSBncmFkX2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50W2RdID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyW2RdID0gbztcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRfZW1iZWRkaW5nLnNldF9lbnRyeShqLCBkLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhaWxfZW1iZWRkaW5nLnNldF9lbnRyeSh0YWlsW2tdLCBkLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcG9jaF9vZl9uZXh0X25lZ2F0aXZlX3NhbXBsZVtpXSArPSBuX25lZ19zYW1wbGVzICogZXBvY2hzX3Blcl9uZWdhdGl2ZV9zYW1wbGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRfZW1iZWRkaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgaXRlciA9ICsrdGhpcy5faXRlcjtcbiAgICAgICAgbGV0IFkgPSB0aGlzLlk7XG5cbiAgICAgICAgdGhpcy5fYWxwaGEgPSB0aGlzLnBhcmFtZXRlcihcIl9pbml0aWFsX2FscGhhXCIpICogKDEgLSBpdGVyIC8gdGhpcy5wYXJhbWV0ZXIoXCJfbl9lcG9jaHNcIikpO1xuICAgICAgICB0aGlzLlkgPSB0aGlzLl9vcHRpbWl6ZV9sYXlvdXQoWSwgWSwgdGhpcy5faGVhZCwgdGhpcy5fdGFpbCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuWTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBNYXRyaXgsIGxpbnNwYWNlIH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFBDQSB9IGZyb20gXCIuL1BDQS5qc1wiO1xuaW1wb3J0IHsgQmFsbFRyZWUgfSBmcm9tIFwiLi4va25uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgVHJpTWFwXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgVHJpTWFwIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgVHJpTWFwXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy53ZWlnaHRfYWRqID0gNTAwXSAtIHNjYWxpbmcgZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5jID0gNV0gLSBudW1iZXIgb2YgdHJpcGxldHMgbXVsdGlwbGllci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy50b2wgPSAxZS04XSAtXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtZXRlcnMubWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtUcmlNYXB9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE5MTAuMDAyMDR2MS5wZGZ9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VhbWlkL3RyaW1hcH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKFgsIHsgd2VpZ2h0X2FkajogNTAwLCBjOiA1LCBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgdG9sOiAxZS04LCBzZWVkOiAxMjEyIH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBbcGNhID0gbnVsbF0gLSBJbml0aWFsIEVtYmVkZGluZyAoaWYgbnVsbCB0aGVuIFBDQSBnZXRzIHVzZWQpLlxuICAgICAqIEBwYXJhbSB7S05OfSBba25uID0gbnVsbF0gLSBLTk4gT2JqZWN0IChpZiBudWxsIHRoZW4gQmFsbFRyZWUgZ2V0cyB1c2VkKS5cbiAgICAgKi9cbiAgICBpbml0KHBjYSA9IG51bGwsIGtubiA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgTiA9IFguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHsgZCwgbWV0cmljLCBjIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLm5faW5saWVycyA9IDIgKiBjO1xuICAgICAgICB0aGlzLm5fb3V0bGllcnMgPSAxICogYztcbiAgICAgICAgdGhpcy5uX3JhbmRvbSA9IDEgKiBjO1xuICAgICAgICB0aGlzLlkgPSBwY2EgfHwgbmV3IFBDQShYLCBkKS50cmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5rbm4gPSBrbm4gfHwgbmV3IEJhbGxUcmVlKFgudG8yZEFycmF5LCBtZXRyaWMpO1xuICAgICAgICBjb25zdCB7IHRyaXBsZXRzLCB3ZWlnaHRzIH0gPSB0aGlzLl9nZW5lcmF0ZV90cmlwbGV0cyh0aGlzLm5faW5saWVycywgdGhpcy5uX291dGxpZXJzLCB0aGlzLm5fcmFuZG9tKTtcbiAgICAgICAgdGhpcy50cmlwbGV0cyA9IHRyaXBsZXRzO1xuICAgICAgICB0aGlzLndlaWdodHMgPSB3ZWlnaHRzO1xuICAgICAgICB0aGlzLmxyID0gKDEwMDAgKiBOKSAvIHRyaXBsZXRzLnNoYXBlWzBdO1xuICAgICAgICB0aGlzLkMgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy52ZWwgPSBuZXcgTWF0cml4KE4sIGQsIDApO1xuICAgICAgICB0aGlzLmdhaW4gPSBuZXcgTWF0cml4KE4sIGQsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMge0BsaW5rIG5faW5saWVyc30geCB7QGxpbmsgbl9vdXRsaWVyc30geCB7QGxpbmsgbl9yYW5kb219IHRyaXBsZXRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX2lubGllcnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbl9vdXRsaWVyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX3JhbmRvbVxuICAgICAqL1xuICAgIF9nZW5lcmF0ZV90cmlwbGV0cyhuX2lubGllcnMsIG5fb3V0bGllcnMsIG5fcmFuZG9tKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0cmljLCB3ZWlnaHRfYWRqIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3Qga25uID0gdGhpcy5rbm47XG4gICAgICAgIGNvbnN0IG5fZXh0cmEgPSBNYXRoLm1pbihuX2lubGllcnMgKyAyMCwgTik7XG4gICAgICAgIGNvbnN0IG5icnMgPSBuZXcgTWF0cml4KE4sIG5fZXh0cmEpO1xuICAgICAgICBjb25zdCBrbm5fZGlzdGFuY2VzID0gbmV3IE1hdHJpeChOLCBuX2V4dHJhKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGtubi5zZWFyY2goWC5yb3coaSksIG5fZXh0cmEgKyAxKVxuICAgICAgICAgICAgICAgIC5yYXdfZGF0YSgpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZCkgPT4gZC52YWx1ZSAhPSAwKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnZhbHVlIC0gYi52YWx1ZSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoZCwgaikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBuYnJzLnNldF9lbnRyeShpLCBqLCBkLmVsZW1lbnQuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBrbm5fZGlzdGFuY2VzLnNldF9lbnRyeShpLCBqLCBkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzY2FsZSBwYXJhbWV0ZXJcbiAgICAgICAgY29uc3Qgc2lnID0gbmV3IEZsb2F0NjRBcnJheShOKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIHNpZ1tpXSA9IE1hdGgubWF4KChrbm5fZGlzdGFuY2VzLmVudHJ5KGksIDMpICsga25uX2Rpc3RhbmNlcy5lbnRyeShpLCA0KSArIGtubl9kaXN0YW5jZXMuZW50cnkoaSwgNSkgKyBrbm5fZGlzdGFuY2VzLmVudHJ5KGksIDYpKSAvIDQsIDFlLTEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFAgPSB0aGlzLl9maW5kX3Aoa25uX2Rpc3RhbmNlcywgc2lnLCBuYnJzKTtcblxuICAgICAgICBsZXQgdHJpcGxldHMgPSB0aGlzLl9zYW1wbGVfa25uX3RyaXBsZXRzKFAsIG5icnMsIG5faW5saWVycywgbl9vdXRsaWVycyk7XG4gICAgICAgIGxldCBuX3RyaXBsZXRzID0gdHJpcGxldHMuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IG91dGxpZXJfZGlzdGFuY2VzID0gbmV3IEZsb2F0NjRBcnJheShuX3RyaXBsZXRzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuX3RyaXBsZXRzOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSB0cmlwbGV0cy5lbnRyeShpLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGsgPSB0cmlwbGV0cy5lbnRyeShpLCAyKTtcbiAgICAgICAgICAgIG91dGxpZXJfZGlzdGFuY2VzW2ldID0gbWV0cmljKFgucm93KGopLCBYLnJvdyhrKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdlaWdodHMgPSB0aGlzLl9maW5kX3dlaWdodHModHJpcGxldHMsIFAsIG5icnMsIG91dGxpZXJfZGlzdGFuY2VzLCBzaWcpO1xuXG4gICAgICAgIGlmIChuX3JhbmRvbSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZG9tX3RyaXBsZXRzLCByYW5kb21fd2VpZ2h0cyB9ID0gdGhpcy5fc2FtcGxlX3JhbmRvbV90cmlwbGV0cyhYLCBuX3JhbmRvbSwgc2lnKTtcbiAgICAgICAgICAgIHRyaXBsZXRzID0gdHJpcGxldHMuY29uY2F0KHJhbmRvbV90cmlwbGV0cywgXCJ2ZXJ0aWNhbFwiKTtcbiAgICAgICAgICAgIHdlaWdodHMgPSBGbG9hdDY0QXJyYXkuZnJvbShbLi4ud2VpZ2h0cywgLi4ucmFuZG9tX3dlaWdodHNdKTtcbiAgICAgICAgfVxuICAgICAgICBuX3RyaXBsZXRzID0gdHJpcGxldHMuc2hhcGVbMF07XG4gICAgICAgIGxldCBtYXhfd2VpZ2h0ID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5fdHJpcGxldHM7ICsraSkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHdlaWdodHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0c1tpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4X3dlaWdodCA8IHdlaWdodHNbaV0pIG1heF93ZWlnaHQgPSB3ZWlnaHRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXhfd2VpZ2h0XzIgPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbl90cmlwbGV0czsgKytpKSB7XG4gICAgICAgICAgICB3ZWlnaHRzW2ldIC89IG1heF93ZWlnaHQ7XG4gICAgICAgICAgICB3ZWlnaHRzW2ldICs9IDAuMDAwMTtcbiAgICAgICAgICAgIHdlaWdodHNbaV0gPSBNYXRoLmxvZygxICsgd2VpZ2h0X2FkaiAqIHdlaWdodHNbaV0pO1xuICAgICAgICAgICAgaWYgKG1heF93ZWlnaHRfMiA8IHdlaWdodHNbaV0pIG1heF93ZWlnaHRfMiA9IHdlaWdodHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuX3RyaXBsZXRzOyArK2kpIHtcbiAgICAgICAgICAgIHdlaWdodHNbaV0gLz0gbWF4X3dlaWdodF8yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmlwbGV0czogdHJpcGxldHMsXG4gICAgICAgICAgICB3ZWlnaHRzOiB3ZWlnaHRzLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNpbWlsYXJpdHkgbWF0cml4IFBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBrbm5fZGlzdGFuY2VzIC0gbWF0cml4IG9mIHBhaXJ3aXNlIGtubiBkaXN0YW5jZXNcbiAgICAgKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gc2lnIC0gc2NhbGluZyBmYWN0b3IgZm9yIHRoZSBkaXN0YW5jZXNcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbmJycyAtIG5lYXJlc3QgbmVpZ2hib3JzXG4gICAgICogQHJldHVybnMge01hdHJpeH0gcGFpcndpc2Ugc2ltaWxhcml0eSBtYXRyaXhcbiAgICAgKi9cbiAgICBfZmluZF9wKGtubl9kaXN0YW5jZXMsIHNpZywgbmJycykge1xuICAgICAgICBjb25zdCBbTiwgbl9uZWlnaGJvcnNdID0ga25uX2Rpc3RhbmNlcy5zaGFwZTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoTiwgbl9uZWlnaGJvcnMsIChpLCBqKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5leHAoLShrbm5fZGlzdGFuY2VzLmVudHJ5KGksIGopICoqIDIgLyBzaWdbaV0gLyBzaWdbbmJycy5lbnRyeShpLCBqKV0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2FtcGxlIG5lYXJlc3QgbmVpZ2hib3JzIHRyaXBsZXRzIGJhc2VkIG9uIHRoZSBzaW1pbGFyaXR5IHZhbHVlcyBnaXZlbiBpbiBQLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFAgLSBNYXRyaXggb2YgcGFpcndpc2Ugc2ltaWxhcml0aWVzIGJldHdlZW4gZWFjaCBwb2ludCBhbmQgaXRzIG5laWdoYm9ycyBnaXZlbiBpbiBtYXRyaXggbmJycy5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbmJycyAtIE5lYXJlc3QgbmVpZ2hib3JzIGluZGljZXMgZm9yIGVhY2ggcG9pbnQuIFRoZSBzaW1pbGFyaXR5IHZhbHVlcyBhcmUgZ2l2ZW4gaW4gbWF0cml4IHtAbGluayBQfS4gUm93IGkgY29ycmVzcG9uZHMgdG8gdGhlIGktdGggcG9pbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5faW5saWVycyAtIE51bWJlciBvZiBpbmxpZXIgcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX291dGxpZXJzIC0gTnVtYmVyIG9mIG91dGxpZXIgcG9pbnRzLlxuICAgICAqXG4gICAgICovXG4gICAgX3NhbXBsZV9rbm5fdHJpcGxldHMoUCwgbmJycywgbl9pbmxpZXJzLCBuX291dGxpZXJzKSB7XG4gICAgICAgIGNvbnN0IE4gPSBuYnJzLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCB0cmlwbGV0cyA9IG5ldyBNYXRyaXgoTiAqIG5faW5saWVycyAqIG5fb3V0bGllcnMsIDMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgbGV0IG5faSA9IGkgKiBuX2lubGllcnMgKiBuX291dGxpZXJzO1xuICAgICAgICAgICAgY29uc3Qgc29ydF9pbmRpY2VzID0gdGhpcy5fX2FyZ3NvcnQoUC5yb3coaSkubWFwKChkKSA9PiAtZCkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuX2lubGllcnM7ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBuX2ogPSBqICogbl9vdXRsaWVycztcbiAgICAgICAgICAgICAgICBjb25zdCBzaW0gPSBuYnJzLmVudHJ5KGksIHNvcnRfaW5kaWNlc1tqXSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FtcGxlcyA9IHRoaXMuX3JlamVjdGlvbl9zYW1wbGUobl9vdXRsaWVycywgTiwgc29ydF9pbmRpY2VzLnNsaWNlKDAsIGogKyAxKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuX291dGxpZXJzOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBuX2kgKyBuX2ogKyBrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSBzYW1wbGVzW2tdO1xuICAgICAgICAgICAgICAgICAgICB0cmlwbGV0cy5zZXRfZW50cnkoaW5kZXgsIDAsIGkpO1xuICAgICAgICAgICAgICAgICAgICB0cmlwbGV0cy5zZXRfZW50cnkoaW5kZXgsIDEsIHNpbSk7XG4gICAgICAgICAgICAgICAgICAgIHRyaXBsZXRzLnNldF9lbnRyeShpbmRleCwgMiwgb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyaXBsZXRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3VsZCBkbyB0aGUgc2FtZSBhcyBucC5hcmdzb3J0KClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IEFcbiAgICAgKi9cbiAgICBfX2FyZ3NvcnQoQSkge1xuICAgICAgICByZXR1cm4gQS5tYXAoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGQ6IGQsIGk6IGkgfTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmQgLSBiLmQpXG4gICAgICAgICAgICAubWFwKChkKSA9PiBkLmkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhbXBsZXMge0BsaW5rIG5fc2FtcGxlc30gaW50ZWdlcnMgZnJvbSBhIGdpdmVuIGludGVydmFsIFswLCB7QGxpbmsgbWF4X2ludH1dIHdoaWxlIHJlamVjdGlvbiB0aGUgdmFsdWVzIHRoYXQgYXJlIGluIHRoZSB7QGxpbmsgcmVqZWN0c30uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG5fc2FtcGxlc1xuICAgICAqIEBwYXJhbSB7Kn0gbWF4X2ludFxuICAgICAqIEBwYXJhbSB7Kn0gcmVqZWN0c1xuICAgICAqL1xuICAgIF9yZWplY3Rpb25fc2FtcGxlKG5fc2FtcGxlcywgbWF4X2ludCwgcmVqZWN0cykge1xuICAgICAgICBjb25zdCByYW5kb21pemVyID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBsaW5zcGFjZSgwLCBtYXhfaW50IC0gMSkuZmlsdGVyKChkKSA9PiByZWplY3RzLmluZGV4T2YoZCkgPCAwKTtcbiAgICAgICAgcmV0dXJuIHJhbmRvbWl6ZXIuY2hvaWNlKGludGVydmFsLCBNYXRoLm1pbihuX3NhbXBsZXMsIGludGVydmFsLmxlbmd0aCAtIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB3ZWlnaHRzIGZvciB0aGUgc2FtcGxlZCBuZWFyZXN0IG5laWdoYm9ycyB0cmlwbGV0c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IHRyaXBsZXRzIC0gU2FtcGxlZCBUcmlwbGV0cy5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gUCAtIFBhaXJ3aXNlIHNpbWlsYXJpdHkgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBuYnJzIC0gbmVhcmVzdCBOZWlnaGJvcnNcbiAgICAgKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gb3V0bGllcl9kaXN0YW5jZXMgLSBNYXRyaXggb2YgcGFpcndpc2Ugb3V0bGllciBkaXN0YW5jZXNcbiAgICAgKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gc2lnIC0gc2NhbGluZyBmYWN0b3IgZm9yIHRoZSBkaXN0YW5jZXMuXG4gICAgICovXG4gICAgX2ZpbmRfd2VpZ2h0cyh0cmlwbGV0cywgUCwgbmJycywgb3V0bGllcl9kaXN0YW5jZXMsIHNpZykge1xuICAgICAgICBjb25zdCBuX3RyaXBsZXRzID0gdHJpcGxldHMuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHdlaWdodHMgPSBuZXcgRmxvYXQ2NEFycmF5KG5fdHJpcGxldHMpO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IG5fdHJpcGxldHM7ICsrdCkge1xuICAgICAgICAgICAgY29uc3QgaSA9IHRyaXBsZXRzLmVudHJ5KHQsIDApO1xuICAgICAgICAgICAgY29uc3Qgc2ltID0gbmJycy5yb3coaSkuaW5kZXhPZih0cmlwbGV0cy5lbnRyeSh0LCAxKSk7XG4gICAgICAgICAgICBjb25zdCBwX3NpbSA9IFAuZW50cnkoaSwgc2ltKTtcbiAgICAgICAgICAgIGxldCBwX291dCA9IE1hdGguZXhwKC0ob3V0bGllcl9kaXN0YW5jZXNbdF0gKiogMiAvIChzaWdbaV0gKiBzaWdbdHJpcGxldHMuZW50cnkodCwgMildKSkpO1xuICAgICAgICAgICAgaWYgKHBfb3V0IDwgMWUtMjApIHBfb3V0ID0gMWUtMjA7XG4gICAgICAgICAgICB3ZWlnaHRzW3RdID0gcF9zaW0gLyBwX291dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2VpZ2h0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYW1wbGUgdW5pZm9ybWx5IHJhbm9tIHRyaXBsZXRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIERhdGEgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX3JhbmRvbSAtIE51bWJlciBvZiByYW5kb20gdHJpcGxldHMgcGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IHNpZyAtIFNjYWxpbmcgZmFjdG9yIGZvciB0aGUgZGlzdGFuY2VzXG4gICAgICovXG4gICAgX3NhbXBsZV9yYW5kb21fdHJpcGxldHMoWCwgbl9yYW5kb20sIHNpZykge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLnBhcmFtZXRlcihcIm1ldHJpY1wiKTtcbiAgICAgICAgY29uc3QgcmFuZG9taXplciA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIGNvbnN0IE4gPSBYLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCByYW5kb21fdHJpcGxldHMgPSBuZXcgTWF0cml4KE4gKiBuX3JhbmRvbSwgMyk7XG4gICAgICAgIGNvbnN0IHJhbmRvbV93ZWlnaHRzID0gbmV3IEZsb2F0NjRBcnJheShOICogbl9yYW5kb20pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgbl9pID0gaSAqIG5fcmFuZG9tO1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IFsuLi5saW5zcGFjZSgwLCBpIC0gMSksIC4uLmxpbnNwYWNlKGkgKyAxLCBOIC0gMSldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuX3JhbmRvbTsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IFtzaW0sIG91dF0gPSByYW5kb21pemVyLmNob2ljZShpbmRpY2VzLCAyKTtcbiAgICAgICAgICAgICAgICBsZXQgcF9zaW0gPSBNYXRoLmV4cCgtKG1ldHJpYyhYLnJvdyhpKSwgWC5yb3coc2ltKSkgKiogMiAvIChzaWdbaV0gKiBzaWdbc2ltXSkpKTtcbiAgICAgICAgICAgICAgICBpZiAocF9zaW0gPCAxZS0yMCkgcF9zaW0gPSAxZS0yMDtcbiAgICAgICAgICAgICAgICBsZXQgcF9vdXQgPSBNYXRoLmV4cCgtKG1ldHJpYyhYLnJvdyhpKSwgWC5yb3cob3V0KSkgKiogMiAvIChzaWdbaV0gKiBzaWdbb3V0XSkpKTtcbiAgICAgICAgICAgICAgICBpZiAocF9vdXQgPCAxZS0yMCkgcF9vdXQgPSAxZS0yMDtcblxuICAgICAgICAgICAgICAgIGlmIChwX3NpbSA8IHBfb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIFtzaW0sIG91dF0gPSBbb3V0LCBzaW1dO1xuICAgICAgICAgICAgICAgICAgICBbcF9zaW0sIHBfb3V0XSA9IFtwX291dCwgcF9zaW1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG5faSArIGo7XG4gICAgICAgICAgICAgICAgcmFuZG9tX3RyaXBsZXRzLnNldF9lbnRyeShpbmRleCwgMCwgaSk7XG4gICAgICAgICAgICAgICAgcmFuZG9tX3RyaXBsZXRzLnNldF9lbnRyeShpbmRleCwgMSwgc2ltKTtcbiAgICAgICAgICAgICAgICByYW5kb21fdHJpcGxldHMuc2V0X2VudHJ5KGluZGV4LCAyLCBvdXQpO1xuICAgICAgICAgICAgICAgIHJhbmRvbV93ZWlnaHRzW2luZGV4XSA9IHBfc2ltIC8gcF9vdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhbmRvbV90cmlwbGV0czogcmFuZG9tX3RyaXBsZXRzLFxuICAgICAgICAgICAgcmFuZG9tX3dlaWdodHM6IHJhbmRvbV93ZWlnaHRzLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBncmFkaWVudCBmb3IgdXBkYXRpbmcgdGhlIGVtYmVkZGluZy5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWSAtIFRoZSBlbWJlZGRpbmdcbiAgICAgKi9cbiAgICBfZ3JhZChZKSB7XG4gICAgICAgIGNvbnN0IG5faW5saWVycyA9IHRoaXMubl9pbmxpZXJzO1xuICAgICAgICBjb25zdCBuX291dGxpZXJzID0gdGhpcy5uX291dGxpZXJzO1xuICAgICAgICBjb25zdCB0cmlwbGV0cyA9IHRoaXMudHJpcGxldHM7XG4gICAgICAgIGNvbnN0IHdlaWdodHMgPSB0aGlzLndlaWdodHM7XG4gICAgICAgIGNvbnN0IFtOLCBkaW1dID0gWS5zaGFwZTtcbiAgICAgICAgY29uc3Qgbl90cmlwbGV0cyA9IHRyaXBsZXRzLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBncmFkID0gbmV3IE1hdHJpeChOLCBkaW0sIDApO1xuICAgICAgICBsZXQgeV9paiA9IG5ldyBGbG9hdDY0QXJyYXkoZGltKTtcbiAgICAgICAgbGV0IHlfaWsgPSBuZXcgRmxvYXQ2NEFycmF5KGRpbSk7XG4gICAgICAgIGxldCBkX2lqID0gMTtcbiAgICAgICAgbGV0IGRfaWsgPSAxO1xuICAgICAgICBsZXQgbl92aW9sID0gMDtcbiAgICAgICAgbGV0IGxvc3MgPSAwO1xuICAgICAgICBjb25zdCBuX2tubl90cmlwbGV0cyA9IE4gKiBuX2lubGllcnMgKiBuX291dGxpZXJzO1xuXG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgbl90cmlwbGV0czsgKyt0KSB7XG4gICAgICAgICAgICBjb25zdCBbaSwgaiwga10gPSB0cmlwbGV0cy5yb3codCk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgeV9paiwgeV9paywgZF9paiwgZF9pa1xuICAgICAgICAgICAgaWYgKHQgJSBuX291dGxpZXJzID09IDAgfHwgdCA+PSBuX2tubl90cmlwbGV0cykge1xuICAgICAgICAgICAgICAgIGRfaWogPSAxO1xuICAgICAgICAgICAgICAgIGRfaWsgPSAxO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWV9pZCA9IFkuZW50cnkoaSwgZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFlfamQgPSBZLmVudHJ5KGosIGQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBZX2tkID0gWS5lbnRyeShrLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgeV9paltkXSA9IFlfaWQgLSBZX2pkO1xuICAgICAgICAgICAgICAgICAgICB5X2lrW2RdID0gWV9pZCAtIFlfa2Q7XG4gICAgICAgICAgICAgICAgICAgIGRfaWogKz0geV9paltkXSAqKiAyO1xuICAgICAgICAgICAgICAgICAgICBkX2lrICs9IHlfaWtbZF0gKiogMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHlfaWsgYW5kIGRfaWsgb25seVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkX2lrID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFlfaWQgPSBZLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBZX2tkID0gWS5lbnRyeShrLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgeV9pa1tkXSA9IFlfaWQgLSBZX2tkO1xuICAgICAgICAgICAgICAgICAgICBkX2lrICs9IHlfaWtbZF0gKiogMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkX2lqID4gZF9paykgKytuX3Zpb2w7XG4gICAgICAgICAgICBsb3NzICs9IHdlaWdodHNbdF0gLyAoMSArIGRfaWsgLyBkX2lqKTtcbiAgICAgICAgICAgIGNvbnN0IHcgPSAod2VpZ2h0c1t0XSAvIChkX2lqICsgZF9paykpICoqIDI7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3MgPSB5X2lqW2RdICogZF9payAqIHc7XG4gICAgICAgICAgICAgICAgY29uc3QgZ28gPSB5X2lrW2RdICogZF9paiAqIHc7XG4gICAgICAgICAgICAgICAgZ3JhZC5zZXRfZW50cnkoaSwgZCwgZ3JhZC5lbnRyeShpLCBkKSArIGdzIC0gZ28pO1xuICAgICAgICAgICAgICAgIGdyYWQuc2V0X2VudHJ5KGosIGQsIGdyYWQuZW50cnkoaiwgZCkgLSBncyk7XG4gICAgICAgICAgICAgICAgZ3JhZC5zZXRfZW50cnkoaywgZCwgZ3JhZC5lbnRyeShrLCBkKSArIGdvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBncmFkLCBsb3NzLCBuX3Zpb2wgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhfaXRlcmF0aW9uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKG1heF9pdGVyYXRpb24gPSA0MDApIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGl0ZXIgPSAwOyBpdGVyIDwgbWF4X2l0ZXJhdGlvbjsgKytpdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGl0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heF9pdGVyYXRpb25cbiAgICAgKiBAeWllbGRzIHtNYXRyaXh9XG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICAqZ2VuZXJhdG9yKG1heF9pdGVyYXRpb24gPSA4MDApIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGl0ZXIgPSAwOyBpdGVyIDwgbWF4X2l0ZXJhdGlvbjsgKytpdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGl0ZXIpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgaXRlcmF0aW9uIHN0ZXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaXRlclxuICAgICAqL1xuICAgIF9uZXh0KGl0ZXIpIHtcbiAgICAgICAgY29uc3QgZ2FtbWEgPSBpdGVyID4gMTUwID8gMC41IDogMC4zO1xuICAgICAgICBjb25zdCBvbGRfQyA9IHRoaXMuQztcbiAgICAgICAgY29uc3QgdmVsID0gdGhpcy52ZWw7XG4gICAgICAgIGNvbnN0IFkgPSB0aGlzLlkuYWRkKHZlbC5tdWx0KGdhbW1hKSk7XG4gICAgICAgIGNvbnN0IHsgZ3JhZCwgbG9zcywgbl92aW9sIH0gPSB0aGlzLl9ncmFkKFkpO1xuICAgICAgICB0aGlzLkMgPSBsb3NzO1xuICAgICAgICB0aGlzLlkgPSB0aGlzLl91cGRhdGVfZW1iZWRkaW5nKFksIGl0ZXIsIGdyYWQpO1xuICAgICAgICB0aGlzLmxyICo9IG9sZF9DID4gbG9zcyArIHRoaXMuX3BhcmFtZXRlcnMudG9sID8gMS4wMSA6IDAuOTtcbiAgICAgICAgcmV0dXJuIHRoaXMuWTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBlbWJlZGRpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGdyYWRcbiAgICAgKi9cbiAgICBfdXBkYXRlX2VtYmVkZGluZyhZLCBpdGVyLCBncmFkKSB7XG4gICAgICAgIGNvbnN0IFtOLCBkaW1dID0gWS5zaGFwZTtcbiAgICAgICAgY29uc3QgZ2FtbWEgPSBpdGVyID4gMTUwID8gMC45IDogMC41OyAvLyBtb21lbnQgcGFyYW1ldGVyXG4gICAgICAgIGNvbnN0IG1pbl9nYWluID0gMC4wMTtcbiAgICAgICAgY29uc3QgZ2FpbiA9IHRoaXMuZ2FpbjtcbiAgICAgICAgY29uc3QgdmVsID0gdGhpcy52ZWw7XG4gICAgICAgIGNvbnN0IGxyID0gdGhpcy5scjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdfZ2FpbiA9IE1hdGguc2lnbih2ZWwuZW50cnkoaSwgZCkpICE9IE1hdGguc2lnbihncmFkLmVudHJ5KGksIGQpKSA/IGdhaW4uZW50cnkoaSwgZCkgKyAwLjIgOiBNYXRoLm1heChnYWluLmVudHJ5KGksIGQpICogMC44LCBtaW5fZ2Fpbik7XG4gICAgICAgICAgICAgICAgZ2Fpbi5zZXRfZW50cnkoaSwgZCwgbmV3X2dhaW4pO1xuICAgICAgICAgICAgICAgIHZlbC5zZXRfZW50cnkoaSwgZCwgZ2FtbWEgKiB2ZWwuZW50cnkoaSwgZCkgLSBsciAqIGdhaW4uZW50cnkoaSwgZCkgKiBncmFkLmVudHJ5KGksIGQpKTtcbiAgICAgICAgICAgICAgICBZLnNldF9lbnRyeShpLCBkLCBZLmVudHJ5KGksIGQpICsgdmVsLmVudHJ5KGksIGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBIaWVyYXJjaGljYWxfQ2x1c3RlcmluZ1xuICovXG5leHBvcnQgY2xhc3MgSGllcmFyY2hpY2FsX0NsdXN0ZXJpbmcge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y2x1c3RlcmluZ1xuICAgICAqIEBhbGlhcyBIaWVyYXJjaGljYWxfQ2x1c3RlcmluZ1xuICAgICAqIEB0b2RvIG5lZWRzIHJlc3RydWN0dXJpbmcuXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IC0gRGF0YSBvciBkaXN0YW5jZSBtYXRyaXggaWYgbWV0cmljIGlzICdwcmVjb21wdXRlZCdcbiAgICAgKiBAcGFyYW0geyhcInNpbmdsZVwifFwiY29tcGxldGVcInxcImF2ZXJhZ2VcIil9IFtsaW5rYWdlID0gXCJjb21wbGV0ZVwiXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbbWV0cmljID0gZXVjbGlkZWFuXVxuICAgICAqIEByZXR1cm5zIHtIaWVyYXJjaGljYWxfQ2x1c3RlcmluZ31cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIGxpbmthZ2UgPSBcImNvbXBsZXRlXCIsIG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgICAgICB0aGlzLl9pZCA9IDA7XG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeCBpbnN0YW5jZW9mIE1hdHJpeCA/IG1hdHJpeCA6IE1hdHJpeC5mcm9tKG1hdHJpeCk7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcbiAgICAgICAgdGhpcy5fbGlua2FnZSA9IGxpbmthZ2U7XG4gICAgICAgIGlmIChtZXRyaWMgPT09IFwicHJlY29tcHV0ZWRcIiAmJiB0aGlzLl9tYXRyaXguc2hhcGVbMF0gIT09IHRoaXMuX21hdHJpeC5zaGFwZVsxXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWYgbWV0cmljIGlzICdwcmVjb21wdXRlZCcsIHRoZW4gbWF0cml4IGhhcyB0byBiZSBzcXVhcmUhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLmRvKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdmFsdWUgd2hlcmUgdG8gY3V0IHRoZSB0cmVlLlxuICAgICAqIEBwYXJhbSB7KFwiZGlzdGFuY2VcInxcImRlcHRoXCIpfSBbdHlwZSA9IFwiZGlzdGFuY2VcIl0gLSB0eXBlIG9mIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IC0gQXJyYXkgb2YgY2x1c3RlcnMgd2l0aCB0aGUgaW5kaWNlcyBvZiB0aGUgcm93cyBpbiBnaXZlbiB7QGxpbmsgbWF0cml4fS5cbiAgICAgKi9cbiAgICBnZXRfY2x1c3RlcnModmFsdWUsIHR5cGUgPSBcImRpc3RhbmNlXCIpIHtcbiAgICAgICAgbGV0IGNsdXN0ZXJzID0gW107XG4gICAgICAgIGxldCBhY2Nlc3NvcjtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGlzdGFuY2VcIjpcbiAgICAgICAgICAgICAgICBhY2Nlc3NvciA9IChkKSA9PiBkLmRpc3Q7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVwdGhcIjpcbiAgICAgICAgICAgICAgICBhY2Nlc3NvciA9IChkKSA9PiBkLmRlcHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhdmVyc2UodGhpcy5yb290LCBhY2Nlc3NvciwgdmFsdWUsIGNsdXN0ZXJzKTtcbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IG5vZGVcbiAgICAgKiBAcGFyYW0geyp9IGZcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSByZXN1bHRcbiAgICAgKi9cbiAgICBfdHJhdmVyc2Uobm9kZSwgZiwgdmFsdWUsIHJlc3VsdCkge1xuICAgICAgICBpZiAoZihub2RlKSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZS5sZWF2ZXMoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmF2ZXJzZShub2RlLmxlZnQsIGYsIHZhbHVlLCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5fdHJhdmVyc2Uobm9kZS5yaWdodCwgZiwgdmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlcyB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9tYXRyaXg7XG4gICAgICAgIGNvbnN0IG4gPSAodGhpcy5fbiA9IEEuc2hhcGVbMF0pO1xuICAgICAgICBjb25zdCBkX21pbiA9ICh0aGlzLl9kX21pbiA9IG5ldyBGbG9hdDY0QXJyYXkobikpO1xuICAgICAgICBsZXQgZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICBpZiAobWV0cmljICE9PSBcInByZWNvbXB1dGVkXCIpIHtcbiAgICAgICAgICAgIGRpc3RhbmNlX21hdHJpeCA9IG5ldyBNYXRyaXgobiwgbiwgMCk7IC8vbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkX21pbltpXSA9IDA7XG4gICAgICAgICAgICAgICAgLy9kaXN0YW5jZV9tYXRyaXhbaV0gPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlX21hdHJpeC5zZXRfZW50cnkoaSwgaiwgaSA9PT0gaiA/IEluZmluaXR5IDogbWV0cmljKEEucm93KGkpLCBBLnJvdyhqKSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VfbWF0cml4LmVudHJ5KGksIGRfbWluW2ldKSA+IGRpc3RhbmNlX21hdHJpeC5lbnRyeShpLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZF9taW5baV0gPSBqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzdGFuY2VfbWF0cml4ID0gdGhpcy5fbWF0cml4LmNsb25lKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZV9tYXRyaXguc2V0X2VudHJ5KGksIGosIEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZV9tYXRyaXguZW50cnkoaSwgZF9taW5baV0pID4gZGlzdGFuY2VfbWF0cml4LmVudHJ5KGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkX21pbltpXSA9IGo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzdGFuY2VfbWF0cml4ID0gZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9ICh0aGlzLl9jbHVzdGVycyA9IG5ldyBBcnJheShuKSk7XG4gICAgICAgIGNvbnN0IGNfc2l6ZSA9ICh0aGlzLl9jX3NpemUgPSBuZXcgVWludDE2QXJyYXkobikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgY2x1c3RlcnNbaV0gPSBbXTtcbiAgICAgICAgICAgIGNsdXN0ZXJzW2ldWzBdID0gbmV3IENsdXN0ZXIodGhpcy5faWQrKywgbnVsbCwgbnVsbCwgMCwgQS5yb3coaSksIGksIDEsIDApO1xuICAgICAgICAgICAgY19zaXplW2ldID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlcyB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBkbygpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX247XG4gICAgICAgIGNvbnN0IGRfbWluID0gdGhpcy5fZF9taW47XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9kaXN0YW5jZV9tYXRyaXg7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gdGhpcy5fY2x1c3RlcnM7XG4gICAgICAgIGNvbnN0IGNfc2l6ZSA9IHRoaXMuX2Nfc2l6ZTtcbiAgICAgICAgY29uc3QgbGlua2FnZSA9IHRoaXMuX2xpbmthZ2U7XG4gICAgICAgIGxldCByb290ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgcCA9IDAsIHBfbWF4ID0gbiAtIDE7IHAgPCBwX21heDsgKytwKSB7XG4gICAgICAgICAgICBsZXQgYzEgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgRF9pX21pbiA9IEQuZW50cnkoaSwgZF9taW5baV0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRF9pX21pbiA+IEQuZW50cnkoaSwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRfbWluW2ldID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIERfaV9taW4gPSBELmVudHJ5KGksIGRfbWluW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEQuZW50cnkoaSwgZF9taW5baV0pIDwgRC5lbnRyeShjMSwgZF9taW5bYzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBjMSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGMyID0gZF9taW5bYzFdO1xuICAgICAgICAgICAgbGV0IGMxX2NsdXN0ZXIgPSBjbHVzdGVyc1tjMV1bMF07XG4gICAgICAgICAgICBsZXQgYzJfY2x1c3RlciA9IGNsdXN0ZXJzW2MyXVswXTtcbiAgICAgICAgICAgIGxldCBjMV9jbHVzdGVyX2luZGljZXMgPSBjMV9jbHVzdGVyLmlzTGVhZiA/IFtjMV9jbHVzdGVyLmluZGV4XSA6IGMxX2NsdXN0ZXIuaW5kZXg7XG4gICAgICAgICAgICBsZXQgYzJfY2x1c3Rlcl9pbmRpY2VzID0gYzJfY2x1c3Rlci5pc0xlYWYgPyBbYzJfY2x1c3Rlci5pbmRleF0gOiBjMl9jbHVzdGVyLmluZGV4O1xuICAgICAgICAgICAgbGV0IGluZGljZXMgPSBjMV9jbHVzdGVyX2luZGljZXMuY29uY2F0KGMyX2NsdXN0ZXJfaW5kaWNlcyk7XG4gICAgICAgICAgICBsZXQgbmV3X2NsdXN0ZXIgPSBuZXcgQ2x1c3Rlcih0aGlzLl9pZCsrLCBjMV9jbHVzdGVyLCBjMl9jbHVzdGVyLCBELmVudHJ5KGMxLCBjMiksIG51bGwsIGluZGljZXMpO1xuICAgICAgICAgICAgYzFfY2x1c3Rlci5wYXJlbnQgPSBuZXdfY2x1c3RlcjtcbiAgICAgICAgICAgIGMyX2NsdXN0ZXIucGFyZW50ID0gbmV3X2NsdXN0ZXI7XG4gICAgICAgICAgICBjbHVzdGVyc1tjMV0udW5zaGlmdChuZXdfY2x1c3Rlcik7XG4gICAgICAgICAgICBjX3NpemVbYzFdICs9IGNfc2l6ZVtjMl07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IERfYzFfaiA9IEQuZW50cnkoYzEsIGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IERfYzJfaiA9IEQuZW50cnkoYzIsIGopO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGxpbmthZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNpbmdsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihEX2MxX2osIERfYzJfaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KERfYzFfaiwgRF9jMl9qKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXZlcmFnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoY19zaXplW2MxXSAqIERfYzFfaiArIGNfc2l6ZVtjMl0gKiBEX2MyX2opIC8gKGNfc2l6ZVtjMV0gKyBjX3NpemVbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEQuc2V0X2VudHJ5KGosIGMxLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgRC5zZXRfZW50cnkoYzEsIGosIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgRC5zZXRfZW50cnkoYzEsIGMxLCBJbmZpbml0eSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIEQuc2V0X2VudHJ5KGksIGMyLCBJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgRC5zZXRfZW50cnkoYzIsIGksIEluZmluaXR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogZm9yIChsZXQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAoZF9taW5bal0gPT09IGMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRfbWluW2pdID0gYzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChELmVudHJ5KGMxLCBqKSA8IEQuZW50cnkoYzEsIGRfbWluW2MxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZF9taW5bYzFdID0gajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICovXG4gICAgICAgICAgICByb290ID0gbmV3X2NsdXN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxufVxuXG5jbGFzcyBDbHVzdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgbGVmdCwgcmlnaHQsIGRpc3QsIGNlbnRyb2lkLCBpbmRleCwgc2l6ZSwgZGVwdGgpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuZGlzdCA9IGRpc3Q7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZSA/PyBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGggPz8gMSArIE1hdGgubWF4KGxlZnQuZGVwdGgsIHJpZ2h0LmRlcHRoKTtcbiAgICAgICAgdGhpcy5jZW50cm9pZCA9IGNlbnRyb2lkID8/IHRoaXMuX2NhbGN1bGF0ZV9jZW50cm9pZChsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZV9jZW50cm9pZChsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBsX3NpemUgPSBsZWZ0LnNpemU7XG4gICAgICAgIGNvbnN0IHJfc2l6ZSA9IHJpZ2h0LnNpemU7XG4gICAgICAgIGNvbnN0IGxfY2VudHJvaWQgPSBsZWZ0LmNlbnRyb2lkO1xuICAgICAgICBjb25zdCByX2NlbnRyb2lkID0gcmlnaHQuY2VudHJvaWQ7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGNvbnN0IG4gPSBsZWZ0LmNlbnRyb2lkLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3X2NlbnRyb2lkID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIG5ld19jZW50cm9pZFtpXSA9IChsX3NpemUgKiBsX2NlbnRyb2lkW2ldICsgcl9zaXplICogcl9jZW50cm9pZFtpXSkgLyBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdfY2VudHJvaWQ7XG4gICAgfVxuXG4gICAgZ2V0IGlzTGVhZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGggPT09IDA7XG4gICAgfVxuXG4gICAgbGVhdmVzKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xlYWYpIHJldHVybiBbdGhpc107XG4gICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodDtcbiAgICAgICAgcmV0dXJuIChsZWZ0LmlzTGVhZiA/IFtsZWZ0XSA6IGxlZnQubGVhdmVzKCkpLmNvbmNhdChyaWdodC5pc0xlYWYgPyBbcmlnaHRdIDogcmlnaHQubGVhdmVzKCkpO1xuICAgIH1cblxuICAgIGRlc2NlbmRhbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xlYWYpIHJldHVybiBbdGhpc107XG4gICAgICAgIGNvbnN0IGxlZnRfZGVzY2VuZGFudHMgPSB0aGlzLmxlZnQuZGVzY2VuZGFudHMoKTtcbiAgICAgICAgY29uc3QgcmlnaHRfZGVzY2VuZGFudHMgPSB0aGlzLnJpZ2h0LmRlc2NlbmRhbnRzKCk7XG4gICAgICAgIHJldHVybiBsZWZ0X2Rlc2NlbmRhbnRzLmNvbmNhdChyaWdodF9kZXNjZW5kYW50cykuY29uY2F0KFt0aGlzXSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFJhbmRvbWl6ZXIgfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSGVhcCB9IGZyb20gXCIuLi9kYXRhc3RydWN0dXJlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBsaW5zcGFjZSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBLTWVhbnNcbiAqL1xuZXhwb3J0IGNsYXNzIEtNZWFucyB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjbHVzdGVyaW5nXG4gICAgICogQGFsaWFzIEtNZWFuc1xuICAgICAqIEB0b2RvIG5lZWRzIHJlc3RydWN0dXJpbmcuIFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXggXG4gICAgICogQHBhcmFtIHtOdW1iZXJzfSBLIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VlZCA9IDE5ODddXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5pdCA9IHRydWVdXG4gICAgICogQHJldHVybnMge0tNZWFuc31cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIEssIG1ldHJpYyA9IGV1Y2xpZGVhbiwgc2VlZD0xOTg3LCBpbml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9tZXRyaWMgPSBtZXRyaWM7XG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeDtcbiAgICAgICAgdGhpcy5fSyA9IEs7XG4gICAgICAgIGNvbnN0IFtOLCBEXSA9IG1hdHJpeC5zaGFwZTtcbiAgICAgICAgdGhpcy5fTiA9IE47XG4gICAgICAgIHRoaXMuX0QgPSBEO1xuICAgICAgICBpZiAoSyA+IE4pIEsgPSBOO1xuICAgICAgICB0aGlzLl9yYW5kb21pemVyID0gbmV3IFJhbmRvbWl6ZXIoc2VlZCk7XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJzID0gbmV3IEFycmF5KE4pLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fY2x1c3Rlcl9jZW50cm9pZHMgPSB0aGlzLl9nZXRfcmFuZG9tX2NlbnRyb2lkcyhLKTtcbiAgICAgICAgaWYgKGluaXQpIHRoaXMuaW5pdChLLCB0aGlzLl9jbHVzdGVyX2NlbnRyb2lkcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IC0gQXJyYXkgb2YgY2x1c3RlcnMgd2l0aCB0aGUgaW5kaWNlcyBvZiB0aGUgcm93cyBpbiBnaXZlbiB7QGxpbmsgbWF0cml4fS4gXG4gICAgICovXG4gICAgZ2V0X2NsdXN0ZXJzKCkge1xuICAgICAgICBjb25zdCBLID0gdGhpcy5fSztcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSB0aGlzLl9jbHVzdGVycztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KEspLmZpbGwoKS5tYXAoKCkgPT4gbmV3IEFycmF5KCkpO1xuICAgICAgICBjbHVzdGVycy5mb3JFYWNoKChjLCBpKSA9PiByZXN1bHRbY10ucHVzaChpKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2FuZGlkYXRlcyBcbiAgICAgKi9cbiAgICBfZnVydGhlc3RfcG9pbnQocG9pbnRzLCBjYW5kaWRhdGVzKSB7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9tYXRyaXg7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgbGV0IGkgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBsZXQgSCA9IEhlYXAuaGVhcGlmeShcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMsIFxuICAgICAgICAgICAgKGQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBBZCA9IEEucm93KGQpXG4gICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IG1ldHJpYyhBZCwgcG9pbnRzW2pdKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICBcIm1heFwiXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIEgucG9wKCkuZWxlbWVudDtcbiAgICB9XG5cbiAgICBfZ2V0X3JhbmRvbV9jZW50cm9pZHMoSykge1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgcmFuZG9taXplciA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9tYXRyaXg7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJfY2VudHJvaWRzID0gbmV3IEFycmF5KEspLmZpbGwoKVxuICAgICAgICBjb25zdCBpbmRpY2VzID0gbGluc3BhY2UoMCwgTiAtIDEpO1xuICAgICAgICBjb25zdCByYW5kb21fcG9pbnQgPSByYW5kb21pemVyLnJhbmRvbV9pbnQgJSAoTiAtIDEpO1xuICAgICAgICBjbHVzdGVyX2NlbnRyb2lkc1swXSA9IEEucm93KHJhbmRvbV9wb2ludCk7XG4gICAgICAgIGNvbnN0IGluaXRfcG9pbnRzID0gW3JhbmRvbV9wb2ludF07XG4gICAgICAgIGNvbnN0IHNhbXBsZV9zaXplID0gTWF0aC5mbG9vcigoTiAtIEspIC8gSyk7Ly8gLyBLXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgSzsgKytpKSB7XG4gICAgICAgICAgICAvLyBzYW1wbGluZyArIGttZWFucysrIGltcHJvdmVtZW50P1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlID0gcmFuZG9taXplci5jaG9pY2UoaW5kaWNlcy5maWx0ZXIoZCA9PiBpbml0X3BvaW50cy5pbmRleE9mKGQpID09IC0xKSwgc2FtcGxlX3NpemUpO1xuICAgICAgICAgICAgY29uc3QgZnVydGhlc3RfcG9pbnQgPSB0aGlzLl9mdXJ0aGVzdF9wb2ludChjbHVzdGVyX2NlbnRyb2lkcy5zbGljZSgwLCBpKSwgc2FtcGxlKTtcbiAgICAgICAgICAgIGluaXRfcG9pbnRzLnB1c2goZnVydGhlc3RfcG9pbnQpO1xuICAgICAgICAgICAgY2x1c3Rlcl9jZW50cm9pZHNbaV0gPSBBLnJvdyhmdXJ0aGVzdF9wb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJfY2VudHJvaWRzO1xuICAgIH1cblxuICAgIF9pdGVyYXRpb24oY2x1c3Rlcl9jZW50cm9pZHMpIHtcbiAgICAgICAgY29uc3QgSyA9IGNsdXN0ZXJfY2VudHJvaWRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9EO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fbWF0cml4O1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gdGhpcy5fY2x1c3RlcnM7XG4gICAgICAgIGxldCBjbHVzdGVyc19jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIC8vIGZpbmQgbmVhcmVzdCBjbHVzdGVyIGNlbnRyb2lkLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgQWkgPSBBLnJvdyhpKVxuICAgICAgICAgICAgbGV0IG1pbl9kaXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBsZXQgbWluX2NsdXN0ZXIgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBLOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgZCA9IG1ldHJpYyhjbHVzdGVyX2NlbnRyb2lkc1tqXSwgQWkpO1xuICAgICAgICAgICAgICAgIGlmIChkIDwgbWluX2Rpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluX2Rpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICBtaW5fY2x1c3RlciA9IGo7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbHVzdGVyc1tpXSAhPT0gbWluX2NsdXN0ZXIpIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyc19jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsdXN0ZXJzW2ldID0gbWluX2NsdXN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGNsdXN0ZXIgY2VudHJvaWRcbiAgICAgICAgLy8gcmVzZXQgY2x1c3RlciBjZW50cm9pZHMgdG8gMFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEs7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY2VudHJvaWQgPSBjbHVzdGVyX2NlbnRyb2lkc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgRDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2VudHJvaWRbal0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXB1dGUgY2VudHJvaWRcbiAgICAgICAgdGhpcy5fY29tcHV0ZV9jZW50cm9pZChjbHVzdGVyX2NlbnRyb2lkcyk7XG5cbiAgICAgICAgcmV0dXJuIHsgICBcbiAgICAgICAgICAgIFwiY2x1c3RlcnNfY2hhbmdlZFwiOiBjbHVzdGVyc19jaGFuZ2VkLFxuICAgICAgICAgICAgXCJjbHVzdGVyX2NlbnRyb2lkc1wiOiBjbHVzdGVyX2NlbnRyb2lkc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9jb21wdXRlX2NlbnRyb2lkKGNsdXN0ZXJfY2VudHJvaWRzKSB7XG4gICAgICAgIGNvbnN0IEsgPSBjbHVzdGVyX2NlbnRyb2lkcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBEID0gdGhpcy5fRDtcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX21hdHJpeDtcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSB0aGlzLl9jbHVzdGVycztcbiAgICAgICAgY29uc3QgY2x1c3Rlcl9jb3VudGVyID0gbmV3IEFycmF5KEspLmZpbGwoMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IEFpID0gQS5yb3coaSk7XG4gICAgICAgICAgICBjb25zdCBjaSA9IGNsdXN0ZXJzW2ldO1xuICAgICAgICAgICAgY2x1c3Rlcl9jb3VudGVyW2NpXSsrO1xuICAgICAgICAgICAgY29uc3QgY2VudHJvaWQgPSBjbHVzdGVyX2NlbnRyb2lkc1tjaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IEQ7ICsraikge1xuICAgICAgICAgICAgICAgIGNlbnRyb2lkW2pdICs9IEFpW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSzsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gY2x1c3Rlcl9jb3VudGVyW2ldO1xuICAgICAgICAgICAgY2x1c3Rlcl9jZW50cm9pZHNbaV0gPSBjbHVzdGVyX2NlbnRyb2lkc1tpXS5tYXAoYyA9PiBjIC8gbik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMge0BsaW5rIEt9IGNsdXN0ZXJzIG91dCBvZiB0aGUge0BsaW5rIG1hdHJpeH0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IEsgLSBudW1iZXIgb2YgY2x1c3RlcnMuXG4gICAgICovXG4gICAgaW5pdChLLCBjbHVzdGVyX2NlbnRyb2lkcykge1xuICAgICAgICBpZiAoIUspIEsgPSB0aGlzLl9LO1xuICAgICAgICBpZiAoIWNsdXN0ZXJfY2VudHJvaWRzKSBjbHVzdGVyX2NlbnRyb2lkcyA9IHRoaXMuX2dldF9yYW5kb21fY2VudHJvaWRzKEspO1xuICAgICAgICBsZXQgY2x1c3RlcnNfY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBpdGVyYXRpb25fcmVzdWx0ID0gdGhpcy5faXRlcmF0aW9uKGNsdXN0ZXJfY2VudHJvaWRzKVxuICAgICAgICAgICAgY2x1c3Rlcl9jZW50cm9pZHMgPSBpdGVyYXRpb25fcmVzdWx0LmNsdXN0ZXJfY2VudHJvaWRzO1xuICAgICAgICAgICAgY2x1c3RlcnNfY2hhbmdlZCA9IGl0ZXJhdGlvbl9yZXN1bHQuY2x1c3RlcnNfY2hhbmdlZDtcbiAgICAgICAgfSB3aGlsZSAoY2x1c3RlcnNfY2hhbmdlZClcbiAgICB9XG4gICAgXG59XG4iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUmFuZG9taXplciB9IGZyb20gXCIuLi91dGlsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBsaW5zcGFjZSwgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbWluIH0gZnJvbSBcIi4uL3V0aWwvaW5kZXguanNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgS01lZG9pZHNcbiAqL1xuZXhwb3J0IGNsYXNzIEtNZWRvaWRzIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNsdXN0ZXJpbmdcbiAgICAgKiBAYWxpYXMgS01lZG9pZHNcbiAgICAgKiBAdG9kbyBuZWVkcyByZXN0cnVjdHVyaW5nLiBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4IC0gZGF0YSBtYXRyaXhcbiAgICAgKiBAcGFyYW0ge051bWJlcnN9IEsgLSBudW1iZXIgb2YgY2x1c3RlcnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heF9pdGVyPW51bGxdIC0gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucy4gRGVmYXVsdCBpcyAxMCAqIE1hdGgubG9nMTAoTilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIG1ldHJpYyBkZWZpbmluZyB0aGUgZGlzc2ltaWxhcml0eSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHNlZWQgdmFsdWUgZm9yIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gICAgICogQHJldHVybnMge0tNZWRvaWRzfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbGluay5zcHJpbmdlci5jb20vY2hhcHRlci8xMC4xMDA3Lzk3OC0zLTAzMC0zMjA0Ny04XzE2fSBGYXN0ZXIgay1NZWRvaWRzIENsdXN0ZXJpbmc6IEltcHJvdmluZyB0aGUgUEFNLCBDTEFSQSwgYW5kIENMQVJBTlMgQWxnb3JpdGhtc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1hdHJpeCwgSywgbWF4X2l0ZXI9bnVsbCwgbWV0cmljID0gZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgdGhpcy5fbWV0cmljID0gbWV0cmljO1xuICAgICAgICB0aGlzLl9tYXRyaXggPSBtYXRyaXg7XG4gICAgICAgIHRoaXMuX0EgPSB0aGlzLl9tYXRyaXgudG8yZEFycmF5O1xuICAgICAgICB0aGlzLl9LID0gSztcbiAgICAgICAgY29uc3QgW04sIERdID0gbWF0cml4LnNoYXBlO1xuICAgICAgICB0aGlzLl9OID0gTjtcbiAgICAgICAgdGhpcy5fRCA9IEQ7XG4gICAgICAgIHRoaXMuX21heF9pdGVyID0gbWF4X2l0ZXIgfHwgMTAgKiBNYXRoLmxvZzEwKE4pIFxuICAgICAgICB0aGlzLl9kaXN0YW5jZV9tYXRyaXggPSBuZXcgTWF0cml4KE4sIE4sIFwiemVyb3NcIik7XG4gICAgICAgIC8qIGZvciAobGV0IGkgPSAxOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IG1ldHJpYyh0aGlzLl9BW2ldLCB0aGlzLl9BW2pdKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZV9tYXRyaXguc2V0X2VudHJ5KGksIGosIGRpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlX21hdHJpeC5zZXRfZW50cnkoaiwgaSwgZGlzdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAqL1xuICAgICAgICBpZiAoSyA+IE4pIEsgPSBOO1xuICAgICAgICB0aGlzLl9yYW5kb21pemVyID0gbmV3IFJhbmRvbWl6ZXIoc2VlZCk7XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJzID0gbmV3IEFycmF5KE4pLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fY2x1c3Rlcl9tZWRvaWRzID0gdGhpcy5fZ2V0X3JhbmRvbV9tZWRvaWRzKEspO1xuICAgICAgICAvL2lmIChpbml0KSB0aGlzLmluaXQoSywgdGhpcy5fY2x1c3Rlcl9tZWRvaWRzKTtcbiAgICAgICAgdGhpcy5faXNfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gLSBBcnJheSBvZiBjbHVzdGVycyB3aXRoIHRoZSBpbmRpY2VzIG9mIHRoZSByb3dzIGluIGdpdmVuIHtAbGluayBtYXRyaXh9LiBcbiAgICAgKi9cbiAgICBnZXRfY2x1c3RlcnMoKSB7XG4gICAgICAgIGNvbnN0IEsgPSB0aGlzLl9LO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc19pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0KEssIHRoaXMuX2NsdXN0ZXJfbWVkb2lkcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KEspLmZpbGwoKS5tYXAoKCkgPT4gbmV3IEFycmF5KCkpO1xuICAgICAgICBBLmZvckVhY2goKHhfaiwgaikgPT4ge1xuICAgICAgICAgICAgcmVzdWx0W3RoaXMuX25lYXJlc3RfbWVkb2lkKHhfaiwgaikuaW5kZXhfbmVhcmVzdF0ucHVzaChqKTtcbiAgICAgICAgfSlcbiAgICAgICAgcmVzdWx0Lm1lZG9pZHMgPSB0aGlzLl9jbHVzdGVyX21lZG9pZHM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMqIGdlbmVyYXRvcigpIHtcbiAgICAgICAgY29uc3QgbWF4X2l0ZXIgPSB0aGlzLl9tYXhfaXRlcjtcbiAgICAgICAgeWllbGQgdGhpcy5nZXRfY2x1c3RlcnMoKVxuICAgICAgICBsZXQgZmluaXNoID0gZmFsc2U7XG4gICAgICAgIGxldCBpID0gMFxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBmaW5pc2ggPSB0aGlzLl9pdGVyYXRpb24oKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0X2NsdXN0ZXJzKCk7XG4gICAgICAgIH0gd2hpbGUgKCFmaW5pc2ggJiYgKytpIDwgbWF4X2l0ZXIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxnb3JpdGhtIDEuIEZhc3RQQU0xOiBJbXByb3ZlZCBTV0FQIGFsZ29yaXRobVxuICAgICAqL1xuICAgIC8qIF9pdGVyYXRpb25fMSgpIHtcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX0E7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBLID0gdGhpcy5fSztcbiAgICAgICAgY29uc3QgbWVkb2lkcyA9IHRoaXMuX2NsdXN0ZXJfbWVkb2lkcztcbiAgICAgICAgbGV0IERlbHRhVEQgPSAwO1xuICAgICAgICBsZXQgbTAgPSBudWxsO1xuICAgICAgICBsZXQgeDAgPSBudWxsO1xuICAgICAgICBBLmZvckVhY2goKHhfaiwgaikgPT4ge1xuICAgICAgICAgICAgaWYgKG1lZG9pZHMuZmluZEluZGV4KG0gPT4gbSA9PT0gaikgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmVhcmVzdF9tZWRvaWQgPSB0aGlzLl9uZWFyZXN0X21lZG9pZCh4X2osIGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRfaiA9IG5lYXJlc3RfbWVkb2lkLmRpc3RhbmNlX25lYXJlc3Q7IC8vIGRpc3RhbmNlIHRvIGN1cnJlbnQgbWVkb2lkXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFURCA9IG5ldyBBcnJheShLKS5maWxsKC1kX2opOyAvLyBjaGFuZ2UgaWYgbWFraW5nIGogYSBtZWRvaWRcbiAgICAgICAgICAgICAgICBBLmZvckVhY2goKHhfbywgbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBkaXNhbmNlIHRvIG5ldyBtZWRvaWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZF9vaiA9IHRoaXMuX2dldF9kaXN0YW5jZShvLCBqLCB4X28sIHhfaik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5kZXhfbmVhcmVzdFwiOiBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXN0YW5jZV9uZWFyZXN0XCI6IGRfbixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzdGFuY2Vfc2Vjb25kXCI6IGRfcyxcbiAgICAgICAgICAgICAgICAgICAgfSA9IHRoaXMuX25lYXJlc3RfbWVkb2lkKHhfbywgbyk7IFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbHVzdGVyc1tvXSA9IG47IC8vIGNhY2hlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFURFtuXSArPSBNYXRoLm1pbihkX29qLCBkX3MpIC0gZF9uOyAvLyBsb3NzIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZF9vaiA8IGRfbikgeyAvLyByZWFzc2lnbm1lbnQgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVEQuZm9yRWFjaCgoZF9pLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFURFtpXSA9IGRfaSArIGRfb2ogLSBkX247IC8vIHVwZGF0ZSBsb3NzIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gY2hvb3NlIGJlc3QgbWVkb2lkIGk7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IGRlbHRhVERcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoZCwgaSkgPT4gW2QsIGldKVxuICAgICAgICAgICAgICAgICAgICAuc29ydCgoZDEsIGQyKSA9PiBkMVswXSAtIGQyWzBdKVswXVsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVREX2kgPSBkZWx0YVREW2ldO1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlXG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhVERfaSA8IERlbHRhVEQpIHtcbiAgICAgICAgICAgICAgICAgICAgRGVsdGFURCA9IGRlbHRhVERfaTtcbiAgICAgICAgICAgICAgICAgICAgbTAgPSBpO1xuICAgICAgICAgICAgICAgICAgICB4MCA9IGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoRGVsdGFURCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZSAvLyBicmVhayBsb29wIGlmIERlbHRhVEQgPj0gMFxuICAgICAgICB9XG4gICAgICAgIC8vIHN3YXAgcm9sZXMgb2YgbWVkb2lkIG0gYW5kIG5vbi1tZWRvaWQgeDtcbiAgICAgICAgbWVkb2lkc1ttMF0gPSB4MDtcbiAgICAgICAgdGhpcy5fY2x1c3Rlcl9tZWRvaWRzID0gbWVkb2lkcztcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSAqL1xuXG4gICAgLyoqIEFsZ29yaXRobSAyLiBGYXN0UEFNMjogU1dBUCB3aXRoIG11bHRpcGxlIGNhbmRpZGF0ZXNcbiAgICAgKiBcbiAgICAgKi9cbiAgICBfaXRlcmF0aW9uKCkge1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgSyA9IHRoaXMuX0s7XG4gICAgICAgIGNvbnN0IG1lZG9pZHMgPSB0aGlzLl9jbHVzdGVyX21lZG9pZHM7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gQS5tYXAoKHhfbywgbykgPT4gdGhpcy5fbmVhcmVzdF9tZWRvaWQoeF9vLCBvKSk7XG4gICAgICAgIC8vIGVtcHR5IGJlc3QgY2FuZGlkYXRlcyBhcnJheVxuICAgICAgICBjb25zdCBEZWx0YVREID0gbmV3IEFycmF5KEspLmZpbGwoMCk7XG4gICAgICAgIGNvbnN0IHhzID0gbmV3IEFycmF5KEspLmZpbGwobnVsbCk7XG4gICAgICAgIEEuZm9yRWFjaCgoeF9qLCBqKSA9PiB7XG4gICAgICAgICAgICBpZiAobWVkb2lkcy5maW5kSW5kZXgobSA9PiBtID09PSBqKSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkX2ogPSBjYWNoZVtqXS5kaXN0YW5jZV9uZWFyZXN0OyAvLyBkaXN0YW5jZSB0byBjdXJyZW50IG1lZG9pZFxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhVEQgPSBuZXcgQXJyYXkoSykuZmlsbCgtZF9qKTsgLy8gY2hhbmdlIGlmIG1ha2luZyBqIGEgbWVkb2lkXG4gICAgICAgICAgICAgICAgQS5mb3JFYWNoKCh4X28sIG8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IG8pIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZF9vaiA9IHRoaXMuX2dldF9kaXN0YW5jZShvLCBqLCB4X28sIHhfaik7IC8vIGRpc3RhbmNlIHRvIG5ldyBtZWRvaWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qge1wiaW5kZXhfbmVhcmVzdFwiOiBuLCBcImRpc3RhbmNlX25lYXJlc3RcIjogZF9uLCBcImRpc3RhbmNlX3NlY29uZFwiOiBkX3N9ID0gY2FjaGVbb107IC8vIGNhY2hlZFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVREW25dICs9IE1hdGgubWluKGRfb2osIGRfcykgLSBkX247IC8vIGxvc3MgY2hhbmdlIGZvciB4X29cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhc3NpZ25tZW50IGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChkX29qIDwgZF9uKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGxvc3MgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEs7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBuKSBkZWx0YVREW2ldICs9IGRfb2ogLSBkX247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyByZW1lbWJlciBiZXN0IHN3YXAgZm9yIGk7XG4gICAgICAgICAgICAgICAgZGVsdGFURFxuICAgICAgICAgICAgICAgICAgICAubWFwKChkLCBpKSA9PiBbZCwgaV0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtkLCBpXSkgPT4gZCA8IERlbHRhVERbaV0pXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKChbZCwgaV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgRGVsdGFURFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlbHRhVERbaV0gPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhzW2ldID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLy8gc3RvcCBpZiBubyBpbXByb3ZlbWVudHMgd2VyZSBmb3VuZFxuICAgICAgICBpZiAobWluKERlbHRhVEQpID49IDApIHJldHVybiB0cnVlOyBcblxuICAgICAgICAvLyBleGVjdXRlIGFsbCBpbXByb3ZlbWVudHNcbiAgICAgICAgd2hpbGUgKG1pbihEZWx0YVREKSA8IDApIHtcbiAgICAgICAgICAgIC8vIHN3YXAgcm9sZXMgb2YgbWVkb2lkIG1faSBhbmQgbm9uX21lZG9pZCB4c19pXG4gICAgICAgICAgICBjb25zdCBpID0gRGVsdGFURFxuICAgICAgICAgICAgICAgIC5tYXAoKGQsIGkpID0+IFtkLCBpXSlcbiAgICAgICAgICAgICAgICAuc29ydCgoW2FdLCBbYl0pID0+IGEgLSBiKVswXVsxXTtcbiAgICAgICAgICAgIGlmIChtZWRvaWRzLmZpbHRlcihtID0+IG0gPT0geHNbaV0pLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbWVkb2lkc1tpXSA9IHhzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGlzYWJsZSB0aGUgc3dhcCBqdXN0IHBlcmZvcm1lZFxuICAgICAgICAgICAgRGVsdGFURFtpXSA9IDA7IFxuICAgICAgICAgICAgLy8gcmVjb21wdXRlIFREIGZvciByZW1haW5pbmcgc3dhcCBjYW5kaWRhdGVzXG4gICAgICAgICAgICBEZWx0YVREXG4gICAgICAgICAgICAgICAgLm1hcCgoZF9qLCBqKSA9PiBbZF9qLCBqXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbZF9qXSkgPT4gZF9qIDwgMClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoW18sIGpdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhfaiA9IEFbal07XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBBLmZvckVhY2goKHhfbywgbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lZG9pZHMuZmluZEluZGV4KG0gPT4gbSAhPSBqICYmIG0gPT0gbykgPj0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gaikgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlW29dLmluZGV4X25lYXJlc3QgPT09IG1lZG9pZHNbal0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IChNYXRoLm1pbih0aGlzLl9nZXRfZGlzdGFuY2UobywgaiwgeF9vLCB4X2opLCBjYWNoZVtvXS5kaXN0YW5jZV9zZWNvbmQpIC0gY2FjaGVbb10uZGlzdGFuY2VfbmVhcmVzdCk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IChNYXRoLm1pbih0aGlzLl9nZXRfZGlzdGFuY2UobywgaiwgeF9vLCB4X2opIC0gY2FjaGVbb10uZGlzdGFuY2VfbmVhcmVzdCwgMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgRGVsdGFURFtqXSA9IHN1bTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJfbWVkb2lkcyA9IG1lZG9pZHM7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBfZ2V0X2Rpc3RhbmNlKGksIGosIHhfaT1udWxsLCB4X2o9bnVsbCkge1xuICAgICAgICBpZiAoaSA9PT0gaikgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9kaXN0YW5jZV9tYXRyaXg7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9BO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGxldCBkX2lqID0gRC5lbnRyeShpLCBqKTtcbiAgICAgICAgaWYgKGRfaWogPT09IDApIHtcbiAgICAgICAgICAgIGRfaWogPSBtZXRyaWMoeF9pIHx8IEFbaV0sIHhfaiB8fCBBW2pdKTtcbiAgICAgICAgICAgIEQuc2V0X2VudHJ5KGksIGosIGRfaWopO1xuICAgICAgICAgICAgRC5zZXRfZW50cnkoaiwgaSwgZF9paik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRfaWo7XG4gICAgfVxuXG4gICAgX25lYXJlc3RfbWVkb2lkKHhfaiwgaikge1xuICAgICAgICBjb25zdCBtZWRvaWRzID0gdGhpcy5fY2x1c3Rlcl9tZWRvaWRzO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgW25lYXJlc3QsIHNlY29uZF0gPSBtZWRvaWRzXG4gICAgICAgICAgICAubWFwKChtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeF9tID0gQVttXTsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLl9nZXRfZGlzdGFuY2UoaiwgbSwgeF9qLCB4X20pLCBpXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc29ydCgobTEsIG0yKSA9PiBtMVswXSAtIG0yWzBdKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgXCJkaXN0YW5jZV9uZWFyZXN0XCI6IG5lYXJlc3RbMF0sIFxuICAgICAgICAgICAgXCJpbmRleF9uZWFyZXN0XCI6IG5lYXJlc3RbMV0sXG4gICAgICAgICAgICBcImRpc3RhbmNlX3NlY29uZFwiOiBzZWNvbmRbMF0sXG4gICAgICAgICAgICBcImluZGV4X3NlY29uZFwiOiBzZWNvbmRbMV0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMge0BsaW5rIEt9IGNsdXN0ZXJzIG91dCBvZiB0aGUge0BsaW5rIG1hdHJpeH0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IEsgLSBudW1iZXIgb2YgY2x1c3RlcnMuXG4gICAgICovXG4gICAgaW5pdChLLCBjbHVzdGVyX21lZG9pZHMpIHtcbiAgICAgICAgaWYgKCFLKSBLID0gdGhpcy5fSztcbiAgICAgICAgaWYgKCFjbHVzdGVyX21lZG9pZHMpIGNsdXN0ZXJfbWVkb2lkcyA9IHRoaXMuX2dldF9yYW5kb21fbWVkb2lkcyhLKTtcbiAgICAgICAgY29uc3QgbWF4X2l0ZXIgPSB0aGlzLl9tYXhfaXRlcjtcbiAgICAgICAgbGV0IGZpbmlzaCA9IGZhbHNlO1xuICAgICAgICBsZXQgaSA9IDBcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZmluaXNoID0gdGhpcy5faXRlcmF0aW9uKCk7XG4gICAgICAgIH0gd2hpbGUgKCFmaW5pc2ggJiYgKytpIDwgbWF4X2l0ZXIpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsZ29yaXRobSAzLiBGYXN0UEFNIExBQjogTGluZWFyIEFwcHJveGltYXRlIEJVSUxEIGluaXRpYWxpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBLIC0gbnVtYmVyIG9mIGNsdXN0ZXJzXG4gICAgICogXG4gICAgICovXG4gICAgX2dldF9yYW5kb21fbWVkb2lkcyhLKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IGxpbnNwYWNlKDAsIE4gLSAxKTtcbiAgICAgICAgY29uc3QgcmFuZG9taXplciA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihOLCAxMCArIE1hdGguY2VpbChNYXRoLnNxcnQoTikpKTtcbiAgICAgICAgY29uc3QgVEQgPSBuZXcgQXJyYXkobikuZmlsbChJbmZpbml0eSk7XG4gICAgICAgIGNvbnN0IG1lZG9pZHMgPSBbXTtcbiAgICAgICAgLy8gZmlyc3QgbWVkb2lkXG4gICAgICAgIGxldCBURDAgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IFMgPSByYW5kb21pemVyLmNob2ljZShpbmRpY2VzLCBuKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IFNfaiA9IFNbal07XG4gICAgICAgICAgICBjb25zdCB4X2ogPSBBW1Nfal07XG4gICAgICAgICAgICBmb3IgKGxldCBvID0gMDsgbyA8IG47ICsrbykge1xuICAgICAgICAgICAgICAgIGlmIChvID09PSBqKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB4X28gPSBBW1Nbb11dO1xuICAgICAgICAgICAgICAgIFREW2pdICs9IHRoaXMuX2dldF9kaXN0YW5jZShqLCBvLCB4X2osIHhfbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVERbal0gPCBURDApIHtcbiAgICAgICAgICAgICAgICBURDAgPSBURFtqXTsgLy8gc21hbGxlc3QgZGlzdGFuY2Ugc3VtXG4gICAgICAgICAgICAgICAgbWVkb2lkcy5wdXNoKFNfaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXIgbWVkb2lkc1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEs7ICsraSkge1xuICAgICAgICAgICAgbGV0IERlbHRhVEQgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIFMgPSByYW5kb21pemVyLmNob2ljZShpbmRpY2VzLmZpbHRlcihpbmRleCA9PiBtZWRvaWRzLmZpbmRJbmRleChkID0+IGQgPT09IGluZGV4KSA8IDApLCBuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlbHRhVEQgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IFNfaiA9IFNbal07XG4gICAgICAgICAgICAgICAgY29uc3QgeF9qID0gQVtTX2pdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgbjsgKytvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvID09PSBqKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgU19vID0gU1tvXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeF9vID0gQVtTX29dO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGEgPSB0aGlzLl9nZXRfZGlzdGFuY2UoU19qLCBTX28sIHhfaiwgeF9vKSAtIG1pbihtZWRvaWRzLm1hcChtID0+IHRoaXMuX2dldF9kaXN0YW5jZShTX28sIG0sIHhfbykpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFURCA9IGRlbHRhVEQgKyBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBiZXN0IHJlZHVjdGlvblxuICAgICAgICAgICAgICAgIGlmIChkZWx0YVREIDwgRGVsdGFURCkge1xuICAgICAgICAgICAgICAgICAgICBEZWx0YVREID0gZGVsdGFURDtcbiAgICAgICAgICAgICAgICAgICAgbWVkb2lkcy5wdXNoKFNfaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVEQwICs9IERlbHRhVEQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lZG9pZHMuc2xpY2UoMCwgSyk7XG4gICAgfVxuICAgIFxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IEhlYXAgfSBmcm9tIFwiLi4vZGF0YXN0cnVjdHVyZS9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIE9QVElDU1xuICovXG5leHBvcnQgY2xhc3MgT1BUSUNTIHtcbiAgICAvKipcbiAgICAgKiAqKk8qKnJkZXJpbmcgKipQKipvaW50cyAqKlQqKm8gKipJKipkZW50aWZ5IHRoZSAqKkMqKmx1c3RlcmluZyAqKlMqKnRydWN0dXJlLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y2x1c3RlcmluZ1xuICAgICAqIEBhbGlhcyBPUFRJQ1NcbiAgICAgKiBAdG9kbyBuZWVkcyByZXN0cnVjdHVyaW5nLiBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4IC0gdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVwc2lsb24gLSB0aGUgbWluaW11bSBkaXN0YW5jZSB3aGljaCBkZWZpbmVzIHdoZXRoZXIgYSBwb2ludCBpcyBhIG5laWdoYm9yIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluX3BvaW50cyAtIHRoZSBtaW5pbXVtIG51bWJlciBvZiBwb2ludHMgd2hpY2ggYSBwb2ludCBuZWVkcyB0byBjcmVhdGUgYSBjbHVzdGVyLiAoU2hvdWxkIGJlIGhpZ2hlciB0aGFuIDEsIGVsc2UgZWFjaCBwb2ludCBjcmVhdGVzIGEgY2x1c3Rlci4pXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgZGlzdGFuY2UgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBvZiB0aGUge0BsaW5rIG1hdHJpeH0uXG4gICAgICogQHJldHVybnMge09QVElDU31cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5kYnMuaWZpLmxtdS5kZS9QdWJsaWthdGlvbmVuL1BhcGVycy9PUFRJQ1MucGRmfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09QVElDU19hbGdvcml0aG19XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF0cml4LCBlcHNpbG9uLCBtaW5fcG9pbnRzLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbWF0cml4O1xuICAgICAgICB0aGlzLl9lcHNpbG9uID0gZXBzaWxvbjtcbiAgICAgICAgdGhpcy5fbWluX3BvaW50cyA9IG1pbl9wb2ludHM7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcblxuICAgICAgICB0aGlzLl9vcmRlcmVkX2xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fREIgPSBuZXcgQXJyYXkobWF0cml4LnNoYXBlWzBdKS5maWxsKCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgY2x1c3RlcmluZy5cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBvcmRlcmVkX2xpc3QgPSB0aGlzLl9vcmRlcmVkX2xpc3Q7XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcbiAgICAgICAgY29uc3QgTiA9IG1hdHJpeC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgREIgPSB0aGlzLl9EQjtcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSB0aGlzLl9jbHVzdGVycztcbiAgICAgICAgbGV0IGNsdXN0ZXJfaW5kZXggPSB0aGlzLl9jbHVzdGVyX2luZGV4ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgREJbaV0gPSB7XG4gICAgICAgICAgICAgICAgXCJlbGVtZW50XCI6IG1hdHJpeC5yb3coaSksXG4gICAgICAgICAgICAgICAgXCJpbmRleFwiOiBpLFxuICAgICAgICAgICAgICAgIFwicmVhY2hhYmlsaXR5X2Rpc3RhbmNlXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcInByb2Nlc3NlZFwiOiBmYWxzZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgREIpIHtcbiAgICAgICAgICAgIGlmIChwLnByb2Nlc3NlZCkgY29udGludWU7XG4gICAgICAgICAgICBwLm5laWdoYm9ycyA9IHRoaXMuX2dldF9uZWlnaGJvcnMocCk7XG4gICAgICAgICAgICBwLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICBjbHVzdGVycy5wdXNoKFtwLmluZGV4XSlcbiAgICAgICAgICAgIGNsdXN0ZXJfaW5kZXggPSBjbHVzdGVycy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgb3JkZXJlZF9saXN0LnB1c2gocCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29yZV9kaXN0YW5jZShwKSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWVkcyA9IG5ldyBIZWFwKG51bGwsIGQgPT4gZC5yZWFjaGFiaWxpdHlfZGlzdGFuY2UsIFwibWluXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKHAsIHNlZWRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRfY2x1c3RlcihzZWVkcywgY2x1c3RlcnNbY2x1c3Rlcl9pbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHAgLSBhIHBvaW50IG9mIHtAbGluayBtYXRyaXh9LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgY29uc2lzdGluZyBvZiB0aGUge0BsaW5rIGVwc2lsb259LW5laWdoYm9yaG9vZCBvZiB7QGxpbmsgcH0uXG4gICAgICovXG4gICAgX2dldF9uZWlnaGJvcnMocCkge1xuICAgICAgICBpZiAoXCJuZWlnaGJvcnNcIiBpbiBwKSByZXR1cm4gcC5uZWlnaGJvcnM7XG4gICAgICAgIGNvbnN0IERCID0gdGhpcy5fREI7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuX2Vwc2lsb247XG4gICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHEgb2YgREIpIHtcbiAgICAgICAgICAgIGlmIChxLmluZGV4ID09IHAuaW5kZXgpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG1ldHJpYyhwLmVsZW1lbnQsIHEuZWxlbWVudCkgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5laWdoYm9ycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwIC0gYSBwb2ludCBvZiB7QGxpbmsgbWF0cml4fS5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZGlzdGFuY2UgdG8gdGhlIHtAbGluayBtaW5fcG9pbnRzfS10aCBuZWFyZXN0IHBvaW50IG9mIHtAbGluayBwfSwgb3IgdW5kZWZpbmVkIGlmIHRoZSB7QGxpbmsgZXBzaWxvbn0tbmVpZ2hib3Job29kIGhhcyBmZXdlciBlbGVtZW50cyB0aGFuIHtAbGluayBtaW5fcG9pbnRzfS5cbiAgICAgKi9cbiAgICBfY29yZV9kaXN0YW5jZShwKSB7XG4gICAgICAgIGNvbnN0IG1pbl9wb2ludHMgPSB0aGlzLl9taW5fcG9pbnRzO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGlmIChwLm5laWdoYm9ycyAmJiBwLm5laWdoYm9ycy5sZW5ndGggPD0gbWluX3BvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0cmljKHAuZWxlbWVudCwgcC5uZWlnaGJvcnNbbWluX3BvaW50c10uZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVhY2hhYmlsaXR5IGRpc3RhbmNlIG9mIHRoZSBwb2ludHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcCBcbiAgICAgKiBAcGFyYW0ge0hlYXB9IHNlZWRzIFxuICAgICAqL1xuICAgIF91cGRhdGUocCwgc2VlZHMpIHtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBjb3JlX2Rpc3RhbmNlID0gdGhpcy5fY29yZV9kaXN0YW5jZShwKTtcbiAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gdGhpcy5fZ2V0X25laWdoYm9ycyhwKTsvL3AubmVpZ2hib3JzO1xuICAgICAgICBmb3IgKGNvbnN0IHEgb2YgbmVpZ2hib3JzKSB7XG4gICAgICAgICAgICBpZiAocS5wcm9jZXNzZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbmV3X3JlYWNoYWJpbGl0eV9kaXN0YW5jZSA9IE1hdGgubWF4KGNvcmVfZGlzdGFuY2UsIG1ldHJpYyhwLmVsZW1lbnQsIHEuZWxlbWVudCkpO1xuICAgICAgICAgICAgLy9pZiAocS5yZWFjaGFiaWxpdHlfZGlzdGFuY2UgPT0gdW5kZWZpbmVkKSB7IC8vIHEgaXMgbm90IGluIHNlZWRzXG4gICAgICAgICAgICBpZiAoc2VlZHMucmF3X2RhdGEoKS5maW5kSW5kZXgoZCA9PiBkLmVsZW1lbnQgPT0gcSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcS5yZWFjaGFiaWxpdHlfZGlzdGFuY2UgPSBuZXdfcmVhY2hhYmlsaXR5X2Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHNlZWRzLnB1c2gocSk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBxIGlzIGluIHNlZWRzXG4gICAgICAgICAgICAgICAgaWYgKG5ld19yZWFjaGFiaWxpdHlfZGlzdGFuY2UgPCBxLnJlYWNoYWJpbGl0eV9kaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBxLnJlYWNoYWJpbGl0eV9kaXN0YW5jZSA9IG5ld19yZWFjaGFiaWxpdHlfZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIHNlZWRzID0gSGVhcC5oZWFwaWZ5KHNlZWRzLmRhdGEoKSwgZCA9PiBkLnJlYWNoYWJpbGl0eV9kaXN0YW5jZSwgXCJtaW5cIik7IC8vIHNlZWRzIGNoYW5nZSBrZXkgPS9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSB7QGxpbmsgY2x1c3Rlcn0gd2l0aCBwb2ludHMgaW4ge0BsaW5rIHNlZWRzfS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SGVhcH0gc2VlZHMgXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2x1c3RlciBcbiAgICAgKi9cbiAgICBfZXhwYW5kX2NsdXN0ZXIoc2VlZHMsIGNsdXN0ZXIpIHtcbiAgICAgICAgY29uc3Qgb3JkZXJlZF9saXN0ID0gdGhpcy5fb3JkZXJlZF9saXN0O1xuICAgICAgICB3aGlsZSAoIXNlZWRzLmVtcHR5KSB7XG4gICAgICAgICAgICBjb25zdCBxID0gc2VlZHMucG9wKCkuZWxlbWVudDtcbiAgICAgICAgICAgIHEubmVpZ2hib3JzID0gdGhpcy5fZ2V0X25laWdoYm9ycyhxKTtcbiAgICAgICAgICAgIHEucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsdXN0ZXIucHVzaChxLmluZGV4KTtcbiAgICAgICAgICAgIG9yZGVyZWRfbGlzdC5wdXNoKHEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvcmVfZGlzdGFuY2UocSkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKHEsIHNlZWRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRfY2x1c3RlcihzZWVkcywgY2x1c3Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNsdXN0ZXJzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IEFycmF5IG9mIGNsdXN0ZXJzIHdpdGggdGhlIGluZGljZXMgb2YgdGhlIHJvd3MgaW4gZ2l2ZW4ge0BsaW5rIG1hdHJpeH0uXG4gICAgICovXG4gICAgZ2V0X2NsdXN0ZXJzKCkge1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9IFtdO1xuICAgICAgICBjb25zdCBvdXRsaWVycyA9IFtdO1xuICAgICAgICBjb25zdCBtaW5fcG9pbnRzID0gdGhpcy5fbWluX3BvaW50cztcbiAgICAgICAgZm9yIChjb25zdCBjbHVzdGVyIG9mIHRoaXMuX2NsdXN0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoY2x1c3Rlci5sZW5ndGggPCBtaW5fcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgb3V0bGllcnMucHVzaCguLi5jbHVzdGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2x1c3RlcnMucHVzaChjbHVzdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbHVzdGVycy5wdXNoKG91dGxpZXJzKTtcbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSwgd2hlcmUgdGhlIGl0aCBlbnRyeSBkZWZpbmVzIHRoZSBjbHVzdGVyIGFmZmlybWF0aW9uIG9mIHRoZSBpdGggcG9pbnQgb2Yge0BsaW5rIG1hdHJpeH0uICgtMSBzdGFuZHMgZm9yIG91dGxpZXIpXG4gICAgICovXG4gICAgZ2V0X2NsdXN0ZXJfYWZmaXJtYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9tYXRyaXguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShOKS5maWxsKCk7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gdGhpcy5nZXRfY2x1c3RlcnMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBjbHVzdGVycy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBjbHVzdGVyc1tpXVxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBjbHVzdGVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IChpIDwgbiAtIDEpID8gaSA6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuaW1wb3J0IHsgTURTIH0gZnJvbSBcIi4vTURTLmpzXCI7XG5pbXBvcnQgeyBLTWVkb2lkcyB9IGZyb20gXCIuLi9jbHVzdGVyaW5nL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQmFsbFRyZWUgfSBmcm9tIFwiLi4va25uL2luZGV4LmpzXCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIExTUFxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIExTUCBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKiBMZWFzdCBTcXVhcmVzIFByb2plY3Rpb24uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgTFNQXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5uZWlnaGJvcnMgPSBNYXRoLm1heChNYXRoLmZsb29yKE4gLyAxMCksIDIpXSAtIG51bWJlciBvZiBuZWlnaGJvcnMgdG8gY29uc2lkZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmNvbnRyb2xfcG9pbnRzID0gTWF0aC5jZWlsKE1hdGguc3FydChOKSldIC0gbnVtYmVyIG9mIGNvbnRyb2xwb2ludHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbWV0ZXJzLm1ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuc2VlZCA9IDEyMTJdIC0gdGhlIHNlZWQgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7TFNQfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vaWVlZXhwbG9yZS5pZWVlLm9yZy9kb2N1bWVudC80Mzc4MzcwfVxuICAgICAqIEB0b2RvIGFjY2VwdCBwcmVjb21wdXRlZCBkaXN0YW5jZSBtYXRyaXguXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IG5laWdoYm9yczogdW5kZWZpbmVkLCBjb250cm9sX3BvaW50czogdW5kZWZpbmVkLCBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJuZWlnaGJvcnNcIiwgTWF0aC5taW4ocGFyYW1ldGVycy5uZWlnaGJvcnMgPz8gTWF0aC5tYXgoTWF0aC5mbG9vcih0aGlzLl9OIC8gMTApLCAyKSwgdGhpcy5fTiAtIDEpKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJjb250cm9sX3BvaW50c1wiLCBNYXRoLm1pbihwYXJhbWV0ZXJzLmNvbnRyb2xfcG9pbnRzID8/IE1hdGguY2VpbChNYXRoLnNxcnQodGhpcy5fTikpLCB0aGlzLl9OIC0gMSkpO1xuICAgICAgICB0aGlzLl9pc19pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RFJ9IERSIC0gbWV0aG9kIHVzZWQgZm9yIHBvc2l0aW9uIGNvbnRyb2wgcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBEUl9wYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBmb3IgdGhlIERSIG1ldGhvZCB3aGljaCBwcm9qZWN0cyB0aGUgY29udHJvbCBwb2ludHNcbiAgICAgKiBAcmV0dXJucyB7TFNQfVxuICAgICAqL1xuICAgIGluaXQoRFIgPSBNRFMsIERSX3BhcmFtZXRlcnMgPSB7fSwgS05OID0gQmFsbFRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzX2luaXRpYWxpemVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IEsgPSB0aGlzLnBhcmFtZXRlcihcIm5laWdoYm9yc1wiKTtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMucGFyYW1ldGVyKFwiZFwiKTtcbiAgICAgICAgY29uc3Qgc2VlZCA9IHRoaXMucGFyYW1ldGVyKFwic2VlZFwiKTtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5wYXJhbWV0ZXIoXCJtZXRyaWNcIik7XG4gICAgICAgIERSX3BhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHtkLCBtZXRyaWMsIHNlZWQgfSwgRFJfcGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IG5jID0gdGhpcy5wYXJhbWV0ZXIoXCJjb250cm9sX3BvaW50c1wiKTtcbiAgICAgICAgY29uc3QgY29udHJvbF9wb2ludHMgPSBuZXcgS01lZG9pZHMoWCwgbmMsIG51bGwsIG1ldHJpYykuZ2V0X2NsdXN0ZXJzKCkubWVkb2lkcztcbiAgICAgICAgY29uc3QgQyA9IG5ldyBNYXRyaXgobmMsIE4sIFwiemVyb3NcIik7XG4gICAgICAgIGNvbnRyb2xfcG9pbnRzLmZvckVhY2goKGNfaSwgaSkgPT4ge1xuICAgICAgICAgICAgQy5zZXRfZW50cnkoaSwgY19pLCAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IFlfQyA9IG5ldyBEUihNYXRyaXguZnJvbShjb250cm9sX3BvaW50cy5tYXAoKGNfaSkgPT4gWC5yb3coY19pKSkpLCBEUl9wYXJhbWV0ZXJzKS50cmFuc2Zvcm0oKTtcblxuICAgICAgICBjb25zdCBYQSA9IFgudG8yZEFycmF5O1xuICAgICAgICBjb25zdCBrbm4gPSBuZXcgS05OKFhBLCBtZXRyaWMpO1xuICAgICAgICBjb25zdCBMID0gbmV3IE1hdHJpeChOLCBOLCBcIklcIik7XG4gICAgICAgIGNvbnN0IGFscGhhID0gLTEgLyBLO1xuICAgICAgICBYQS5mb3JFYWNoKCh4X2ksIGkpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBpbmRleDogaiB9IG9mIGtubi5zZWFyY2goeF9pLCBLKS5pdGVyYXRlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaikgY29udGludWU7XG4gICAgICAgICAgICAgICAgTC5zZXRfZW50cnkoaSwgaiwgYWxwaGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgQSA9IEwuY29uY2F0KEMsIFwidmVydGljYWxcIik7XG5cbiAgICAgICAgY29uc3QgeiA9IG5ldyBNYXRyaXgoTiwgZCwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgY29uc3QgYiA9IHouY29uY2F0KFlfQywgXCJ2ZXJ0aWNhbFwiKTtcblxuICAgICAgICB0aGlzLl9BID0gQTtcbiAgICAgICAgdGhpcy5fYiA9IGI7XG4gICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHJldHVybnMge01hdHJpeH0gUmV0dXJucyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgQVQgPSBBLlQ7XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLl9iO1xuICAgICAgICBjb25zdCBBVEEgPSBBVC5kb3QoQSk7XG4gICAgICAgIGNvbnN0IEFUYiA9IEFULmRvdChiKTtcbiAgICAgICAgdGhpcy5ZID0gTWF0cml4LnNvbHZlX0NHKEFUQSwgQVRiLCB0aGlzLl9yYW5kb21pemVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuaW1wb3J0IHsgRGlzam9pbnRTZXQgfSBmcm9tIFwiLi4vZGF0YXN0cnVjdHVyZS9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIFRvcG9NYXBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgVG9wb01hcCBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKiBUb3BvTWFwOiBBIDAtZGltZW5zaW9uYWwgSG9tb2xvZ3kgUHJlc2VydmluZyBQcm9qZWN0aW9uIG9mIEhpZ2gtRGltZW5zaW9uYWwgRGF0YS5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBUb3BvTWFwXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbWV0ZXJzLm1ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuc2VlZCA9IDEyMTJdIC0gdGhlIHNlZWQgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7VG9wb01hcH1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2FyeGl2Lm9yZy9wZGYvMjAwOS4wMTUxMi5wZGZ9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IG1ldHJpYzogZXVjbGlkZWFuLCBzZWVkOiAxMjEyIH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICBbdGhpcy5fTiwgdGhpcy5fRF0gPSB0aGlzLlguc2hhcGU7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlX21hdHJpeCA9IG5ldyBNYXRyaXgodGhpcy5fTiwgdGhpcy5fTiwgMCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX19sYXp5X2Rpc3RhbmNlX21hdHJpeChpLCBqLCBtZXRyaWMpIHtcbiAgICAgICAgY29uc3QgRCA9IHRoaXMuX2Rpc3RhbmNlX21hdHJpeDtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgRF9paiA9IEQuZW50cnkoaSwgaik7XG4gICAgICAgIGlmIChEX2lqID09PSAwKSB7XG4gICAgICAgICAgICBsZXQgZGlzdCA9IG1ldHJpYyhYLnJvdyhpKSwgWC5yb3coaikpO1xuICAgICAgICAgICAgRC5zZXRfZW50cnkoaSwgaiwgZGlzdCk7XG4gICAgICAgICAgICBELnNldF9lbnRyeShqLCBpLCBkaXN0KTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEX2lqO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHNwYW5uaW5nIHRyZWUsIHVzaW5nIGEgZ2l2ZW4gbWV0cmljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRyaWNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LcnVza2FsJTI3c19hbGdvcml0aG19XG4gICAgICovXG4gICAgX21ha2VfbWluaW11bV9zcGFubmluZ190cmVlKG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgWCA9IFsuLi50aGlzLlhdO1xuXG4gICAgICAgIGxldCBkaXNqb2ludF9zZXQgPSBuZXcgRGlzam9pbnRTZXQoWCk7XG4gICAgICAgIGNvbnN0IEYgPSBbXTtcbiAgICAgICAgbGV0IEUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIEUucHVzaChbaSwgaiwgdGhpcy5fX2xhenlfZGlzdGFuY2VfbWF0cml4KGksIGosIG1ldHJpYyldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBFID0gRS5zb3J0KChhLCBiKSA9PiBhWzJdIC0gYlsyXSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBbdSwgdiwgd10gb2YgRSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0X3UgPSBkaXNqb2ludF9zZXQuZmluZChYW3VdKTtcbiAgICAgICAgICAgIGNvbnN0IHNldF92ID0gZGlzam9pbnRfc2V0LmZpbmQoWFt2XSk7XG4gICAgICAgICAgICBpZiAoc2V0X3UgIT09IHNldF92KSB7XG4gICAgICAgICAgICAgICAgRi5wdXNoKFt1LCB2LCB3XSk7XG4gICAgICAgICAgICAgICAgZGlzam9pbnRfc2V0LnVuaW9uKHNldF91LCBzZXRfdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRi5zb3J0KChhLCBiKSA9PiBhWzJdIC0gYlsyXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZXMgVG9wb01hcC4gU2V0cyBhbGwgcHJvamN0ZWQgcG9pbnRzIHRvIHplcm8sIGFuZCBjb21wdXRlcyBhIG1pbmltdW0gc3Bhbm5pbmcgdHJlZS5cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCB7IG1ldHJpY30gPSB0aGlzLl9wYXJhbWV0ZXJzXG4gICAgICAgIHRoaXMuWSA9IG5ldyBNYXRyaXgodGhpcy5fTiwgMiwgMCk7XG4gICAgICAgIHRoaXMuX0Vtc3QgPSB0aGlzLl9tYWtlX21pbmltdW1fc3Bhbm5pbmdfdHJlZShtZXRyaWMpO1xuICAgICAgICB0aGlzLl9pc19pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBQb2ludCBDIGlzIGxlZnQgb2YgbGluZSBBQi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFBvaW50QSAtIFBvaW50IEEgb2YgbGluZSBBQlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFBvaW50QiAtIFBvaW50IEIgb2YgbGluZSBBQlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFBvaW50QyAtIFBvaW50IENcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBfX2h1bGxfY3Jvc3MoW2F4LCBheV0sIFtieCwgYnldLCBbc3gsIHN5XSkge1xuICAgICAgICByZXR1cm4gKGJ4IC0gYXgpICogKHN5IC0gYXkpIC0gKGJ5IC0gYXkpICogKHN4IC0gYXgpIDw9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGNvbnZleCBodWxsIG9mIHRoZSBzZXQgb2YgUG9pbnRzIFNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFMgLSBTZXQgb2YgUG9pbnRzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9HZW9tZXRyeS9Db252ZXhfaHVsbC9Nb25vdG9uZV9jaGFpbiNKYXZhU2NyaXB0fVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY29udmV4IGh1bGwgb2YgUy4gU3RhcnRzIGF0IHRoZSBib3R0b20tbW9zdCBwb2ludCBhbmQgY29udGludWVzIGNvdW50ZXItY2xvY2t3aXNlLlxuICAgICAqL1xuICAgIF9faHVsbChTKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFMuc29ydCgoW3gxLCB5MV0sIFt4MiwgeTJdKSA9PiB5MSAtIHkyIHx8IHgxIC0geDIpO1xuICAgICAgICBjb25zdCBOID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKE4gPD0gMikgcmV0dXJuIHBvaW50cztcblxuICAgICAgICBjb25zdCBsb3dlciA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgd2hpbGUgKGxvd2VyLmxlbmd0aCA+PSAyICYmIHRoaXMuX19odWxsX2Nyb3NzKGxvd2VyW2xvd2VyLmxlbmd0aCAtIDJdLCBsb3dlcltsb3dlci5sZW5ndGggLSAxXSwgcG9pbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgIGxvd2VyLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG93ZXIucHVzaChwb2ludHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwcGVyID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBOIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHdoaWxlICh1cHBlci5sZW5ndGggPj0gMiAmJiB0aGlzLl9faHVsbF9jcm9zcyh1cHBlclt1cHBlci5sZW5ndGggLSAyXSwgdXBwZXJbdXBwZXIubGVuZ3RoIC0gMV0sIHBvaW50c1tpXSkpIHtcbiAgICAgICAgICAgICAgICB1cHBlci5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwcGVyLnB1c2gocG9pbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB1cHBlci5wb3AoKTtcbiAgICAgICAgbG93ZXIucG9wKCk7XG4gICAgICAgIHJldHVybiBsb3dlci5jb25jYXQodXBwZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBhbmdsZSB0byByb3RhdGUgUG9pbnQgQSBhbmQgQiB0byBsaWUgb24gYSBsaW5lIHBhcmFsbGVsIHRvIHRoZSB4LWF4aXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBQb2ludEFcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBQb2ludEJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBzaW51cy0gYW5kIGNvc2ludXMtdmFsdWVzIGZvciBhIHJvdGF0aW9uLlxuICAgICAqL1xuICAgIF9fZmluZEFuZ2xlKFtwMXgsIHAxeV0sIFtwMngsIHAyeV0pIHtcbiAgICAgICAgY29uc3QgbiA9IGV1Y2xpZGVhbihbcDF4LCBwMXldLCBbcDJ4LCBwMnldKTtcbiAgICAgICAgaWYgKG4gPT09IDApXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNpbjogMCxcbiAgICAgICAgICAgICAgICBjb3M6IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjb25zdCB2ZWMgPSBbKHAyeCAtIHAxeCkgLyBuLCAocDJ5IC0gcDF5KSAvIG5dO1xuICAgICAgICBjb25zdCBjb3MgPSB2ZWNbMF07XG4gICAgICAgIGxldCBzaW4gPSBNYXRoLnNxcnQoMSAtIGNvcyAqIGNvcyk7XG4gICAgICAgIHNpbiA9IHZlY1sxXSA+PSAwID8gLXNpbiA6IHNpbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpbjogc2luLFxuICAgICAgICAgICAgY29zOiBjb3MsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBodWxsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcFxuICAgICAqIEBwYXJhbSB7Qm9vbH0gdG9wRWRnZVxuICAgICAqL1xuICAgIF9fYWxpZ25faHVsbChodWxsLCBwLCB0b3BFZGdlKSB7XG4gICAgICAgIGxldCB2ID0gLTE7XG4gICAgICAgIGxldCBkMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBodWxsLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gZXVjbGlkZWFuKGh1bGxbaV0sIHApO1xuICAgICAgICAgICAgaWYgKHYgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZDIgPSBkO1xuICAgICAgICAgICAgICAgIHYgPSBpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZDIgPiBkKSB7XG4gICAgICAgICAgICAgICAgICAgIGQyID0gZDtcbiAgICAgICAgICAgICAgICAgICAgdiA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBsZXQgdjI7XG4gICAgICAgIGlmICh0b3BFZGdlKSB7XG4gICAgICAgICAgICB2MSA9IGh1bGxbdl07XG4gICAgICAgICAgICB2MiA9IGh1bGxbKHYgKyAxKSAlIGh1bGwubGVuZ3RoXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2ID09IDApIHYgPSBodWxsLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2MSA9IGh1bGxbdl07XG4gICAgICAgICAgICB2MiA9IGh1bGxbKHYgLSAxKSAlIGh1bGwubGVuZ3RoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uID0ge1xuICAgICAgICAgICAgdHg6IC1odWxsW3ZdWzBdLFxuICAgICAgICAgICAgdHk6IC1odWxsW3ZdWzFdLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChodWxsLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNpbiwgY29zIH0gPSB0aGlzLl9fZmluZEFuZ2xlKHYxLCB2Mik7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbi5zaW4gPSBzaW47XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbi5jb3MgPSBjb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbi5zaW4gPSAwO1xuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24uY29zID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFBvaW50IC0gVGhlIHBvaW50IHdoaWNoIHNob3VsZCBnZXQgdHJhbnNmb3JtZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFRyYW5zZm9ybWF0aW9uIC0gY29udGFpbnMgdGhlIHZhbHVlcyBmb3IgdHJhbnNsYXRpb24gYW5kIHJvdGF0aW9uLlxuICAgICAqL1xuICAgIF9fdHJhbnNmb3JtKFtweCwgcHldLCB7IHR4LCB0eSwgc2luLCBjb3MgfSkge1xuICAgICAgICBsZXQgeCA9IHB4ICsgdHg7XG4gICAgICAgIGxldCB5ID0gcHkgKyB0eTtcbiAgICAgICAgbGV0IHh4ID0geCAqIGNvcyAtIHkgKiBzaW47XG4gICAgICAgIGxldCB5eSA9IHggKiBzaW4gKyB5ICogY29zO1xuICAgICAgICByZXR1cm4gW3h4LCB5eV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMge0BsaW5rIF9fdHJhbnNmb3JtfSBmb3IgZWFjaCBwb2ludCBpbiBTZXQgQ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gQyAtIFNldCBvZiBwb2ludHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHQgLSBUcmFuc2Zvcm0gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5T2Zmc2V0IC0gdmFsdWUgdG8gb2Zmc2V0IHNldCBDLlxuICAgICAqL1xuICAgIF9fdHJhbnNmb3JtX2NvbXBvbmVudChDLCB0LCB5T2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IE4gPSBDLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBDW2ldO1xuICAgICAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLl9fdHJhbnNmb3JtKGMsIHQpO1xuICAgICAgICAgICAgY1swXSA9IGN4O1xuICAgICAgICAgICAgY1sxXSA9IGN5ICsgeU9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdSAtIHBvaW50IHVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2IC0gcG9pbnQgdlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3IC0gZWRnZSB3ZWlnaHQgd1xuICAgICAqL1xuICAgIF9fYWxpZ25fY29tcG9uZW50cyh1LCB2LCB3KSB7XG4gICAgICAgIGNvbnN0IHBvaW50c191ID0gWy4uLnUuX19kaXNqb2ludF9zZXQuY2hpbGRyZW5dO1xuICAgICAgICBjb25zdCBwb2ludHNfdiA9IFsuLi52Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuXTtcblxuICAgICAgICBjb25zdCBodWxsX3UgPSB0aGlzLl9faHVsbChwb2ludHNfdSk7XG4gICAgICAgIGNvbnN0IGh1bGxfdiA9IHRoaXMuX19odWxsKHBvaW50c192KTtcblxuICAgICAgICBjb25zdCB0X3UgPSB0aGlzLl9fYWxpZ25faHVsbChodWxsX3UsIHUsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgdF92ID0gdGhpcy5fX2FsaWduX2h1bGwoaHVsbF92LCB2LCB0cnVlKTtcblxuICAgICAgICB0aGlzLl9fdHJhbnNmb3JtX2NvbXBvbmVudChwb2ludHNfdSwgdF91LCAwKTtcbiAgICAgICAgdGhpcy5fX3RyYW5zZm9ybV9jb21wb25lbnQocG9pbnRzX3YsIHRfdiwgdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXRkYXRhIHtAbGluayBYfSB0byBkaW1lbnNpb25hbGl0eSAyLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc19pbml0aWFsaXplZCkgdGhpcy5pbml0KCk7XG4gICAgICAgIGNvbnN0IEVtc3QgPSB0aGlzLl9FbXN0O1xuICAgICAgICBjb25zdCBZID0gdGhpcy5ZLnRvMmRBcnJheTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IG5ldyBEaXNqb2ludFNldChcbiAgICAgICAgICAgIFkubWFwKCh5LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgeS5pID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChjb25zdCBbdSwgdiwgd10gb2YgRW1zdCkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50X3UgPSBjb21wb25lbnRzLmZpbmQoWVt1XSk7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRfdiA9IGNvbXBvbmVudHMuZmluZChZW3ZdKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRfdSA9PT0gY29tcG9uZW50X3YpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5fX2FsaWduX2NvbXBvbmVudHMoY29tcG9uZW50X3UsIGNvbXBvbmVudF92LCB3KTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMudW5pb24oY29tcG9uZW50X3UsIGNvbXBvbmVudF92KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgICpnZW5lcmF0b3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNfaW5pdGlhbGl6ZWQpIHRoaXMuaW5pdCgpO1xuICAgICAgICBjb25zdCBFbXN0ID0gdGhpcy5fRW1zdDtcbiAgICAgICAgY29uc3QgWSA9IHRoaXMuWS50bzJkQXJyYXk7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBuZXcgRGlzam9pbnRTZXQoXG4gICAgICAgICAgICBZLm1hcCgoeSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHkuaSA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGZvciAoY29uc3QgW3UsIHYsIHddIG9mIEVtc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudF91ID0gY29tcG9uZW50cy5maW5kKFlbdV0pO1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50X3YgPSBjb21wb25lbnRzLmZpbmQoWVt2XSk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50X3UgPT09IGNvbXBvbmVudF92KSBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMuX19hbGlnbl9jb21wb25lbnRzKGNvbXBvbmVudF91LCBjb21wb25lbnRfdiwgdyk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnVuaW9uKGNvbXBvbmVudF91LCBjb21wb25lbnRfdik7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnByb2plY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuaW1wb3J0IHsgUENBLCBNRFMgfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGlzdGFuY2VfbWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIFNBTU1PTlxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIFNBTU1PTiBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKiBTQU1NT04ncyBNYXBwaW5nXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgU0FNTU9OXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5kID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxcInByZWNvbXB1dGVkXCJ9IFtwYXJhbWV0ZXJzLm1ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge1wiUENBXCJ8XCJNRFNcInxcInJhbmRvbVwifSBbcGFyYW1ldGVycy5pbml0ID0gXCJyYW5kb21cIl0gLSBFaXRoZXIgXCJQQ0FcIiBvciBcIk1EU1wiLCB3aXRoIHdoaWNoIFNBTU1PTiBpbml0aWFsaWF0ZXMgdGhlIHByb2plY3Rpb24uIFdpdGggXCJyYW5kb21cIiBhIHJhbmRvbSBtYXRyaXggZ2V0cyB1c2VkIGFzIHN0YXJ0aW5nIHBvaW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVycy5pbml0X3BhcmFtZXRlcnNdIC0gUGFyYW1ldGVycyBmb3IgdGhlIHtAbGluayBpbml0fS1EUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge1NBTU1PTn1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2FyeGl2Lm9yZy9wZGYvMjAwOS4wMTUxMi5wZGZ9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IG1hZ2ljOiAwLjEsIGQ6IDIsIG1ldHJpYzogZXVjbGlkZWFuLCBzZWVkOiAxMjEyLCBpbml0X0RSOiBcInJhbmRvbVwiLCBpbml0X3BhcmFtZXRlcnM6IHt9IH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplcyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLlguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHsgZCwgbWV0cmljLCBpbml0X0RSOiBpbml0X0RSLCBpbml0X3BhcmFtZXRlcnM6IERSX3BhcmFtZXRlcnMgfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGlmIChpbml0X0RSID09PSBcInJhbmRvbVwiKSB7XG4gICAgICAgICAgICBjb25zdCByYW5kb21pemVyID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgICAgIHRoaXMuWSA9IG5ldyBNYXRyaXgoTiwgZCwgKCkgPT4gcmFuZG9taXplci5yYW5kb20pO1xuICAgICAgICB9IGVsc2UgaWYgKFtcIlBDQVwiLCBcIk1EU1wiXS5pbmNsdWRlcyhpbml0X0RSKSkge1xuICAgICAgICAgICAgdGhpcy5ZID0gTWF0cml4LmZyb20oaW5pdF9EUiA9PSBcIlBDQVwiID8gUENBLnRyYW5zZm9ybSh0aGlzLlgsIERSX3BhcmFtZXRlcnMpIDogTURTLnRyYW5zZm9ybSh0aGlzLlgsIERSX3BhcmFtZXRlcnMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdF9EUiBuZWVkcyB0byBiZSBlaXRoZXIgXCJyYW5kb21cIiBvciBhIERSIG1ldGhvZCEnKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzdGFuY2VfbWF0cml4ID0gbWV0cmljID09IFwicHJlY29tcHV0ZWRcIiA/IE1hdHJpeC5mcm9tKHRoaXMuWCkgOiBkaXN0YW5jZV9tYXRyaXgodGhpcy5YLCBtZXRyaWMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuaW9uYWxpdHkgMi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW21heF9pdGVyPTIwMF0gLSBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb24gc3RlcHMuXG4gICAgICogQHJldHVybnMge01hdHJpeHxBcnJheX0gLSBUaGUgcHJvamVjdGlvbiBvZiB7QGxpbmsgWH0uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKG1heF9pdGVyID0gMjAwKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNfaW5pdGlhbGl6ZWQpIHRoaXMuaW5pdCgpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1heF9pdGVyOyArK2opIHtcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0ZGF0YSB7QGxpbmsgWH0gdG8gZGltZW5pb25hbGl0eSAyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4X2l0ZXI9MjAwXSAtIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbiBzdGVwcy5cbiAgICAgKiBAcmV0dXJucyB7R2VuZXJhdG9yfSAtIEEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSBpbnRlcm1lZGlhdGUgc3RlcHMgb2YgdGhlIHByb2plY3Rpb24gb2Yge0BsaW5rIFh9LlxuICAgICAqL1xuICAgICpnZW5lcmF0b3IobWF4X2l0ZXIgPSAyMDApIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc19pbml0aWFsaXplZCkgdGhpcy5pbml0KCk7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXhfaXRlcjsgKytqKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGVwKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnByb2plY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIF9zdGVwKCkge1xuICAgICAgICBjb25zdCBNQUdJQyA9IHRoaXMucGFyYW1ldGVyKFwibWFnaWNcIik7XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLmRpc3RhbmNlX21hdHJpeDtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgeyBkLCBtZXRyaWMgfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGxldCBZID0gdGhpcy5ZO1xuXG4gICAgICAgIGxldCBHID0gbmV3IE1hdHJpeChOLCBkLCAwKTtcblxuICAgICAgICBsZXQgc3VtID0gbmV3IEZsb2F0NjRBcnJheShkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBlMSA9IG5ldyBGbG9hdDY0QXJyYXkoZCk7XG4gICAgICAgICAgICBsZXQgZTIgPSBuZXcgRmxvYXQ2NEFycmF5KGQpO1xuICAgICAgICAgICAgY29uc3QgWWkgPSBZLnJvdyhpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGopIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IFlqID0gWS5yb3coaik7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBuZXcgRmxvYXQ2NEFycmF5KGQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhW2tdID0gWWlba10gLSBZaltrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZFkgPSBtZXRyaWMoWWksIFlqKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkWCA9IEQuZW50cnkoaSwgaik7XG4gICAgICAgICAgICAgICAgY29uc3QgZHEgPSBkWCAtIGRZO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRyID0gTWF0aC5tYXgoZFggKiBkWSwgMWUtMik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgZTFba10gKz0gKGRlbHRhW2tdICogZHEpIC8gZHI7XG4gICAgICAgICAgICAgICAgICAgIGUyW2tdICs9IChkcSAtIChNYXRoLnBvdyhkZWx0YVtrXSwgMikgKiAoMSArIGRxIC8gZFkpKSAvIGRZKSAvIGRyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZDsgKytrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gWS5lbnRyeShpLCBrKSArICgoTUFHSUMgKiBlMVtrXSkgLyBNYXRoLmFicyhlMltrXSkgfHwgMCk7XG4gICAgICAgICAgICAgICAgRy5zZXRfZW50cnkoaSwgaywgdmFsKTtcbiAgICAgICAgICAgICAgICBzdW1ba10gKz0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZDsgKytrKSB7XG4gICAgICAgICAgICBzdW1ba10gLz0gTjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGQ7ICsraykge1xuICAgICAgICAgICAgICAgIFkuc2V0X2VudHJ5KGksIGssIEcuZW50cnkoaSwgaykgLSBzdW1ba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBZO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJhIiwiYiIsIk1hdGgiLCJzcXJ0IiwiZXVjbGlkZWFuX3NxdWFyZWQiLCJzdW1tYW5kcyIsInkiLCJ0IiwibiIsImxlbmd0aCIsInN1bSIsImNvbXBlbnNhdGlvbiIsImkiLCJzdW1tYW5kIiwiYWJzIiwicyIsIkFycmF5IiwieCIsIm5ldW1haXJfc3VtIiwic3VtX2EiLCJzdW1fYiIsImFjb3MiLCJyZXMiLCJwdXNoIiwibWF4IiwibnVtX25vbl96ZXJvIiwibnVtX2VxdWFsIiwiZGlzYWdyZWUiLCJudW1fbm90X2VxdWFsIiwibnVtX3RydWVfdHJ1ZSIsIm51bV90cnVlX2ZhbHNlIiwibnVtX2ZhbHNlX3RydWUiLCJBIiwiayIsIm1ldHJpYyIsImV1Y2xpZGVhbiIsInJvd3MiLCJzaGFwZSIsIkQiLCJkaXN0YW5jZV9tYXRyaXgiLCJuTiIsInJvdyIsImZyb20iLCJtYXAiLCJkaXN0YW5jZSIsImNvbCIsImoiLCJzb3J0Iiwic2xpY2UiLCJNYXRyaXgiLCJBX2kiLCJkaXN0Iiwic2V0X2VudHJ5Iiwic3RhcnQiLCJlbmQiLCJudW1iZXIiLCJyb3VuZCIsInJlc3VsdCIsInYiLCJ2ZWN0b3IiLCJjb2xzIiwiRXJyb3IiLCJGbG9hdDY0QXJyYXkiLCJ2X25vcm0iLCJub3JtIiwidmFsdWUiLCJRIiwiUiIsInEiLCJxX2RvdF92IiwicV8iLCJ2XyIsImNsb25lIiwieF9ub3JtIiwieDAiLCJlbnRyeSIsInJobyIsInNpZ24iLCJ1MSIsInUiLCJkaXZpZGUiLCJiZXRhIiwidV9vdXRlcl91Iiwib3V0ZXIiLCJSX2Jsb2NrIiwiZ2V0X2Jsb2NrIiwibmV3X1IiLCJzdWIiLCJkb3QiLCJtdWx0IiwiUV9ibG9jayIsIm5ld19RIiwic2V0X2Jsb2NrIiwic2VlZCIsIm1heF9pdGVyYXRpb25zIiwicXIiLCJxcl9ncmFtc2NobWlkdCIsInRvbCIsInJhbmRvbWl6ZXIiLCJSYW5kb21pemVyIiwicmFuZG9tIiwib2xkUSIsIlFSIiwidmFsdWVzIiwiZWlnZW52YWx1ZXMiLCJkaWFnIiwiZWlnZW52ZWN0b3JzIiwidHJhbnNwb3NlIiwidG8yZEFycmF5IiwiTiIsImNvbnN0cnVjdG9yIiwidGhpcyIsIl9yb3dzIiwiX2NvbHMiLCJfZGF0YSIsInN0YXRpYyIsInR5cGUiLCJpc0FycmF5IiwibSIsIl8iLCJkYXRhIiwic3ViYXJyYXkiLCJpdGVyYXRlX3Jvd3MiLCJTeW1ib2wiLCJpdGVyYXRvciIsInNldF9yb3ciLCJvZmZzZXQiLCJyZXN1bHRfY29sIiwiVCIsImludmVyc2UiLCJCIiwiaCIsImlfbWF4IiwibWF4X3ZhbCIsIkluZmluaXR5IiwidmFsIiwiaF92YWwiLCJpX3ZhbCIsImYiLCJCX3Jvd19yb3ciLCJCX2lfaiIsImpvaW4iLCJJIiwiQl9pIiwiQyIsImUiLCJsIiwiY29uY2F0Iiwicm93c19BIiwiY29sc19BIiwicm93c19CIiwiY29sc19CIiwiWCIsIm9mZnNldF9yb3ciLCJvZmZzZXRfY29sIiwic3RhcnRfcm93Iiwic3RhcnRfY29sIiwiZW5kX3JvdyIsImVuZF9jb2wiLCJuZXdfcm93IiwibmV3X2NvbCIsImdhdGhlciIsInJvd19pbmRpY2VzIiwiY29sX2luZGljZXMiLCJyb3dfaW5kZXgiLCJjb2xfaW5kZXgiLCJfYXBwbHlfYXJyYXkiLCJfYXBwbHlfcm93d2lzZV9hcnJheSIsIl9hcHBseV9jb2x3aXNlX2FycmF5IiwiX2FwcGx5IiwidmFsdWVfcm93cyIsInZhbHVlX2NvbHMiLCJhZGQiLCJhc0FycmF5IiwibWluX3Jvd19jb2wiLCJtaW4iLCJtZWFuIiwibWVhblJvd3MiLCJtZWFuQ29scyIsImJfaSIsInIiLCJkIiwieiIsImFscGhhIiwicl9uZXh0IiwiTCIsIlUiLCJMVSIsIkxfZGlhZyIsIlVfZGlhZyIsImRldCIsIk0iLCJNVCIsIk10TSIsIk1NdCIsIlYiLCJTaWdtYSIsInNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbiIsInNpZ21hIiwiX3NlZWQiLCJfTiIsIl9NIiwiX01BVFJJWF9BIiwiX1VQUEVSX01BU0siLCJfTE9XRVJfTUFTSyIsIl9tdCIsIl9tdGkiLCJEYXRlIiwiZ2V0VGltZSIsIm10IiwibXRpIiwicmFuZG9tX2ludCIsIm1hZzAxIiwia2siLCJOX00iLCJNX04iLCJjaG9pY2UiLCJzYW1wbGUiLCJpbmRleF9saXN0IiwibGluc3BhY2UiLCJyYW5kb21faW5kZXgiLCJzcGxpY2UiLCJ1bmRlZmluZWQiLCJIZWFwIiwiZWxlbWVudHMiLCJhY2Nlc3NvciIsImNvbXBhcmF0b3IiLCJoZWFwaWZ5IiwiX2FjY2Vzc29yIiwiX2NvbnRhaW5lciIsIl9jb21wYXJhdG9yIiwiaGVhcCIsImNvbnRhaW5lciIsImVsZW1lbnQiLCJmbG9vciIsIl9oZWFwaWZ5X2Rvd24iLCJfc3dhcCIsImluZGV4X2EiLCJpbmRleF9iIiwiX2hlYXBpZnlfdXAiLCJpbmRleCIsInBhcmVudEluZGV4Iiwibm9kZSIsInN0YXJ0X2luZGV4IiwibGVmdCIsInJpZ2h0IiwicG9wIiwiaXRlbSIsImZpcnN0IiwiaXRlcmF0ZSIsInRvQXJyYXkiLCJyYXdfZGF0YSIsImVtcHR5IiwiRGlzam9pbnRTZXQiLCJfbGlzdCIsIlNldCIsIm1ha2Vfc2V0IiwibGlzdCIsImhhcyIsIl9fZGlzam9pbnRfc2V0IiwicGFyZW50IiwiY2hpbGRyZW4iLCJzaXplIiwiZmluZCIsInVuaW9uIiwibm9kZV94Iiwibm9kZV95IiwiZm9yRWFjaCIsIkJhbGxUcmVlIiwiX05vZGUiLCJwaXZvdCIsImNoaWxkMSIsImNoaWxkMiIsInJhZGl1cyIsIl9MZWFmIiwicG9pbnRzIiwiX21ldHJpYyIsIl9yb290IiwiX2NvbnN0cnVjdCIsImMiLCJfZ3JlYXRlc3Rfc3ByZWFkIiwic29ydGVkX2VsZW1lbnRzIiwicF9pbmRleCIsInAiLCJzcHJlYWQiLCJyZWR1Y2UiLCJhY2MiLCJjdXJyZW50Iiwic2VhcmNoIiwiX3NlYXJjaCIsIktOTiIsIl9lbGVtZW50cyIsIl9EIiwiZGlzdGFuY2VzIiwiSCIsIm5lYXJlc3RfZWxlbWVudF9pbmRleCIsIm5lYXJlc3RfZGlzdCIsIk51bWJlciIsImlzSW50ZWdlciIsIkRSIiwiZGVmYXVsdF9wYXJhbWV0ZXJzIiwicGFyYW1ldGVycyIsIl9wYXJhbWV0ZXJzIiwiT2JqZWN0IiwiYXNzaWduIiwic2VhbCIsIl90eXBlIiwiX3JhbmRvbWl6ZXIiLCJfaXNfaW5pdGlhbGl6ZWQiLCJwYXJhbWV0ZXIiLCJuYW1lIiwiaGFzT3duUHJvcGVydHkiLCJwYXJhIiwidHJhbnNmb3JtIiwiY2hlY2tfaW5pdCIsInByb2plY3Rpb24iLCJnZW5lcmF0b3IiLCJpbml0IiwiWSIsImFzeW5jIiwiYXJncyIsIlBDQSIsInN1cGVyIiwiZWlnX2FyZ3MiLCJwcmluY2lwYWxfY29tcG9uZW50cyIsIm1lYW5zIiwiWF9jZW50IiwiTURTIiwiYWlfIiwiYV9qIiwiYV9fIiwiX2RfWCIsInN0cmVzcyIsImRfWCIsImRfWSIsInRvcF9zdW0iLCJib3R0b21fc3VtIiwicG93IiwiSVNPTUFQIiwibmVpZ2hib3JzIiwia05lYXJlc3ROZWlnaGJvcnMiLCJHIiwib3RoZXIiLCJGQVNUTUFQIiwiX2Nob29zZV9kaXN0YW50X29iamVjdHMiLCJhX2luZGV4IiwiYl9pbmRleCIsIm1heF9kaXN0IiwiZF9haSIsImRfYmkiLCJfY29sIiwib2xkX2Rpc3QiLCJkX2FiIiwieV9pIiwiTERBIiwibGFiZWxzIiwidW5pcXVlX2xhYmVscyIsImxhYmVsX2lkIiwiY291bnQiLCJpZCIsIlhfbWVhbiIsIlZfbWVhbiIsImxhYmVsIiwidl9tZWFuIiwiU19iIiwiU193Iiwicm93X3YiLCJMTEUiLCJrX25lYXJlc3RfbmVpZ2hib3JzIiwiTyIsIlciLCJuTl9yb3ciLCJaIiwiQ190cmFjZSIsInciLCJzb2x2ZV9DRyIsIklXIiwiTFRTQSIsIklfaSIsIlhfaSIsImciLCJHX2lfdCIsIldfaSIsIlRTTkUiLCJwZXJwbGV4aXR5IiwiZXBzaWxvbiIsIl9pdGVyIiwiSHRhcmdldCIsImxvZyIsIkRlbHRhIiwiZHJ1aWQiLCJQIiwiX3lzdGVwIiwiX2dhaW5zIiwicHJvdyIsImJldGFtaW4iLCJiZXRhbWF4IiwiZG9uZSIsIm51bSIsInBzdW0iLCJwaiIsImV4cCIsIkhoZXJlIiwiUG91dCIsIk4yIiwiX1AiLCJpdGVyYXRpb25zIiwibmV4dCIsIml0ZXIiLCJ5c3RlcCIsImdhaW5zIiwiZGltIiwicG11bCIsIlF1IiwicXN1bSIsImRzdW0iLCJkaGVyZSIsInF1IiwiZ3JhZCIsInByZW11bHQiLCJ5bWVhbiIsImdpZCIsInNpZCIsImdhaW5pZCIsIm5ld2dhaW4iLCJuZXdzaWQiLCJtYXhfaXRlciIsInBmeCIsImZ4IiwiY29udmVyZ2VuY2UiLCJmeGkiLCJkeCIsIlVNQVAiLCJuX25laWdoYm9ycyIsImxvY2FsX2Nvbm5lY3Rpdml0eSIsIm1pbl9kaXN0IiwiX3NwcmVhZCIsIl9zZXRfb3BfbWl4X3JhdGlvIiwiX3JlcHVsc2lvbl9zdHJlbmd0aCIsIl9uZWdhdGl2ZV9zYW1wbGVfcmF0ZSIsIl9uX2Vwb2NocyIsIl9pbml0aWFsX2FscGhhIiwiX2ZpbmRfYWJfcGFyYW1zIiwieHYiLCJ5diIsInh2X2kiLCJwb3dlbGwiLCJlcnJvciIsIl9jb21wdXRlX21lbWJlcnNoaXBfc3RyZW5ndGhzIiwic2lnbWFzIiwicmhvcyIsIl9zbW9vdGhfa25uX2Rpc3QiLCJrbm4iLCJTTU9PVEhfS19UT0xFUkFOQ0UiLCJNSU5fS19ESVNUX1NDQUxFIiwidGFyZ2V0IiwibG9nMiIsInJldmVyc2UiLCJ4X2kiLCJsbyIsImhpIiwibWlkIiwic2VhcmNoX3Jlc3VsdCIsIm5vbl96ZXJvX2Rpc3QiLCJmaWx0ZXIiLCJub25femVyb19kaXN0X2xlbmd0aCIsImludGVycG9sYXRpb24iLCJtZWFuX2l0aGQiLCJtZWFuX2QiLCJfZnV6enlfc2ltcGxpY2lhbF9zZXQiLCJkaXN0YW5jZXNfaSIsInRyYW5zcG9zZWRfcmVzdWx0IiwicHJvZF9tYXRyaXgiLCJfbWFrZV9lcG9jaHNfcGVyX3NhbXBsZSIsIm5fZXBvY2hzIiwid2VpZ2h0cyIsIl93ZWlnaHRzIiwiRmxvYXQzMkFycmF5IiwiZmlsbCIsIndlaWdodHNfbWF4Iiwibl9zYW1wbGVzIiwiX3RvY29vIiwiZ3JhcGgiLCJyb3dzX24iLCJjb2xzX24iLCJfYSIsIl9iIiwiX2dyYXBoIiwiX2hlYWQiLCJfdGFpbCIsIl9lcG9jaHNfcGVyX3NhbXBsZSIsIl9lcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZSIsIl9lcG9jaF9vZl9uZXh0X3NhbXBsZSIsIl9lcG9jaF9vZl9uZXh0X25lZ2F0aXZlX3NhbXBsZSIsIl9jbGlwIiwiX29wdGltaXplX2xheW91dCIsImhlYWRfZW1iZWRkaW5nIiwidGFpbF9lbWJlZGRpbmciLCJoZWFkIiwidGFpbCIsIl9kIiwiX2FscGhhIiwicmVwdWxzaW9uX3N0cmVuZ3RoIiwiZXBvY2hzX3Blcl9zYW1wbGUiLCJlcG9jaHNfcGVyX25lZ2F0aXZlX3NhbXBsZSIsImVwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlIiwiZXBvY2hfb2ZfbmV4dF9zYW1wbGUiLCJjbGlwIiwidGFpbF9sZW5ndGgiLCJncmFkX2NvZWZmIiwiZ3JhZF9kIiwibyIsIm5fbmVnX3NhbXBsZXMiLCJUcmlNYXAiLCJ3ZWlnaHRfYWRqIiwicGNhIiwibl9pbmxpZXJzIiwibl9vdXRsaWVycyIsIm5fcmFuZG9tIiwidHJpcGxldHMiLCJfZ2VuZXJhdGVfdHJpcGxldHMiLCJsciIsInZlbCIsImdhaW4iLCJuX2V4dHJhIiwibmJycyIsImtubl9kaXN0YW5jZXMiLCJzaWciLCJfZmluZF9wIiwiX3NhbXBsZV9rbm5fdHJpcGxldHMiLCJuX3RyaXBsZXRzIiwib3V0bGllcl9kaXN0YW5jZXMiLCJfZmluZF93ZWlnaHRzIiwicmFuZG9tX3RyaXBsZXRzIiwicmFuZG9tX3dlaWdodHMiLCJfc2FtcGxlX3JhbmRvbV90cmlwbGV0cyIsIm1heF93ZWlnaHQiLCJpc05hTiIsIm1heF93ZWlnaHRfMiIsIm5faSIsInNvcnRfaW5kaWNlcyIsIl9fYXJnc29ydCIsIm5faiIsInNpbSIsInNhbXBsZXMiLCJfcmVqZWN0aW9uX3NhbXBsZSIsIm91dCIsIm1heF9pbnQiLCJyZWplY3RzIiwiaW50ZXJ2YWwiLCJpbmRleE9mIiwicF9zaW0iLCJwX291dCIsImluZGljZXMiLCJfZ3JhZCIsInlfaWoiLCJ5X2lrIiwiZF9paiIsImRfaWsiLCJuX3Zpb2wiLCJsb3NzIiwibl9rbm5fdHJpcGxldHMiLCJZX2lkIiwiWV9qZCIsIllfa2QiLCJncyIsImdvIiwibWF4X2l0ZXJhdGlvbiIsIl9uZXh0IiwiZ2FtbWEiLCJvbGRfQyIsIl91cGRhdGVfZW1iZWRkaW5nIiwibmV3X2dhaW4iLCJIaWVyYXJjaGljYWxfQ2x1c3RlcmluZyIsIm1hdHJpeCIsImxpbmthZ2UiLCJfaWQiLCJfbWF0cml4IiwiX2xpbmthZ2UiLCJyb290IiwiZG8iLCJnZXRfY2x1c3RlcnMiLCJjbHVzdGVycyIsImRlcHRoIiwiX3RyYXZlcnNlIiwibGVhdmVzIiwiX24iLCJkX21pbiIsIl9kX21pbiIsIl9kaXN0YW5jZV9tYXRyaXgiLCJfY2x1c3RlcnMiLCJjX3NpemUiLCJfY19zaXplIiwiVWludDE2QXJyYXkiLCJDbHVzdGVyIiwicF9tYXgiLCJjMSIsIkRfaV9taW4iLCJjMiIsImMxX2NsdXN0ZXIiLCJjMl9jbHVzdGVyIiwiYzFfY2x1c3Rlcl9pbmRpY2VzIiwiaXNMZWFmIiwiYzJfY2x1c3Rlcl9pbmRpY2VzIiwibmV3X2NsdXN0ZXIiLCJ1bnNoaWZ0IiwiRF9jMV9qIiwiRF9jMl9qIiwiY2VudHJvaWQiLCJfY2FsY3VsYXRlX2NlbnRyb2lkIiwibF9zaXplIiwicl9zaXplIiwibF9jZW50cm9pZCIsInJfY2VudHJvaWQiLCJuZXdfY2VudHJvaWQiLCJkZXNjZW5kYW50cyIsImxlZnRfZGVzY2VuZGFudHMiLCJyaWdodF9kZXNjZW5kYW50cyIsIktNZWFucyIsIksiLCJfSyIsIl9jbHVzdGVyX2NlbnRyb2lkcyIsIl9nZXRfcmFuZG9tX2NlbnRyb2lkcyIsIl9mdXJ0aGVzdF9wb2ludCIsImNhbmRpZGF0ZXMiLCJBZCIsImNsdXN0ZXJfY2VudHJvaWRzIiwicmFuZG9tX3BvaW50IiwiaW5pdF9wb2ludHMiLCJzYW1wbGVfc2l6ZSIsImZ1cnRoZXN0X3BvaW50IiwiX2l0ZXJhdGlvbiIsImNsdXN0ZXJzX2NoYW5nZWQiLCJBaSIsIm1pbl9jbHVzdGVyIiwiX2NvbXB1dGVfY2VudHJvaWQiLCJjbHVzdGVyX2NvdW50ZXIiLCJjaSIsIml0ZXJhdGlvbl9yZXN1bHQiLCJLTWVkb2lkcyIsIl9BIiwiX21heF9pdGVyIiwibG9nMTAiLCJfY2x1c3Rlcl9tZWRvaWRzIiwiX2dldF9yYW5kb21fbWVkb2lkcyIsInhfaiIsIl9uZWFyZXN0X21lZG9pZCIsImluZGV4X25lYXJlc3QiLCJtZWRvaWRzIiwiZmluaXNoIiwiY2FjaGUiLCJ4X28iLCJEZWx0YVREIiwieHMiLCJmaW5kSW5kZXgiLCJkX2oiLCJkaXN0YW5jZV9uZWFyZXN0IiwiZGVsdGFURCIsImRfb2oiLCJfZ2V0X2Rpc3RhbmNlIiwiZF9uIiwiZGlzdGFuY2Vfc2Vjb25kIiwiZF9zIiwibmVhcmVzdCIsInNlY29uZCIsInhfbSIsIm0xIiwibTIiLCJpbmRleF9zZWNvbmQiLCJjbHVzdGVyX21lZG9pZHMiLCJjZWlsIiwiVEQiLCJURDAiLCJTIiwiU19qIiwiU19vIiwiZGVsdGEiLCJPUFRJQ1MiLCJtaW5fcG9pbnRzIiwiX2Vwc2lsb24iLCJfbWluX3BvaW50cyIsIl9vcmRlcmVkX2xpc3QiLCJfREIiLCJvcmRlcmVkX2xpc3QiLCJEQiIsImNsdXN0ZXJfaW5kZXgiLCJfY2x1c3Rlcl9pbmRleCIsInJlYWNoYWJpbGl0eV9kaXN0YW5jZSIsInByb2Nlc3NlZCIsIl9nZXRfbmVpZ2hib3JzIiwiX2NvcmVfZGlzdGFuY2UiLCJzZWVkcyIsIl91cGRhdGUiLCJfZXhwYW5kX2NsdXN0ZXIiLCJjb3JlX2Rpc3RhbmNlIiwibmV3X3JlYWNoYWJpbGl0eV9kaXN0YW5jZSIsImNsdXN0ZXIiLCJvdXRsaWVycyIsImdldF9jbHVzdGVyX2FmZmlybWF0aW9uIiwiTFNQIiwiY29udHJvbF9wb2ludHMiLCJEUl9wYXJhbWV0ZXJzIiwibmMiLCJjX2kiLCJZX0MiLCJYQSIsIkFUIiwiQVRBIiwiQVRiIiwiVG9wb01hcCIsIl9fbGF6eV9kaXN0YW5jZV9tYXRyaXgiLCJEX2lqIiwiX21ha2VfbWluaW11bV9zcGFubmluZ190cmVlIiwiZGlzam9pbnRfc2V0IiwiRiIsIkUiLCJzZXRfdSIsInNldF92IiwiX0Vtc3QiLCJfX2h1bGxfY3Jvc3MiLCJheCIsImF5IiwiYngiLCJieSIsInN4Iiwic3kiLCJfX2h1bGwiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImxvd2VyIiwidXBwZXIiLCJfX2ZpbmRBbmdsZSIsInAxeCIsInAxeSIsInAyeCIsInAyeSIsInNpbiIsImNvcyIsInZlYyIsIl9fYWxpZ25faHVsbCIsImh1bGwiLCJ0b3BFZGdlIiwiZDIiLCJ2MSIsInYyIiwidHJhbnNmb3JtYXRpb24iLCJ0eCIsInR5IiwiX190cmFuc2Zvcm0iLCJweCIsInB5IiwiX190cmFuc2Zvcm1fY29tcG9uZW50IiwieU9mZnNldCIsImN4IiwiY3kiLCJfX2FsaWduX2NvbXBvbmVudHMiLCJwb2ludHNfdSIsInBvaW50c192IiwiaHVsbF91IiwiaHVsbF92IiwidF91IiwidF92IiwiRW1zdCIsImNvbXBvbmVudHMiLCJjb21wb25lbnRfdSIsImNvbXBvbmVudF92IiwiU0FNTU9OIiwibWFnaWMiLCJpbml0X0RSIiwiaW5pdF9wYXJhbWV0ZXJzIiwiaW5jbHVkZXMiLCJfc3RlcCIsIk1BR0lDIiwiZTEiLCJlMiIsIllpIiwiWWoiLCJkWSIsImRYIiwiZHEiLCJkciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBU2UsbUJBQVVBLEVBQUdDLEdBQ3hCLE9BQU9DLEtBQUtDLEtBQUtDLGtCQUFrQkosRUFBR0M7Ozs7Ozs7O0dDRjNCLG1CQUFVSSxHQUNyQixJQUdJQyxFQUFHQyxFQUhIQyxFQUFJSCxFQUFTSSxPQUNiQyxFQUFNLEVBQ05DLEVBQWUsRUFHbkIsSUFBSyxJQUFJQyxFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQ3JCTixFQUFJRCxFQUFTTyxHQUFLRCxFQUNsQkosRUFBSUcsRUFBTUosRUFDVkssRUFBZUosRUFBSUcsRUFBTUosRUFDekJJLEVBQU1ILEVBRVYsT0FBT0c7Ozs7Ozs7O0dDWkkscUJBQVVMLEdBQ3JCLElBQUlHLEVBQUlILEVBQVNJLE9BQ2JDLEVBQU0sRUFDTkMsRUFBZSxFQUVuQixJQUFLLElBQUlDLEVBQUksRUFBR0EsRUFBSUosSUFBS0ksRUFBRyxDQUN4QixJQUFJQyxFQUFVUixFQUFTTyxHQUNuQkwsRUFBSUcsRUFBTUcsRUFDVlgsS0FBS1ksSUFBSUosSUFBUVIsS0FBS1ksSUFBSUQsR0FDMUJGLEdBQWdCRCxFQUFNSCxFQUFJTSxFQUUxQkYsR0FBZ0JFLEVBQVVOLEVBQUlHLEVBRWxDQSxFQUFNSCxFQUVWLE9BQU9HLEVBQU1DOzs7Ozs7OztHQ2RGLDJCQUFVWCxFQUFHQyxHQUN4QixHQUFJRCxFQUFFUyxRQUFVUixFQUFFUSxPQUFRLE9BQzFCLElBQUlELEVBQUlSLEVBQUVTLE9BQ05NLEVBQUksSUFBSUMsTUFBTVIsR0FDbEIsSUFBSyxJQUFJSSxFQUFJLEVBQUdBLEVBQUlKLElBQUtJLEVBQUcsQ0FDeEIsSUFBSUssRUFBSWpCLEVBQUVZLEdBQ05O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
