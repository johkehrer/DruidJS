// https://renecutura.eu v0.5.1 Copyright 2022 Rene Cutura
/**
 * Computes the euclidean distance (l<sub>2</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias euclidean
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the euclidean distance between {@link a} and {@link b}.
 */
function euclidean(t,e){return Math.sqrt(euclidean_squared(t,e))}
/**
 * Numerical stable summation with the Kahan summation algorithm.
 * @memberof module:numerical
 * @alias kahan_sum
 * @param {Array} summands - Array of values to sum up.
 * @returns {number} The sum.
 * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm}
 */function kahan_sum(t){let e,r,s=t.length,i=0,n=0;for(let o=0;o<s;++o)e=t[o]-n,r=i+e,n=r-i-e,i=r;return i}
/**
 * Numerical stable summation with the Neumair summation algorithm.
 * @memberof module:numerical
 * @alias neumair_sum
 * @param {Array} summands - Array of values to sum up.
 * @returns {number} The sum.
 * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements}
 */function neumair_sum(t){let e=t.length,r=0,s=0;for(let i=0;i<e;++i){let e=t[i],n=r+e;Math.abs(r)>=Math.abs(e)?s+=r-n+e:s+=e-n+r,r=n}return r+s}
/**
 * Computes the squared euclidean distance (l<sub>2</sub><sup>2</sup>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias euclidean_squared
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the squared euclidean distance between {@link a} and {@link b}.
 */function euclidean_squared(t,e){if(t.length!=e.length)return;let r=t.length,s=new Array(r);for(let i=0;i<r;++i){let r=t[i],n=e[i];s[i]=(r-n)*(r-n)}return neumair_sum(s)}
/**
 * Computes the cosine distance (not similarity) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias cosine
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @example
 * druid.cosine([1,0],[1,1]) == 0.7853981633974484 == π/4
 * @returns {Number} The cosine distance between {@link a} and {@link b}.
 */function cosine(t,e){if(t.length!==e.length)return;let r=t.length,s=0,i=0,n=0;for(let o=0;o<r;++o)s+=t[o]*e[o],i+=t[o]*t[o],n+=e[o]*e[o];return Math.acos(s/(Math.sqrt(i)*Math.sqrt(n)))}
/**
 * Computes the manhattan distance (l<sub>1</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias manhattan
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the manhattan distance between {@link a} and {@link b}.
 */function manhattan(t,e){if(t.length!=e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i]);return s}
/**
 * Computes the chebyshev distance (L<sub>∞</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias chebyshev
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the chebyshev distance between {@link a} and {@link b}.
 */function chebyshev(t,e){if(t.length!=e.length)return;let r=t.length,s=[];for(let i=0;i<r;++i)s.push(Math.abs(t[i]-e[i]));return Math.max(...s)}
/**
 * Computes the canberra distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias canberra
 * @param {Array<Number>} a 
 * @param {Array<Number>} b 
 * @returns {Number} The canberra distance between {@link a} and {@link b}.
 * @see {@link https://en.wikipedia.org/wiki/Canberra_distance}
 */function canberra(t,e){if(t.length!==e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i])/(Math.abs(t[i])+Math.abs(e[i]));return s}
/**
 * Computes the jaccard distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias jaccard
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the jaccard distance between {@link a} and {@link b}.
 */function jaccard(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,i=0;for(let n=0;n<r;++n){const r=0!=t[n],o=0!=e[n];s+=r||o,i+=r&&o}return(s-i)/s}
/**
 * Computes the hamming distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias hamming
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the hamming distance between {@link a} and {@link b}.
 */function hamming(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let i=0;i<r;++i){s+=t[i]!=e[i]}return s/r}
/**
 * Computes the Sokal-Michener distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias sokal_michener
 * @param {Array<Number>} a 
 * @param {Array<Number>} b 
 * @returns {Number} the Sokal-Michener distance between {@link a} and {@link b}.  
 */function sokal_michener(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let i=0;i<r;++i){s+=0!=t[i]!=(0!=e[i])}return 2*s/(r+s)}
/**
 * Computes the yule distance between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias yule
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the yule distance between {@link a} and {@link b}.
 */function yule(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,i=0,n=0;for(let o=0;o<r;++o){const r=0!=t[o],a=0!=e[o];s+=r&&a,i+=r&&!a,n+=!r&&r}return 0==i||0==n?0:2*i*n/(s*(r-s-i-n)+i*n)}
/**
 * Computes the k-nearest neighbors of each row of {@link A}.
 * @memberof module:matrix
 * @alias k_nearest_neigbhors
 * @param {Matrix} A - Either the data matrix, or a distance matrix.
 * @param {Number} k - The number of neighbors to compute.
 * @param {Function|"precomputed"} [metric=euclidean]
 * @returns {Array<Object>} -
 */function k_nearest_neighbors(t,e,r=euclidean){const s=t.shape[0];let i="precomputed"==r?t:distance_matrix(t,r),n=new Array(s);for(let t=0;t<s;++t)n[t]=Array.from(i.row(t)).map(((e,r)=>({i:t,j:r,distance:e}))).sort(((t,e)=>t.distance-e.distance)).slice(1,e+1);return n}
/**
 * Computes the distance matrix of datamatrix {@link A}.
 * @memberof module:matrix
 * @alias distance_matrix
 * @param {Matrix} A - Matrix.
 * @param {Function} [metric=euclidean] - The diistance metric.
 * @returns {Matrix} D - The distance matrix of {@link A}.
 */function distance_matrix(t,e=euclidean){let r=t.shape[0];const s=new Matrix(r,r);for(let i=0;i<r;++i){const n=t.row(i);for(let o=i+1;o<r;++o){const r=e(n,t.row(o));s.set_entry(i,o,r),s.set_entry(o,i,r)}}return s}
/**
 * Creates an Array containing {@link number} numbers from {@link start} to {@link end}.
 * If <code>{@link number} = null</null>.
 * @memberof module:matrix
 * @alias linspace
 * @param {Number} start - Start value.
 * @param {Number} end - End value.
 * @param {Number} [number = null] - Number of number between {@link start} and {@link end}.
 * @returns {Array} - An array with {@link number} entries, beginning at {@link start} ending at {@link end}.
 */function linspace(t,e,r=null){if(r||(r=Math.max(Math.round(e-t)+1,1)),r<2)return 1===r?[t]:[];let s=new Array(r);for(let i=r-=1;i>=0;--i)s[i]=(i*e+(r-i)*t)/r;return s}
//import { neumair_sum } from "../numerical/index";
/**
 * Computes the norm of a vector, by computing its distance to **0**.
 * @memberof module:matrix
 * @alias norm
 * @param {Matrix|Array<Number>|Float64Array} v - Vector. 
 * @param {Function} [metric = euclidean] - Which metric should be used to compute the norm.
 * @returns {Number} - The norm of {@link v}.
 */function norm(t,e=euclidean){let r=null;if(t instanceof Matrix){let[e,s]=t.shape;if(1===e)r=t.row(0);else{if(1!==s)throw new Error("Matrix must be 1d!");r=t.col(0)}}else r=t;const s=r.length;return e(r,Float64Array.from({length:s},(()=>0)))}
/**
 * Normalizes Vector {@link v}.
 * @memberof module:matrix
 * @alias normalize
 * @param {Array<Number>|Float64Array} v - Vector
 * @param {Function} metric 
 * @returns {Array<Number>|Float64Array} - The normalized vector with length 1.
 */function normalize(t,e=euclidean){const r=norm(t,e);return t.map((t=>t/r))}
/**
 * Computes the QR Decomposition of the Matrix {@link A} using Gram-Schmidt process.
 * @memberof module:linear_algebra
 * @alias qr
 * @param {Matrix} A
 * @returns {{R: Matrix, Q: Matrix}}
 * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_the_Gram%E2%80%93Schmidt_process}
 */function qr_gramschmidt(t){const[e,r]=t.shape,s=new Matrix(e,r,"identity"),i=new Matrix(r,r,0);for(let n=0;n<r;++n){let r=t.col(n);for(let t=0;t<n;++t){const e=s.col(t),o=neumair_sum(e.map(((t,e)=>t*r[e])));i.set_entry(t,n,o),r=r.map(((t,r)=>t-o*e[r]))}const o=norm(r,euclidean);for(let t=0;t<e;++t)s.set_entry(t,n,r[t]/o);i.set_entry(n,n,o)}return{R:i,Q:s}}
/**
 * Computes the QR Decomposition of the Matrix {@link A} with householder transformations.
 * @memberof module:linear_algebra
 * @alias qr_householder
 * @param {Matrix} A
 * @returns {{R: Matrix, Q: Matrix}}
 * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections}
 * @see {@link http://mlwiki.org/index.php/Householder_Transformation}
 */function qr_householder(t){const[e,r]=t.shape,s=new Matrix(e,e,"I"),i=t.clone();for(let t=0;t<r;++t){const e=Matrix.from(i.col(t).slice(t)),r=norm(e),n=e.entry(0,0),o=-Math.sign(n),a=n-o*r,h=e.divide(a).set_entry(0,0,1),l=-o*a/r,_=h.outer(h),c=i.get_block(t,0),u=c.sub(_.dot(c).mult(l)),d=s.get_block(0,t),m=d.sub(d.dot(_).mult(l));i.set_block(t,0,u),s.set_block(0,t,m)}return{R:i,Q:s}}
/**
 * Computes the {@link k} biggest Eigenvectors and Eigenvalues from Matrix {@link A} with the QR-Algorithm.
 * @memberof module:linear_algebra
 * @alias simultaneous_poweriteration
 * @param {Matrix} A - The Matrix
 * @param {Number} k - The number of eigenvectors and eigenvalues to compute.
 * @param {Object} parameters - Object containing parameterization of the simultanious poweriteration method.
 * @param {Number} [parameters.max_iterations=100] - The number of maxiumum iterations the algorithm should run.
 * @param {Number|Randomizer} [parameters.seed=1212] - The seed value or a randomizer used in the algorithm.
 * @param {Function} [parameters.qr=qr_gramschmidt] - The QR technique to use.
 * @param {Number} [parameters.tol=1e-8] - Allowed error for stopping criteria
 * @returns {{eigenvalues: Array, eigenvectors: Array}} - The {@link k} biggest eigenvectors and eigenvalues of Matrix {@link A}.
 */function simultaneous_poweriteration(t,e=2,{seed:r=1212,max_iterations:s=100,qr:i=qr_gramschmidt,tol:n=1e-8}={}){const o=r instanceof Randomizer?r:new Randomizer(r);t instanceof Matrix||(t=Matrix.from(t));const a=t.shape[0];let{Q:h,R:l}=i(new Matrix(a,e,(()=>2*(o.random-.5))));for(;s--;){const e=h.clone(),r=i(t.dot(h));h=r.Q,l=r.R;if(euclidean_squared(h.values,e.values)<n)break}return{eigenvalues:l.diag,eigenvectors:h.transpose().to2dArray}}
/**
 * Computes the inner product between two arrays of the same length.
 * @memberof module:linear_algebra
 * @alias inner_product
 * @param {Array|Float64Array} a - Array a
 * @param {Array|Float64Array} b - Array b
 * @returns The inner product between {@link a} and {@link b}
 */function inner_product(t,e){const r=t.length;if(r!=e.length)throw new Error("Array a and b must have the same length!");let s=0;for(let i=0;i<r;++i)s+=t*e;return s}
/**
 * @class
 * @alias Matrix
 * @requires module:numerical/neumair_sum
 */class Matrix{
/**
     * creates a new Matrix. Entries are stored in a Float64Array.
     * @constructor
     * @memberof module:matrix
     * @alias Matrix
     * @param {number} rows - The amount of rows of the matrix.
     * @param {number} cols - The amount of columns of the matrix.
     * @param {(function|string|number)} value=0 - Can be a function with row and col as parameters, a number, or "zeros", "identity" or "I", or "center".
     *  - **function**: for each entry the function gets called with the parameters for the actual row and column.
     *  - **string**: allowed are
     *      - "zero", creates a zero matrix.
     *      - "identity" or "I", creates an identity matrix.
     *      - "center", creates an center matrix.
     *  - **number**: create a matrix filled with the given value.
     * @example
     *
     * let A = new Matrix(10, 10, () => Math.random()); //creates a 10 times 10 random matrix.
     * let B = new Matrix(3, 3, "I"); // creates a 3 times 3 identity matrix.
     * @returns {Matrix} returns a {@link rows} times {@link cols} Matrix filled with {@link value}.
     */
constructor(t=null,e=null,r=null){if(this._rows=t,this._cols=e,this._data=null,t&&e){if(!r)return this._data=new Float64Array(t*e),this;if("function"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}if("string"==typeof r){if("zeros"===r)return new Matrix(t,e,0);if("identity"===r||"I"===r){this._data=new Float64Array(t*e);for(let r=0;r<t;++r)this._data[r*e+r]=1;return this}if("center"===r&&t==e){this._data=new Float64Array(t*e),r=(e,r)=>(e===r?1:0)-1/t;for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}}if("number"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r;return this}}return this}
/**
     * Creates a Matrix out of {@link A}.
     * @param {(Matrix|Array|Float64Array|number)} A - The matrix, array, or number, which should converted to a Matrix.
     * @param {"row"|"col"|"diag"} [type = "row"] - If {@link A} is a Array or Float64Array, then type defines if it is a row- or a column vector.
     * @returns {Matrix}
     *
     * @example
     * let A = Matrix.from([[1, 0], [0, 1]]); //creates a two by two identity matrix.
     * let S = Matrix.from([1, 2, 3], "diag"); // creates a 3 by 3 matrix with 1, 2, 3 on its diagonal. [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
     */static from(t,e="row"){if(t instanceof Matrix)return t.clone();if(!(Array.isArray(t)||t instanceof Float64Array)){if("number"==typeof t)return new Matrix(1,1,t);throw new Error("error")}{let r=t.length;if(0===r)throw new Error("Array is empty");
// 1d
if(!(Array.isArray(t[0])||t[0]instanceof Float64Array)){if("row"===e)return new Matrix(1,r,((e,r)=>t[r]));
// 2d
if("col"===e)return new Matrix(r,1,(e=>t[e]));if("diag"===e)return new Matrix(r,r,((e,r)=>e==r?t[e]:0));throw new Error("1d array has NaN entries")}if(Array.isArray(t[0])||t[0]instanceof Float64Array){let e=t[0].length;for(let s=0;s<r;++s)if(t[s].length!==e)throw new Error("various array lengths");return new Matrix(r,e,((e,r)=>t[e][r]))}}}
/**
     * Returns the {@link row}<sup>th</sup> row from the Matrix.
     * @param {Number} row
     * @returns {Float64Array}
     */row(t){const e=this.values,r=this._cols;return e.subarray(t*r,(t+1)*r)}
/**
     * Returns an generator yielding each row of the Matrix.
     * @yields {Float64Array}
     */*iterate_rows(){const t=this._cols,e=this._rows,r=this.values;for(let s=0;s<e;++s)yield r.subarray(s*t,(s+1)*t)}
/**
     * Makes a {@link Matrix} object an iterable object.
     * @yields {Float64Array}
     */*[Symbol.iterator](){for(const t of this.iterate_rows())yield t}
/**
     * Sets the entries of {@link row}<sup>th</sup> row from the Matrix to the entries from {@link values}.
     * @param {int} row
     * @param {Array} values
     * @returns {Matrix}
     */set_row(t,e){let r=this._cols;if(Array.isArray(e)&&e.length===r){let s=t*r;for(let t=0;t<r;++t)this.values[s+t]=e[t]}else if(e instanceof Matrix&&e.shape[1]===r&&1===e.shape[0]){let s=t*r;for(let t=0;t<r;++t)this.values[s+t]=e._data[t]}return this}
/**
     * Returns the {@link col}<sup>th</sup> column from the Matrix.
     * @param {int} col
     * @returns {Array}
     */col(t){let e=new Float64Array(this._rows);for(let r=0;r<this._rows;++r)e[r]=this.values[r*this._cols+t];return e}
/**
     * Returns the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix.
     * @param {int} row
     * @param {int} col
     * @returns {float64}
     */entry(t,e){return this.values[t*this._cols+e]}
/**
     * Sets the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix to the given {@link value}.
     * @param {int} row
     * @param {int} col
     * @param {float64} value
     * @returns {Matrix}
     */set_entry(t,e,r){return this.values[t*this._cols+e]=r,this}
/**
     * Returns a new transposed Matrix.
     * @returns {Matrix}
     */transpose(){return new Matrix(this._cols,this._rows,((t,e)=>this.entry(e,t)))}
/**
     * Returns a new transposed Matrix. Short-form of {@function transpose}.
     * @returns {Matrix}
     */get T(){return this.transpose()}
/**
     * Returns the inverse of the Matrix.
     * @returns {Matrix}
     */inverse(){const t=this._rows,e=this._cols;let r=new Matrix(t,2*e,((t,r)=>r>=e?t===r-e?1:0:this.entry(t,r))),s=0,i=0;for(;s<t&&i<e;){var n=0;let o=-1/0;for(let e=s;e<t;++e){let t=Math.abs(r.entry(e,i));o<t&&(n=e,o=t)}if(0==r.entry(n,i))i++;else{
// swap rows
for(let t=0;t<2*e;++t){let e=r.entry(s,t),i=r.entry(n,t);r.set_entry(s,t,e),r.set_entry(n,t,i)}for(let n=s+1;n<t;++n){let t=r.entry(n,i)/r.entry(s,i);r.set_entry(n,i,0);for(let o=i+1;o<2*e;++o)r.set_entry(n,o,r.entry(n,o)-r.entry(s,o)*t)}s++,i++}}for(let s=0;s<t;++s){let t=r.entry(s,s);for(let i=s;i<2*e;++i)r.set_entry(s,i,r.entry(s,i)/t)}for(let s=t-1;s>=0;--s){let t=r.entry(s,s);for(let i=0;i<s;i++){let n=r.entry(i,s)/t;for(let t=i;t<2*e;++t){let e=r.entry(i,t);e-=r.entry(s,t)*n,r.set_entry(i,t,e)}}}return new Matrix(t,e,((t,s)=>r.entry(t,s+e)))}
/**
     * Returns the dot product. If {@link B} is an Array or Float64Array then an Array gets returned. If {@link B} is a Matrix then a Matrix gets returned.
     * @param {(Matrix|Array|Float64Array)} B the right side
     * @returns {(Matrix|Array)}
     */dot(t){if(t instanceof Matrix){let e=this;if(e.shape[1]!==t.shape[0])throw new Error(`A.dot(B): A is a ${e.shape.join(" ⨯ ")}-Matrix, B is a ${t.shape.join(" ⨯ ")}-Matrix: \n                A has ${e.shape[1]} cols and B ${t.shape[0]} rows. \n                Must be equal!`);let r=e.shape[1];return new Matrix(e.shape[0],t.shape[1],((s,i)=>{const n=e.row(s),o=t.col(i);let a=0;for(let t=0;t<r;++t)a+=n[t]*o[t];return a}))}if(Array.isArray(t)||t instanceof Float64Array){let e=this._rows;if(t.length!==e)throw new Error(`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`);let r=new Array(e);for(let s=0;s<e;++s)r[s]=neumair_sum(this.row(s).map((e=>e*t[s])));return r}throw new Error("B must be Matrix or Array")}
/**
     * Computes the outer product from {@link this} and {@link B}.
     * @param {Matrix} B
     * @returns {Matrix}
     */outer(t){let e=this,r=e._data.length;if(r!=t._data.length)return;let s=new Matrix;return s.shape=[r,r,(r,i)=>r<=i?e._data[r]*t._data[i]:s.entry(i,r)],s}
/**
     * Appends matrix {@link B} to the matrix.
     * @param {Matrix} B - matrix to append.
     * @param {"horizontal"|"vertical"|"diag"} [type = "horizontal"] - type of concatenation.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 1], [1, 1]]); // 2 by 2 matrix filled with ones.
     * let B = Matrix.from([[2, 2], [2, 2]]); // 2 by 2 matrix filled with twos.
     *
     * A.concat(B, "horizontal"); // 2 by 4 matrix. [[1, 1, 2, 2], [1, 1, 2, 2]]
     * A.concat(B, "vertical"); // 4 by 2 matrix. [[1, 1], [1, 1], [2, 2], [2, 2]]
     * A.concat(B, "diag"); // 4 by 4 matrix. [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 2, 2], [0, 0, 2, 2]]
     */concat(t,e="horizontal"){const r=this,[s,i]=r.shape,[n,o]=t.shape;if("horizontal"==e){if(s!=n)throw new Error(`A.concat(B, "horizontal"): A and B need same number of rows, A has ${s} rows, B has ${n} rows.`);const e=new Matrix(s,i+o,"zeros");return e.set_block(0,0,r),e.set_block(0,i,t),e}if("vertical"==e){if(i!=o)throw new Error(`A.concat(B, "vertical"): A and B need same number of columns, A has ${i} columns, B has ${o} columns.`);const e=new Matrix(s+n,i,"zeros");return e.set_block(0,0,r),e.set_block(s,0,t),e}if("diag"==e){const e=new Matrix(s+n,i+o,"zeros");return e.set_block(0,0,r),e.set_block(s,i,t),e}throw new Error(`type must be "horizontal" or "vertical", but type is ${e}!`)}
/**
     * Writes the entries of B in A at an offset position given by {@link offset_row} and {@link offset_col}.
     * @param {int} offset_row
     * @param {int} offset_col
     * @param {Matrix} B
     * @returns {Matrix}
     */set_block(t,e,r){let[s,i]=r.shape;for(let n=0;n<s;++n)if(!(n>this._rows))for(let s=0;s<i;++s)s>this._cols||this.set_entry(n+t,s+e,r.entry(n,s));return this}
/**
     * Extracts the entries from the {@link start_row}<sup>th</sup> row to the {@link end_row}<sup>th</sup> row, the {@link start_col}<sup>th</sup> column to the {@link end_col}<sup>th</sup> column of the matrix.
     * If {@link end_row} or {@link end_col} is empty, the respective value is set to {@link this.rows} or {@link this.cols}.
     * @param {Number} start_row
     * @param {Number} start_col
     * @param {Number} [end_row = null]
     * @param {Number} [end_col = null]
     * @returns {Matrix} Returns a end_row - start_row times end_col - start_col matrix, with respective entries from the matrix.
     * @example
     *
     * let A = Matrix.from([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); // a 3 by 3 matrix.
     *
     * A.get_block(1, 1); // [[5, 6], [8, 9]]
     * A.get_block(0, 0, 1, 1); // [[1]]
     * A.get_block(1, 1, 2, 2); // [[5]]
     * A.get_block(0, 0, 2, 2); // [[1, 2], [4, 5]]
     */get_block(t,e,r=null,s=null){const[i,n]=this.shape;if(s=s??n,(r=r??i)<=t||s<=e)throw new Error(`\n                end_row must be greater than start_row, and \n                end_col must be greater than start_col, but\n                end_row = ${r}, start_row = ${t}, end_col = ${s}, and start_col = ${e}!`);const o=new Matrix(r-t,s-e,"zeros");for(let i=t,n=0;i<r;++i,++n)for(let t=e,r=0;t<s;++t,++r)o.set_entry(n,r,this.entry(i,t));return o;
//return new Matrix(end_row - start_row, end_col - start_col, (i, j) => this.entry(i + start_row, j + start_col));
}
/**
     * Returns a new array gathering entries defined by the indices given by argument.
     * @param {Array<Number>} row_indices - Array consists of indices of rows for gathering entries of this matrix
     * @param {Array<Number>} col_indices  - Array consists of indices of cols for gathering entries of this matrix
     * @returns {Matrix}
     */gather(t,e){const r=t.length,s=e.length,i=new Matrix(r,s);for(let s=0;s<r;++s){const n=t[s];for(let t=0;t<r;++t){const r=e[t];i.set_entry(s,t,this.entry(n,r))}}return i}
/**
     * Applies a function to each entry of the matrix.
     * @private
     * @param {function} f function takes 2 parameters, the value of the actual entry and a value given by the function {@link v}. The result of {@link f} gets writen to the Matrix.
     * @param {function} v function takes 2 parameters for row and col, and returns a value witch should be applied to the colth entry of the rowth row of the matrix.
     */_apply_array(t,e){const r=this.values,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o;r[i]=t(r[i],e(n,o))}}return this}_apply_rowwise_array(t,e){return this._apply_array(e,((e,r)=>t[r]))}_apply_colwise_array(t,e){const r=this.values,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o;r[i]=e(r[i],t[n])}}return this}_apply(t,e){let r=this.values;if(t instanceof Matrix){let[s,i]=t.shape,[n,o]=this.shape;if(1===s){if(o!==i)throw new Error("cols !== value_cols");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(0,i))}else if(1===i){if(n!==s)throw new Error("rows !== value_rows");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,0))}else{if(n!=s||o!=i)throw new Error("error");for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,i))}}else if(Array.isArray(t)){let s=this._rows,i=this._cols;if(t.length===s)for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[n]);else{if(t.length!==i)throw new Error("error");for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[s])}}else for(let s=0,i=this._rows*this._cols;s<i;++s)r[s]=e(r[s],t);return this}
/**
     * Clones the Matrix.
     * @returns {Matrix}
     */clone(){let t=new Matrix;return t._rows=this._rows,t._cols=this._cols,t._data=this.values.slice(0),t}
/**
     * Entrywise multiplication with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.mult(2); // [[2, 4], [6, 8]];
     * A.mult(B); // [[1, 4], [9, 16]];
     */mult(t){return this.clone()._apply(t,((t,e)=>t*e))}
/**
     * Entrywise division with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.divide(2); // [[0.5, 1], [1.5, 2]];
     * A.divide(B); // [[1, 1], [1, 1]];
     */divide(t){return this.clone()._apply(t,((t,e)=>t/e))}
/**
     * Entrywise addition with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.add(2); // [[3, 4], [5, 6]];
     * A.add(B); // [[2, 4], [6, 8]];
     */add(t){return this.clone()._apply(t,((t,e)=>t+e))}
/**
     * Entrywise subtraction with {@link value}.
     * @param {Matrix|Array|Number} value
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.sub(2); // [[-1, 0], [1, 2]];
     * A.sub(B); // [[0, 0], [0, 0]];
     */sub(t){return this.clone()._apply(t,((t,e)=>t-e))}
/**
     * Returns the number of rows and columns of the Matrix.
     * @returns {Array} An Array in the form [rows, columns].
     */get shape(){return[this._rows,this._cols]}
/**
     * Returns the matrix in the given shape with the given function which returns values for the entries of the matrix.
     * @param {Array} parameter - takes an Array in the form [rows, cols, value], where rows and cols are the number of rows and columns of the matrix, and value is a function which takes two parameters (row and col) which has to return a value for the colth entry of the rowth row.
     * @returns {Matrix}
     */set shape([t,e,r=(()=>0)]){this._rows=t,this._cols=e,this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}
/**
     * Returns the Matrix as a Array of Float64Arrays.
     * @returns {Array<Float64Array>}
     */get to2dArray(){const t=[];for(const e of this.iterate_rows())t.push(e);return t}
/**
     * Returns the Matrix as a Array of Arrays.
     * @returns {Array<Array>}
     */get asArray(){const t=[];for(const e of this.iterate_rows())t.push(Array.from(e));return t}
/**
     * Returns the diagonal of the Matrix.
     * @returns {Float64Array}
     */get diag(){const t=this._rows,e=this._cols,r=Math.min(t,e);let s=new Float64Array(r);for(let t=0;t<r;++t)s[t]=this.entry(t,t);return s}
/**
     * Returns the mean of all entries of the Matrix.
     * @returns {Number}
     */get mean(){return this.sum/(this._rows*this._cols)}
/**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Number}
     */get sum(){return neumair_sum(this.values)}
/**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Float64Array}
     */get values(){return this._data}
/**
     * Returns the mean of each row of the matrix.
     * @returns {Float64Array}
     */get meanRows(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:e});for(let i=0;i<e;++i){s[i]=0;for(let e=0;e<r;++e)s[i]+=t[i*r+e];s[i]/=r}return s}
/** Returns the mean of each column of the matrix.
     * @returns {Float64Array}
     */get meanCols(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:r});for(let i=0;i<r;++i){s[i]=0;for(let n=0;n<e;++n)s[i]+=t[n*r+i];s[i]/=e}return s}
/**
     * Solves the equation {@link A}x = {@link b} using the conjugate gradient method. Returns the result x.
     * @param {Matrix} A - Matrix
     * @param {Matrix} b - Matrix
     * @param {Randomizer} [randomizer=null]
     * @param {Number} [tol=1e-3]
     * @returns {Matrix}
     */static solve_CG(t,e,r,s=.001){null===r&&(r=new Randomizer);const i=t.shape[0],n=e.shape[1];let o=new Matrix(i,0);for(let a=0;a<n;++a){const n=Matrix.from(e.col(a)).T;let h=new Matrix(i,1,(()=>r.random)),l=n.sub(t.dot(h)),_=l.clone();do{const e=t.dot(_),r=l.T.dot(l).entry(0,0)/_.T.dot(e).entry(0,0);h=h.add(_.mult(r));const s=l.sub(e.mult(r)),i=s.T.dot(s).entry(0,0)/l.T.dot(l).entry(0,0);_=s.add(_.mult(i)),l=s}while(Math.abs(l.mean)>s);o=o.concat(h,"horizontal")}return o}
/**
     * Solves the equation {@link A}x = {@link b}. Returns the result x.
     * @param {Matrix} A - Matrix or LU Decomposition
     * @param {Matrix} b - Matrix
     * @returns {Matrix}
     */static solve(t,e){let{L:r,U:s}="L"in t&&"U"in t?t:Matrix.LU(t),i=r.shape[0],n=e.clone();
// forward
for(let t=0;t<i;++t){for(let e=0;e<t-1;++e)n.set_entry(0,t,n.entry(0,t)-r.entry(t,e)*n.entry(1,e));n.set_entry(0,t,n.entry(0,t)/r.entry(t,t))}
// backward
for(let t=i-1;t>=0;--t){for(let e=i-1;e>t;--e)n.set_entry(0,t,n.entry(0,t)-s.entry(t,e)*n.entry(0,e));n.set_entry(0,t,n.entry(0,t)/s.entry(t,t))}return n}
/**
     * {@link L}{@link U} decomposition of the Matrix {@link A}. Creates two matrices, so that the dot product LU equals A.
     * @param {Matrix} A
     * @returns {{L: Matrix, U: Matrix}} result - Returns the left triangle matrix {@link L} and the upper triangle matrix {@link U}.
     */static LU(t){const e=t.shape[0],r=new Matrix(e,e,"zeros"),s=new Matrix(e,e,"identity");for(let i=0;i<e;++i){for(let n=i;n<e;++n){let e=0;for(let t=0;t<i;++t)e+=r.entry(n,t)*s.entry(t,i);r.set_entry(n,i,t.entry(n,i)-e)}for(let n=i;n<e;++n){if(0===r.entry(i,i))return;let e=0;for(let t=0;t<i;++t)e+=r.entry(i,t)*s.entry(t,n);s.set_entry(i,n,(t.entry(i,n)-e)/r.entry(i,i))}}return{L:r,U:s}}
/**
     * Computes the determinante of {@link A}, by using the LU decomposition of {@link A}.
     * @param {Matrix} A
     * @returns {Number} det - Returns the determinate of the Matrix {@link A}.
     */static det(t){const e=t.shape[0],{L:r,U:s}=Matrix.LU(t),i=r.diag,n=s.diag;let o=i[0]*n[0];for(let t=1;t<e;++t)o*=i[t]*n[t];return o}
/**
     * Computes the {@link k} components of the SVD decomposition of the matrix {@link M}
     * @param {Matrix} M
     * @param {int} [k=2]
     * @returns {{U: Matrix, Sigma: Matrix, V: Matrix}}
     */static SVD(t,e=2){const r=t.T;let s=r.dot(t),i=t.dot(r),{eigenvectors:n,eigenvalues:o}=simultaneous_poweriteration(s,e),{eigenvectors:a}=simultaneous_poweriteration(i,e);return{U:a,Sigma:o.map((t=>Math.sqrt(t))),V:n};
//Algorithm 1a: Householder reduction to bidiagonal form:
/* const [m, n] = A.shape;
        let U = new Matrix(m, n, (i, j) => i == j ? 1 : 0);
        console.log(U.to2dArray)
        let V = new Matrix(n, m, (i, j) => i == j ? 1 : 0);
        console.log(V.to2dArray)
        let B = Matrix.bidiagonal(A.clone(), U, V);
        console.log(U,V,B)
        return { U: U, "Sigma": B, V: V }; */}}
/**
 * @class
 * @memberof module:utils
 * @alias Randomizer
 */class Randomizer{
/**
     * Mersenne Twister random number generator.
     * @constructor
     * @param {Number} [_seed=new Date().getTime()] - The seed for the random number generator. If <code>_seed == null</code> then the actual time gets used as seed.
     * @see https://github.com/bmurray7/mersenne-twister-examples/blob/master/javascript-mersenne-twister.js
     */
constructor(t){return this._N=624,this._M=397,this._MATRIX_A=2567483615,this._UPPER_MASK=2147483648,this._LOWER_MASK=2147483647,this._mt=new Array(this._N),this._mti=this.N+1,this.seed=t||(new Date).getTime(),this}set seed(t){this._seed=t;let e=this._mt;for(e[0]=t>>>0,this._mti=1;this._mti<this._N;this._mti+=1){let t=this._mti,r=e[t-1]^e[t-1]>>>30;e[t]=(1812433253*((4294901760&r)>>>16)<<16)+1812433253*(65535&r)+t,e[t]>>>=0}}
/**
     * Returns the seed of the random number generator.
     * @returns {Number} - The seed.
     */get seed(){return this._seed}
/**
     * Returns a float between 0 and 1.
     * @returns {Number} - A random number between [0, 1]
     */get random(){return this.random_int*(1/4294967296)}
/**
     * Returns an integer between 0 and MAX_INTEGER.
     * @returns {Integer} - A random integer.
     */get random_int(){let t,e=new Array(0,this._MATRIX_A);if(this._mti>=this._N){let r,s=this._N-this._M,i=this._M-this._N;
/* if (this._mti == this._N + 1) {
                this.seed = 5489;
            } */for(r=0;r<s;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+this._M]^t>>>1^e[1&t];for(;r<this._N-1;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+i]^t>>>1^e[1&t];t=this._mt[this._N-1]&this._UPPER_MASK|this._mt[0]&this._LOWER_MASK,this._mt[this._N-1]=this._mt[this._M-1]^t>>>1^e[1&t],this._mti=0}return t=this._mt[this._mti+=1],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,t^=t>>>18,t>>>0}
/**
     * Returns samples from an input Matrix or Array.
     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.
     * @param {Number} n - The number of samples.
     * @returns {Array} - A random selection form {@link A} of {@link n} samples.
     */choice(t,e){if(t instanceof Matrix){let r=t.shape[0];if(e>r)throw new Error("n bigger than A!");let s=new Array(e),i=linspace(0,r-1);for(let t=0,r=i.length;t<e;++t,--r){let e=this.random_int%r;s[t]=i.splice(e,1)[0]}return s.map((e=>t.row(e)))}if(Array.isArray(t)||t instanceof Float64Array){let r=t.length;if(e>r)throw new Error("n bigger than A!");let s=new Array(e),i=linspace(0,r-1);for(let t=0,r=i.length;t<e;++t,--r){let e=this.random_int%r;s[t]=i.splice(e,1)[0]}return s.map((e=>t[e]))}}
/**
     * @static
     * Returns samples from an input Matrix or Array.
     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.
     * @param {Number} n - The number of samples.
     * @param {Number} seed - The seed for the random number generator.
     * @returns {Array} - A random selection form {@link A} of {@link n} samples.
     */static choice(t,e,r=1212){return new Randomizer(r).choice(t,e);
/* let rows = A.shape[0];
        if (n > rows) {
            throw new Error("n bigger than A!");
        }
        let rand = new Randomizer(seed);
        let sample = new Array(n);
        let index_list = linspace(0, rows - 1);
        for (let i = 0, l = index_list.length; i < n; ++i, --l) {
            let random_index = rand.random_int % l;
            sample[i] = index_list.splice(random_index, 1)[0];
        }
        //return result;
        //return new Matrix(n, cols, (row, col) => A.entry(sample[row], col))
        return sample.map((d) => A.row(d)); */}}
/**
 * Returns maximum in Array {@link values}.
 * @memberof module:utils
 * @alias max
 * @param {Array} values 
 * @returns {Number}
 */function max(t){let e;for(const r of t)null!=r&&(e<r||void 0===e&&r>=r)&&(e=r);return e}
/**
 * Returns maximum in Array {@link values}.
 * @memberof module:utils
 * @alias min
 * @param {Array} values
 * @returns {Number}
 */function min(t){let e;for(const r of t)null!=r&&(e>r||void 0===e&&r<=r)&&(e=r);return e}
/**
 * @class
 * @alias Heap
 */class Heap{
/**
     * A heap is a datastructure holding its elements in a specific way, so that the top element would be the first entry of an ordered list.
     * @constructor
     * @memberof module:datastructure
     * @alias Heap
     * @param {Array=} elements - Contains the elements for the Heap. {@link elements} can be null.
     * @param {Function} [accessor = (d) => d] - Function returns the value of the element.
     * @param {("min"|"max"|Function)} [comparator = "min"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. ("min" for a Min-Heap, "max" for a Max_heap)
     * @returns {Heap}
     * @see {@link https://en.wikipedia.org/wiki/Binary_heap}
     */
constructor(t=null,e=(t=>t),r="min"){return t?Heap.heapify(t,e,r):(this._accessor=e,this._container=[],this._comparator="min"==r?(t,e)=>t<e:"max"==r?(t,e)=>t>e:r,this)}
/**
     * Creates a Heap from an Array
     * @param {Array|Set} elements - Contains the elements for the Heap.
     * @param {Function=} [accessor = (d) => d] - Function returns the value of the element.
     * @param {(String=|Function)} [comparator = "min"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. ("min" for a Min-Heap, "max" for a Max_heap)
     * @returns {Heap}
     */static heapify(t,e=(t=>t),r="min"){const s=new Heap(null,e,r),i=s._container;for(const r of t)i.push({element:r,value:e(r)});for(let e=Math.floor(t.length/2-1);e>=0;--e)s._heapify_down(e);return s}
/**
     * Swaps elements of container array.
     * @private
     * @param {Number} index_a 
     * @param {Number} index_b 
     */_swap(t,e){const r=this._container;[r[e],r[t]]=[r[t],r[e]]}
/**
     * @private
     */_heapify_up(){const t=this._container;let e=t.length-1;for(;e>0;){let r=Math.floor((e-1)/2);if(!this._comparator(t[e].value,t[r].value))break;this._swap(r,e),e=r}}
/**
     * Pushes the element to the heap.
     * @param {} element
     * @returns {Heap}
     */push(t){const e={element:t,value:this._accessor(t)};
//const node = new Node(element, value);
return this._container.push(e),this._heapify_up(),this}
/**
     * @private
     * @param {Number} [start_index = 0] 
     */_heapify_down(t=0){const e=this._container,r=this._comparator,s=e.length;let i=2*t+1,n=2*t+2,o=t;if(o>s)throw"index higher than length";i<s&&r(e[i].value,e[o].value)&&(o=i),n<s&&r(e[n].value,e[o].value)&&(o=n),o!==t&&(this._swap(t,o),this._heapify_down(o))}
/**
     * Removes and returns the top entry of the heap.
     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).
     */pop(){const t=this._container;if(0===t.length)return null;if(1===t.length)return t.pop();this._swap(0,t.length-1);const e=t.pop();return this._heapify_down(),e}
/**
     * Returns the top entry of the heap without removing it.
     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).
     */get first(){return this._container.length>0?this._container[0]:null}
/**
     * Yields the raw data
     * @yields {Object} Object consists of the element and its value (computed by {@link accessor}).
     */*iterate(){for(let t=0,e=this._container.length;t<e;++t)yield this._container[t].element}
/**
     * Returns the heap as ordered array.
     * @returns {Array} Array consisting the elements ordered by {@link comparator}.
     */toArray(){return this.data().sort(((t,e)=>this._comparator(t,e)?-1:0))}
/**
     * Returns elements of container array.
     * @returns {Array} Array consisting the elements.
     */data(){return this._container.map((t=>t.element))}
/**
     * Returns the container array.
     * @returns {Array} The container array.
     */raw_data(){return this._container}
/**
     * The size of the heap.
     * @returns {Number}
     */get length(){return this._container.length}
/**
     * Returns false if the the heap has entries, true if the heap has no entries.
     * @returns {Boolean}
     */get empty(){return 0===this.length}}
/**
 * @class
 * @alias DisjointSet
 * @see {@link https://en.wikipedia.org/wiki/Disjoint-set_data_structure}
 */class DisjointSet{
/**
     * @constructor
     * @alias DisjointSet
     * @memberof module:datastructure
     * @param {Array=} elements 
     * @returns {DisjointSet}
     */
constructor(t=null){if(this._list=new Set,t)for(const e of t)this.make_set(e);return this}make_set(t){const e=this._list;return e.has(t)||(e.add(t),t.__disjoint_set={},t.__disjoint_set.parent=t,t.__disjoint_set.children=new Set([t]),t.__disjoint_set.size=1),this}find(t){return this._list.has(t)?t.__disjoint_set.parent!==t?(t.__disjoint_set.children.add(...t),t.__disjoint_set.parent=this.find(t.__disjoint_set.parent),t.__disjoint_set.parent):t:null}union(t,e){let r=this.find(t),s=this.find(e);return r===s||(r.__disjoint_set.size<s.__disjoint_set.size&&([r,s]=[s,r]),s.__disjoint_set.parent=r,
// keep track of children?
s.__disjoint_set.children.forEach(r.__disjoint_set.children.add,r.__disjoint_set.children),r.__disjoint_set.size+=s.__disjoint_set.size),this}}
/**
 * @class
 * @alias BallTree
 */class BallTree{
/**
     * Generates a BallTree with given {@link elements}.
     * @constructor
     * @memberof module:knn
     * @alias BallTree
     * @param {Array=} elements - Elements which should be added to the BallTree
     * @param {Function} [metric = euclidean] metric to use: (a, b) => distance
     * @see {@link https://en.wikipedia.org/wiki/Ball_tree}
     * @see {@link https://github.com/invisal/noobjs/blob/master/src/tree/BallTree.js}
     * @returns {BallTree}
     */
constructor(t=null,e=euclidean){return this._Node=class{constructor(t,e=null,r=null,s=null){this.pivot=t,this.child1=e,this.child2=r,this.radius=s}},this._Leaf=class{constructor(t){this.points=t}},this._metric=e,t&&this.add(t),this}
/**
     * 
     * @param {Array<*>} elements - new elements.
     * @returns {BallTree}
     */add(t){return t=t.map(((t,e)=>({index:e,element:t}))),this._root=this._construct(t),this}
/**
     * @private
     * @param {Array<*>} elements 
     * @returns {Node} root of balltree.
     */_construct(t){if(1===t.length)return new this._Leaf(t);{let e,r=this._greatest_spread(t),s=t.sort(((t,e)=>t.element[r]-e.element[r])),i=s.length,n=Math.floor(i/2),o=t[n],a=s.slice(0,n),h=s.slice(n,i),l=Math.max(...t.map((t=>this._metric(o.element,t.element))));return e=a.length>0&&h.length>0?new this._Node(o,this._construct(a),this._construct(h),l):new this._Leaf(t),e}}
/**
     * @private
     * @param {Node} B 
     * @returns {Number}
     */_greatest_spread(t){let e=t[0].element.length,r=new Array(e);for(let t=0;t<e;++t)r[t]=[1/0,-1/0];let s=t.reduce(((t,r)=>{for(let s=0;s<e;++s)t[s][0]=Math.min(t[s][0],r.element[s]),t[s][1]=Math.max(t[s][1],r.element[s]);return t}),r);s=s.map((t=>t[1]-t[0]));let i=0;for(let t=0;t<e;++t)i=s[t]>s[i]?t:i;return i}
/**
     * 
     * @param {*} t - query element.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.
     */search(t,e=5){return this._search(t,e,new Heap(null,(e=>this._metric(e.element,t)),"max"),this._root)}
/**
     * @private
     * @param {*} t - query element.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @param {Heap} Q - Heap consists of the currently found {@link k} nearest neighbors.
     * @param {Node|Leaf} B 
     */_search(t,e,r,s){
// B is Node
if(r.length>=e&&s.pivot&&s.radius&&this._metric(t,s.pivot.element)-s.radius>=r.first.value)return r;
// B is leaf
if(s.child1&&this._search(t,e,r,s.child1),s.child2&&this._search(t,e,r,s.child2),s.points)for(let t=0,i=s.points.length;t<i;++t){let i=s.points[t];e>r.length?r.push(i):(r.push(i),r.pop())}return r}}
/**
 * @class
 * @alias KNN
 */class KNN{
/**
     * Generates a KNN list with given {@link elements}.
     * @constructor
     * @memberof module:knn
     * @alias KNN
     * @param {Array=} elements - Elements which should be added to the KNN list
     * @param {Function|"precomputed"} [metric = euclidean] metric is either precomputed or a function to use: (a, b) => distance
     * @returns {KNN}
     */
constructor(t=null,e=euclidean){this._metric=e,this._elements=t instanceof Matrix?t:Matrix.from(t);const r=this._elements.shape[0];this._D="precomputed"===e?this._elements.clone():distance_matrix(this._elements,e),this.KNN=[];for(let t=0;t<r;++t){const e=this._D.row(t),s=new Heap(null,(t=>t.value),"min");for(let t=0;t<r;++t)s.push({value:e[t],index:t});this.KNN.push(s)}}
/**
     * 
     * @param {Array|Number} t - query element or index.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.
     */search(t,e=5){const r=this._metric,s=this.KNN;let i;if(Array.isArray(t)){if("precomputed"==this._metric)throw"Search by query element is only possible when not using a precomputed distance matrix!";const e=this._elements,n=s.length;let o=null,a=1/0;for(let s=0;s<n;++s){const i=r(t,e.row(s));i<a&&(o=s,a=i)}i=s[o]}else Number.isInteger(t)&&(i=s[t]);let n=[];for(let t=0;t<e;++t)n.push(i.pop());return n.forEach((t=>i.push(t.element))),n}}
/**
 * @class
 * @alias DR
 * @borrows DR#parameter as DR#para
 * @borrows DR#parameter as DR#p
 */class DR{
/**
     * Takes the default parameters and seals them, remembers the type of input <code>X</code>, and initializes the random number generator.
     * @constructor
     * @memberof module:@druid/dimensionality_reduction
     * @alias DR
     * @param {Matrix|Number[][]} X - the high-dimensional data.
     * @param {Object} [parameters] - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed value for the random number generator.
     * @returns {DR}
     */
constructor(t,e,r){if(this._parameters=Object.assign(Object.seal(e),r),Array.isArray(t))this._type="array",this.X=Matrix.from(t);else{if(!(t instanceof Matrix))throw new Error("No valid type for X!");this._type="matrix",this.X=t}return[this._N,this._D]=this.X.shape,this._randomizer=new Randomizer(this._parameters.seed),this._is_initialized=!1,this}
/**
     * Set and get parameters
     * @chainable
     * @param {String} name - name of the parameter.
     * @param {any} [value = null] - value of the parameter to set.
     * @returns {DR|any} - On setting a parameter, this function returns the DR object. If <code>value == null</code> then return actual parameter value.
     * @example
     * const DR = new druid.TSNE(X, {d: 3}); // creates a new DR object, with parameter for <code>d</code> = 3.
     * DR.parameter("d"); // returns 3,
     * DR.parameter("d", 2); // sets parameter <code>d</code> to 2 and returns <code>DR</code>.
     */parameter(t,e=null){if(!this._parameters.hasOwnProperty(t))throw new Error(`${t} is not a valid parameter!`);return e?(this._parameters[t]=e,this._is_initialized=!1,this):this._parameters[t]}para(t,e=null){return this.parameter(t,e)}p(t,e=null){return this.parameter(t,e)}
/**
     * Computes the projection.
     * @returns {Matrix} - Returns the projection.
     */transform(){return this.check_init(),this.projection}
/**
     * Computes the projection.
     * @returns {Generator} - A generator yielding the intermediate steps of the dimensionality reduction method.
     */*generator(){return this.transform()}
/**
     * If the respective DR method has an <code>init</code> function, call it before <code>transform</code>.
     * @returns {DR}
     */check_init(){return this._is_initialized||"function"!=typeof this.init||(this.init(),this._is_initialized=!0),this}
/**
     * @returns {Matrix|Number[][]} Returns the projection.
     */get projection(){if(this.hasOwnProperty("Y"))return this.check_init(),"matrix"===this._type?this.Y:this.Y.to2dArray;throw new Error("The dataset is not transformed yet!")}
/**
     *
     * @param  {...any} [args] - Arguments the transform method of the respective DR method takes.
     * @returns {Promise} - A promise yielding the dimensionality reduced dataset.
     */async transform_async(...t){return this.transform(...t)}
/**
     * @static
     * @param  {...any} [args] - Takes the same arguments of the constructor of the respective DR method.
     * @returns {Matrix|Array} - The dimensionality reduced dataset.
     */static transform(...t){return new this(...t).transform()}
/**
     * @static
     * @param  {...any} [args] - Takes the same arguments of the constructor of the respective DR method.
     * @returns {Promise} - A promise yielding the dimensionality reduced dataset.
     */static async transform_async(...t){return this.transform(...t)}
/**
     * @static
     * @param  {...any} [args] - Takes the same arguments of the constructor of the respective DR method.
     * @returns {Generator} - A generator yielding the intermediate steps of the dimensionality reduction method.
     */static*generator(...t){const e=new this(...t).generator();for(const t of e)yield t}}
/**
 * @class
 * @alias PCA
 * @augments DR
 */class PCA extends DR{
/**
     * @constructor
     * @memberof module:druid/dimensionality_reduction
     * @alias PCA
     * @param {Matrix|Number[][]} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @returns {PCA}
     */
constructor(t,e){return super(t,{d:2,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Transforms the inputdata {@link X} to dimensionality {@link d}. If parameter {@link A} is given, then project {@link A} with the principal components of {@link X}.
     * @param {null|Matrix|Array} [A = null] - If given, the data to project.
     * @returns {Matrix|Array} - The projected data.
     */transform(t=null){const e=this.principal_components();if(null==t){const t=this.X;return this.Y=t.dot(e),this.projection}if(Array.isArray(t))return Matrix.from(t).dot(e).asArray;if(t instanceof Matrix)return t.dot(e);throw new Error("No valid type for A!")}
/**
     * Computes the {@link d} principal components of Matrix {@link X}.
     * @returns {Matrix}
     */principal_components(){if(this.V)return this.V;const{d:t,eig_args:e}=this._parameters,r=this.X,s=Matrix.from(r.meanCols),i=r.sub(s),n=i.transpose().dot(i),{eigenvectors:o}=simultaneous_poweriteration(n,t,e);return this.V=Matrix.from(o).transpose(),this.V}static principal_components(t,e){return new this(t,e).principal_components()}}
/**
 * @class
 * @extends DR
 */class MDS extends DR{
/**
     * Classical MDS.
     * @constructor
     * @name druid.MDS
     * @alias MDS
     * @memberof module:@druid/dimensionality_reduction
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} [parameters] - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Object} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     */
constructor(t,e){return super(t,{d:2,metric:euclidean,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Transforms the inputdata {@link X} to dimensionality {@link d}.
     * @returns {Matrix|Array}
     */transform(){const t=this.X,e=t.shape[0],{d:r,metric:s,eig_args:i}=this._parameters,n="precomputed"===s?t:distance_matrix(t,s),o=n.meanCols,a=n.meanRows,h=n.mean;this._d_X=n;const l=new Matrix(e,e,((t,e)=>n.entry(t,e)-o[t]-a[e]+h)),{eigenvectors:_}=simultaneous_poweriteration(l,r,i);return this.Y=Matrix.from(_).transpose(),this.projection}
/**
     * @returns {Number} - the stress of the projection.
     */stress(){const t=this.X.shape[0],e=this.Y,r=this._d_X,s=new Matrix;s.shape=[t,t,(t,r)=>t<r?euclidean(e.row(t),e.row(r)):s.entry(r,t)];let i=0,n=0;for(let e=0;e<t;++e)for(let o=e+1;o<t;++o)i+=Math.pow(r.entry(e,o)-s.entry(e,o),2),n+=Math.pow(r.entry(e,o),2);return Math.sqrt(i/n)}}
/**
 * @class
 * @alias ISOMAP
 * @extends DR
 */class ISOMAP extends DR{
/**
     * Isometric feature mapping (ISOMAP).
     * @constructor
     * @memberof module:druid/dimensionality_reduction
     * @alias ISOMAP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} parameters.neighbors - the number of neighbors {@link ISOMAP} should use to project the data.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://doi.org/10.1126/science.290.5500.2319}
     */
constructor(t,e){return super(t,{neighbors:void 0,d:2,metric:euclidean,seed:1212,eig_args:{}},e),this.parameter("neighbors",Math.min(this._parameters.neighbors??Math.max(Math.floor(this.X.shape[0]/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */transform(){this.check_init();const t=this.X,e=this._N,{d:r,metric:s,eig_args:i,neighbors:n}=this._parameters,o=new Matrix;o.shape=[e,e,(e,r)=>e<=r?s(t.row(e),t.row(r)):o.entry(r,e)];const a=[];for(let t=0;t<e;++t){const r=[];for(let s=0;s<e;++s)r.push({index:s,distance:o.entry(t,s)});const s=new Heap(r,(t=>t.distance),"min");a.push(s.toArray().slice(1,n+1))}
/*D = dijkstra(kNearestNeighbors);*/
// compute shortest paths
// TODO: make extern
/** @see {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm} */const h=new Matrix(e,e,((t,e)=>{const r=a[t].find((t=>t.index===e));return r?r.distance:1/0}));for(let t=0;t<e;++t)for(let r=0;r<e;++r)for(let s=0;s<e;++s)h.set_entry(t,r,Math.min(h.entry(t,r),h.entry(t,s)+h.entry(s,r)));let l=new Float64Array(e),_=new Float64Array(e),c=0;const u=new Matrix(e,e,((t,e)=>{let r=h.entry(t,e);return r=r===1/0?0:r,l[t]+=r,_[e]+=r,c+=r,r}));l=l.map((t=>t/e)),_=_.map((t=>t/e)),c/=e**2;const d=new Matrix(e,e,((t,e)=>u.entry(t,e)-l[t]-_[e]+c)),{eigenvectors:m}=simultaneous_poweriteration(d,r,i);
// compute d eigenvectors
// return embedding
return this.Y=Matrix.from(m).transpose(),this.projection}}class FASTMAP extends DR{
/**
     * FastMap: a fast algorithm for indexing, data-mining and visualization of traditional and multimedia datasets
     * @constructor
     * @memberof druid/FASTMAP
     * @alias FASTMAP
     * @typicalname druid.FASTMAP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} [parameters] - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the dimensionality of the projection.
     * @returns {FASTMAP}
     * @see {@link https://doi.org/10.1145/223784.223812}
     */
constructor(t,e){return super(t,{d:2,metric:euclidean,seed:1212},e),this}
/**
     * Chooses two points which are the most distant in the actual projection.
     * @private
     * @param {Function} dist
     * @returns {Array} An array consisting of first index, second index, and distance between the two points.
     */_choose_distant_objects(t){const e=this.X.shape[0];let r=this._randomizer.random_int%e-1,s=null,i=-1/0;for(let n=0;n<e;++n){const e=t(r,n);e>i&&(i=e,s=n)}i=-1/0;for(let n=0;n<e;++n){const e=t(s,n);e>i&&(i=e,r=n)}return[r,s,i]}
/**
     * Computes the projection.
     * @returns {Matrix} The **d**-dimensional projection of the data matrix <code>X</code>.
     */transform(){const t=this.X,e=t.shape[0],{d:r,metric:s}=this._parameters,i=new Matrix(e,r,0);let dist=(e,r)=>s(t.row(e),t.row(r));for(let t=0;t<r;++t){let r=dist;
// choose pivot objects
const[s,n,o]=this._choose_distant_objects(dist);if(0!==o){
// project the objects on the line (O_a, O_b)
for(let r=0;r<e;++r){const e=(dist(s,r)**2+o**2-dist(n,r)**2)/(2*o);i.set_entry(r,t,e)}
// consider the projections of the objects on a
// hyperplane perpendicluar to the line (a, b);
// the distance function D'() between two
// projections is given by Eq.4
dist=(e,s)=>Math.sqrt(r(e,s)**2-(i.entry(e,t)-i.entry(s,t))**2)}}
// return embedding.
return this.Y=i,this.projection}}
/**
 * @class
 * @alias LDA
 * @extends DR
 */class LDA extends DR{
/**
     * Linear Discriminant Analysis.
     * @constructor
     * @memberof module:druid/dimensionality_reduction
     * @alias LDA
     * @param {Matrix} X - The high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Array} parameters.labels - The labels / classes for each data point.
     * @param {number} [parameters.d = 2] - The dimensionality of the projection.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://onlinelibrary.wiley.com/doi/10.1111/j.1469-1809.1936.tb02137.x}
     */
constructor(t,e){return super(t,{labels:null,d:2,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,[e,r]=t.shape,{d:s,labels:i,eig_args:n}=this._parameters;if(null===i||i.length!=e)throw new Error("LDA needs parameter label to every datapoint to work!");const o={};let a=0;i.forEach(((e,r)=>{e in o?(o[e].count++,o[e].rows.push(t.row(r))):o[e]={id:a++,count:1,rows:[t.row(r)]}}));
// create X_mean and vector means;
const h=t.mean,l=new Matrix(a,r);for(const t in o){const e=Matrix.from(o[t].rows).meanCols;for(let s=0;s<r;++s)l.set_entry(o[t].id,s,e[s])}
// scatter_between
let _=new Matrix(r,r);for(const t in o){const e=l.row(o[t].id),s=new Matrix(r,1,(t=>e[t]-h)),i=o[t].count;_=_.add(s.dot(s.transpose()).mult(i))}
// scatter_within
let c=new Matrix(r,r);for(const t in o){const e=l.row(o[t].id),s=new Matrix(r,1,(t=>e[t])),i=o[t].rows;for(let e=0,n=o[t].count;e<n;++e){const t=new Matrix(r,1,((t,r)=>i[e][t]-s.entry(t,0)));c=c.add(t.dot(t.transpose()))}}let{eigenvectors:u}=simultaneous_poweriteration(c.inverse().dot(_),s,n);
// return embedding
return u=Matrix.from(u).transpose(),this.Y=t.dot(u),this.projection}}
/**
 * @class
 * @alias LLE
 * @extends DR
 */class LLE extends DR{
/**
     * Locally Linear Embedding.
     * @constructor
     * @memberof module:druid/dimensionality_reduction
     * @alias LLE
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} neighbors - the label / class of each data point.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://doi.org/10.1126/science.290.5500.2323}
     */
constructor(t,e){return super(t,{neighbors:void 0,d:2,metric:euclidean,seed:1212,eig_args:{}},e),this.parameter("neighbors",Math.min(e.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,e=this._N,r=this._D,{neighbors:s,d:i,eig_args:n,metric:o}=this._parameters,a=k_nearest_neighbors(t,s,o),h=new Matrix(s,1,1),l=new Matrix(e,e);for(let i=0;i<e;++i){const e=a[i],n=new Matrix(s,r,((r,s)=>t.entry(e[r].j,s)-t.entry(i,s))),o=n.dot(n.T);if(s>r){const t=neumair_sum(o.diag)/1e3;for(let e=0;e<s;++e)o.set_entry(e,e,o.entry(e,e)+t)}
// reconstruct;
let _=Matrix.solve_CG(o,h,this._randomizer);_=_.divide(_.sum);for(let t=0;t<s;++t)l.set_entry(i,e[t].j,_.entry(t,0))}
// comp embedding
const _=new Matrix(e,e,"identity").sub(l),c=_.T.dot(_),{eigenvectors:u}=simultaneous_poweriteration(c.T.inverse(),i+1,n);
// return embedding
return this.Y=Matrix.from(u.slice(1,1+i)).T,this.projection}}
/**
 * @class
 * @alias LTSA
 * @extends DR
 */class LTSA extends DR{
/**
     * Local Tangent Space Alignment
     * @constructor
     * @memberof module:druid/dimensionality_reduction
     * @alias LTSA
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} parameters.neighbors - the number of neighbors {@link LTSA} should use to project the data.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://epubs.siam.org/doi/abs/10.1137/S1064827502419154}
     */
constructor(t,e){if(super(t,{neighbors:void 0,d:2,metric:euclidean,seed:1212,eig_args:{}},e),this.parameter("neighbors",Math.min(e.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this._D<=this.parameter("d"))throw new Error(`Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${this.parameter("d")})!`);return this}
/**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */transform(){const t=this.X,[e,r]=t.shape,{d:s,neighbors:i,metric:n,eig_args:o}=this._parameters,a=k_nearest_neighbors(t,i,n),h=new Matrix(r,r,"center"),l=new Matrix(e,e,0);for(let r=0;r<e;++r){
// 1.2 compute the d largest eigenvectors of the correlation matrix
const e=[r,...a[r].map((t=>t.j))];let n=Matrix.from(e.map((e=>t.row(e))));
// center X_i
n=n.dot(h);
// correlation matrix
const _=n.dot(n.transpose()),{eigenvectors:c}=simultaneous_poweriteration(_,s,o),u=Matrix.from(c),d=u.transpose().dot(u).add(1/Math.sqrt(i+1));for(let t=0;t<i+1;++t)for(let r=0;r<i+1;++r)l.set_entry(e[t],e[r],l.entry(e[t],e[r])-(t===r?1:0)+d.entry(t,r))}
// 3. Aligning global coordinates
const{eigenvectors:_}=simultaneous_poweriteration(l,s+1,o);
// return embedding
return this.Y=Matrix.from(_.slice(1)).transpose(),this.projection}}
/**
 * @class
 * @alias TSNE
 * @extends DR
 */class TSNE extends DR{
/**
     *
     * @constructor
     * @memberof module:druid/dimensionality_reduction
     * @alias TSNE
     * @param {Matrix|Number[][]} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.perplexity = 50] - perplexity.
     * @param {Number} [parameters.epsilon = 10] - learning parameter.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {TSNE}
     */
constructor(t,e){return super(t,{perplexity:50,epsilon:10,d:2,metric:euclidean,seed:1212},e),[this._N,this._D]=this.X.shape,this._iter=0,this.Y=new Matrix(this._N,this.parameter("d"),(()=>this._randomizer.random)),this}
/**
     *
     * @param {Matrix} distance_matrix - accepts a precomputed distance matrix
     * @returns {TSNE}
     */init(){
// init
const t=Math.log(this.parameter("perplexity")),e=this._N,r=this._D,{metric:s}=this._parameters,i=this.X;let n;if("precomputed"==s)n=druid.Matrix.from(i);else{n=new Matrix(e,e);for(let t=0;t<e;++t){const r=i.row(t);for(let o=t+1;o<e;++o){const e=s(r,i.row(o));n.set_entry(t,o,e),n.set_entry(o,t,e)}}}const o=new Matrix(e,e,"zeros");this._ystep=new Matrix(e,r,"zeros"),this._gains=new Matrix(e,r,1);
// search for fitting sigma
let a=new Float64Array(e);for(let r=0;r<e;++r){let s=-1/0,i=1/0,h=1,l=!1,_=0;for(;!l;){let o=0;for(let t=0;t<e;++t){let e=Math.exp(-n.entry(r,t)*h);r===t&&(e=0),a[t]=e,o+=e}let c=0;for(let t=0;t<e;++t){let e=0===o?0:a[t]/o;a[t]=e,e>1e-7&&(c-=e*Math.log(e))}c>t?(s=h,h=i===1/0?2*h:(h+i)/2):(i=h,h=s===-1/0?h/2:(h+s)/2),++_,Math.abs(c-t)<1e-4&&(l=!0),_>=50&&(l=!0)}for(let t=0;t<e;++t)o.set_entry(r,t,a[t])}
//compute probabilities
const h=new Matrix(e,e,"zeros"),l=2*e;for(let t=0;t<e;++t)for(let r=t;r<e;++r){const e=Math.max((o.entry(t,r)+o.entry(r,t))/l,1e-100);h.set_entry(t,r,e),h.set_entry(r,t,e)}return this._P=h,this}
/**
     *
     * @param {Number} [iterations=500] - number of iterations.
     * @yields {Matrix|Array<Array>} - the projection.
     */transform(t=500){this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}
/**
     *
     * @param {Number} [iterations=500] - number of iterations.
     * @yields {Matrix|Array<Array>} - the projection.
     */*generator(t=500){this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}
/**
     * performs a optimization step
     * @private
     * @returns {Matrix}
     */next(){const t=++this._iter,e=this._P,r=this._ystep,s=this._gains,i=this._N,{d:n,epsilon:o}=this._parameters;let a=this.Y;
//calc cost gradient;
const h=t<100?4:1,l=new Matrix(i,i,"zeros");
// compute Q dist (unnormalized)
let _=0;for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){let r=0;for(let s=0;s<n;++s){const i=a.entry(t,s)-a.entry(e,s);r+=i*i}const s=1/(1+r);l.set_entry(t,e,s),l.set_entry(e,t,s),_+=2*s}
// normalize Q dist
const c=new Matrix(i,i,0);for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){const r=Math.max(l.entry(t,e)/_,1e-100);c.set_entry(t,e,r),c.set_entry(e,t,r)}const u=new Matrix(i,n,"zeros");for(let t=0;t<i;++t)for(let r=0;r<i;++r){const s=4*(h*e.entry(t,r)-c.entry(t,r))*l.entry(t,r);for(let e=0;e<n;++e)u.set_entry(t,e,u.entry(t,e)+s*(a.entry(t,e)-a.entry(r,e)))}
// perform gradient step
let d=new Float64Array(n);for(let e=0;e<i;++e)for(let i=0;i<n;++i){const n=u.entry(e,i),h=r.entry(e,i),l=s.entry(e,i);let _=Math.sign(n)===Math.sign(h)?.8*l:l+.2;_<.01&&(_=.01),s.set_entry(e,i,_);const c=(t<250?.5:.8)*h-o*_*n;r.set_entry(e,i,c),a.set_entry(e,i,a.entry(e,i)+c),d[i]+=a.entry(e,i)}for(let t=0;t<i;++t)for(let e=0;e<2;++e)a.set_entry(t,e,a.entry(t,e)-d[e]/i);return this.Y}}
/**
 *
 * @memberof module:optimization
 * @alias powell
 * @param {Function} f
 * @param {Array} x0
 * @param {Number} [max_iter = 300]
 * @returns {Array}
 * @see http://optimization-js.github.io/optimization-js/optimization.js.html#line438
 */function powell(t,e,r=300){const s=e.length;let i=.001,n=1e4,o=e.slice(),a=t(o),h=!1;for(;r-- >=0&&!h;){h=!0;for(let e=0;e<s;++e){o[e]+=1e-6;let r=t(o);o[e]-=1e-6;let s=(r-a)/1e-6;Math.abs(s)>.01&&(h=!1),o[e]-=i*s,a=t(o)}i*=n>=a?1.05:.4,n=a}return o}
/**
 * @class
 * @alias UMAP
 * @extends DR
 */class UMAP extends DR{
/**
     *
     * @constructor
     * @memberof module:druid/dimensionality_reduction
     * @alias UMAP
     * @param {Matrix|Number[][]} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.n_neighbors = 15] - size of the local neighborhood.
     * @param {Number} [parameters.local_connectivity = 1] - number of nearest neighbors connected in the local neighborhood.
     * @param {Number} [parameters.min_dist = 1] - controls how tightly points get packed together.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points in the high-dimensional space.
     * @param {Number} [parameters._spread = 1] - The effective scale of embedded points. (In combination with {@link parameters.min_dist})
     * @param {Number} [parameters._set_op_mix_ratio = 1] - Interpolate between union and intersection.
     * @param {Number} [parameters._repulsion_strength = 1]  - Weighting applied to negative samples.
     * @param {Number} [parameters._negative_sample_rate = 5] - The number of negative samples per positive sample.
     * @param {Number} [parameters._n_epochs = 350] - The number of training epochs.
     * @param {Number} [parameter._initial_alpha = 1] - The initial learning rate for the optimization.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {UMAP}
     */
constructor(t,e){
/* let n_neighbors = Math.min(this._N - 1, parameters.n_neighbors);
        this.parameter("n_neighbors", n_neighbors);
        this.parameter("local_connectivity", Math.min(this.parameter("local_connectivity"), n_neighbors - 1)); */
if(super(t,{n_neighbors:15,local_connectivity:1,min_dist:1,d:2,metric:euclidean,seed:1212,_spread:1,_set_op_mix_ratio:1,_repulsion_strength:1,_negative_sample_rate:5,_n_epochs:350,_initial_alpha:1},e),[this._N,this._D]=this.X.shape,this.parameter("n_neighbors")>this._N)throw new Error(`Parameter n_neighbors (=${this.parameter("n_neighbors")}) needs to be smaller than dataset size (N=${this._N})!`);if(this.parameter("local_connectivity")>this.parameter("n_neighbors"))throw new Error(`Parameter local_connectivity (=${this.parameter("local_connectivity")}) needs to be smaller than parameter n_neighbors (=${this.parameter("n_neighbors")})`);this._iter=0;const r=this._randomizer;return this.Y=new Matrix(this._N,this.parameter("d"),(()=>r.random)),this}
/**
     * @private
     * @param {Number} spread
     * @param {Number} min_dist
     * @returns {Array}
     */_find_ab_params(t,e){const r=linspace(0,3*t,300),s=linspace(0,3*t,300);for(let i=0,n=r.length;i<n;++i){const n=r[i];s[i]=n<e?1:Math.exp(-(n-e)/t)}return powell((t=>{const e=linspace(1,300).map(((e,i)=>{return s[i]-(n=r[i],o=t[0],a=t[1],1/(1+o*Math.pow(n,2*a)));var n,o,a}));return Math.sqrt(neumair_sum(e.map((t=>t*t))))}),[1,1])}
/**
     * @private
     * @param {Array<Array>} distances
     * @param {Array<Number>} sigmas
     * @param {Array<Number>} rhos
     * @returns {Array}
     */_compute_membership_strengths(t,e,r){for(let s=0,i=t.length;s<i;++s)for(let i=0,n=t[s].length;i<n;++i){const n=t[s][i].value-r[s];t[s][i].value=n>0?Math.exp(-n/e[s]):1}return t}
/**
     * @private
     * @param {KNN|BallTree} knn
     * @param {Number} k
     * @returns {Object}
     */_smooth_knn_dist(t,e){const r=1e-5,s=.001,{local_connectivity:i,metric:n}=this._parameters,o=Math.log2(e),a=[],h=[],l=this.X,_=l.shape[0],c=[];if("precomputed"===n)for(let r=0;r<_;++r)c.push(t.search(r,e).reverse());else for(const r of l)c.push(t.search(r,e).raw_data().reverse());for(let t=0;t<_;++t){let n=0,l=1/0,_=1;const u=c[t],d=u.filter((t=>t.value>0)),m=d.length;if(m>=i){const e=Math.floor(i),s=i-e;e>0?(a.push(d[e-1]),s>r&&(a[t].value+=s*(d[e].value-d[e-1]))):a[t].value=s*d[0].value}else m>0&&(a[t]=d[m-1].value);for(let s=0;s<64;++s){let s=0;for(let r=0;r<e;++r){const e=u[r].value-a[t];s+=e>0?Math.exp(-e/_):1}if(Math.abs(s-o)<r)break;s>o?[l,_]=[_,(n+l)/2]:[n,_]=l===1/0?[_,2*_]:[_,(n+l)/2]}h[t]=_;const p=u.reduce(((t,e)=>t+e.value),0)/u.length;
//let mean_d = null;
if(a[t]>0)h[t]<s*p&&(h[t]=s*p);else{const e=c.reduce(((t,e)=>t+e.reduce(((t,e)=>t+e.value),0)/e.length));h[t]>s*e&&(h[t]=s*e)}}return{distances:c,sigmas:h,rhos:a}}
/**
     * @private
     * @param {Matrix} X
     * @param {Number} n_neighbors
     * @returns {Matrix}
     */_fuzzy_simplicial_set(t,e){const r=t.shape[0],{metric:s,_set_op_mix_ratio:i}=this._parameters,n="precomputed"===s?new KNN(t,"precomputed"):new BallTree(t.to2dArray,s);let{distances:o,sigmas:a,rhos:h}=this._smooth_knn_dist(n,e);o=this._compute_membership_strengths(o,a,h);const l=new Matrix(r,r,"zeros");for(let t=0;t<r;++t){const e=o[t];for(let r=0;r<e.length;++r)l.set_entry(t,e[r].element.index,e[r].value)}const _=l.T,c=l.mult(_);return l.add(_).sub(c).mult(i).add(c.mult(1-i))}
/**
     * @private
     * @param {Number} n_epochs
     * @returns {Array}
     */_make_epochs_per_sample(t){const e=this._weights,r=new Float32Array(e.length).fill(-1),s=max(e),i=e.map((e=>t*(e/s)));for(let e=0;e<r.length;++e)i[e]>0&&(r[e]=Math.round(t/i[e]));return r}
/**
     * @private
     * @param {Matrix} graph
     * @returns {Object}
     */_tocoo(t){const e=[],r=[],s=[],[i,n]=t.shape;for(let o=0;o<i;++o)for(let i=0;i<n;++i){const n=t.entry(o,i);0!==n&&(e.push(o),r.push(i),s.push(n))}return{rows:e,cols:r,data:s}}
/**
     * Computes all necessary
     * @returns {UMAP}
     */init(){const{_spread:t,min_dist:e,n_neighbors:r,_n_epochs:s,_negative_sample_rate:i}=this._parameters,[n,o]=this._find_ab_params(t,e);this._a=n,this._b=o,this._graph=this._fuzzy_simplicial_set(this.X,r);const{rows:a,cols:h,data:l}=this._tocoo(this._graph);return this._head=a,this._tail=h,this._weights=l,this._epochs_per_sample=this._make_epochs_per_sample(s),this._epochs_per_negative_sample=this._epochs_per_sample.map((t=>t*i)),this._epoch_of_next_sample=this._epochs_per_sample.slice(),this._epoch_of_next_negative_sample=this._epochs_per_negative_sample.slice(),this}graph(){return this.check_init(),{cols:this._head,rows:this._tail,weights:this._weights}}
/**
     *
     * @param {Number} [iterations=350] - number of iterations.
     * @returns {Matrix|Array}
     */transform(t=350){this.parameter("_n_epochs")!=t&&(this.parameter("_n_epochs",t),this.init()),this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}
/**
     *
     * @param {Number} [iterations=350] - number of iterations.
     * @returns {Matrix|Array}
     */*generator(t=350){this.parameter("_n_epochs")!=t&&(this.parameter("_n_epochs",t),this.init()),this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}
/**
     * @private
     * @param {Number} x
     * @returns {Number}
     */_clip(t){return t>4?4:t<-4?-4:t}
/**
     * performs the optimization step.
     * @private
     * @param {Matrix} head_embedding
     * @param {Matrix} tail_embedding
     * @param {Matrix} head
     * @param {Matrix} tail
     * @returns {Matrix}
     */_optimize_layout(t,e,r,s){const i=this._randomizer,{_repulsion_strength:n,d:o}=this._parameters,{_alpha:a,_a:h,_b:l,_epochs_per_sample:_,_epochs_per_negative_sample:c,_epoch_of_next_negative_sample:u,_epoch_of_next_sample:d,_clip:m}=this,p=s.length;for(let f=0,y=_.length;f<y;++f)if(d[f]<=this._iter){const y=r[f],w=s[f],g=t.row(y),x=e.row(w),M=euclidean_squared(g,x);let A=0;M>0&&(A=-2*h*l*Math.pow(M,l-1)/(h*Math.pow(M,l)+1));for(let r=0;r<o;++r){const s=m(A*(g[r]-x[r]))*a,i=g[r]+s,n=x[r]-s;g[r]=i,x[r]=n,t.set_entry(y,r,i),e.set_entry(w,r,n)}d[f]+=_[f];const b=(this._iter-u[f])/c[f];for(let r=0;r<b;++r){const r=i.random_int%p,_=e.row(s[r]),c=euclidean_squared(g,_);let u=0;if(c>0)u=2*n*l/((.01+c)*(h*Math.pow(c,l)+1));else if(y===r)continue;for(let i=0;i<o;++i){const n=m(u*(g[i]-_[i]))*a,o=g[i]+n,h=_[i]-n;g[i]=o,_[i]=h,t.set_entry(y,i,o),e.set_entry(s[r],i,h)}}u[f]+=b*c[f]}return t}
/**
     * @private
     * @returns {Matrix}
     */next(){const t=++this._iter,e=this.Y,{_initial_alpha:r,_n_epochs:s}=this._parameters;return this._alpha=r*(1-t/s),this.Y=this._optimize_layout(e,e,this._head,this._tail),this.Y}}
/**
 * @class
 * @alias TriMap
 * @extends DR
 */class TriMap extends DR{
/**
     *
     * @constructor
     * @memberof module:druid/dimensionality_reduction
     * @alias TriMap
     * @param {Matrix|Number[][]} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.weight_adj = 500] - scaling factor.
     * @param {Number} [parameters.c = 5] - number of triplets multiplier.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Number} [parameters.tol = 1e-8] -
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {TriMap}
     * @see {@link https://arxiv.org/pdf/1910.00204v1.pdf}
     * @see {@link https://github.com/eamid/trimap}
     */
constructor(t,e){return super(t,{weight_adj:500,c:5,d:2,metric:euclidean,tol:1e-8,seed:1212},e),this}
/**
     *
     * @param {Matrix} [pca = null] - Initial Embedding (if null then PCA gets used).
     * @param {KNN} [knn = null] - KNN Object (if null then BallTree gets used).
     */init(t=null,e=null){const r=this.X,s=r.shape[0],{d:i,metric:n,c:o}=this._parameters;this.n_inliers=2*o,this.n_outliers=1*o,this.n_random=1*o,this.Y=t||new PCA(r,i).transform(),this.knn=e||new BallTree(r.to2dArray,n);const{triplets:a,weights:h}=this._generate_triplets(this.n_inliers,this.n_outliers,this.n_random);return this.triplets=a,this.weights=h,this.lr=1e3*s/a.shape[0],this.C=1/0,this.vel=new Matrix(s,i,0),this.gain=new Matrix(s,i,1),this}
/**
     * Generates {@link n_inliers} x {@link n_outliers} x {@link n_random} triplets.
     * @param {Number} n_inliers
     * @param {Number} n_outliers
     * @param {Number} n_random
     */_generate_triplets(t,e,r){const{metric:s,weight_adj:i}=this._parameters,n=this.X,o=n.shape[0],a=this.knn,h=Math.min(t+20,o),l=new Matrix(o,h),_=new Matrix(o,h);for(let t=0;t<o;++t)a.search(n.row(t),h+1).raw_data().filter((t=>0!=t.value)).sort(((t,e)=>t.value-e.value)).forEach(((e,r)=>{l.set_entry(t,r,e.element.index),_.set_entry(t,r,e.value)}));
// scale parameter
const c=new Float64Array(o);for(let t=0;t<o;++t)c[t]=Math.max((_.entry(t,3)+_.entry(t,4)+_.entry(t,5)+_.entry(t,6))/4,1e-10);const u=this._find_p(_,c,l);let d=this._sample_knn_triplets(u,l,t,e),m=d.shape[0];const p=new Float64Array(m);for(let t=0;t<m;++t){const e=d.entry(t,0),r=d.entry(t,2);p[t]=s(n.row(e),n.row(r))}let f=this._find_weights(d,u,l,p,c);if(r>0){const{random_triplets:t,random_weights:e}=this._sample_random_triplets(n,r,c);d=d.concat(t,"vertical"),f=Float64Array.from([...f,...e])}m=d.shape[0];let y=-1/0;for(let t=0;t<m;++t)isNaN(f[t])&&(f[t]=0),y<f[t]&&(y=f[t]);let w=-1/0;for(let t=0;t<m;++t)f[t]/=y,f[t]+=1e-4,f[t]=Math.log(1+i*f[t]),w<f[t]&&(w=f[t]);for(let t=0;t<m;++t)f[t]/=w;return{triplets:d,weights:f}}
/**
     * Calculates the similarity matrix P
     * @private
     * @param {Matrix} knn_distances - matrix of pairwise knn distances
     * @param {Float64Array} sig - scaling factor for the distances
     * @param {Matrix} nbrs - nearest neighbors
     * @returns {Matrix} pairwise similarity matrix
     */_find_p(t,e,r){const[s,i]=t.shape;return new Matrix(s,i,((s,i)=>Math.exp(-(t.entry(s,i)**2)/e[s]/e[r.entry(s,i)])))}
/**
     * Sample nearest neighbors triplets based on the similarity values given in P.
     * @private
     * @param {Matrix} P - Matrix of pairwise similarities between each point and its neighbors given in matrix nbrs.
     * @param {Matrix} nbrs - Nearest neighbors indices for each point. The similarity values are given in matrix {@link P}. Row i corresponds to the i-th point.
     * @param {Number} n_inliers - Number of inlier points.
     * @param {Number} n_outliers - Number of outlier points.
     *
     */_sample_knn_triplets(t,e,r,s){const i=e.shape[0],n=new Matrix(i*r*s,3);for(let o=0;o<i;++o){let a=o*r*s;const h=this.__argsort(t.row(o).map((t=>-t)));for(let t=0;t<r;++t){let r=t*s;const l=e.entry(o,h[t]),_=this._rejection_sample(s,i,h.slice(0,t+1));for(let t=0;t<s;++t){const e=a+r+t,s=_[t];n.set_entry(e,0,o),n.set_entry(e,1,l),n.set_entry(e,2,s)}}}return n}
/**
     * Should do the same as np.argsort()
     * @private
     * @param {Array} A
     */__argsort(t){return t.map(((t,e)=>({d:t,i:e}))).sort(((t,e)=>t.d-e.d)).map((t=>t.i))}
/**
     * Samples {@link n_samples} integers from a given interval [0, {@link max_int}] while rejection the values that are in the {@link rejects}.
     * @private
     * @param {*} n_samples
     * @param {*} max_int
     * @param {*} rejects
     */_rejection_sample(t,e,r){const s=this._randomizer,i=linspace(0,e-1).filter((t=>r.indexOf(t)<0));return s.choice(i,Math.min(t,i.length-2))}
/**
     * Calculates the weights for the sampled nearest neighbors triplets
     * @private
     * @param {Matrix} triplets - Sampled Triplets.
     * @param {Matrix} P - Pairwise similarity matrix.
     * @param {Matrix} nbrs - nearest Neighbors
     * @param {Float64Array} outlier_distances - Matrix of pairwise outlier distances
     * @param {Float64Array} sig - scaling factor for the distances.
     */_find_weights(t,e,r,s,i){const n=t.shape[0],o=new Float64Array(n);for(let a=0;a<n;++a){const n=t.entry(a,0),h=r.row(n).indexOf(t.entry(a,1)),l=e.entry(n,h);let _=Math.exp(-(s[a]**2)/(i[n]*i[t.entry(a,2)]));_<1e-20&&(_=1e-20),o[a]=l/_}return o}
/**
     * Sample uniformly ranom triplets
     * @private
     * @param {Matrix} X - Data matrix.
     * @param {Number} n_random - Number of random triplets per point
     * @param {Float64Array} sig - Scaling factor for the distances
     */_sample_random_triplets(t,e,r){const s=this.parameter("metric"),i=this._randomizer,n=t.shape[0],o=new Matrix(n*e,3),a=new Float64Array(n*e);for(let h=0;h<n;++h){const l=h*e,_=[...linspace(0,h-1),...linspace(h+1,n-1)];for(let n=0;n<e;++n){let[e,c]=i.choice(_,2),u=Math.exp(-(s(t.row(h),t.row(e))**2)/(r[h]*r[e]));u<1e-20&&(u=1e-20);let d=Math.exp(-(s(t.row(h),t.row(c))**2)/(r[h]*r[c]));d<1e-20&&(d=1e-20),u<d&&([e,c]=[c,e],[u,d]=[d,u]);const m=l+n;o.set_entry(m,0,h),o.set_entry(m,1,e),o.set_entry(m,2,c),a[m]=u/d}}return{random_triplets:o,random_weights:a}}
/**
     * Computes the gradient for updating the embedding.
     * @param {Matrix} Y - The embedding
     */_grad(t){const e=this.n_inliers,r=this.n_outliers,s=this.triplets,i=this.weights,[n,o]=t.shape,a=s.shape[0],h=new Matrix(n,o,0);let l=new Float64Array(o),_=new Float64Array(o),c=1,u=1,d=0,m=0;const p=n*e*r;for(let e=0;e<a;++e){const[n,a,f]=s.row(e);
// update y_ij, y_ik, d_ij, d_ik
if(e%r==0||e>=p){c=1,u=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(a,e),i=t.entry(f,e);l[e]=r-s,_[e]=r-i,c+=l[e]**2,u+=_[e]**2}
// update y_ik and d_ik only
}else{u=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(f,e);_[e]=r-s,u+=_[e]**2}}c>u&&++d,m+=i[e]/(1+u/c);const y=(i[e]/(c+u))**2;for(let t=0;t<o;++t){const e=l[t]*u*y,r=_[t]*c*y;h.set_entry(n,t,h.entry(n,t)+e-r),h.set_entry(a,t,h.entry(a,t)-e),h.set_entry(f,t,h.entry(f,t)+r)}}return{grad:h,loss:m,n_viol:d}}
/**
     *
     * @param {Number} max_iteration
     */transform(t=400){this.check_init();for(let e=0;e<t;++e)this._next(e);return this.projection}
/**
     * @param {Number} max_iteration
     * @yields {Matrix}
     * @returns {Matrix}
     */*generator(t=800){this.check_init();for(let e=0;e<t;++e)this._next(e),yield this.projection;return this.projection}
/**
     * Does the iteration step.
     * @private
     * @param {Number} iter
     */_next(t){const e=t>150?.5:.3,r=this.C,s=this.vel,i=this.Y.add(s.mult(e)),{grad:n,loss:o,n_viol:a}=this._grad(i);return this.C=o,this.Y=this._update_embedding(i,t,n),this.lr*=r>o+this._parameters.tol?1.01:.9,this.Y}
/**
     * Updates the embedding.
     * @private
     * @param {Matrix} Y
     * @param {Number} iter
     * @param {Matrix} grad
     */_update_embedding(t,e,r){const[s,i]=t.shape,n=e>150?.9:.5,o=this.gain,a=this.vel,h=this.lr;for(let e=0;e<s;++e)for(let s=0;s<i;++s){const i=Math.sign(a.entry(e,s))!=Math.sign(r.entry(e,s))?o.entry(e,s)+.2:Math.max(.8*o.entry(e,s),.01);o.set_entry(e,s,i),a.set_entry(e,s,n*a.entry(e,s)-h*o.entry(e,s)*r.entry(e,s)),t.set_entry(e,s,t.entry(e,s)+a.entry(e,s))}return t}}
/**
 * @class
 * @alias Hierarchical_Clustering
 */class Hierarchical_Clustering{
/**
     * @constructor
     * @memberof module:clustering
     * @alias Hierarchical_Clustering
     * @todo needs restructuring.
     * @param {Matrix} - Data or distance matrix if metric is 'precomputed'
     * @param {("single"|"complete"|"average")} [linkage = "complete"]
     * @param {Function|"precomputed"} [metric = euclidean]
     * @returns {Hierarchical_Clustering}
     */
constructor(t,e="complete",r=euclidean){if(this._id=0,this._matrix=t instanceof Matrix?t:Matrix.from(t),this._metric=r,this._linkage=e,"precomputed"===r&&this._matrix.shape[0]!==this._matrix.shape[1])throw new Error("If metric is 'precomputed', then matrix has to be square!");return this.init(),this.root=this.do(),this}
/**
     *
     * @param {Number} value - value where to cut the tree.
     * @param {("distance"|"depth")} [type = "distance"] - type of value.
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}.
     */get_clusters(t,e="distance"){let r,s=[];switch(e){case"distance":r=t=>t.dist;break;case"depth":r=t=>t.depth;break;default:throw new Error("invalid type")}return this._traverse(this.root,r,t,s),s}
/**
     * @private
     * @param {} node
     * @param {*} f
     * @param {*} value
     * @param {*} result
     */_traverse(t,e,r,s){e(t)<=r?s.push(t.leaves()):(this._traverse(t.left,e,r,s),this._traverse(t.right,e,r,s))}
/**
     * computes the tree.
     */init(){const t=this._metric,e=this._matrix,r=this._n=e.shape[0],s=this._d_min=new Float64Array(r);let i;if("precomputed"!==t){i=new Matrix(r,r,0);//new Array(n);
for(let n=0;n<r;++n){s[n]=0;
//distance_matrix[i] = new Float64Array(n);
for(let o=0;o<r;++o)i.set_entry(n,o,n===o?1/0:t(e.row(n),e.row(o))),i.entry(n,s[n])>i.entry(n,o)&&(s[n]=o)}}else{i=this._matrix.clone();for(let t=0;t<r;++t)for(let e=0;e<r;++e)t===e?i.set_entry(t,e,1/0):i.entry(t,s[t])>i.entry(t,e)&&(s[t]=e)}this._distance_matrix=i;const n=this._clusters=new Array(r),o=this._c_size=new Uint16Array(r);for(let t=0;t<r;++t)n[t]=[],n[t][0]=new Cluster(this._id++,null,null,0,e.row(t),t,1,0),o[t]=1;return this}
/**
     * computes the tree.
     */do(){const t=this._n,e=this._d_min,r=this._distance_matrix,s=this._clusters,i=this._c_size,n=this._linkage;let o=null;for(let a=0,h=t-1;a<h;++a){let a=0;for(let s=0;s<t;++s){let i=r.entry(s,e[s]);for(let n=s+1;n<t;++n)i>r.entry(s,n)&&(e[s]=n,i=r.entry(s,e[s]))}for(let s=0;s<t;++s)r.entry(s,e[s])<r.entry(a,e[a])&&(a=s);let h=e[a],l=s[a][0],_=s[h][0],c=l.isLeaf?[l.index]:l.index,u=_.isLeaf?[_.index]:_.index,d=c.concat(u),m=new Cluster(this._id++,l,_,r.entry(a,h),null,d);l.parent=m,_.parent=m,s[a].unshift(m),i[a]+=i[h];for(let e=0;e<t;++e){const t=r.entry(a,e),s=r.entry(h,e);let o;switch(n){case"single":o=Math.min(t,s);break;case"complete":o=Math.max(t,s);break;case"average":o=(i[a]*t+i[h]*s)/(i[a]+i[e])}r.set_entry(e,a,o),r.set_entry(a,e,o)}r.set_entry(a,a,1/0);for(let e=0;e<t;++e)r.set_entry(e,h,1/0),r.set_entry(h,e,1/0);
/* for (let j = 0; j < n; ++j) {
                if (d_min[j] === c2) {
                    d_min[j] = c1;
                }
                if (D.entry(c1, j) < D.entry(c1, d_min[c1])) {
                    d_min[c1] = j;
                }
            } */o=m}return o}}class Cluster{constructor(t,e,r,s,i,n,o,a){return this.id=t,this.left=e,this.right=r,this.dist=s,this.index=n,this.size=o??e.size+r.size,this.depth=a??1+Math.max(e.depth,r.depth),this.centroid=i??this._calculate_centroid(e,r),this.parent=null,this}_calculate_centroid(t,e){const r=t.size,s=e.size,i=t.centroid,n=e.centroid,o=this.size,a=t.centroid.length,h=new Float64Array(a);for(let t=0;t<a;++t)h[t]=(r*i[t]+s*n[t])/o;return h}get isLeaf(){return 0===this.depth}leaves(){if(this.isLeaf)return[this];const t=this.left,e=this.right;return(t.isLeaf?[t]:t.leaves()).concat(e.isLeaf?[e]:e.leaves())}descendants(){if(this.isLeaf)return[this];const t=this.left.descendants(),e=this.right.descendants();return t.concat(e).concat([this])}}
/**
 * @class
 * @alias KMeans
 */class KMeans{
/**
     * @constructor
     * @memberof module:clustering
     * @alias KMeans
     * @todo needs restructuring. 
     * @param {Matrix} matrix 
     * @param {Numbers} K 
     * @param {Function} [metric = euclidean] 
     * @param {Number} [seed = 1987]
     * @param {Boolean} [init = true]
     * @returns {KMeans}
     */
constructor(t,e,r=euclidean,s=1987,i=!0){this._metric=r,this._matrix=t,this._K=e;const[n,o]=t.shape;return this._N=n,this._D=o,e>n&&(e=n),this._randomizer=new Randomizer(s),this._clusters=new Array(n).fill(void 0),this._cluster_centroids=this._get_random_centroids(e),i&&this.init(e,this._cluster_centroids),this}
/**
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. 
     */get_clusters(){const t=this._K,e=this._clusters,r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>r[t].push(e))),r}
/**
     * @private
     * @param {Array} points 
     * @param {Array} candidates 
     */_furthest_point(t,e){const r=this._matrix,s=this._metric;let i=t.length;return Heap.heapify(e,(e=>{const n=r.row(e);let o=0;for(let e=0;e<i;++e)o+=s(n,t[e]);return o}),"max").pop().element}_get_random_centroids(t){const e=this._N,r=this._randomizer,s=this._matrix,i=new Array(t).fill(),n=linspace(0,e-1),o=r.random_int%(e-1);i[0]=s.row(o);const a=[o],h=Math.floor((e-t)/t);// / K
for(let e=1;e<t;++e){
// sampling + kmeans++ improvement?
const t=r.choice(n.filter((t=>-1==a.indexOf(t))),h),o=this._furthest_point(i.slice(0,e),t);a.push(o),i[e]=s.row(o)}return i}_iteration(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._metric,o=this._clusters;let a=!1;
// find nearest cluster centroid.
for(let s=0;s<r;++s){const r=i.row(s);let h=1/0,l=null;for(let s=0;s<e;++s){let e=n(t[s],r);e<h&&(h=e,l=s)}o[s]!==l&&(a=!0),o[s]=l}
// update cluster centroid
// reset cluster centroids to 0
for(let r=0;r<e;++r){const e=t[r];for(let t=0;t<s;++t)e[t]=0}
// compute centroid
return this._compute_centroid(t),{clusters_changed:a,cluster_centroids:t}}_compute_centroid(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._clusters,o=new Array(e).fill(0);for(let e=0;e<r;++e){const r=i.row(e),a=n[e];o[a]++;const h=t[a];for(let t=0;t<s;++t)h[t]+=r[t]}for(let r=0;r<e;++r){const e=o[r];t[r]=t[r].map((t=>t/e))}}
/**
     * Computes {@link K} clusters out of the {@link matrix}.
     * @param {Number} K - number of clusters.
     */init(t,e){t||(t=this._K),e||(e=this._get_random_centroids(t));let r=!1;do{const t=this._iteration(e);e=t.cluster_centroids,r=t.clusters_changed}while(r)}}
/**
 * @class
 * @alias KMedoids
 */class KMedoids{
/**
     * @constructor
     * @memberof module:clustering
     * @alias KMedoids
     * @todo needs restructuring. 
     * @param {Matrix} matrix - data matrix
     * @param {Numbers} K - number of clusters
     * @param {number} [max_iter=null] - maximum number of iterations. Default is 10 * Math.log10(N)
     * @param {Function} [metric = euclidean] - metric defining the dissimilarity 
     * @param {Number} [seed = 1212] - seed value for random number generator
     * @returns {KMedoids}
     * @see {@link https://link.springer.com/chapter/10.1007/978-3-030-32047-8_16} Faster k-Medoids Clustering: Improving the PAM, CLARA, and CLARANS Algorithms
     */
constructor(t,e,r=null,s=euclidean,i=1212){this._metric=s,this._matrix=t,this._A=this._matrix.to2dArray,this._K=e;const[n,o]=t.shape;return this._N=n,this._D=o,this._max_iter=r||10*Math.log10(n),this._distance_matrix=new Matrix(n,n,"zeros"),
/* for (let i = 1; i < N; ++i) {
            for (let j = i + 1; j < N; ++j) {
                let dist = metric(this._A[i], this._A[j]);
                this._distance_matrix.set_entry(i, j, dist);
                this._distance_matrix.set_entry(j, i, dist)
            }
        } */
e>n&&(e=n),this._randomizer=new Randomizer(i),this._clusters=new Array(n).fill(void 0),this._cluster_medoids=this._get_random_medoids(e),
//if (init) this.init(K, this._cluster_medoids);
this._is_initialized=!1,this}
/**
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. 
     */get_clusters(){const t=this._K,e=this._A;this._is_initialized||this.init(t,this._cluster_medoids);const r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>{r[this._nearest_medoid(t,e).index_nearest].push(e)})),r.medoids=this._cluster_medoids,r}async*generator(){const t=this._max_iter;yield this.get_clusters();let e=!1,r=0;do{e=this._iteration(),yield this.get_clusters()}while(!e&&++r<t)}
/**
     * Algorithm 1. FastPAM1: Improved SWAP algorithm
     */
/* _iteration_1() {
        const A = this._A;
        const N = this._N;
        const K = this._K;
        const medoids = this._cluster_medoids;
        let DeltaTD = 0;
        let m0 = null;
        let x0 = null;
        A.forEach((x_j, j) => {
            if (medoids.findIndex(m => m === j) < 0) {
                const nearest_medoid = this._nearest_medoid(x_j, j);
                const d_j = nearest_medoid.distance_nearest; // distance to current medoid
                const deltaTD = new Array(K).fill(-d_j); // change if making j a medoid
                A.forEach((x_o, o) => {
                    // disance to new medoid
                    const d_oj = this._get_distance(o, j, x_o, x_j);
                    const {
                        "index_nearest": n,
                        "distance_nearest": d_n,
                        "distance_second": d_s,
                    } = this._nearest_medoid(x_o, o); 
                    this._clusters[o] = n; // cached values
                    deltaTD[n] += Math.min(d_oj, d_s) - d_n; // loss change
                    if (d_oj < d_n) { // reassignment check
                        deltaTD.forEach((d_i, i) => {
                            if (n !== i) {
                                deltaTD[i] = d_i + d_oj - d_n; // update loss change
                            }
                        });
                    }
                });
                // choose best medoid i;
                const i = deltaTD
                    .map((d, i) => [d, i])
                    .sort((d1, d2) => d1[0] - d2[0])[0][1];
                const deltaTD_i = deltaTD[i];
                // store
                if (deltaTD_i < DeltaTD) {
                    DeltaTD = deltaTD_i;
                    m0 = i;
                    x0 = j;
                }
            }
        });

        if (DeltaTD >= 0) {
            return true // break loop if DeltaTD >= 0
        }
        // swap roles of medoid m and non-medoid x;
        medoids[m0] = x0;
        this._cluster_medoids = medoids;
        return false
    } */
/** Algorithm 2. FastPAM2: SWAP with multiple candidates
     * 
     */_iteration(){const t=this._A,e=this._K,r=this._cluster_medoids,s=t.map(((t,e)=>this._nearest_medoid(t,e))),i=new Array(e).fill(0),n=new Array(e).fill(null);
// stop if no improvements were found
if(t.forEach(((o,a)=>{if(r.findIndex((t=>t===a))<0){const r=s[a].distance_nearest,h=new Array(e).fill(-r);// distance to current medoid
// change if making j a medoid
t.forEach(((t,r)=>{if(a===r)return;const i=this._get_distance(r,a,t,o),{index_nearest:n,distance_nearest:l,distance_second:_}=s[r];// distance to new medoid
// loss change for x_o
// Reassignment check
if(// cached
h[n]+=Math.min(i,_)-l,i<l)
// update loss change
for(let t=0;t<e;++t)t!==n&&(h[t]+=i-l)})),
// remember best swap for i;
h.map(((t,e)=>[t,e])).filter((([t,e])=>t<i[e])).forEach((([t,e])=>{t<i[e]&&(i[e]=t,n[e]=a)}))}})),min(i)>=0)return!0;
// execute all improvements
for(;min(i)<0;){
// swap roles of medoid m_i and non_medoid xs_i
const e=i.map(((t,e)=>[t,e])).sort((([t],[e])=>t-e))[0][1];0==r.filter((t=>t==n[e])).length&&(r[e]=n[e]),
// disable the swap just performed
i[e]=0,
// recompute TD for remaining swap candidates
i.map(((t,e)=>[t,e])).filter((([t])=>t<0)).forEach((([n,o])=>{const a=t[o];let h=0;t.forEach(((t,i)=>{r.findIndex((t=>t!=o&&t==i))>=0||e!=o&&(s[i].index_nearest===r[o]?h+=Math.min(this._get_distance(i,o,t,a),s[i].distance_second)-s[i].distance_nearest:h+=Math.min(this._get_distance(i,o,t,a)-s[i].distance_nearest,0))})),i[o]=h}))}return this._cluster_medoids=r,!1}_get_distance(t,e,r=null,s=null){if(t===e)return 0;const i=this._distance_matrix,n=this._A,o=this._metric;let a=i.entry(t,e);return 0===a&&(a=o(r||n[t],s||n[e]),i.set_entry(t,e,a),i.set_entry(e,t,a)),a}_nearest_medoid(t,e){const r=this._cluster_medoids,s=this._A,[i,n]=r.map(((r,i)=>{const n=s[r];return[this._get_distance(e,r,t,n),i]})).sort(((t,e)=>t[0]-e[0]));return{distance_nearest:i[0],index_nearest:i[1],distance_second:n[0],index_second:n[1]}}
/**
     * Computes {@link K} clusters out of the {@link matrix}.
     * @param {Number} K - number of clusters.
     */init(t,e){t||(t=this._K),e||(e=this._get_random_medoids(t));const r=this._max_iter;let s=!1,i=0;do{s=this._iteration()}while(!s&&++i<r);return this}
/**
     * Algorithm 3. FastPAM LAB: Linear Approximate BUILD initialization.
     * @param {number} K - number of clusters
     * 
     */_get_random_medoids(t){const e=this._N,r=this._A,s=linspace(0,e-1),i=this._randomizer,n=Math.min(e,10+Math.ceil(Math.sqrt(e))),o=new Array(n).fill(1/0),a=[];
// first medoid
let h=1/0,l=i.choice(s,n);for(let t=0;t<n;++t){const e=l[t],s=r[e];for(let e=0;e<n;++e){if(e===t)continue;const i=r[l[e]];o[t]+=this._get_distance(t,e,s,i)}o[t]<h&&(h=o[t],// smallest distance sum
a.push(e))}
// other medoids
for(let e=1;e<t;++e){let t=1/0;l=i.choice(s.filter((t=>a.findIndex((e=>e===t))<0)),n);for(let e=0;e<n;++e){let s=0;const i=l[e],o=r[i];for(let t=0;t<n;++t){if(t===e)continue;const n=l[t],h=r[n];let _=this._get_distance(i,n,o,h)-min(a.map((t=>this._get_distance(n,t,h))));_<0&&(s+=_)}
// best reduction
s<t&&(t=s,a.push(i))}h+=t}return a.slice(0,t)}}
/**
 * @class
 * @alias OPTICS
 */class OPTICS{
/**
     * **O**rdering **P**oints **T**o **I**dentify the **C**lustering **S**tructure.
     * @constructor
     * @memberof module:clustering
     * @alias OPTICS
     * @todo needs restructuring. 
     * @param {Matrix} matrix - the data.
     * @param {Number} epsilon - the minimum distance which defines whether a point is a neighbor or not.
     * @param {Number} min_points - the minimum number of points which a point needs to create a cluster. (Should be higher than 1, else each point creates a cluster.)
     * @param {Function} [metric = euclidean] - the distance metric which defines the distance between two points of the {@link matrix}.
     * @returns {OPTICS}
     * @see {@link https://www.dbs.ifi.lmu.de/Publikationen/Papers/OPTICS.pdf}
     * @see {@link https://en.wikipedia.org/wiki/OPTICS_algorithm}
     */
constructor(t,e,r,s=euclidean){return this._matrix=t,this._epsilon=e,this._min_points=r,this._metric=s,this._ordered_list=[],this._clusters=[],this._DB=new Array(t.shape[0]).fill(),this.init(),this}
/**
     * Computes the clustering.
     */init(){const t=this._ordered_list,e=this._matrix,r=e.shape[0],s=this._DB,i=this._clusters;let n=this._cluster_index=0;for(let t=0;t<r;++t)s[t]={element:e.row(t),index:t,reachability_distance:void 0,processed:!1};for(const e of s)if(!e.processed&&(e.neighbors=this._get_neighbors(e),e.processed=!0,i.push([e.index]),n=i.length-1,t.push(e),null!=this._core_distance(e))){const t=new Heap(null,(t=>t.reachability_distance),"min");this._update(e,t),this._expand_cluster(t,i[n])}return this}
/**
     * 
     * @private
     * @param {Object} p - a point of {@link matrix}.
     * @returns {Array} An array consisting of the {@link epsilon}-neighborhood of {@link p}.
     */_get_neighbors(t){if("neighbors"in t)return t.neighbors;const e=this._DB,r=this._metric,s=this._epsilon,i=[];for(const n of e)n.index!=t.index&&r(t.element,n.element)<s&&i.push(n);return i}
/**
     * 
     * @private
     * @param {Object} p - a point of {@link matrix}.
     * @returns {Number} The distance to the {@link min_points}-th nearest point of {@link p}, or undefined if the {@link epsilon}-neighborhood has fewer elements than {@link min_points}.
     */_core_distance(t){const e=this._min_points,r=this._metric;if(!(t.neighbors&&t.neighbors.length<=e))return r(t.element,t.neighbors[e].element)}
/**
     * Updates the reachability distance of the points.
     * @private
     * @param {Object} p 
     * @param {Heap} seeds 
     */_update(t,e){const r=this._metric,s=this._core_distance(t),i=this._get_neighbors(t);//p.neighbors;
for(const n of i){if(n.processed)continue;const i=Math.max(s,r(t.element,n.element));
//if (q.reachability_distance == undefined) { // q is not in seeds
e.raw_data().findIndex((t=>t.element==n))<0?(n.reachability_distance=i,e.push(n)):// q is in seeds
i<n.reachability_distance&&(n.reachability_distance=i,e=Heap.heapify(e.data(),(t=>t.reachability_distance),"min"))}}
/**
     * Expands the {@link cluster} with points in {@link seeds}.
     * @private
     * @param {Heap} seeds 
     * @param {Array} cluster 
     */_expand_cluster(t,e){const r=this._ordered_list;for(;!t.empty;){const s=t.pop().element;s.neighbors=this._get_neighbors(s),s.processed=!0,e.push(s.index),r.push(s),null!=this._core_distance(s)&&(this._update(s,t),this._expand_cluster(t,e))}}
/**
     * Returns an array of clusters.
     * @returns {Array<Array>} Array of clusters with the indices of the rows in given {@link matrix}.
     */get_clusters(){const t=[],e=[],r=this._min_points;for(const s of this._clusters)s.length<r?e.push(...s):t.push(s);return t.push(e),t}
/**
     * @returns {Array} Returns an array, where the ith entry defines the cluster affirmation of the ith point of {@link matrix}. (-1 stands for outlier)
     */get_cluster_affirmation(){const t=this._matrix.shape[0],e=new Array(t).fill(),r=this.get_clusters();for(let t=0,s=r.length;t<s;++t){const i=r[t];for(const r of i)e[r]=t<s-1?t:-1}return e}}
/**
 * @class
 * @alias LSP
 * @extends DR
 */class LSP extends DR{
/**
     * Least Squares Projection.
     * @constructor
     * @memberof module:druid/dimensionality_reduction
     * @alias LSP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.neighbors = Math.max(Math.floor(N / 10), 2)] - number of neighbors to consider.
     * @param {Number} [parameters.control_points = Math.ceil(Math.sqrt(N))] - number of controlpoints
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {LSP}
     * @see {@link https://ieeexplore.ieee.org/document/4378370}
     * @todo accept precomputed distance matrix.
     */
constructor(t,e){return super(t,{neighbors:void 0,control_points:void 0,d:2,metric:euclidean,seed:1212},e),this.parameter("neighbors",Math.min(e.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this.parameter("control_points",Math.min(e.control_points??Math.ceil(Math.sqrt(this._N)),this._N-1)),this._is_initialized=!1,this}
/**
     *
     * @param {DR} DR - method used for position control points.
     * @param {Object} DR_parameters - Object containing parameters for the DR method which projects the control points
     * @returns {LSP}
     */init(t=MDS,e={},r=BallTree){if(this._is_initialized)return this;const s=this.X,i=this._N,n=this.parameter("neighbors"),o=this.parameter("d"),a=this.parameter("seed"),h=this.parameter("metric");e=Object.assign({d:o,metric:h,seed:a},e);const l=this.parameter("control_points"),_=new KMedoids(s,l,null,h).get_clusters().medoids,c=new Matrix(l,i,"zeros");_.forEach(((t,e)=>{c.set_entry(e,t,1)}));const u=new t(Matrix.from(_.map((t=>s.row(t)))),e).transform(),d=s.to2dArray,m=new r(d,h),p=new Matrix(i,i,"I"),f=-1/n;d.forEach(((t,e)=>{for(const{index:r}of m.search(t,n).iterate())e!==r&&p.set_entry(e,r,f)}));const y=p.concat(c,"vertical"),w=new Matrix(i,o,"zeros").concat(u,"vertical");return this._A=y,this._b=w,this._is_initialized=!0,this}
/**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */transform(){this.check_init();const t=this._A,e=t.T,r=this._b,s=e.dot(t),i=e.dot(r);return this.Y=Matrix.solve_CG(s,i,this._randomizer),this.projection}}
/**
 * @class
 * @alias TopoMap
 * @extends DR
 */class TopoMap extends DR{
/**
     * TopoMap: A 0-dimensional Homology Preserving Projection of High-Dimensional Data.
     * @constructor
     * @memberof module:druid/dimensionality_reduction
     * @alias TopoMap
     * @param {Matrix|Number[][]} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {TopoMap}
     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}
     */
constructor(t,e){return super(t,{metric:euclidean,seed:1212},e),[this._N,this._D]=this.X.shape,this._distance_matrix=new Matrix(this._N,this._N,0),this}
/**
     * @private
     */__lazy_distance_matrix(t,e,r){const s=this._distance_matrix,i=this.X,n=s.entry(t,e);if(0===n){let n=r(i.row(t),i.row(e));return s.set_entry(t,e,n),s.set_entry(e,t,n),n}return n}
/**
     * Computes the minimum spanning tree, using a given metric
     * @private
     * @param {Function} metric
     * @see {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}
     */_make_minimum_spanning_tree(t=euclidean){const e=this._N,r=[...this.X];let s=new DisjointSet(r);const i=[];let n=[];for(let r=0;r<e;++r)for(let s=r+1;s<e;++s)n.push([r,s,this.__lazy_distance_matrix(r,s,t)]);n=n.sort(((t,e)=>t[2]-e[2]));for(const[t,e,o]of n){const n=s.find(r[t]),a=s.find(r[e]);n!==a&&(i.push([t,e,o]),s.union(n,a))}return i.sort(((t,e)=>t[2]-e[2]))}
/**
     * initializes TopoMap. Sets all projcted points to zero, and computes a minimum spanning tree.
     */init(){const{metric:t}=this._parameters;return this.Y=new Matrix(this._N,2,0),this._Emst=this._make_minimum_spanning_tree(t),this._is_initialized=!0,this}
/**
     * Returns true if Point C is left of line AB.
     * @private
     * @param {Array} PointA - Point A of line AB
     * @param {Array} PointB - Point B of line AB
     * @param {Array} PointC - Point C
     * @returns {Boolean}
     */__hull_cross([t,e],[r,s],[i,n]){return(r-t)*(n-e)-(s-e)*(i-t)<=0}
/**
     * Computes the convex hull of the set of Points S
     * @private
     * @param {Array} S - Set of Points.
     * @see {@link https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript}
     * @returns {Array} convex hull of S. Starts at the bottom-most point and continues counter-clockwise.
     */__hull(t){const e=t.sort((([t,e],[r,s])=>e-s||t-r)),r=e.length;if(r<=2)return e;const s=[];for(let t=0;t<r;++t){for(;s.length>=2&&this.__hull_cross(s[s.length-2],s[s.length-1],e[t]);)s.pop();s.push(e[t])}const i=[];for(let t=r-1;t>=0;--t){for(;i.length>=2&&this.__hull_cross(i[i.length-2],i[i.length-1],e[t]);)i.pop();i.push(e[t])}return i.pop(),s.pop(),s.concat(i)}
/**
     * Finds the angle to rotate Point A and B to lie on a line parallel to the x-axis.
     * @private
     * @param {Array} PointA
     * @param {Array} PointB
     * @return {Object} Object containing the sinus- and cosinus-values for a rotation.
     */__findAngle([t,e],[r,s]){const i=euclidean([t,e],[r,s]);if(0===i)return{sin:0,cos:1};const n=[(r-t)/i,(s-e)/i],o=n[0];let a=Math.sqrt(1-o*o);return a=n[1]>=0?-a:a,{sin:a,cos:o}}
/**
     * @private
     * @param {Array} hull
     * @param {Array} p
     * @param {Bool} topEdge
     */__align_hull(t,e,r){let s,i,n,o=-1;for(let r=0;r<t.length;++r){const i=euclidean(t[r],e);(-1===o||s>i)&&(s=i,o=r)}r?(i=t[o],n=t[(o+1)%t.length]):(0==o&&(o=t.length-1),i=t[o],n=t[(o-1)%t.length]);const a={tx:-t[o][0],ty:-t[o][1]};if(t.length>=2){const{sin:t,cos:e}=this.__findAngle(i,n);a.sin=t,a.cos=e}else a.sin=0,a.cos=1;return a}
/**
     * @private
     * @param {Array} Point - The point which should get transformed.
     * @param {Object} Transformation - contains the values for translation and rotation.
     */__transform([t,e],{tx:r,ty:s,sin:i,cos:n}){let o=t+r,a=e+s;return[o*n-a*i,o*i+a*n]}
/**
     * Calls {@link __transform} for each point in Set C
     * @private
     * @param {Array} C - Set of points.
     * @param {Object} t - Transform object.
     * @param {Number} yOffset - value to offset set C.
     */__transform_component(t,e,r){const s=t.length;for(let i=0;i<s;++i){const s=t[i],[n,o]=this.__transform(s,e);s[0]=n,s[1]=o+r}}
/**
     * @private
     * @param {Array} u - point u
     * @param {Array} v - point v
     * @param {Number} w - edge weight w
     */__align_components(t,e,r){const s=[...t.__disjoint_set.children],i=[...e.__disjoint_set.children],n=this.__hull(s),o=this.__hull(i),a=this.__align_hull(n,t,!1),h=this.__align_hull(o,e,!0);this.__transform_component(s,a,0),this.__transform_component(i,h,r)}
/**
     * Transforms the inputdata {@link X} to dimensionality 2.
     */transform(){this._is_initialized||this.init();const t=this._Emst,e=this.Y.to2dArray,r=new DisjointSet(e.map(((t,e)=>(t.i=e,t))));for(const[s,i,n]of t){const t=r.find(e[s]),o=r.find(e[i]);t!==o&&(this.__align_components(t,o,n),r.union(t,o))}return this.projection}*generator(){this._is_initialized||this.init();const t=this._Emst,e=this.Y.to2dArray,r=new DisjointSet(e.map(((t,e)=>(t.i=e,t))));for(const[s,i,n]of t){const t=r.find(e[s]),o=r.find(e[i]);t!==o&&(this.__align_components(t,o,n),r.union(t,o),yield this.projection)}return this.projection}}
/**
 * @class
 * @alias SAMMON
 * @extends DR
 */class SAMMON extends DR{
/**
     * SAMMON's Mapping
     * @constructor
     * @memberof module:@druid/dimensionality_reduction
     * @alias SAMMON
     * @param {Matrix|Number[][]} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {"PCA"|"MDS"|"random"} [parameters.init = "random"] - Either "PCA" or "MDS", with which SAMMON initialiates the projection. With "random" a random matrix gets used as starting point.
     * @param {Object} [parameters.init_parameters] - Parameters for the {@link init}-DR method.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {SAMMON}
     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}
     */
constructor(t,e){return super(t,{magic:.1,d:2,metric:euclidean,seed:1212,init_DR:"random",init_parameters:{}},e),this}
/**
     * initializes the projection.
     * @private
     */init(){const t=this.X.shape[0],{d:e,metric:r,init_DR:s,init_parameters:i}=this._parameters;if("random"===s){const r=this._randomizer;this.Y=new Matrix(t,e,(()=>r.random))}else{if(!["PCA","MDS"].includes(s))throw new Error('init_DR needs to be either "random" or a DR method!');this.Y=Matrix.from("PCA"==s?PCA.transform(this.X,i):MDS.transform(this.X,i))}return this.distance_matrix="precomputed"==r?Matrix.from(this.X):distance_matrix(this.X,r),this}
/**
     * Transforms the inputdata {@link X} to dimenionality 2.
     * @param {Number} [max_iter=200] - Maximum number of iteration steps.
     * @returns {Matrix|Array} - The projection of {@link X}.
     */transform(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step();return this.projection}
/**
     * Transforms the inputdata {@link X} to dimenionality 2.
     * @param {Number} [max_iter=200] - Maximum number of iteration steps.
     * @returns {Generator} - A generator yielding the intermediate steps of the projection of {@link X}.
     */*generator(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step(),yield this.projection;return this.projection}_step(){const t=this.parameter("magic"),e=this.distance_matrix,r=this.X.shape[0],{d:s,metric:i}=this._parameters;let n=this.Y,o=new Matrix(r,s,0),a=new Float64Array(s);for(let h=0;h<r;++h){let l=new Float64Array(s),_=new Float64Array(s);const c=n.row(h);for(let t=0;t<r;++t){if(h===t)continue;const r=n.row(t),o=new Float64Array(s);for(let t=0;t<s;++t)o[t]=c[t]-r[t];const a=i(c,r),u=e.entry(h,t),d=u-a,m=Math.max(u*a,.01);for(let t=0;t<s;++t)l[t]+=o[t]*d/m,_[t]+=(d-Math.pow(o[t],2)*(1+d/a)/a)/m}for(let e=0;e<s;++e){const r=n.entry(h,e)+(t*l[e]/Math.abs(_[e])||0);o.set_entry(h,e,r),a[e]+=r}}for(let t=0;t<s;++t)a[t]/=r;for(let t=0;t<r;++t)for(let e=0;e<s;++e)n.set_entry(t,e,o.entry(t,e)-a[e]);return n}}var t="0.5.1";export{BallTree,DisjointSet,FASTMAP,Heap,Hierarchical_Clustering,ISOMAP,KMeans,KMedoids,KNN,LDA,LLE,LSP,LTSA,MDS,Matrix,OPTICS,PCA,Randomizer,SAMMON,TSNE,TopoMap,TriMap,UMAP,canberra,chebyshev,cosine,distance_matrix,euclidean,euclidean_squared,hamming,inner_product,jaccard,k_nearest_neighbors,kahan_sum,linspace,manhattan,max,min,neumair_sum,norm,normalize,powell,qr_gramschmidt as qr,qr_householder,simultaneous_poweriteration,sokal_michener,t as version,yule};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJ1aWQuZXNtLmpzIiwic291cmNlcyI6WyIuLi9tZXRyaWNzL2V1Y2xpZGVhbi5qcyIsIi4uL251bWVyaWNhbC9rYWhhbl9zdW0uanMiLCIuLi9udW1lcmljYWwvbmV1bWFpcl9zdW0uanMiLCIuLi9tZXRyaWNzL2V1Y2xpZGVhbl9zcXVhcmVkLmpzIiwiLi4vbWV0cmljcy9jb3NpbmUuanMiLCIuLi9tZXRyaWNzL21hbmhhdHRhbi5qcyIsIi4uL21ldHJpY3MvY2hlYnlzaGV2LmpzIiwiLi4vbWV0cmljcy9jYW5iZXJyYS5qcyIsIi4uL21ldHJpY3MvamFjY2FyZC5qcyIsIi4uL21ldHJpY3MvaGFtbWluZy5qcyIsIi4uL21ldHJpY3Mvc29rYWxfbWljaGVuZXIuanMiLCIuLi9tZXRyaWNzL3l1bGUuanMiLCIuLi9tYXRyaXgva19uZWFyZXN0X25laWdoYm9ycy5qcyIsIi4uL21hdHJpeC9kaXN0YW5jZV9tYXRyaXguanMiLCIuLi9tYXRyaXgvbGluc3BhY2UuanMiLCIuLi9tYXRyaXgvbm9ybS5qcyIsIi4uL21hdHJpeC9ub3JtYWxpemUuanMiLCIuLi9saW5lYXJfYWxnZWJyYS9xci5qcyIsIi4uL2xpbmVhcl9hbGdlYnJhL3FyX2hvdXNlaG9sZGVyLmpzIiwiLi4vbGluZWFyX2FsZ2VicmEvc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uLmpzIiwiLi4vbGluZWFyX2FsZ2VicmEvaW5uZXJfcHJvZHVjdC5qcyIsIi4uL21hdHJpeC9NYXRyaXguanMiLCIuLi91dGlsL3JhbmRvbWl6ZXIuanMiLCIuLi91dGlsL21heC5qcyIsIi4uL3V0aWwvbWluLmpzIiwiLi4vZGF0YXN0cnVjdHVyZS9IZWFwLmpzIiwiLi4vZGF0YXN0cnVjdHVyZS9EaXNqb2ludFNldC5qcyIsIi4uL2tubi9CYWxsVHJlZS5qcyIsIi4uL2tubi9LTk4uanMiLCIuLi9kaW1yZWQvRFIuanMiLCIuLi9kaW1yZWQvUENBLmpzIiwiLi4vZGltcmVkL01EUy5qcyIsIi4uL2RpbXJlZC9JU09NQVAuanMiLCIuLi9kaW1yZWQvRkFTVE1BUC5qcyIsIi4uL2RpbXJlZC9MREEuanMiLCIuLi9kaW1yZWQvTExFLmpzIiwiLi4vZGltcmVkL0xUU0EuanMiLCIuLi9kaW1yZWQvVFNORS5qcyIsIi4uL29wdGltaXphdGlvbi9wb3dlbGwuanMiLCIuLi9kaW1yZWQvVU1BUC5qcyIsIi4uL2RpbXJlZC9UcmlNYXAuanMiLCIuLi9jbHVzdGVyaW5nL0hpZXJhcmNoaWNhbF9DbHVzdGVyaW5nLmpzIiwiLi4vY2x1c3RlcmluZy9LTWVhbnMuanMiLCIuLi9jbHVzdGVyaW5nL0tNZWRvaWRzLmpzIiwiLi4vY2x1c3RlcmluZy9PUFRJQ1MuanMiLCIuLi9kaW1yZWQvTFNQLmpzIiwiLi4vZGltcmVkL1RvcG9NYXAuanMiLCIuLi9kaW1yZWQvU0FNTU9OLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV1Y2xpZGVhbl9zcXVhcmVkIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIGV1Y2xpZGVhbiBkaXN0YW5jZSAobDxzdWI+Mjwvc3ViPikgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGV1Y2xpZGVhblxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGV1Y2xpZGVhbl9zcXVhcmVkKGEsIGIpKTtcbn1cbiIsIi8qKlxuICogTnVtZXJpY2FsIHN0YWJsZSBzdW1tYXRpb24gd2l0aCB0aGUgS2FoYW4gc3VtbWF0aW9uIGFsZ29yaXRobS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bnVtZXJpY2FsXG4gKiBAYWxpYXMga2FoYW5fc3VtXG4gKiBAcGFyYW0ge0FycmF5fSBzdW1tYW5kcyAtIEFycmF5IG9mIHZhbHVlcyB0byBzdW0gdXAuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3VtLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2FoYW5fc3VtbWF0aW9uX2FsZ29yaXRobX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN1bW1hbmRzKSB7XG4gICAgbGV0IG4gPSBzdW1tYW5kcy5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IGNvbXBlbnNhdGlvbiA9IDA7XG4gICAgbGV0IHksIHQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICB5ID0gc3VtbWFuZHNbaV0gLSBjb21wZW5zYXRpb247XG4gICAgICAgIHQgPSBzdW0gKyB5O1xuICAgICAgICBjb21wZW5zYXRpb24gPSB0IC0gc3VtIC0geTtcbiAgICAgICAgc3VtID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cbiIsIi8qKlxuICogTnVtZXJpY2FsIHN0YWJsZSBzdW1tYXRpb24gd2l0aCB0aGUgTmV1bWFpciBzdW1tYXRpb24gYWxnb3JpdGhtLlxuICogQG1lbWJlcm9mIG1vZHVsZTpudW1lcmljYWxcbiAqIEBhbGlhcyBuZXVtYWlyX3N1bVxuICogQHBhcmFtIHtBcnJheX0gc3VtbWFuZHMgLSBBcnJheSBvZiB2YWx1ZXMgdG8gc3VtIHVwLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIHN1bS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0thaGFuX3N1bW1hdGlvbl9hbGdvcml0aG0jRnVydGhlcl9lbmhhbmNlbWVudHN9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzdW1tYW5kcykge1xuICAgIGxldCBuID0gc3VtbWFuZHMubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGxldCBjb21wZW5zYXRpb24gPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbGV0IHN1bW1hbmQgPSBzdW1tYW5kc1tpXTtcbiAgICAgICAgbGV0IHQgPSBzdW0gKyBzdW1tYW5kO1xuICAgICAgICBpZiAoTWF0aC5hYnMoc3VtKSA+PSBNYXRoLmFicyhzdW1tYW5kKSkge1xuICAgICAgICAgICAgY29tcGVuc2F0aW9uICs9IHN1bSAtIHQgKyBzdW1tYW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcGVuc2F0aW9uICs9IHN1bW1hbmQgLSB0ICsgc3VtO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHQ7XG4gICAgfVxuICAgIHJldHVybiBzdW0gKyBjb21wZW5zYXRpb247XG59XG4iLCJpbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkZWFuIGRpc3RhbmNlIChsPHN1Yj4yPC9zdWI+PHN1cD4yPC9zdXA+KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgZXVjbGlkZWFuX3NxdWFyZWRcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgc3F1YXJlZCBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgcyA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBsZXQgeCA9IGFbaV07XG4gICAgICAgIGxldCB5ID0gYltpXTtcbiAgICAgICAgc1tpXSA9ICh4IC0geSkgKiAoeCAtIHkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV1bWFpcl9zdW0ocyk7XG59XG4iLCIvKipcbiAqIENvbXB1dGVzIHRoZSBjb3NpbmUgZGlzdGFuY2UgKG5vdCBzaW1pbGFyaXR5KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgY29zaW5lXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYlxuICogQGV4YW1wbGVcbiAqIGRydWlkLmNvc2luZShbMSwwXSxbMSwxXSkgPT0gMC43ODUzOTgxNjMzOTc0NDg0ID09IM+ALzRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBjb3NpbmUgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IHN1bV9hID0gMDtcbiAgICBsZXQgc3VtX2IgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHN1bSArPSBhW2ldICogYltpXTtcbiAgICAgICAgc3VtX2EgKz0gYVtpXSAqIGFbaV07XG4gICAgICAgIHN1bV9iICs9IGJbaV0gKiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5hY29zKHN1bSAvIChNYXRoLnNxcnQoc3VtX2EpICogTWF0aC5zcXJ0KHN1bV9iKSkpO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgbWFuaGF0dGFuIGRpc3RhbmNlIChsPHN1Yj4xPC9zdWI+KSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgbWFuaGF0dGFuXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYlxuICogQHJldHVybnMge051bWJlcn0gdGhlIG1hbmhhdHRhbiBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovIFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBzdW0gKz0gTWF0aC5hYnMoYVtpXSAtIGJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgY2hlYnlzaGV2IGRpc3RhbmNlIChMPHN1Yj7iiJ48L3N1Yj4pIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1ldHJpY3NcbiAqIEBhbGlhcyBjaGVieXNoZXZcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY2hlYnlzaGV2IGRpc3RhbmNlIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKE1hdGguYWJzKGFbaV0gLSBiW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCguLi5yZXMpO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgY2FuYmVycmEgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGNhbmJlcnJhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGEgXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGIgXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgY2FuYmVycmEgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbmJlcnJhX2Rpc3RhbmNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgbiA9IGEubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHN1bSArPSAoTWF0aC5hYnMoYVtpXSAtIGJbaV0pIC8gKE1hdGguYWJzKGFbaV0pICsgTWF0aC5hYnMoYltpXSkpKVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufSIsIi8qKlxuICogQ29tcHV0ZXMgdGhlIGphY2NhcmQgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIGphY2NhcmRcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgamFjY2FyZCBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IG51bV9ub25femVybyA9IDA7XG4gICAgbGV0IG51bV9lcXVhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY29uc3QgeCA9IGFbaV0gIT0gMDtcbiAgICAgICAgY29uc3QgeSA9IGJbaV0gIT0gMDtcbiAgICAgICAgbnVtX25vbl96ZXJvICs9IHggfHwgeTtcbiAgICAgICAgbnVtX2VxdWFsICs9IHggJiYgeTtcbiAgICB9XG4gICAgcmV0dXJuIChudW1fbm9uX3plcm8gLSBudW1fZXF1YWwpIC8gbnVtX25vbl96ZXJvO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgaGFtbWluZyBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptZXRyaWNzXG4gKiBAYWxpYXMgaGFtbWluZ1xuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBoYW1taW5nIGRpc3RhbmNlIGJldHdlZW4ge0BsaW5rIGF9IGFuZCB7QGxpbmsgYn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG4gPSBhLmxlbmd0aDtcbiAgICBsZXQgZGlzYWdyZWUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IHggPSBhW2ldO1xuICAgICAgICBjb25zdCB5ID0gYltpXTtcbiAgICAgICAgZGlzYWdyZWUgKz0geCAhPSB5O1xuICAgIH1cbiAgICByZXR1cm4gZGlzYWdyZWUgLyBuO1xufVxuIiwiLyoqXG4gKiBDb21wdXRlcyB0aGUgU29rYWwtTWljaGVuZXIgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIHNva2FsX21pY2hlbmVyXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGEgXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGIgXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgU29rYWwtTWljaGVuZXIgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS4gIFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgY29uc3QgbiA9IGEubGVuZ3RoO1xuICAgIGxldCBudW1fbm90X2VxdWFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCB4ID0gYVtpXSAhPSAwO1xuICAgICAgICBjb25zdCB5ID0gYltpXSAhPSAwO1xuICAgICAgICBudW1fbm90X2VxdWFsICs9IHggIT0geTtcbiAgICB9XG4gICAgcmV0dXJuICgyICogbnVtX25vdF9lcXVhbCkgLyAobiArIG51bV9ub3RfZXF1YWwpO1xufSIsIi8qKlxuICogQ29tcHV0ZXMgdGhlIHl1bGUgZGlzdGFuY2UgYmV0d2VlbiB7QGxpbmsgYX0gYW5kIHtAbGluayBifS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWV0cmljc1xuICogQGFsaWFzIHl1bGVcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYVxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgeXVsZSBkaXN0YW5jZSBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBuID0gYS5sZW5ndGg7XG4gICAgbGV0IG51bV90cnVlX3RydWUgPSAwO1xuICAgIGxldCBudW1fdHJ1ZV9mYWxzZSA9IDA7XG4gICAgbGV0IG51bV9mYWxzZV90cnVlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCB4ID0gYVtpXSAhPSAwO1xuICAgICAgICBjb25zdCB5ID0gYltpXSAhPSAwO1xuICAgICAgICBudW1fdHJ1ZV90cnVlICs9IHggJiYgeTtcbiAgICAgICAgbnVtX3RydWVfZmFsc2UgKz0geCAmJiAheTtcbiAgICAgICAgbnVtX2ZhbHNlX3RydWUgKz0gIXggJiYgeDtcbiAgICB9XG4gICAgY29uc3QgbnVtX2ZhbHNlX2ZhbHNlID0gbiAtIG51bV90cnVlX3RydWUgLSBudW1fdHJ1ZV9mYWxzZSAtIG51bV9mYWxzZV90cnVlO1xuICAgIHJldHVybiBudW1fdHJ1ZV9mYWxzZSA9PSAwIHx8IG51bV9mYWxzZV90cnVlID09IDAgPyAwIDogKDIgKiBudW1fdHJ1ZV9mYWxzZSAqIG51bV9mYWxzZV90cnVlKSAvIChudW1fdHJ1ZV90cnVlICogbnVtX2ZhbHNlX2ZhbHNlICsgbnVtX3RydWVfZmFsc2UgKiBudW1fZmFsc2VfdHJ1ZSk7XG59XG4iLCJpbXBvcnQgeyBkaXN0YW5jZV9tYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBrLW5lYXJlc3QgbmVpZ2hib3JzIG9mIGVhY2ggcm93IG9mIHtAbGluayBBfS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWF0cml4XG4gKiBAYWxpYXMga19uZWFyZXN0X25laWdiaG9yc1xuICogQHBhcmFtIHtNYXRyaXh9IEEgLSBFaXRoZXIgdGhlIGRhdGEgbWF0cml4LCBvciBhIGRpc3RhbmNlIG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBrIC0gVGhlIG51bWJlciBvZiBuZWlnaGJvcnMgdG8gY29tcHV0ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbbWV0cmljPWV1Y2xpZGVhbl1cbiAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSAtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChBLCBrLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICBjb25zdCByb3dzID0gQS5zaGFwZVswXTtcbiAgICBsZXQgRCA9IG1ldHJpYyA9PSBcInByZWNvbXB1dGVkXCIgPyBBIDogZGlzdGFuY2VfbWF0cml4KEEsIG1ldHJpYyk7XG4gICAgbGV0IG5OID0gbmV3IEFycmF5KHJvd3MpO1xuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgIG5OW3Jvd10gPSBBcnJheS5mcm9tKEQucm93KHJvdykpXG4gICAgICAgICAgICAubWFwKChkaXN0YW5jZSwgY29sKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaTogcm93LFxuICAgICAgICAgICAgICAgICAgICBqOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZSlcbiAgICAgICAgICAgIC5zbGljZSgxLCBrICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBuTjtcbn1cbiIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBtYXRyaXggb2YgZGF0YW1hdHJpeCB7QGxpbmsgQX0uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1hdHJpeFxuICogQGFsaWFzIGRpc3RhbmNlX21hdHJpeFxuICogQHBhcmFtIHtNYXRyaXh9IEEgLSBNYXRyaXguXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljPWV1Y2xpZGVhbl0gLSBUaGUgZGlpc3RhbmNlIG1ldHJpYy5cbiAqIEByZXR1cm5zIHtNYXRyaXh9IEQgLSBUaGUgZGlzdGFuY2UgbWF0cml4IG9mIHtAbGluayBBfS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKEEsIG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgIGxldCBuID0gQS5zaGFwZVswXTtcbiAgICBjb25zdCBEID0gbmV3IE1hdHJpeChuLCBuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCBBX2kgPSBBLnJvdyhpKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gbWV0cmljKEFfaSwgQS5yb3coaikpO1xuICAgICAgICAgICAgRC5zZXRfZW50cnkoaSwgaiwgZGlzdCk7XG4gICAgICAgICAgICBELnNldF9lbnRyeShqLCBpLCBkaXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRDtcbn1cbiIsIi8qKlxuICogQ3JlYXRlcyBhbiBBcnJheSBjb250YWluaW5nIHtAbGluayBudW1iZXJ9IG51bWJlcnMgZnJvbSB7QGxpbmsgc3RhcnR9IHRvIHtAbGluayBlbmR9LlxuICogSWYgPGNvZGU+e0BsaW5rIG51bWJlcn0gPSBudWxsPC9udWxsPi5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bWF0cml4XG4gKiBAYWxpYXMgbGluc3BhY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCAtIFN0YXJ0IHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCAtIEVuZCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbnVtYmVyID0gbnVsbF0gLSBOdW1iZXIgb2YgbnVtYmVyIGJldHdlZW4ge0BsaW5rIHN0YXJ0fSBhbmQge0BsaW5rIGVuZH0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgd2l0aCB7QGxpbmsgbnVtYmVyfSBlbnRyaWVzLCBiZWdpbm5pbmcgYXQge0BsaW5rIHN0YXJ0fSBlbmRpbmcgYXQge0BsaW5rIGVuZH0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBudW1iZXIgPSBudWxsKSB7XG4gICAgaWYgKCFudW1iZXIpIHtcbiAgICAgICAgbnVtYmVyID0gTWF0aC5tYXgoTWF0aC5yb3VuZChlbmQgLSBzdGFydCkgKyAxLCAxKTtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDIpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlciA9PT0gMSA/IFtzdGFydF0gOiBbXTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBBcnJheShudW1iZXIpO1xuICAgIG51bWJlciAtPSAxO1xuICAgIGZvciAobGV0IGkgPSBudW1iZXI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IChpICogZW5kICsgKG51bWJlciAtIGkpICogc3RhcnQpIC8gbnVtYmVyO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbi8vaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4XCI7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG5vcm0gb2YgYSB2ZWN0b3IsIGJ5IGNvbXB1dGluZyBpdHMgZGlzdGFuY2UgdG8gKiowKiouXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1hdHJpeFxuICogQGFsaWFzIG5vcm1cbiAqIEBwYXJhbSB7TWF0cml4fEFycmF5PE51bWJlcj58RmxvYXQ2NEFycmF5fSB2IC0gVmVjdG9yLiBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gV2hpY2ggbWV0cmljIHNob3VsZCBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIG5vcm0uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBub3JtIG9mIHtAbGluayB2fS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHYsIG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgIGxldCB2ZWN0b3IgPSBudWxsO1xuICAgIGlmICh2IGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgIGxldCBbcm93cywgY29sc10gPSB2LnNoYXBlO1xuICAgICAgICBpZiAocm93cyA9PT0gMSkgdmVjdG9yID0gdi5yb3coMCk7XG4gICAgICAgIGVsc2UgaWYgKGNvbHMgPT09IDEpIHZlY3RvciA9IHYuY29sKDApO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIk1hdHJpeCBtdXN0IGJlIDFkIVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2ZWN0b3IgPSB2O1xuICAgIH1cbiAgICBjb25zdCBuID0gdmVjdG9yLmxlbmd0aDtcbiAgICBjb25zdCB6ZXJvcyA9IEZsb2F0NjRBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sICgpID0+IDApO1xuICAgIHJldHVybiBtZXRyaWModmVjdG9yLCB6ZXJvcyk7XG59XG4iLCJpbXBvcnQgeyBub3JtIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5cbi8qKlxuICogTm9ybWFsaXplcyBWZWN0b3Ige0BsaW5rIHZ9LlxuICogQG1lbWJlcm9mIG1vZHVsZTptYXRyaXhcbiAqIEBhbGlhcyBub3JtYWxpemVcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPnxGbG9hdDY0QXJyYXl9IHYgLSBWZWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldHJpYyBcbiAqIEByZXR1cm5zIHtBcnJheTxOdW1iZXI+fEZsb2F0NjRBcnJheX0gLSBUaGUgbm9ybWFsaXplZCB2ZWN0b3Igd2l0aCBsZW5ndGggMS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odiwgbWV0cmljID0gZXVjbGlkZWFuKSAge1xuICAgIGNvbnN0IHZfbm9ybSA9IG5vcm0odiwgbWV0cmljKTtcbiAgICByZXR1cm4gdi5tYXAodmFsdWUgPT4gdmFsdWUgLyB2X25vcm0pO1xufSIsImltcG9ydCB7IE1hdHJpeCwgbm9ybSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUVIgRGVjb21wb3NpdGlvbiBvZiB0aGUgTWF0cml4IHtAbGluayBBfSB1c2luZyBHcmFtLVNjaG1pZHQgcHJvY2Vzcy5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bGluZWFyX2FsZ2VicmFcbiAqIEBhbGlhcyBxclxuICogQHBhcmFtIHtNYXRyaXh9IEFcbiAqIEByZXR1cm5zIHt7UjogTWF0cml4LCBROiBNYXRyaXh9fVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUVJfZGVjb21wb3NpdGlvbiNVc2luZ190aGVfR3JhbSVFMiU4MCU5M1NjaG1pZHRfcHJvY2Vzc31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKEEpIHtcbiAgICBjb25zdCBbcm93cywgY29sc10gPSBBLnNoYXBlO1xuICAgIGNvbnN0IFEgPSBuZXcgTWF0cml4KHJvd3MsIGNvbHMsIFwiaWRlbnRpdHlcIik7XG4gICAgY29uc3QgUiA9IG5ldyBNYXRyaXgoY29scywgY29scywgMCk7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7ICsraikge1xuICAgICAgICBsZXQgdiA9IEEuY29sKGopO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGo7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcSA9IFEuY29sKGkpO1xuICAgICAgICAgICAgY29uc3QgcV9kb3RfdiA9IG5ldW1haXJfc3VtKHEubWFwKChxXywgaykgPT4gcV8gKiB2W2tdKSk7XG4gICAgICAgICAgICBSLnNldF9lbnRyeShpLCBqLCBxX2RvdF92KTtcbiAgICAgICAgICAgIHYgPSB2Lm1hcCgodl8sIGspID0+IHZfIC0gcV9kb3RfdiAqIHFba10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZfbm9ybSA9IG5vcm0odiwgZXVjbGlkZWFuKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3dzOyArK2spIHtcbiAgICAgICAgICAgIFEuc2V0X2VudHJ5KGssIGosIHZba10gLyB2X25vcm0pO1xuICAgICAgICB9XG4gICAgICAgIFIuc2V0X2VudHJ5KGosIGosIHZfbm9ybSk7XG4gICAgfVxuICAgIHJldHVybiB7IFIsIFEgfTtcbn1cbiIsImltcG9ydCB7IE1hdHJpeCwgbm9ybSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUVIgRGVjb21wb3NpdGlvbiBvZiB0aGUgTWF0cml4IHtAbGluayBBfSB3aXRoIGhvdXNlaG9sZGVyIHRyYW5zZm9ybWF0aW9ucy5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bGluZWFyX2FsZ2VicmFcbiAqIEBhbGlhcyBxcl9ob3VzZWhvbGRlclxuICogQHBhcmFtIHtNYXRyaXh9IEFcbiAqIEByZXR1cm5zIHt7UjogTWF0cml4LCBROiBNYXRyaXh9fVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUVJfZGVjb21wb3NpdGlvbiNVc2luZ19Ib3VzZWhvbGRlcl9yZWZsZWN0aW9uc31cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9tbHdpa2kub3JnL2luZGV4LnBocC9Ib3VzZWhvbGRlcl9UcmFuc2Zvcm1hdGlvbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKEEpIHtcbiAgICBjb25zdCBbcm93cywgY29sc10gPSBBLnNoYXBlO1xuICAgIGNvbnN0IFEgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MsIFwiSVwiKTtcbiAgICBjb25zdCBSID0gQS5jbG9uZSgpO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcbiAgICAgICAgY29uc3QgeCA9IE1hdHJpeC5mcm9tKFIuY29sKGopLnNsaWNlKGopKTtcbiAgICAgICAgY29uc3QgeF9ub3JtID0gbm9ybSh4KTtcbiAgICAgICAgY29uc3QgeDAgPSB4LmVudHJ5KDAsIDApO1xuICAgICAgICBjb25zdCByaG8gPSAtTWF0aC5zaWduKHgwKTtcbiAgICAgICAgY29uc3QgdTEgPSB4MCAtIHJobyAqIHhfbm9ybTtcbiAgICAgICAgY29uc3QgdSA9IHguZGl2aWRlKHUxKS5zZXRfZW50cnkoMCwgMCwgMSk7XG4gICAgICAgIGNvbnN0IGJldGEgPSAoLXJobyAqIHUxKSAvIHhfbm9ybTtcblxuICAgICAgICBjb25zdCB1X291dGVyX3UgPSB1Lm91dGVyKHUpO1xuICAgICAgICBjb25zdCBSX2Jsb2NrID0gUi5nZXRfYmxvY2soaiwgMCk7XG4gICAgICAgIGNvbnN0IG5ld19SID0gUl9ibG9jay5zdWIodV9vdXRlcl91LmRvdChSX2Jsb2NrKS5tdWx0KGJldGEpKTtcbiAgICAgICAgY29uc3QgUV9ibG9jayA9IFEuZ2V0X2Jsb2NrKDAsIGopO1xuICAgICAgICBjb25zdCBuZXdfUSA9IFFfYmxvY2suc3ViKFFfYmxvY2suZG90KHVfb3V0ZXJfdSkubXVsdChiZXRhKSk7XG4gICAgICAgIFIuc2V0X2Jsb2NrKGosIDAsIG5ld19SKTtcbiAgICAgICAgUS5zZXRfYmxvY2soMCwgaiwgbmV3X1EpO1xuICAgIH1cbiAgICByZXR1cm4geyBSLCBRIH07XG59XG4iLCJpbXBvcnQgeyBxciBhcyBxcl9ncmFtc2NobWlkdCB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBSYW5kb21pemVyIH0gZnJvbSBcIi4uL3V0aWwvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbl9zcXVhcmVkIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUge0BsaW5rIGt9IGJpZ2dlc3QgRWlnZW52ZWN0b3JzIGFuZCBFaWdlbnZhbHVlcyBmcm9tIE1hdHJpeCB7QGxpbmsgQX0gd2l0aCB0aGUgUVItQWxnb3JpdGhtLlxuICogQG1lbWJlcm9mIG1vZHVsZTpsaW5lYXJfYWxnZWJyYVxuICogQGFsaWFzIHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvblxuICogQHBhcmFtIHtNYXRyaXh9IEEgLSBUaGUgTWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gayAtIFRoZSBudW1iZXIgb2YgZWlnZW52ZWN0b3JzIGFuZCBlaWdlbnZhbHVlcyB0byBjb21wdXRlLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBzaW11bHRhbmlvdXMgcG93ZXJpdGVyYXRpb24gbWV0aG9kLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLm1heF9pdGVyYXRpb25zPTEwMF0gLSBUaGUgbnVtYmVyIG9mIG1heGl1bXVtIGl0ZXJhdGlvbnMgdGhlIGFsZ29yaXRobSBzaG91bGQgcnVuLlxuICogQHBhcmFtIHtOdW1iZXJ8UmFuZG9taXplcn0gW3BhcmFtZXRlcnMuc2VlZD0xMjEyXSAtIFRoZSBzZWVkIHZhbHVlIG9yIGEgcmFuZG9taXplciB1c2VkIGluIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1ldGVycy5xcj1xcl9ncmFtc2NobWlkdF0gLSBUaGUgUVIgdGVjaG5pcXVlIHRvIHVzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy50b2w9MWUtOF0gLSBBbGxvd2VkIGVycm9yIGZvciBzdG9wcGluZyBjcml0ZXJpYVxuICogQHJldHVybnMge3tlaWdlbnZhbHVlczogQXJyYXksIGVpZ2VudmVjdG9yczogQXJyYXl9fSAtIFRoZSB7QGxpbmsga30gYmlnZ2VzdCBlaWdlbnZlY3RvcnMgYW5kIGVpZ2VudmFsdWVzIG9mIE1hdHJpeCB7QGxpbmsgQX0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChBLCBrID0gMiwge3NlZWQgPSAxMjEyLCBtYXhfaXRlcmF0aW9ucyA9IDEwMCwgcXIgPSBxcl9ncmFtc2NobWlkdCwgdG9sID0gMWUtOH0gPSB7fSkge1xuICAgIGNvbnN0IHJhbmRvbWl6ZXIgPSBzZWVkIGluc3RhbmNlb2YgUmFuZG9taXplciA/IHNlZWQgOiBuZXcgUmFuZG9taXplcihzZWVkKTtcbiAgICBpZiAoIShBIGluc3RhbmNlb2YgTWF0cml4KSkgQSA9IE1hdHJpeC5mcm9tKEEpO1xuICAgIGNvbnN0IG4gPSBBLnNoYXBlWzBdO1xuICAgIGxldCB7IFEsIFIgfSA9IHFyKG5ldyBNYXRyaXgobiwgaywgKCkgPT4gKHJhbmRvbWl6ZXIucmFuZG9tIC0gLjUpICogMikpO1xuICAgIHdoaWxlIChtYXhfaXRlcmF0aW9ucy0tKSB7XG4gICAgICAgIGNvbnN0IG9sZFEgPSBRLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IFogPSBBLmRvdChRKTtcbiAgICAgICAgY29uc3QgUVIgPSBxcihaKTtcbiAgICAgICAgUSA9IFFSLlE7XG4gICAgICAgIFIgPSBRUi5SO1xuICAgICAgICBjb25zdCBlcnJvciA9IGV1Y2xpZGVhbl9zcXVhcmVkKFEudmFsdWVzLCBvbGRRLnZhbHVlcyk7XG4gICAgICAgIGlmIChlcnJvciA8IHRvbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlaWdlbnZhbHVlcyA9IFIuZGlhZztcbiAgICBjb25zdCBlaWdlbnZlY3RvcnMgPSBRLnRyYW5zcG9zZSgpLnRvMmRBcnJheTtcbiAgICByZXR1cm4geyBlaWdlbnZhbHVlcywgZWlnZW52ZWN0b3JzIH07XG59XG4iLCJpbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgaW5uZXIgcHJvZHVjdCBiZXR3ZWVuIHR3byBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoLlxuICogQG1lbWJlcm9mIG1vZHVsZTpsaW5lYXJfYWxnZWJyYVxuICogQGFsaWFzIGlubmVyX3Byb2R1Y3RcbiAqIEBwYXJhbSB7QXJyYXl8RmxvYXQ2NEFycmF5fSBhIC0gQXJyYXkgYVxuICogQHBhcmFtIHtBcnJheXxGbG9hdDY0QXJyYXl9IGIgLSBBcnJheSBiXG4gKiBAcmV0dXJucyBUaGUgaW5uZXIgcHJvZHVjdCBiZXR3ZWVuIHtAbGluayBhfSBhbmQge0BsaW5rIGJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgY29uc3QgTiA9IGEubGVuZ3RoO1xuICAgIGlmIChOICE9IGIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5IGEgYW5kIGIgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCFcIilcbiAgICB9XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgc3VtICs9IGEgKiBiO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuIiwiaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IFJhbmRvbWl6ZXIgfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBNYXRyaXhcbiAqIEByZXF1aXJlcyBtb2R1bGU6bnVtZXJpY2FsL25ldW1haXJfc3VtXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRyaXgge1xuICAgIC8qKlxuICAgICAqIGNyZWF0ZXMgYSBuZXcgTWF0cml4LiBFbnRyaWVzIGFyZSBzdG9yZWQgaW4gYSBGbG9hdDY0QXJyYXkuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTptYXRyaXhcbiAgICAgKiBAYWxpYXMgTWF0cml4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgLSBUaGUgYW1vdW50IG9mIHJvd3Mgb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29scyAtIFRoZSBhbW91bnQgb2YgY29sdW1ucyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9ufHN0cmluZ3xudW1iZXIpfSB2YWx1ZT0wIC0gQ2FuIGJlIGEgZnVuY3Rpb24gd2l0aCByb3cgYW5kIGNvbCBhcyBwYXJhbWV0ZXJzLCBhIG51bWJlciwgb3IgXCJ6ZXJvc1wiLCBcImlkZW50aXR5XCIgb3IgXCJJXCIsIG9yIFwiY2VudGVyXCIuXG4gICAgICogIC0gKipmdW5jdGlvbioqOiBmb3IgZWFjaCBlbnRyeSB0aGUgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgd2l0aCB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIGFjdHVhbCByb3cgYW5kIGNvbHVtbi5cbiAgICAgKiAgLSAqKnN0cmluZyoqOiBhbGxvd2VkIGFyZVxuICAgICAqICAgICAgLSBcInplcm9cIiwgY3JlYXRlcyBhIHplcm8gbWF0cml4LlxuICAgICAqICAgICAgLSBcImlkZW50aXR5XCIgb3IgXCJJXCIsIGNyZWF0ZXMgYW4gaWRlbnRpdHkgbWF0cml4LlxuICAgICAqICAgICAgLSBcImNlbnRlclwiLCBjcmVhdGVzIGFuIGNlbnRlciBtYXRyaXguXG4gICAgICogIC0gKipudW1iZXIqKjogY3JlYXRlIGEgbWF0cml4IGZpbGxlZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBuZXcgTWF0cml4KDEwLCAxMCwgKCkgPT4gTWF0aC5yYW5kb20oKSk7IC8vY3JlYXRlcyBhIDEwIHRpbWVzIDEwIHJhbmRvbSBtYXRyaXguXG4gICAgICogbGV0IEIgPSBuZXcgTWF0cml4KDMsIDMsIFwiSVwiKTsgLy8gY3JlYXRlcyBhIDMgdGltZXMgMyBpZGVudGl0eSBtYXRyaXguXG4gICAgICogQHJldHVybnMge01hdHJpeH0gcmV0dXJucyBhIHtAbGluayByb3dzfSB0aW1lcyB7QGxpbmsgY29sc30gTWF0cml4IGZpbGxlZCB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm93cyA9IG51bGwsIGNvbHMgPSBudWxsLCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuX2NvbHMgPSBjb2xzO1xuICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKHJvd3MgJiYgY29scykge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IHZhbHVlKHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiemVyb3NcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChyb3dzLCBjb2xzLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcImlkZW50aXR5XCIgfHwgdmFsdWUgPT09IFwiSVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbcm93ICogY29scyArIHJvd10gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiY2VudGVyXCIgJiYgcm93cyA9PSBjb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoaSwgaikgPT4gKGkgPT09IGogPyAxIDogMCkgLSAxIC8gcm93cztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IHZhbHVlKHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkocm93cyAqIGNvbHMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1hdHJpeCBvdXQgb2Yge0BsaW5rIEF9LlxuICAgICAqIEBwYXJhbSB7KE1hdHJpeHxBcnJheXxGbG9hdDY0QXJyYXl8bnVtYmVyKX0gQSAtIFRoZSBtYXRyaXgsIGFycmF5LCBvciBudW1iZXIsIHdoaWNoIHNob3VsZCBjb252ZXJ0ZWQgdG8gYSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtcInJvd1wifFwiY29sXCJ8XCJkaWFnXCJ9IFt0eXBlID0gXCJyb3dcIl0gLSBJZiB7QGxpbmsgQX0gaXMgYSBBcnJheSBvciBGbG9hdDY0QXJyYXksIHRoZW4gdHlwZSBkZWZpbmVzIGlmIGl0IGlzIGEgcm93LSBvciBhIGNvbHVtbiB2ZWN0b3IuXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDBdLCBbMCwgMV1dKTsgLy9jcmVhdGVzIGEgdHdvIGJ5IHR3byBpZGVudGl0eSBtYXRyaXguXG4gICAgICogbGV0IFMgPSBNYXRyaXguZnJvbShbMSwgMiwgM10sIFwiZGlhZ1wiKTsgLy8gY3JlYXRlcyBhIDMgYnkgMyBtYXRyaXggd2l0aCAxLCAyLCAzIG9uIGl0cyBkaWFnb25hbC4gW1sxLCAwLCAwXSwgWzAsIDIsIDBdLCBbMCwgMCwgM11dXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oQSwgdHlwZSA9IFwicm93XCIpIHtcbiAgICAgICAgaWYgKEEgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBBLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShBKSB8fCBBIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSB7XG4gICAgICAgICAgICBsZXQgbSA9IEEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG0gPT09IDApIHRocm93IG5ldyBFcnJvcihcIkFycmF5IGlzIGVtcHR5XCIpO1xuICAgICAgICAgICAgLy8gMWRcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShBWzBdKSAmJiAhKEFbMF0gaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicm93XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoMSwgbSwgKF8sIGopID0+IEFbal0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb2xcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtLCAxLCAoaSkgPT4gQVtpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRpYWdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtLCBtLCAoaSwgaikgPT4gKGkgPT0gaiA/IEFbaV0gOiAwKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiMWQgYXJyYXkgaGFzIE5hTiBlbnRyaWVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAyZFxuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEFbMF0pIHx8IEFbMF0gaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbiA9IEFbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG07ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBW3Jvd10ubGVuZ3RoICE9PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YXJpb3VzIGFycmF5IGxlbmd0aHNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgobSwgbiwgKGksIGopID0+IEFbaV1bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBBID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCgxLCAxLCBBKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVycm9yXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIHJvd308c3VwPnRoPC9zdXA+IHJvdyBmcm9tIHRoZSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgICAqIEByZXR1cm5zIHtGbG9hdDY0QXJyYXl9XG4gICAgICovXG4gICAgcm93KHJvdykge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICByZXR1cm4gZGF0YS5zdWJhcnJheShyb3cgKiBjb2xzLCAocm93ICsgMSkgKiBjb2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGdlbmVyYXRvciB5aWVsZGluZyBlYWNoIHJvdyBvZiB0aGUgTWF0cml4LlxuICAgICAqIEB5aWVsZHMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICAqaXRlcmF0ZV9yb3dzKCkge1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIHlpZWxkIGRhdGEuc3ViYXJyYXkocm93ICogY29scywgKHJvdyArIDEpICogY29scyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIHtAbGluayBNYXRyaXh9IG9iamVjdCBhbiBpdGVyYWJsZSBvYmplY3QuXG4gICAgICogQHlpZWxkcyB7RmxvYXQ2NEFycmF5fVxuICAgICAqL1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5pdGVyYXRlX3Jvd3MoKSkge1xuICAgICAgICAgICAgeWllbGQgcm93O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZW50cmllcyBvZiB7QGxpbmsgcm93fTxzdXA+dGg8L3N1cD4gcm93IGZyb20gdGhlIE1hdHJpeCB0byB0aGUgZW50cmllcyBmcm9tIHtAbGluayB2YWx1ZXN9LlxuICAgICAqIEBwYXJhbSB7aW50fSByb3dcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHNldF9yb3cocm93LCB2YWx1ZXMpIHtcbiAgICAgICAgbGV0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmIHZhbHVlcy5sZW5ndGggPT09IGNvbHMpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlc1tvZmZzZXQgKyBjb2xdID0gdmFsdWVzW2NvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWVzIGluc3RhbmNlb2YgTWF0cml4ICYmIHZhbHVlcy5zaGFwZVsxXSA9PT0gY29scyAmJiB2YWx1ZXMuc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlc1tvZmZzZXQgKyBjb2xdID0gdmFsdWVzLl9kYXRhW2NvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIGNvbH08c3VwPnRoPC9zdXA+IGNvbHVtbiBmcm9tIHRoZSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtpbnR9IGNvbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBjb2woY29sKSB7XG4gICAgICAgIGxldCByZXN1bHRfY29sID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLl9yb3dzKTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5fcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIHJlc3VsdF9jb2xbcm93XSA9IHRoaXMudmFsdWVzW3JvdyAqIHRoaXMuX2NvbHMgKyBjb2xdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRfY29sO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBjb2x9PHN1cD50aDwvc3VwPiBlbnRyeSBmcm9tIHRoZSB7QGxpbmsgcm93fTxzdXA+dGg8L3N1cD4gcm93IG9mIHRoZSBNYXRyaXguXG4gICAgICogQHBhcmFtIHtpbnR9IHJvd1xuICAgICAqIEBwYXJhbSB7aW50fSBjb2xcbiAgICAgKiBAcmV0dXJucyB7ZmxvYXQ2NH1cbiAgICAgKi9cbiAgICBlbnRyeShyb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbcm93ICogdGhpcy5fY29scyArIGNvbF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUge0BsaW5rIGNvbH08c3VwPnRoPC9zdXA+IGVudHJ5IGZyb20gdGhlIHtAbGluayByb3d9PHN1cD50aDwvc3VwPiByb3cgb2YgdGhlIE1hdHJpeCB0byB0aGUgZ2l2ZW4ge0BsaW5rIHZhbHVlfS5cbiAgICAgKiBAcGFyYW0ge2ludH0gcm93XG4gICAgICogQHBhcmFtIHtpbnR9IGNvbFxuICAgICAqIEBwYXJhbSB7ZmxvYXQ2NH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHNldF9lbnRyeShyb3csIGNvbCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNbcm93ICogdGhpcy5fY29scyArIGNvbF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyB0cmFuc3Bvc2VkIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHRyYW5zcG9zZSgpIHtcbiAgICAgICAgbGV0IEIgPSBuZXcgTWF0cml4KHRoaXMuX2NvbHMsIHRoaXMuX3Jvd3MsIChyb3csIGNvbCkgPT4gdGhpcy5lbnRyeShjb2wsIHJvdykpO1xuICAgICAgICByZXR1cm4gQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHRyYW5zcG9zZWQgTWF0cml4LiBTaG9ydC1mb3JtIG9mIHtAZnVuY3Rpb24gdHJhbnNwb3NlfS5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIGdldCBUKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3Bvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBpbnZlcnNlKCkge1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgIGxldCBCID0gbmV3IE1hdHJpeChyb3dzLCAyICogY29scywgKGksIGopID0+IHtcbiAgICAgICAgICAgIGlmIChqID49IGNvbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA9PT0gaiAtIGNvbHMgPyAxIDogMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50cnkoaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaCA9IDA7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgd2hpbGUgKGggPCByb3dzICYmIGsgPCBjb2xzKSB7XG4gICAgICAgICAgICB2YXIgaV9tYXggPSAwO1xuICAgICAgICAgICAgbGV0IG1heF92YWwgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gaDsgaSA8IHJvd3M7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBNYXRoLmFicyhCLmVudHJ5KGksIGspKTtcbiAgICAgICAgICAgICAgICBpZiAobWF4X3ZhbCA8IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpX21heCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIG1heF92YWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEIuZW50cnkoaV9tYXgsIGspID09IDApIHtcbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgcm93c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMiAqIGNvbHM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaF92YWwgPSBCLmVudHJ5KGgsIGopO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaV92YWwgPSBCLmVudHJ5KGlfbWF4LCBqKTtcbiAgICAgICAgICAgICAgICAgICAgQi5zZXRfZW50cnkoaCwgaiwgaF92YWwpO1xuICAgICAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShpX21heCwgaiwgaV92YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaCArIDE7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGYgPSBCLmVudHJ5KGksIGspIC8gQi5lbnRyeShoLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgQi5zZXRfZW50cnkoaSwgaywgMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBrICsgMTsgaiA8IDIgKiBjb2xzOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEIuc2V0X2VudHJ5KGksIGosIEIuZW50cnkoaSwgaikgLSBCLmVudHJ5KGgsIGopICogZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaCsrO1xuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBsZXQgZiA9IEIuZW50cnkocm93LCByb3cpO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gcm93OyBjb2wgPCAyICogY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBCLnNldF9lbnRyeShyb3csIGNvbCwgQi5lbnRyeShyb3csIGNvbCkgLyBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IHJvd3MgLSAxOyByb3cgPj0gMDsgLS1yb3cpIHtcbiAgICAgICAgICAgIGxldCBCX3Jvd19yb3cgPSBCLmVudHJ5KHJvdywgcm93KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgQl9pX3JvdyA9IEIuZW50cnkoaSwgcm93KTtcbiAgICAgICAgICAgICAgICBsZXQgZiA9IEJfaV9yb3cgLyBCX3Jvd19yb3c7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCAyICogY29sczsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBCX2lfaiA9IEIuZW50cnkoaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBCX3Jvd19qID0gQi5lbnRyeShyb3csIGopO1xuICAgICAgICAgICAgICAgICAgICBCX2lfaiA9IEJfaV9qIC0gQl9yb3dfaiAqIGY7XG4gICAgICAgICAgICAgICAgICAgIEIuc2V0X2VudHJ5KGksIGosIEJfaV9qKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChyb3dzLCBjb2xzLCAoaSwgaikgPT4gQi5lbnRyeShpLCBqICsgY29scykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0LiBJZiB7QGxpbmsgQn0gaXMgYW4gQXJyYXkgb3IgRmxvYXQ2NEFycmF5IHRoZW4gYW4gQXJyYXkgZ2V0cyByZXR1cm5lZC4gSWYge0BsaW5rIEJ9IGlzIGEgTWF0cml4IHRoZW4gYSBNYXRyaXggZ2V0cyByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0geyhNYXRyaXh8QXJyYXl8RmxvYXQ2NEFycmF5KX0gQiB0aGUgcmlnaHQgc2lkZVxuICAgICAqIEByZXR1cm5zIHsoTWF0cml4fEFycmF5KX1cbiAgICAgKi9cbiAgICBkb3QoQikge1xuICAgICAgICBpZiAoQiBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IEEgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKEEuc2hhcGVbMV0gIT09IEIuc2hhcGVbMF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEuZG90KEIpOiBBIGlzIGEgJHtBLnNoYXBlLmpvaW4oXCIg4qivIFwiKX0tTWF0cml4LCBCIGlzIGEgJHtCLnNoYXBlLmpvaW4oXCIg4qivIFwiKX0tTWF0cml4OiBcbiAgICAgICAgICAgICAgICBBIGhhcyAke0Euc2hhcGVbMV19IGNvbHMgYW5kIEIgJHtCLnNoYXBlWzBdfSByb3dzLiBcbiAgICAgICAgICAgICAgICBNdXN0IGJlIGVxdWFsIWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IEkgPSBBLnNoYXBlWzFdO1xuICAgICAgICAgICAgbGV0IEMgPSBuZXcgTWF0cml4KEEuc2hhcGVbMF0sIEIuc2hhcGVbMV0sIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IEFfaSA9IEEucm93KHJvdyk7XG4gICAgICAgICAgICAgICAgY29uc3QgQl9pID0gQi5jb2woY29sKTtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gQV9pW2ldICogQl9pW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gQztcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEIpIHx8IEIgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgICAgIGlmIChCLmxlbmd0aCAhPT0gcm93cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQS5kb3QoQik6IEEgaGFzICR7cm93c30gY29scyBhbmQgQiBoYXMgJHtCLmxlbmd0aH0gcm93cy4gTXVzdCBiZSBlcXVhbCFgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBDID0gbmV3IEFycmF5KHJvd3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICBDW3Jvd10gPSBuZXVtYWlyX3N1bSh0aGlzLnJvdyhyb3cpLm1hcCgoZSkgPT4gZSAqIEJbcm93XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEIgbXVzdCBiZSBNYXRyaXggb3IgQXJyYXlgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBvdXRlciBwcm9kdWN0IGZyb20ge0BsaW5rIHRoaXN9IGFuZCB7QGxpbmsgQn0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEJcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIG91dGVyKEIpIHtcbiAgICAgICAgbGV0IEEgPSB0aGlzO1xuICAgICAgICBsZXQgbCA9IEEuX2RhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgciA9IEIuX2RhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobCAhPSByKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgQyA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgQy5zaGFwZSA9IFtcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgKGksIGopID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBLl9kYXRhW2ldICogQi5fZGF0YVtqXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQy5lbnRyeShqLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gQztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIG1hdHJpeCB7QGxpbmsgQn0gdG8gdGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQiAtIG1hdHJpeCB0byBhcHBlbmQuXG4gICAgICogQHBhcmFtIHtcImhvcml6b250YWxcInxcInZlcnRpY2FsXCJ8XCJkaWFnXCJ9IFt0eXBlID0gXCJob3Jpem9udGFsXCJdIC0gdHlwZSBvZiBjb25jYXRlbmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAxXSwgWzEsIDFdXSk7IC8vIDIgYnkgMiBtYXRyaXggZmlsbGVkIHdpdGggb25lcy5cbiAgICAgKiBsZXQgQiA9IE1hdHJpeC5mcm9tKFtbMiwgMl0sIFsyLCAyXV0pOyAvLyAyIGJ5IDIgbWF0cml4IGZpbGxlZCB3aXRoIHR3b3MuXG4gICAgICpcbiAgICAgKiBBLmNvbmNhdChCLCBcImhvcml6b250YWxcIik7IC8vIDIgYnkgNCBtYXRyaXguIFtbMSwgMSwgMiwgMl0sIFsxLCAxLCAyLCAyXV1cbiAgICAgKiBBLmNvbmNhdChCLCBcInZlcnRpY2FsXCIpOyAvLyA0IGJ5IDIgbWF0cml4LiBbWzEsIDFdLCBbMSwgMV0sIFsyLCAyXSwgWzIsIDJdXVxuICAgICAqIEEuY29uY2F0KEIsIFwiZGlhZ1wiKTsgLy8gNCBieSA0IG1hdHJpeC4gW1sxLCAxLCAwLCAwXSwgWzEsIDEsIDAsIDBdLCBbMCwgMCwgMiwgMl0sIFswLCAwLCAyLCAyXV1cbiAgICAgKi9cbiAgICBjb25jYXQoQiwgdHlwZSA9IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzO1xuICAgICAgICBjb25zdCBbcm93c19BLCBjb2xzX0FdID0gQS5zaGFwZTtcbiAgICAgICAgY29uc3QgW3Jvd3NfQiwgY29sc19CXSA9IEIuc2hhcGU7XG4gICAgICAgIGlmICh0eXBlID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICBpZiAocm93c19BICE9IHJvd3NfQikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQS5jb25jYXQoQiwgXCJob3Jpem9udGFsXCIpOiBBIGFuZCBCIG5lZWQgc2FtZSBudW1iZXIgb2Ygcm93cywgQSBoYXMgJHtyb3dzX0F9IHJvd3MsIEIgaGFzICR7cm93c19CfSByb3dzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgWCA9IG5ldyBNYXRyaXgocm93c19BLCBjb2xzX0EgKyBjb2xzX0IsIFwiemVyb3NcIik7XG4gICAgICAgICAgICBYLnNldF9ibG9jaygwLCAwLCBBKTtcbiAgICAgICAgICAgIFguc2V0X2Jsb2NrKDAsIGNvbHNfQSwgQik7XG4gICAgICAgICAgICByZXR1cm4gWDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgaWYgKGNvbHNfQSAhPSBjb2xzX0IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEuY29uY2F0KEIsIFwidmVydGljYWxcIik6IEEgYW5kIEIgbmVlZCBzYW1lIG51bWJlciBvZiBjb2x1bW5zLCBBIGhhcyAke2NvbHNfQX0gY29sdW1ucywgQiBoYXMgJHtjb2xzX0J9IGNvbHVtbnMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBYID0gbmV3IE1hdHJpeChyb3dzX0EgKyByb3dzX0IsIGNvbHNfQSwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgICAgIFguc2V0X2Jsb2NrKDAsIDAsIEEpO1xuICAgICAgICAgICAgWC5zZXRfYmxvY2socm93c19BLCAwLCBCKTtcbiAgICAgICAgICAgIHJldHVybiBYO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJkaWFnXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IFggPSBuZXcgTWF0cml4KHJvd3NfQSArIHJvd3NfQiwgY29sc19BICsgY29sc19CLCBcInplcm9zXCIpO1xuICAgICAgICAgICAgWC5zZXRfYmxvY2soMCwgMCwgQSk7XG4gICAgICAgICAgICBYLnNldF9ibG9jayhyb3dzX0EsIGNvbHNfQSwgQik7XG4gICAgICAgICAgICByZXR1cm4gWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdHlwZSBtdXN0IGJlIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIiwgYnV0IHR5cGUgaXMgJHt0eXBlfSFgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyaXRlcyB0aGUgZW50cmllcyBvZiBCIGluIEEgYXQgYW4gb2Zmc2V0IHBvc2l0aW9uIGdpdmVuIGJ5IHtAbGluayBvZmZzZXRfcm93fSBhbmQge0BsaW5rIG9mZnNldF9jb2x9LlxuICAgICAqIEBwYXJhbSB7aW50fSBvZmZzZXRfcm93XG4gICAgICogQHBhcmFtIHtpbnR9IG9mZnNldF9jb2xcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gQlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc2V0X2Jsb2NrKG9mZnNldF9yb3csIG9mZnNldF9jb2wsIEIpIHtcbiAgICAgICAgbGV0IFtyb3dzLCBjb2xzXSA9IEIuc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBpZiAocm93ID4gdGhpcy5fcm93cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sID4gdGhpcy5fY29scykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfZW50cnkocm93ICsgb2Zmc2V0X3JvdywgY29sICsgb2Zmc2V0X2NvbCwgQi5lbnRyeShyb3csIGNvbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBlbnRyaWVzIGZyb20gdGhlIHtAbGluayBzdGFydF9yb3d9PHN1cD50aDwvc3VwPiByb3cgdG8gdGhlIHtAbGluayBlbmRfcm93fTxzdXA+dGg8L3N1cD4gcm93LCB0aGUge0BsaW5rIHN0YXJ0X2NvbH08c3VwPnRoPC9zdXA+IGNvbHVtbiB0byB0aGUge0BsaW5rIGVuZF9jb2x9PHN1cD50aDwvc3VwPiBjb2x1bW4gb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBJZiB7QGxpbmsgZW5kX3Jvd30gb3Ige0BsaW5rIGVuZF9jb2x9IGlzIGVtcHR5LCB0aGUgcmVzcGVjdGl2ZSB2YWx1ZSBpcyBzZXQgdG8ge0BsaW5rIHRoaXMucm93c30gb3Ige0BsaW5rIHRoaXMuY29sc30uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0X3Jvd1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydF9jb2xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZF9yb3cgPSBudWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kX2NvbCA9IG51bGxdXG4gICAgICogQHJldHVybnMge01hdHJpeH0gUmV0dXJucyBhIGVuZF9yb3cgLSBzdGFydF9yb3cgdGltZXMgZW5kX2NvbCAtIHN0YXJ0X2NvbCBtYXRyaXgsIHdpdGggcmVzcGVjdGl2ZSBlbnRyaWVzIGZyb20gdGhlIG1hdHJpeC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDIsIDNdLCBbNCwgNSwgNl0sIFs3LCA4LCA5XV0pOyAvLyBhIDMgYnkgMyBtYXRyaXguXG4gICAgICpcbiAgICAgKiBBLmdldF9ibG9jaygxLCAxKTsgLy8gW1s1LCA2XSwgWzgsIDldXVxuICAgICAqIEEuZ2V0X2Jsb2NrKDAsIDAsIDEsIDEpOyAvLyBbWzFdXVxuICAgICAqIEEuZ2V0X2Jsb2NrKDEsIDEsIDIsIDIpOyAvLyBbWzVdXVxuICAgICAqIEEuZ2V0X2Jsb2NrKDAsIDAsIDIsIDIpOyAvLyBbWzEsIDJdLCBbNCwgNV1dXG4gICAgICovXG4gICAgZ2V0X2Jsb2NrKHN0YXJ0X3Jvdywgc3RhcnRfY29sLCBlbmRfcm93ID0gbnVsbCwgZW5kX2NvbCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgW3Jvd3MsIGNvbHNdID0gdGhpcy5zaGFwZTtcbiAgICAgICAgZW5kX3JvdyA9IGVuZF9yb3cgPz8gcm93cztcbiAgICAgICAgZW5kX2NvbCA9IGVuZF9jb2wgPz8gY29scztcbiAgICAgICAgaWYgKGVuZF9yb3cgPD0gc3RhcnRfcm93IHx8IGVuZF9jb2wgPD0gc3RhcnRfY29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgICAgICAgICAgIGVuZF9yb3cgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RhcnRfcm93LCBhbmQgXG4gICAgICAgICAgICAgICAgZW5kX2NvbCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdGFydF9jb2wsIGJ1dFxuICAgICAgICAgICAgICAgIGVuZF9yb3cgPSAke2VuZF9yb3d9LCBzdGFydF9yb3cgPSAke3N0YXJ0X3Jvd30sIGVuZF9jb2wgPSAke2VuZF9jb2x9LCBhbmQgc3RhcnRfY29sID0gJHtzdGFydF9jb2x9IWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFggPSBuZXcgTWF0cml4KGVuZF9yb3cgLSBzdGFydF9yb3csIGVuZF9jb2wgLSBzdGFydF9jb2wsIFwiemVyb3NcIik7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IHN0YXJ0X3JvdywgbmV3X3JvdyA9IDA7IHJvdyA8IGVuZF9yb3c7ICsrcm93LCArK25ld19yb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHN0YXJ0X2NvbCwgbmV3X2NvbCA9IDA7IGNvbCA8IGVuZF9jb2w7ICsrY29sLCArK25ld19jb2wpIHtcbiAgICAgICAgICAgICAgICBYLnNldF9lbnRyeShuZXdfcm93LCBuZXdfY29sLCB0aGlzLmVudHJ5KHJvdywgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFg7XG4gICAgICAgIC8vcmV0dXJuIG5ldyBNYXRyaXgoZW5kX3JvdyAtIHN0YXJ0X3JvdywgZW5kX2NvbCAtIHN0YXJ0X2NvbCwgKGksIGopID0+IHRoaXMuZW50cnkoaSArIHN0YXJ0X3JvdywgaiArIHN0YXJ0X2NvbCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgZ2F0aGVyaW5nIGVudHJpZXMgZGVmaW5lZCBieSB0aGUgaW5kaWNlcyBnaXZlbiBieSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHJvd19pbmRpY2VzIC0gQXJyYXkgY29uc2lzdHMgb2YgaW5kaWNlcyBvZiByb3dzIGZvciBnYXRoZXJpbmcgZW50cmllcyBvZiB0aGlzIG1hdHJpeFxuICAgICAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gY29sX2luZGljZXMgIC0gQXJyYXkgY29uc2lzdHMgb2YgaW5kaWNlcyBvZiBjb2xzIGZvciBnYXRoZXJpbmcgZW50cmllcyBvZiB0aGlzIG1hdHJpeFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgZ2F0aGVyKHJvd19pbmRpY2VzLCBjb2xfaW5kaWNlcykge1xuICAgICAgICBjb25zdCBOID0gcm93X2luZGljZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBEID0gY29sX2luZGljZXMubGVuZ3RoO1xuXG4gICAgICAgIGNvbnN0IFIgPSBuZXcgTWF0cml4KE4sIEQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgcm93X2luZGV4ID0gcm93X2luZGljZXNbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbF9pbmRleCA9IGNvbF9pbmRpY2VzW2pdO1xuICAgICAgICAgICAgICAgIFIuc2V0X2VudHJ5KGksIGosIHRoaXMuZW50cnkocm93X2luZGV4LCBjb2xfaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXguXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmIGZ1bmN0aW9uIHRha2VzIDIgcGFyYW1ldGVycywgdGhlIHZhbHVlIG9mIHRoZSBhY3R1YWwgZW50cnkgYW5kIGEgdmFsdWUgZ2l2ZW4gYnkgdGhlIGZ1bmN0aW9uIHtAbGluayB2fS4gVGhlIHJlc3VsdCBvZiB7QGxpbmsgZn0gZ2V0cyB3cml0ZW4gdG8gdGhlIE1hdHJpeC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB2IGZ1bmN0aW9uIHRha2VzIDIgcGFyYW1ldGVycyBmb3Igcm93IGFuZCBjb2wsIGFuZCByZXR1cm5zIGEgdmFsdWUgd2l0Y2ggc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIGNvbHRoIGVudHJ5IG9mIHRoZSByb3d0aCByb3cgb2YgdGhlIG1hdHJpeC5cbiAgICAgKi9cbiAgICBfYXBwbHlfYXJyYXkoZiwgdikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IFtyb3dzLCBjb2xzXSA9IHRoaXMuc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gb2Zmc2V0ICsgY29sO1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBmKGRhdGFbaV0sIHYocm93LCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfYXBwbHlfcm93d2lzZV9hcnJheSh2YWx1ZXMsIGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5X2FycmF5KGYsIChfLCBqKSA9PiB2YWx1ZXNbal0pO1xuICAgIH1cblxuICAgIF9hcHBseV9jb2x3aXNlX2FycmF5KHZhbHVlcywgZikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IFtyb3dzLCBjb2xzXSA9IHRoaXMuc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSByb3cgKiBjb2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gb2Zmc2V0ICsgY29sO1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBmKGRhdGFbaV0sIHZhbHVlc1tyb3ddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfYXBwbHkodmFsdWUsIGYpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgW3ZhbHVlX3Jvd3MsIHZhbHVlX2NvbHNdID0gdmFsdWUuc2hhcGU7XG4gICAgICAgICAgICBsZXQgW3Jvd3MsIGNvbHNdID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZV9yb3dzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHMgIT09IHZhbHVlX2NvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb2xzICE9PSB2YWx1ZV9jb2xzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3JvdyAqIGNvbHMgKyBjb2xdID0gZihkYXRhW3JvdyAqIGNvbHMgKyBjb2xdLCB2YWx1ZS5lbnRyeSgwLCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVfY29scyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3dzICE9PSB2YWx1ZV9yb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcm93cyAhPT0gdmFsdWVfcm93c2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWUuZW50cnkocm93LCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJvd3MgPT0gdmFsdWVfcm93cyAmJiBjb2xzID09IHZhbHVlX2NvbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWUuZW50cnkocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgICAgICBsZXQgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSByb3dzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbcm93ICogY29scyArIGNvbF0gPSBmKGRhdGFbcm93ICogY29scyArIGNvbF0sIHZhbHVlW3Jvd10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IGNvbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtyb3cgKiBjb2xzICsgY29sXSA9IGYoZGF0YVtyb3cgKiBjb2xzICsgY29sXSwgdmFsdWVbY29sXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXJyb3JgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fcm93cyAqIHRoaXMuX2NvbHM7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2ldID0gZihkYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgbGV0IEIgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIEIuX3Jvd3MgPSB0aGlzLl9yb3dzO1xuICAgICAgICBCLl9jb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgQi5fZGF0YSA9IHRoaXMudmFsdWVzLnNsaWNlKDApO1xuICAgICAgICByZXR1cm4gQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnRyeXdpc2UgbXVsdGlwbGljYXRpb24gd2l0aCB7QGxpbmsgdmFsdWV9LlxuICAgICAqIEBwYXJhbSB7TWF0cml4fEFycmF5fE51bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBsZXQgQSA9IE1hdHJpeC5mcm9tKFtbMSwgMl0sIFszLCA0XV0pOyAvLyBhIDIgYnkgMiBtYXRyaXguXG4gICAgICogbGV0IEIgPSBBLmNsb25lKCk7IC8vIEIgPT0gQTtcbiAgICAgKlxuICAgICAqIEEubXVsdCgyKTsgLy8gW1syLCA0XSwgWzYsIDhdXTtcbiAgICAgKiBBLm11bHQoQik7IC8vIFtbMSwgNF0sIFs5LCAxNl1dO1xuICAgICAqL1xuICAgIG11bHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYXBwbHkodmFsdWUsIChhLCBiKSA9PiBhICogYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW50cnl3aXNlIGRpdmlzaW9uIHdpdGgge0BsaW5rIHZhbHVlfS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeHxBcnJheXxOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogbGV0IEEgPSBNYXRyaXguZnJvbShbWzEsIDJdLCBbMywgNF1dKTsgLy8gYSAyIGJ5IDIgbWF0cml4LlxuICAgICAqIGxldCBCID0gQS5jbG9uZSgpOyAvLyBCID09IEE7XG4gICAgICpcbiAgICAgKiBBLmRpdmlkZSgyKTsgLy8gW1swLjUsIDFdLCBbMS41LCAyXV07XG4gICAgICogQS5kaXZpZGUoQik7IC8vIFtbMSwgMV0sIFsxLCAxXV07XG4gICAgICovXG4gICAgZGl2aWRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2FwcGx5KHZhbHVlLCAoYSwgYikgPT4gYSAvIGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudHJ5d2lzZSBhZGRpdGlvbiB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAyXSwgWzMsIDRdXSk7IC8vIGEgMiBieSAyIG1hdHJpeC5cbiAgICAgKiBsZXQgQiA9IEEuY2xvbmUoKTsgLy8gQiA9PSBBO1xuICAgICAqXG4gICAgICogQS5hZGQoMik7IC8vIFtbMywgNF0sIFs1LCA2XV07XG4gICAgICogQS5hZGQoQik7IC8vIFtbMiwgNF0sIFs2LCA4XV07XG4gICAgICovXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX2FwcGx5KHZhbHVlLCAoYSwgYikgPT4gYSArIGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudHJ5d2lzZSBzdWJ0cmFjdGlvbiB3aXRoIHtAbGluayB2YWx1ZX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGxldCBBID0gTWF0cml4LmZyb20oW1sxLCAyXSwgWzMsIDRdXSk7IC8vIGEgMiBieSAyIG1hdHJpeC5cbiAgICAgKiBsZXQgQiA9IEEuY2xvbmUoKTsgLy8gQiA9PSBBO1xuICAgICAqXG4gICAgICogQS5zdWIoMik7IC8vIFtbLTEsIDBdLCBbMSwgMl1dO1xuICAgICAqIEEuc3ViKEIpOyAvLyBbWzAsIDBdLCBbMCwgMF1dO1xuICAgICAqL1xuICAgIHN1Yih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9hcHBseSh2YWx1ZSwgKGEsIGIpID0+IGEgLSBiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgTWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gQXJyYXkgaW4gdGhlIGZvcm0gW3Jvd3MsIGNvbHVtbnNdLlxuICAgICAqL1xuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl9yb3dzLCB0aGlzLl9jb2xzXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRyaXggaW4gdGhlIGdpdmVuIHNoYXBlIHdpdGggdGhlIGdpdmVuIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdmFsdWVzIGZvciB0aGUgZW50cmllcyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtZXRlciAtIHRha2VzIGFuIEFycmF5IGluIHRoZSBmb3JtIFtyb3dzLCBjb2xzLCB2YWx1ZV0sIHdoZXJlIHJvd3MgYW5kIGNvbHMgYXJlIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgbWF0cml4LCBhbmQgdmFsdWUgaXMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gcGFyYW1ldGVycyAocm93IGFuZCBjb2wpIHdoaWNoIGhhcyB0byByZXR1cm4gYSB2YWx1ZSBmb3IgdGhlIGNvbHRoIGVudHJ5IG9mIHRoZSByb3d0aCByb3cuXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzZXQgc2hhcGUoW3Jvd3MsIGNvbHMsIHZhbHVlID0gKCkgPT4gMF0pIHtcbiAgICAgICAgdGhpcy5fcm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuX2NvbHMgPSBjb2xzO1xuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0NjRBcnJheShyb3dzICogY29scyk7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbcm93ICogY29scyArIGNvbF0gPSB2YWx1ZShyb3csIGNvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTWF0cml4IGFzIGEgQXJyYXkgb2YgRmxvYXQ2NEFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8RmxvYXQ2NEFycmF5Pn1cbiAgICAgKi9cbiAgICBnZXQgdG8yZEFycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5pdGVyYXRlX3Jvd3MoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE1hdHJpeCBhcyBhIEFycmF5IG9mIEFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fVxuICAgICAqL1xuICAgIGdldCBhc0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5pdGVyYXRlX3Jvd3MoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goQXJyYXkuZnJvbShyb3cpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpYWdvbmFsIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgZGlhZygpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLl9jb2xzO1xuICAgICAgICBjb25zdCBtaW5fcm93X2NvbCA9IE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEZsb2F0NjRBcnJheShtaW5fcm93X2NvbCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluX3Jvd19jb2w7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5lbnRyeShpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1lYW4gb2YgYWxsIGVudHJpZXMgb2YgdGhlIE1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBtZWFuKCkge1xuICAgICAgICBjb25zdCBzdW0gPSB0aGlzLnN1bTtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX3Jvd3MgKiB0aGlzLl9jb2xzO1xuICAgICAgICByZXR1cm4gc3VtIC8gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb29mIGFsbCBlbnRyaWVzIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3VtKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIHJldHVybiBuZXVtYWlyX3N1bShkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb29mIGFsbCBlbnRyaWVzIG9mIHRoZSBNYXRyaXguXG4gICAgICogQHJldHVybnMge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWVhbiBvZiBlYWNoIHJvdyBvZiB0aGUgbWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtGbG9hdDY0QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IG1lYW5Sb3dzKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0aGlzLl9yb3dzO1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5fY29scztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRmxvYXQ2NEFycmF5LmZyb20oeyBsZW5ndGg6IHJvd3MgfSk7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICByZXN1bHRbcm93XSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyb3ddICs9IGRhdGFbcm93ICogY29scyArIGNvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbcm93XSAvPSBjb2xzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgdGhlIG1lYW4gb2YgZWFjaCBjb2x1bW4gb2YgdGhlIG1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7RmxvYXQ2NEFycmF5fVxuICAgICAqL1xuICAgIGdldCBtZWFuQ29scygpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMudmFsdWVzO1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5fcm93cztcbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMuX2NvbHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEZsb2F0NjRBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb2xzIH0pO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xzOyArK2NvbCkge1xuICAgICAgICAgICAgcmVzdWx0W2NvbF0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY29sXSArPSBkYXRhW3JvdyAqIGNvbHMgKyBjb2xdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2NvbF0gLz0gcm93cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNvbHZlcyB0aGUgZXF1YXRpb24ge0BsaW5rIEF9eCA9IHtAbGluayBifSB1c2luZyB0aGUgY29uanVnYXRlIGdyYWRpZW50IG1ldGhvZC4gUmV0dXJucyB0aGUgcmVzdWx0IHguXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEEgLSBNYXRyaXhcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gYiAtIE1hdHJpeFxuICAgICAqIEBwYXJhbSB7UmFuZG9taXplcn0gW3JhbmRvbWl6ZXI9bnVsbF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RvbD0xZS0zXVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc3RhdGljIHNvbHZlX0NHKEEsIGIsIHJhbmRvbWl6ZXIsIHRvbCA9IDFlLTMpIHtcbiAgICAgICAgaWYgKHJhbmRvbWl6ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJhbmRvbWl6ZXIgPSBuZXcgUmFuZG9taXplcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvd3MgPSBBLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBjb2xzID0gYi5zaGFwZVsxXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBNYXRyaXgocm93cywgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sczsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBiX2kgPSBNYXRyaXguZnJvbShiLmNvbChpKSkuVDtcbiAgICAgICAgICAgIGxldCB4ID0gbmV3IE1hdHJpeChyb3dzLCAxLCAoKSA9PiByYW5kb21pemVyLnJhbmRvbSk7XG4gICAgICAgICAgICBsZXQgciA9IGJfaS5zdWIoQS5kb3QoeCkpO1xuICAgICAgICAgICAgbGV0IGQgPSByLmNsb25lKCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IEEuZG90KGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscGhhID0gci5ULmRvdChyKS5lbnRyeSgwLCAwKSAvIGQuVC5kb3QoeikuZW50cnkoMCwgMCk7XG4gICAgICAgICAgICAgICAgeCA9IHguYWRkKGQubXVsdChhbHBoYSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJfbmV4dCA9IHIuc3ViKHoubXVsdChhbHBoYSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJldGEgPSByX25leHQuVC5kb3Qocl9uZXh0KS5lbnRyeSgwLCAwKSAvIHIuVC5kb3QocikuZW50cnkoMCwgMCk7XG4gICAgICAgICAgICAgICAgZCA9IHJfbmV4dC5hZGQoZC5tdWx0KGJldGEpKTtcbiAgICAgICAgICAgICAgICByID0gcl9uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAoTWF0aC5hYnMoci5tZWFuKSA+IHRvbCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHgsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNvbHZlcyB0aGUgZXF1YXRpb24ge0BsaW5rIEF9eCA9IHtAbGluayBifS4gUmV0dXJucyB0aGUgcmVzdWx0IHguXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEEgLSBNYXRyaXggb3IgTFUgRGVjb21wb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBiIC0gTWF0cml4XG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzdGF0aWMgc29sdmUoQSwgYikge1xuICAgICAgICBsZXQgeyBMOiBMLCBVOiBVIH0gPSBcIkxcIiBpbiBBICYmIFwiVVwiIGluIEEgPyBBIDogTWF0cml4LkxVKEEpO1xuICAgICAgICBsZXQgcm93cyA9IEwuc2hhcGVbMF07XG4gICAgICAgIGxldCB4ID0gYi5jbG9uZSgpO1xuXG4gICAgICAgIC8vIGZvcndhcmRcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHJvdyAtIDE7ICsrY29sKSB7XG4gICAgICAgICAgICAgICAgeC5zZXRfZW50cnkoMCwgcm93LCB4LmVudHJ5KDAsIHJvdykgLSBMLmVudHJ5KHJvdywgY29sKSAqIHguZW50cnkoMSwgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4LnNldF9lbnRyeSgwLCByb3csIHguZW50cnkoMCwgcm93KSAvIEwuZW50cnkocm93LCByb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJhY2t3YXJkXG4gICAgICAgIGZvciAobGV0IHJvdyA9IHJvd3MgLSAxOyByb3cgPj0gMDsgLS1yb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHJvd3MgLSAxOyBjb2wgPiByb3c7IC0tY29sKSB7XG4gICAgICAgICAgICAgICAgeC5zZXRfZW50cnkoMCwgcm93LCB4LmVudHJ5KDAsIHJvdykgLSBVLmVudHJ5KHJvdywgY29sKSAqIHguZW50cnkoMCwgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4LnNldF9lbnRyeSgwLCByb3csIHguZW50cnkoMCwgcm93KSAvIFUuZW50cnkocm93LCByb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHtAbGluayBMfXtAbGluayBVfSBkZWNvbXBvc2l0aW9uIG9mIHRoZSBNYXRyaXgge0BsaW5rIEF9LiBDcmVhdGVzIHR3byBtYXRyaWNlcywgc28gdGhhdCB0aGUgZG90IHByb2R1Y3QgTFUgZXF1YWxzIEEuXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEFcbiAgICAgKiBAcmV0dXJucyB7e0w6IE1hdHJpeCwgVTogTWF0cml4fX0gcmVzdWx0IC0gUmV0dXJucyB0aGUgbGVmdCB0cmlhbmdsZSBtYXRyaXgge0BsaW5rIEx9IGFuZCB0aGUgdXBwZXIgdHJpYW5nbGUgbWF0cml4IHtAbGluayBVfS5cbiAgICAgKi9cbiAgICBzdGF0aWMgTFUoQSkge1xuICAgICAgICBjb25zdCByb3dzID0gQS5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgTCA9IG5ldyBNYXRyaXgocm93cywgcm93cywgXCJ6ZXJvc1wiKTtcbiAgICAgICAgY29uc3QgVSA9IG5ldyBNYXRyaXgocm93cywgcm93cywgXCJpZGVudGl0eVwiKTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd3M7ICsraikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGo7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGo7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gTC5lbnRyeShpLCBrKSAqIFUuZW50cnkoaywgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEwuc2V0X2VudHJ5KGksIGosIEEuZW50cnkoaSwgaikgLSBzdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGo7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoTC5lbnRyeShqLCBqKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGo7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gTC5lbnRyeShqLCBrKSAqIFUuZW50cnkoaywgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFUuc2V0X2VudHJ5KGosIGksIChBLmVudHJ5KGosIGkpIC0gc3VtKSAvIEwuZW50cnkoaiwgaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgTDogTCwgVTogVSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkZXRlcm1pbmFudGUgb2Yge0BsaW5rIEF9LCBieSB1c2luZyB0aGUgTFUgZGVjb21wb3NpdGlvbiBvZiB7QGxpbmsgQX0uXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IEFcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBkZXQgLSBSZXR1cm5zIHRoZSBkZXRlcm1pbmF0ZSBvZiB0aGUgTWF0cml4IHtAbGluayBBfS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGV0KEEpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IEEuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHsgTCwgVSB9ID0gTWF0cml4LkxVKEEpO1xuICAgICAgICBjb25zdCBMX2RpYWcgPSBMLmRpYWc7XG4gICAgICAgIGNvbnN0IFVfZGlhZyA9IFUuZGlhZztcbiAgICAgICAgbGV0IGRldCA9IExfZGlhZ1swXSAqIFVfZGlhZ1swXTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMTsgcm93IDwgcm93czsgKytyb3cpIHtcbiAgICAgICAgICAgIGRldCAqPSBMX2RpYWdbcm93XSAqIFVfZGlhZ1tyb3ddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHtAbGluayBrfSBjb21wb25lbnRzIG9mIHRoZSBTVkQgZGVjb21wb3NpdGlvbiBvZiB0aGUgbWF0cml4IHtAbGluayBNfVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBNXG4gICAgICogQHBhcmFtIHtpbnR9IFtrPTJdXG4gICAgICogQHJldHVybnMge3tVOiBNYXRyaXgsIFNpZ21hOiBNYXRyaXgsIFY6IE1hdHJpeH19XG4gICAgICovXG4gICAgc3RhdGljIFNWRChNLCBrID0gMikge1xuICAgICAgICBjb25zdCBNVCA9IE0uVDtcbiAgICAgICAgbGV0IE10TSA9IE1ULmRvdChNKTtcbiAgICAgICAgbGV0IE1NdCA9IE0uZG90KE1UKTtcbiAgICAgICAgbGV0IHsgZWlnZW52ZWN0b3JzOiBWLCBlaWdlbnZhbHVlczogU2lnbWEgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihNdE0sIGspO1xuICAgICAgICBsZXQgeyBlaWdlbnZlY3RvcnM6IFUgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihNTXQsIGspO1xuICAgICAgICByZXR1cm4geyBVOiBVLCBTaWdtYTogU2lnbWEubWFwKChzaWdtYSkgPT4gTWF0aC5zcXJ0KHNpZ21hKSksIFY6IFYgfTtcblxuICAgICAgICAvL0FsZ29yaXRobSAxYTogSG91c2Vob2xkZXIgcmVkdWN0aW9uIHRvIGJpZGlhZ29uYWwgZm9ybTpcbiAgICAgICAgLyogY29uc3QgW20sIG5dID0gQS5zaGFwZTtcbiAgICAgICAgbGV0IFUgPSBuZXcgTWF0cml4KG0sIG4sIChpLCBqKSA9PiBpID09IGogPyAxIDogMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFUudG8yZEFycmF5KVxuICAgICAgICBsZXQgViA9IG5ldyBNYXRyaXgobiwgbSwgKGksIGopID0+IGkgPT0gaiA/IDEgOiAwKTtcbiAgICAgICAgY29uc29sZS5sb2coVi50bzJkQXJyYXkpXG4gICAgICAgIGxldCBCID0gTWF0cml4LmJpZGlhZ29uYWwoQS5jbG9uZSgpLCBVLCBWKTtcbiAgICAgICAgY29uc29sZS5sb2coVSxWLEIpXG4gICAgICAgIHJldHVybiB7IFU6IFUsIFwiU2lnbWFcIjogQiwgVjogViB9OyAqL1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGxpbnNwYWNlLCBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnV0aWxzXG4gKiBAYWxpYXMgUmFuZG9taXplclxuICovXG5leHBvcnQgY2xhc3MgUmFuZG9taXplciB7XG4gICAgLyoqXG4gICAgICogTWVyc2VubmUgVHdpc3RlciByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW19zZWVkPW5ldyBEYXRlKCkuZ2V0VGltZSgpXSAtIFRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuIElmIDxjb2RlPl9zZWVkID09IG51bGw8L2NvZGU+IHRoZW4gdGhlIGFjdHVhbCB0aW1lIGdldHMgdXNlZCBhcyBzZWVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JtdXJyYXk3L21lcnNlbm5lLXR3aXN0ZXItZXhhbXBsZXMvYmxvYi9tYXN0ZXIvamF2YXNjcmlwdC1tZXJzZW5uZS10d2lzdGVyLmpzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX3NlZWQpIHtcbiAgICAgICAgdGhpcy5fTiA9IDYyNDtcbiAgICAgICAgdGhpcy5fTSA9IDM5NztcbiAgICAgICAgdGhpcy5fTUFUUklYX0EgPSAweDk5MDhiMGRmO1xuICAgICAgICB0aGlzLl9VUFBFUl9NQVNLID0gMHg4MDAwMDAwMDtcbiAgICAgICAgdGhpcy5fTE9XRVJfTUFTSyA9IDB4N2ZmZmZmZmY7XG4gICAgICAgIHRoaXMuX210ID0gbmV3IEFycmF5KHRoaXMuX04pO1xuICAgICAgICB0aGlzLl9tdGkgPSB0aGlzLk4gKyAxO1xuXG4gICAgICAgIHRoaXMuc2VlZCA9IF9zZWVkIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXQgc2VlZChfc2VlZCkge1xuICAgICAgICB0aGlzLl9zZWVkID0gX3NlZWQ7XG4gICAgICAgIGxldCBtdCA9IHRoaXMuX210O1xuXG4gICAgICAgIG10WzBdID0gX3NlZWQgPj4+IDA7XG4gICAgICAgIGZvciAodGhpcy5fbXRpID0gMTsgdGhpcy5fbXRpIDwgdGhpcy5fTjsgdGhpcy5fbXRpICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBtdGkgPSB0aGlzLl9tdGk7XG4gICAgICAgICAgICBsZXQgcyA9IG10W210aSAtIDFdIF4gKG10W210aSAtIDFdID4+PiAzMCk7XG4gICAgICAgICAgICBtdFttdGldID0gKCgoKHMgJiAweGZmZmYwMDAwKSA+Pj4gMTYpICogMTgxMjQzMzI1MykgPDwgMTYpICsgKHMgJiAweDAwMDBmZmZmKSAqIDE4MTI0MzMyNTMgKyBtdGk7XG4gICAgICAgICAgICBtdFttdGldID4+Pj0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlZWQgb2YgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIHNlZWQuXG4gICAgICovXG4gICAgZ2V0IHNlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybnMge051bWJlcn0gLSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBbMCwgMV1cbiAgICAgKi9cbiAgICBnZXQgcmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5kb21faW50ICogKDEuMCAvIDQyOTQ5NjcyOTYuMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgTUFYX0lOVEVHRVIuXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9IC0gQSByYW5kb20gaW50ZWdlci5cbiAgICAgKi9cbiAgICBnZXQgcmFuZG9tX2ludCgpIHtcbiAgICAgICAgbGV0IHksXG4gICAgICAgICAgICBtYWcwMSA9IG5ldyBBcnJheSgweDAsIHRoaXMuX01BVFJJWF9BKTtcbiAgICAgICAgaWYgKHRoaXMuX210aSA+PSB0aGlzLl9OKSB7XG4gICAgICAgICAgICBsZXQga2s7XG5cbiAgICAgICAgICAgIC8qIGlmICh0aGlzLl9tdGkgPT0gdGhpcy5fTiArIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlZWQgPSA1NDg5O1xuICAgICAgICAgICAgfSAqL1xuXG4gICAgICAgICAgICBsZXQgTl9NID0gdGhpcy5fTiAtIHRoaXMuX007XG4gICAgICAgICAgICBsZXQgTV9OID0gdGhpcy5fTSAtIHRoaXMuX047XG5cbiAgICAgICAgICAgIGZvciAoa2sgPSAwOyBrayA8IE5fTTsgKytraykge1xuICAgICAgICAgICAgICAgIHkgPSAodGhpcy5fbXRba2tdICYgdGhpcy5fVVBQRVJfTUFTSykgfCAodGhpcy5fbXRba2sgKyAxXSAmIHRoaXMuX0xPV0VSX01BU0spO1xuICAgICAgICAgICAgICAgIHRoaXMuX210W2trXSA9IHRoaXMuX210W2trICsgdGhpcy5fTV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyBrayA8IHRoaXMuX04gLSAxOyArK2trKSB7XG4gICAgICAgICAgICAgICAgeSA9ICh0aGlzLl9tdFtra10gJiB0aGlzLl9VUFBFUl9NQVNLKSB8ICh0aGlzLl9tdFtrayArIDFdICYgdGhpcy5fTE9XRVJfTUFTSyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbXRba2tdID0gdGhpcy5fbXRba2sgKyBNX05dIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHkgPSAodGhpcy5fbXRbdGhpcy5fTiAtIDFdICYgdGhpcy5fVVBQRVJfTUFTSykgfCAodGhpcy5fbXRbMF0gJiB0aGlzLl9MT1dFUl9NQVNLKTtcbiAgICAgICAgICAgIHRoaXMuX210W3RoaXMuX04gLSAxXSA9IHRoaXMuX210W3RoaXMuX00gLSAxXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdO1xuXG4gICAgICAgICAgICB0aGlzLl9tdGkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgeSA9IHRoaXMuX210Wyh0aGlzLl9tdGkgKz0gMSldO1xuICAgICAgICB5IF49IHkgPj4+IDExO1xuICAgICAgICB5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcbiAgICAgICAgeSBePSAoeSA8PCAxNSkgJiAweGVmYzYwMDAwO1xuICAgICAgICB5IF49IHkgPj4+IDE4O1xuXG4gICAgICAgIHJldHVybiB5ID4+PiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2FtcGxlcyBmcm9tIGFuIGlucHV0IE1hdHJpeCBvciBBcnJheS5cbiAgICAgKiBAcGFyYW0ge01hdHJpeHxBcnJheXxGbG9hdDY0QXJyYXl9IEEgLSBUaGUgaW5wdXQgTWF0cml4IG9yIEFycmF5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSBBIHJhbmRvbSBzZWxlY3Rpb24gZm9ybSB7QGxpbmsgQX0gb2Yge0BsaW5rIG59IHNhbXBsZXMuXG4gICAgICovXG4gICAgY2hvaWNlKEEsIG4pIHtcbiAgICAgICAgaWYgKEEgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gQS5zaGFwZVswXTtcbiAgICAgICAgICAgIGlmIChuID4gcm93cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm4gYmlnZ2VyIHRoYW4gQSFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2FtcGxlID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgbGV0IGluZGV4X2xpc3QgPSBsaW5zcGFjZSgwLCByb3dzIC0gMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGluZGV4X2xpc3QubGVuZ3RoOyBpIDwgbjsgKytpLCAtLWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZG9tX2luZGV4ID0gdGhpcy5yYW5kb21faW50ICUgbDtcbiAgICAgICAgICAgICAgICBzYW1wbGVbaV0gPSBpbmRleF9saXN0LnNwbGljZShyYW5kb21faW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZS5tYXAoKGQpID0+IEEucm93KGQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEEpIHx8IEEgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gQS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobiA+IHJvd3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuIGJpZ2dlciB0aGFuIEEhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNhbXBsZSA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGxldCBpbmRleF9saXN0ID0gbGluc3BhY2UoMCwgcm93cyAtIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpbmRleF9saXN0Lmxlbmd0aDsgaSA8IG47ICsraSwgLS1sKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmRvbV9pbmRleCA9IHRoaXMucmFuZG9tX2ludCAlIGw7XG4gICAgICAgICAgICAgICAgc2FtcGxlW2ldID0gaW5kZXhfbGlzdC5zcGxpY2UocmFuZG9tX2luZGV4LCAxKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYW1wbGUubWFwKChkKSA9PiBBW2RdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBSZXR1cm5zIHNhbXBsZXMgZnJvbSBhbiBpbnB1dCBNYXRyaXggb3IgQXJyYXkuXG4gICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXl8RmxvYXQ2NEFycmF5fSBBIC0gVGhlIGlucHV0IE1hdHJpeCBvciBBcnJheS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiAtIFRoZSBudW1iZXIgb2Ygc2FtcGxlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VlZCAtIFRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIEEgcmFuZG9tIHNlbGVjdGlvbiBmb3JtIHtAbGluayBBfSBvZiB7QGxpbmsgbn0gc2FtcGxlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY2hvaWNlKEEsIG4sIHNlZWQgPSAxMjEyKSB7XG4gICAgICAgIGNvbnN0IFIgPSBuZXcgUmFuZG9taXplcihzZWVkKTtcbiAgICAgICAgcmV0dXJuIFIuY2hvaWNlKEEsIG4pO1xuICAgICAgICAvKiBsZXQgcm93cyA9IEEuc2hhcGVbMF07XG4gICAgICAgIGlmIChuID4gcm93cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibiBiaWdnZXIgdGhhbiBBIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZCA9IG5ldyBSYW5kb21pemVyKHNlZWQpO1xuICAgICAgICBsZXQgc2FtcGxlID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBsZXQgaW5kZXhfbGlzdCA9IGxpbnNwYWNlKDAsIHJvd3MgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpbmRleF9saXN0Lmxlbmd0aDsgaSA8IG47ICsraSwgLS1sKSB7XG4gICAgICAgICAgICBsZXQgcmFuZG9tX2luZGV4ID0gcmFuZC5yYW5kb21faW50ICUgbDtcbiAgICAgICAgICAgIHNhbXBsZVtpXSA9IGluZGV4X2xpc3Quc3BsaWNlKHJhbmRvbV9pbmRleCwgMSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy9yZXR1cm4gcmVzdWx0O1xuICAgICAgICAvL3JldHVybiBuZXcgTWF0cml4KG4sIGNvbHMsIChyb3csIGNvbCkgPT4gQS5lbnRyeShzYW1wbGVbcm93XSwgY29sKSlcbiAgICAgICAgcmV0dXJuIHNhbXBsZS5tYXAoKGQpID0+IEEucm93KGQpKTsgKi9cbiAgICB9XG59XG4iLCIvKipcbiAqIFJldHVybnMgbWF4aW11bSBpbiBBcnJheSB7QGxpbmsgdmFsdWVzfS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dXRpbHNcbiAqIEBhbGlhcyBtYXhcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICBsZXQgbWF4O1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbn0iLCIvKipcbiAqIFJldHVybnMgbWF4aW11bSBpbiBBcnJheSB7QGxpbmsgdmFsdWVzfS5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dXRpbHNcbiAqIEBhbGlhcyBtaW5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIGxldCBtaW47XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA8PSB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluO1xufSIsIi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSGVhcFxuICovXG5leHBvcnQgY2xhc3MgSGVhcCB7XG4gICAgLyoqXG4gICAgICogQSBoZWFwIGlzIGEgZGF0YXN0cnVjdHVyZSBob2xkaW5nIGl0cyBlbGVtZW50cyBpbiBhIHNwZWNpZmljIHdheSwgc28gdGhhdCB0aGUgdG9wIGVsZW1lbnQgd291bGQgYmUgdGhlIGZpcnN0IGVudHJ5IG9mIGFuIG9yZGVyZWQgbGlzdC5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRhdGFzdHJ1Y3R1cmVcbiAgICAgKiBAYWxpYXMgSGVhcFxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBlbGVtZW50cyAtIENvbnRhaW5zIHRoZSBlbGVtZW50cyBmb3IgdGhlIEhlYXAuIHtAbGluayBlbGVtZW50c30gY2FuIGJlIG51bGwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2FjY2Vzc29yID0gKGQpID0+IGRdIC0gRnVuY3Rpb24gcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHsoXCJtaW5cInxcIm1heFwifEZ1bmN0aW9uKX0gW2NvbXBhcmF0b3IgPSBcIm1pblwiXSAtIEZ1bmN0aW9uIHJldHVybmluZyB0cnVlIG9yIGZhbHNlIGRlZmluaW5nIHRoZSB3aXNoZWQgb3JkZXIgb2YgdGhlIEhlYXAsIG9yIFN0cmluZyBmb3IgcHJlZGVmaW5lZCBmdW5jdGlvbi4gKFwibWluXCIgZm9yIGEgTWluLUhlYXAsIFwibWF4XCIgZm9yIGEgTWF4X2hlYXApXG4gICAgICogQHJldHVybnMge0hlYXB9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmluYXJ5X2hlYXB9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMgPSBudWxsLCBhY2Nlc3NvciA9IGQgPT4gZCwgY29tcGFyYXRvciA9IFwibWluXCIpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gSGVhcC5oZWFwaWZ5KGVsZW1lbnRzLCBhY2Nlc3NvciwgY29tcGFyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hY2Nlc3NvciA9IGFjY2Vzc29yO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gW107XG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvciA9PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IChhLCBiKSA9PiBhIDwgYjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGFyYXRvciA9PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IChhLCBiKSA9PiBhID4gYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEhlYXAgZnJvbSBhbiBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl8U2V0fSBlbGVtZW50cyAtIENvbnRhaW5zIHRoZSBlbGVtZW50cyBmb3IgdGhlIEhlYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbj19IFthY2Nlc3NvciA9IChkKSA9PiBkXSAtIEZ1bmN0aW9uIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7KFN0cmluZz18RnVuY3Rpb24pfSBbY29tcGFyYXRvciA9IFwibWluXCJdIC0gRnVuY3Rpb24gcmV0dXJuaW5nIHRydWUgb3IgZmFsc2UgZGVmaW5pbmcgdGhlIHdpc2hlZCBvcmRlciBvZiB0aGUgSGVhcCwgb3IgU3RyaW5nIGZvciBwcmVkZWZpbmVkIGZ1bmN0aW9uLiAoXCJtaW5cIiBmb3IgYSBNaW4tSGVhcCwgXCJtYXhcIiBmb3IgYSBNYXhfaGVhcClcbiAgICAgKiBAcmV0dXJucyB7SGVhcH1cbiAgICAgKi9cbiAgICBzdGF0aWMgaGVhcGlmeShlbGVtZW50cywgYWNjZXNzb3IgPSBkID0+IGQsIGNvbXBhcmF0b3IgPSBcIm1pblwiKSB7XG4gICAgICAgIGNvbnN0IGhlYXAgPSBuZXcgSGVhcChudWxsLCBhY2Nlc3NvciwgY29tcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGhlYXAuX2NvbnRhaW5lcjtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb250YWluZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgXCJlbGVtZW50XCI6IGUsXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBhY2Nlc3NvcihlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLmZsb29yKChlbGVtZW50cy5sZW5ndGggLyAyKSAtIDEpOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaGVhcC5faGVhcGlmeV9kb3duKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGVsZW1lbnRzIG9mIGNvbnRhaW5lciBhcnJheS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleF9hIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleF9iIFxuICAgICAqL1xuICAgIF9zd2FwKGluZGV4X2EsIGluZGV4X2IpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBbY29udGFpbmVyW2luZGV4X2JdLCBjb250YWluZXJbaW5kZXhfYV1dID0gW2NvbnRhaW5lcltpbmRleF9hXSwgY29udGFpbmVyW2luZGV4X2JdXTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hlYXBpZnlfdXAoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgbGV0IGluZGV4ID0gY29udGFpbmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRJbmRleCA9IE1hdGguZmxvb3IoKGluZGV4IC0gMSkgLyAyKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29tcGFyYXRvcihjb250YWluZXJbaW5kZXhdLnZhbHVlLCBjb250YWluZXJbcGFyZW50SW5kZXhdLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N3YXAocGFyZW50SW5kZXgsIGluZGV4KVxuICAgICAgICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1c2hlcyB0aGUgZWxlbWVudCB0byB0aGUgaGVhcC5cbiAgICAgKiBAcGFyYW0ge30gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtIZWFwfVxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2FjY2Vzc29yKGVsZW1lbnQpO1xuICAgICAgICAvL2NvbnN0IG5vZGUgPSBuZXcgTm9kZShlbGVtZW50LCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB7XCJlbGVtZW50XCI6IGVsZW1lbnQsIFwidmFsdWVcIjogdmFsdWV9O1xuICAgICAgICB0aGlzLl9jb250YWluZXIucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5faGVhcGlmeV91cCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRfaW5kZXggPSAwXSBcbiAgICAgKi9cbiAgICBfaGVhcGlmeV9kb3duKHN0YXJ0X2luZGV4PTApIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBjb25zdCBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY29udGFpbmVyLmxlbmd0aDtcbiAgICAgICAgbGV0IGxlZnQgPSAyICogc3RhcnRfaW5kZXggKyAxO1xuICAgICAgICBsZXQgcmlnaHQgPSAyICogc3RhcnRfaW5kZXggKyAyO1xuICAgICAgICBsZXQgaW5kZXggPSBzdGFydF9pbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoKSB0aHJvdyBcImluZGV4IGhpZ2hlciB0aGFuIGxlbmd0aFwiXG4gICAgICAgIGlmIChsZWZ0IDwgbGVuZ3RoICYmIGNvbXBhcmF0b3IoY29udGFpbmVyW2xlZnRdLnZhbHVlLCBjb250YWluZXJbaW5kZXhdLnZhbHVlKSkge1xuICAgICAgICAgICAgaW5kZXggPSBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCA8IGxlbmd0aCAmJiBjb21wYXJhdG9yKGNvbnRhaW5lcltyaWdodF0udmFsdWUsIGNvbnRhaW5lcltpbmRleF0udmFsdWUpKSB7XG4gICAgICAgICAgICBpbmRleCA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPT0gc3RhcnRfaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N3YXAoc3RhcnRfaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX2hlYXBpZnlfZG93bihpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSB0b3AgZW50cnkgb2YgdGhlIGhlYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IGNvbnNpc3RzIG9mIHRoZSBlbGVtZW50IGFuZCBpdHMgdmFsdWUgKGNvbXB1dGVkIGJ5IHtAbGluayBhY2Nlc3Nvcn0pLlxuICAgICAqL1xuICAgIHBvcCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zd2FwKDAsIGNvbnRhaW5lci5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgaXRlbSA9IGNvbnRhaW5lci5wb3AoKTtcbiAgICAgICAgdGhpcy5faGVhcGlmeV9kb3duKCk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvcCBlbnRyeSBvZiB0aGUgaGVhcCB3aXRob3V0IHJlbW92aW5nIGl0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb25zaXN0cyBvZiB0aGUgZWxlbWVudCBhbmQgaXRzIHZhbHVlIChjb21wdXRlZCBieSB7QGxpbmsgYWNjZXNzb3J9KS5cbiAgICAgKi9cbiAgICBnZXQgZmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXIubGVuZ3RoID4gMCA/IHRoaXMuX2NvbnRhaW5lclswXSA6IG51bGw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBZaWVsZHMgdGhlIHJhdyBkYXRhXG4gICAgICogQHlpZWxkcyB7T2JqZWN0fSBPYmplY3QgY29uc2lzdHMgb2YgdGhlIGVsZW1lbnQgYW5kIGl0cyB2YWx1ZSAoY29tcHV0ZWQgYnkge0BsaW5rIGFjY2Vzc29yfSkuXG4gICAgICovXG4gICAgKiBpdGVyYXRlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NvbnRhaW5lci5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX2NvbnRhaW5lcltpXS5lbGVtZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVhcCBhcyBvcmRlcmVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgY29uc2lzdGluZyB0aGUgZWxlbWVudHMgb3JkZXJlZCBieSB7QGxpbmsgY29tcGFyYXRvcn0uXG4gICAgICovXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpXG4gICAgICAgICAgICAuc29ydCgoYSxiKSA9PiB0aGlzLl9jb21wYXJhdG9yKGEsIGIpID8gLTEgOiAwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZWxlbWVudHMgb2YgY29udGFpbmVyIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgY29uc2lzdGluZyB0aGUgZWxlbWVudHMuXG4gICAgICovXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lclxuICAgICAgICAgICAgLm1hcChkID0+IGQuZWxlbWVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250YWluZXIgYXJyYXkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgY29udGFpbmVyIGFycmF5LlxuICAgICAqL1xuICAgIHJhd19kYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSBoZWFwLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lci5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmYWxzZSBpZiB0aGUgdGhlIGhlYXAgaGFzIGVudHJpZXMsIHRydWUgaWYgdGhlIGhlYXAgaGFzIG5vIGVudHJpZXMuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gICAgfVxufSIsIi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgRGlzam9pbnRTZXRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc2pvaW50LXNldF9kYXRhX3N0cnVjdHVyZX1cbiAqL1xuZXhwb3J0IGNsYXNzIERpc2pvaW50U2V0IHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgRGlzam9pbnRTZXRcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRhdGFzdHJ1Y3R1cmVcbiAgICAgKiBAcGFyYW0ge0FycmF5PX0gZWxlbWVudHMgXG4gICAgICogQHJldHVybnMge0Rpc2pvaW50U2V0fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9saXN0ID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMubWFrZV9zZXQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbWFrZV9zZXQoeCkge1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgaWYgKCFsaXN0Lmhhcyh4KSkge1xuICAgICAgICAgICAgbGlzdC5hZGQoeCk7XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0ID0ge307XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0LnBhcmVudCA9IHg7XG4gICAgICAgICAgICB4Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuID0gbmV3IFNldChbeF0pO1xuICAgICAgICAgICAgeC5fX2Rpc2pvaW50X3NldC5zaXplID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmaW5kKHgpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIGlmIChsaXN0Lmhhcyh4KSkge1xuICAgICAgICAgICAgaWYgKHguX19kaXNqb2ludF9zZXQucGFyZW50ICE9PSB4KSB7XG4gICAgICAgICAgICAgICAgeC5fX2Rpc2pvaW50X3NldC5jaGlsZHJlbi5hZGQoLi4ueCk7XG4gICAgICAgICAgICAgICAgeC5fX2Rpc2pvaW50X3NldC5wYXJlbnQgPSB0aGlzLmZpbmQoeC5fX2Rpc2pvaW50X3NldC5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB4Ll9fZGlzam9pbnRfc2V0LnBhcmVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuaW9uKHgsIHkpIHtcbiAgICAgICAgbGV0IG5vZGVfeCA9IHRoaXMuZmluZCh4KTtcbiAgICAgICAgbGV0IG5vZGVfeSA9IHRoaXMuZmluZCh5KTtcblxuICAgICAgICBpZiAobm9kZV94ID09PSBub2RlX3kpIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAobm9kZV94Ll9fZGlzam9pbnRfc2V0LnNpemUgPCBub2RlX3kuX19kaXNqb2ludF9zZXQuc2l6ZSkgW25vZGVfeCwgbm9kZV95XSA9IFtub2RlX3ksIG5vZGVfeF07XG5cbiAgICAgICAgbm9kZV95Ll9fZGlzam9pbnRfc2V0LnBhcmVudCA9IG5vZGVfeDtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbj9cbiAgICAgICAgbm9kZV95Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuLmZvckVhY2gobm9kZV94Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuLmFkZCwgbm9kZV94Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuKTtcbiAgICAgICAgbm9kZV94Ll9fZGlzam9pbnRfc2V0LnNpemUgKz0gbm9kZV95Ll9fZGlzam9pbnRfc2V0LnNpemU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSIsImltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBIZWFwIH0gZnJvbSBcIi4uL2RhdGFzdHJ1Y3R1cmUvaW5kZXguanNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgQmFsbFRyZWVcbiAqL1xuZXhwb3J0IGNsYXNzIEJhbGxUcmVlIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBCYWxsVHJlZSB3aXRoIGdpdmVuIHtAbGluayBlbGVtZW50c30uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTprbm5cbiAgICAgKiBAYWxpYXMgQmFsbFRyZWVcbiAgICAgKiBAcGFyYW0ge0FycmF5PX0gZWxlbWVudHMgLSBFbGVtZW50cyB3aGljaCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIEJhbGxUcmVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gbWV0cmljIHRvIHVzZTogKGEsIGIpID0+IGRpc3RhbmNlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFsbF90cmVlfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbnZpc2FsL25vb2Jqcy9ibG9iL21hc3Rlci9zcmMvdHJlZS9CYWxsVHJlZS5qc31cbiAgICAgKiBAcmV0dXJucyB7QmFsbFRyZWV9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMgPSBudWxsLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICAgICAgdGhpcy5fTm9kZSA9IGNsYXNzIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBpdm90LCBjaGlsZDE9bnVsbCwgY2hpbGQyPW51bGwsIHJhZGl1cz1udWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waXZvdCA9IHBpdm90O1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQxID0gY2hpbGQxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQyID0gY2hpbGQyO1xuICAgICAgICAgICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX0xlYWYgPSBjbGFzcyB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcihwb2ludHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZXRyaWMgPSBtZXRyaWM7XG4gICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5hZGQoZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXk8Kj59IGVsZW1lbnRzIC0gbmV3IGVsZW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtCYWxsVHJlZX1cbiAgICAgKi9cbiAgICBhZGQoZWxlbWVudHMpIHtcbiAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cy5tYXAoKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpbmRleCwgZWxlbWVudDogZWxlbWVudH1cbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX2NvbnN0cnVjdChlbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gZWxlbWVudHMgXG4gICAgICogQHJldHVybnMge05vZGV9IHJvb3Qgb2YgYmFsbHRyZWUuXG4gICAgICovXG4gICAgX2NvbnN0cnVjdChlbGVtZW50cykge1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuX0xlYWYoZWxlbWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGMgPSB0aGlzLl9ncmVhdGVzdF9zcHJlYWQoZWxlbWVudHMpO1xuICAgICAgICAgICAgbGV0IHNvcnRlZF9lbGVtZW50cyA9IGVsZW1lbnRzLnNvcnQoKGEsIGIpID0+IGEuZWxlbWVudFtjXSAtIGIuZWxlbWVudFtjXSk7XG4gICAgICAgICAgICBsZXQgbiA9IHNvcnRlZF9lbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcF9pbmRleCA9IE1hdGguZmxvb3IobiAvIDIpO1xuICAgICAgICAgICAgbGV0IHAgPSBlbGVtZW50c1twX2luZGV4XTtcbiAgICAgICAgICAgIGxldCBMID0gc29ydGVkX2VsZW1lbnRzLnNsaWNlKDAsIHBfaW5kZXgpO1xuICAgICAgICAgICAgbGV0IFIgPSBzb3J0ZWRfZWxlbWVudHMuc2xpY2UocF9pbmRleCwgbik7XG4gICAgICAgICAgICBsZXQgcmFkaXVzID0gTWF0aC5tYXgoLi4uZWxlbWVudHMubWFwKGQgPT4gdGhpcy5fbWV0cmljKHAuZWxlbWVudCwgZC5lbGVtZW50KSkpO1xuICAgICAgICAgICAgbGV0IEJcbiAgICAgICAgICAgIGlmIChMLmxlbmd0aCA+IDAgJiYgUi5sZW5ndGggPiAwKSB7ICAgICAgICAgXG4gICAgICAgICAgICAgICAgQiA9IG5ldyB0aGlzLl9Ob2RlKHAsIHRoaXMuX2NvbnN0cnVjdChMKSwgdGhpcy5fY29uc3RydWN0KFIpLCByYWRpdXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBCID0gbmV3IHRoaXMuX0xlYWYoZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gQiBcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIF9ncmVhdGVzdF9zcHJlYWQoQikge1xuICAgICAgICBsZXQgZCA9IEJbMF0uZWxlbWVudC5sZW5ndGg7XG4gICAgICAgIGxldCBzdGFydCA9IG5ldyBBcnJheShkKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQ7ICsraSkge1xuICAgICAgICAgICAgc3RhcnRbaV0gPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3ByZWFkID0gQi5yZWR1Y2UoKGFjYywgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkOyArK2kpIHtcbiAgICAgICAgICAgICAgICBhY2NbaV1bMF0gPSBNYXRoLm1pbihhY2NbaV1bMF0sIGN1cnJlbnQuZWxlbWVudFtpXSk7XG4gICAgICAgICAgICAgICAgYWNjW2ldWzFdID0gTWF0aC5tYXgoYWNjW2ldWzFdLCBjdXJyZW50LmVsZW1lbnRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgc3RhcnQpO1xuICAgICAgICBzcHJlYWQgPSBzcHJlYWQubWFwKGQgPT4gZFsxXSAtIGRbMF0pO1xuICAgICAgICBcbiAgICAgICAgbGV0IGMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQ7ICsraSkge1xuICAgICAgICAgICAgYyA9IHNwcmVhZFtpXSA+IHNwcmVhZFtjXSA/IGkgOiBjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Kn0gdCAtIHF1ZXJ5IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtrID0gNV0gLSBudW1iZXIgb2YgbmVhcmVzdCBuZWlnaGJvcnMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtIZWFwfSAtIEhlYXAgY29uc2lzdHMgb2YgdGhlIHtAbGluayBrfSBuZWFyZXN0IG5laWdoYm9ycy5cbiAgICAgKi9cbiAgICBzZWFyY2godCwgayA9IDUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaCh0LCBrLCBuZXcgSGVhcChudWxsLCBkID0+IHRoaXMuX21ldHJpYyhkLmVsZW1lbnQsIHQpLCBcIm1heFwiKSwgdGhpcy5fcm9vdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHQgLSBxdWVyeSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbayA9IDVdIC0gbnVtYmVyIG9mIG5lYXJlc3QgbmVpZ2hib3JzIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0ge0hlYXB9IFEgLSBIZWFwIGNvbnNpc3RzIG9mIHRoZSBjdXJyZW50bHkgZm91bmQge0BsaW5rIGt9IG5lYXJlc3QgbmVpZ2hib3JzLlxuICAgICAqIEBwYXJhbSB7Tm9kZXxMZWFmfSBCIFxuICAgICAqL1xuICAgIF9zZWFyY2godCwgaywgUSwgQikge1xuICAgICAgICAvLyBCIGlzIE5vZGVcbiAgICAgICAgaWYgKFEubGVuZ3RoID49IGsgJiYgQi5waXZvdCAmJiBCLnJhZGl1cyAmJiB0aGlzLl9tZXRyaWModCwgQi5waXZvdC5lbGVtZW50KSAtIEIucmFkaXVzID49IFEuZmlyc3QudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9IFxuICAgICAgICBpZiAoQi5jaGlsZDEpIHRoaXMuX3NlYXJjaCh0LCBrLCBRLCBCLmNoaWxkMSk7XG4gICAgICAgIGlmIChCLmNoaWxkMikgdGhpcy5fc2VhcmNoKHQsIGssIFEsIEIuY2hpbGQyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEIgaXMgbGVhZlxuICAgICAgICBpZiAoQi5wb2ludHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gQi5wb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHAgPSBCLnBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoayA+IFEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIFEucHVzaChwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBRLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIFEucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBRO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSGVhcCB9IGZyb20gXCIuLi9kYXRhc3RydWN0dXJlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkaXN0YW5jZV9tYXRyaXgsIE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBLTk5cbiAqL1xuZXhwb3J0IGNsYXNzIEtOTiB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgS05OIGxpc3Qgd2l0aCBnaXZlbiB7QGxpbmsgZWxlbWVudHN9LlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6a25uXG4gICAgICogQGFsaWFzIEtOTlxuICAgICAqIEBwYXJhbSB7QXJyYXk9fSBlbGVtZW50cyAtIEVsZW1lbnRzIHdoaWNoIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgS05OIGxpc3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFwicHJlY29tcHV0ZWRcIn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gbWV0cmljIGlzIGVpdGhlciBwcmVjb21wdXRlZCBvciBhIGZ1bmN0aW9uIHRvIHVzZTogKGEsIGIpID0+IGRpc3RhbmNlXG4gICAgICogQHJldHVybnMge0tOTn1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cz1udWxsLCBtZXRyaWM9ZXVjbGlkZWFuKSB7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBlbGVtZW50cyBpbnN0YW5jZW9mIE1hdHJpeCA/IGVsZW1lbnRzIDogTWF0cml4LmZyb20oZWxlbWVudHMpO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fZWxlbWVudHMuc2hhcGVbMF07XG4gICAgICAgIGlmIChtZXRyaWMgPT09IFwicHJlY29tcHV0ZWRcIikge1xuICAgICAgICAgICAgdGhpcy5fRCA9IHRoaXMuX2VsZW1lbnRzLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9EID0gZGlzdGFuY2VfbWF0cml4KHRoaXMuX2VsZW1lbnRzLCBtZXRyaWMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuS05OID0gW107XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IE47ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSB0aGlzLl9ELnJvdyhyb3cpO1xuICAgICAgICAgICAgY29uc3QgSCA9IG5ldyBIZWFwKG51bGwsIGQgPT4gZC52YWx1ZSwgXCJtaW5cIik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIEgucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkaXN0YW5jZXNbal0sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBqLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5LTk4ucHVzaChIKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSB0IC0gcXVlcnkgZWxlbWVudCBvciBpbmRleC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2sgPSA1XSAtIG51bWJlciBvZiBuZWFyZXN0IG5laWdoYm9ycyB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0hlYXB9IC0gSGVhcCBjb25zaXN0cyBvZiB0aGUge0BsaW5rIGt9IG5lYXJlc3QgbmVpZ2hib3JzLlxuICAgICAqL1xuICAgIHNlYXJjaCh0LCBrID0gNSkge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IEtOTiA9IHRoaXMuS05OO1xuICAgICAgICBsZXQgSDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZXRyaWMgPT0gXCJwcmVjb21wdXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJTZWFyY2ggYnkgcXVlcnkgZWxlbWVudCBpcyBvbmx5IHBvc3NpYmxlIHdoZW4gbm90IHVzaW5nIGEgcHJlY29tcHV0ZWQgZGlzdGFuY2UgbWF0cml4IVwiXG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cztcbiAgICAgICAgICAgIGNvbnN0IE4gPSBLTk4ubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG5lYXJlc3RfZWxlbWVudF9pbmRleCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbmVhcmVzdF9kaXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50cy5yb3coaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IG1ldHJpYyh0LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG5lYXJlc3RfZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0X2VsZW1lbnRfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0X2Rpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEggPSBLTk5bbmVhcmVzdF9lbGVtZW50X2luZGV4XTtcbiAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHQpKSB7XG4gICAgICAgICAgICBIID0gS05OW3RdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0ID0gW11cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKEgucG9wKCkpXG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmZvckVhY2gocmVzID0+IEgucHVzaChyZXMuZWxlbWVudCkpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9ICAgIFxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IFJhbmRvbWl6ZXIgfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIERSXG4gKiBAYm9ycm93cyBEUiNwYXJhbWV0ZXIgYXMgRFIjcGFyYVxuICogQGJvcnJvd3MgRFIjcGFyYW1ldGVyIGFzIERSI3BcbiAqL1xuZXhwb3J0IGNsYXNzIERSIHtcbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzIGFuZCBzZWFscyB0aGVtLCByZW1lbWJlcnMgdGhlIHR5cGUgb2YgaW5wdXQgPGNvZGU+WDwvY29kZT4sIGFuZCBpbml0aWFsaXplcyB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpAZHJ1aWQvZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIERSXG4gICAgICogQHBhcmFtIHtNYXRyaXh8TnVtYmVyW11bXX0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcml6YXRpb24gb2YgdGhlIERSIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbWV0ZXJzLm1ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuc2VlZCA9IDEyMTJdIC0gdGhlIHNlZWQgdmFsdWUgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7RFJ9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgZGVmYXVsdF9wYXJhbWV0ZXJzLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5zZWFsKGRlZmF1bHRfcGFyYW1ldGVycyksIHBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShYKSkge1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICAgIHRoaXMuWCA9IE1hdHJpeC5mcm9tKFgpO1xuICAgICAgICB9IGVsc2UgaWYgKFggaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBcIm1hdHJpeFwiO1xuICAgICAgICAgICAgdGhpcy5YID0gWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbGlkIHR5cGUgZm9yIFghXCIpO1xuICAgICAgICB9XG4gICAgICAgIFt0aGlzLl9OLCB0aGlzLl9EXSA9IHRoaXMuWC5zaGFwZTtcbiAgICAgICAgdGhpcy5fcmFuZG9taXplciA9IG5ldyBSYW5kb21pemVyKHRoaXMuX3BhcmFtZXRlcnMuc2VlZCk7XG4gICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhbmQgZ2V0IHBhcmFtZXRlcnNcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHthbnl9IFt2YWx1ZSA9IG51bGxdIC0gdmFsdWUgb2YgdGhlIHBhcmFtZXRlciB0byBzZXQuXG4gICAgICogQHJldHVybnMge0RSfGFueX0gLSBPbiBzZXR0aW5nIGEgcGFyYW1ldGVyLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIERSIG9iamVjdC4gSWYgPGNvZGU+dmFsdWUgPT0gbnVsbDwvY29kZT4gdGhlbiByZXR1cm4gYWN0dWFsIHBhcmFtZXRlciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IERSID0gbmV3IGRydWlkLlRTTkUoWCwge2Q6IDN9KTsgLy8gY3JlYXRlcyBhIG5ldyBEUiBvYmplY3QsIHdpdGggcGFyYW1ldGVyIGZvciA8Y29kZT5kPC9jb2RlPiA9IDMuXG4gICAgICogRFIucGFyYW1ldGVyKFwiZFwiKTsgLy8gcmV0dXJucyAzLFxuICAgICAqIERSLnBhcmFtZXRlcihcImRcIiwgMik7IC8vIHNldHMgcGFyYW1ldGVyIDxjb2RlPmQ8L2NvZGU+IHRvIDIgYW5kIHJldHVybnMgPGNvZGU+RFI8L2NvZGU+LlxuICAgICAqL1xuICAgIHBhcmFtZXRlcihuYW1lLCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gaXMgbm90IGEgdmFsaWQgcGFyYW1ldGVyIWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5faXNfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlcnNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJhKG5hbWUsIHZhbHVlID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXIobmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHAobmFtZSwgdmFsdWUgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHJldHVybnMge01hdHJpeH0gLSBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHJldHVybnMge0dlbmVyYXRvcn0gLSBBIGdlbmVyYXRvciB5aWVsZGluZyB0aGUgaW50ZXJtZWRpYXRlIHN0ZXBzIG9mIHRoZSBkaW1lbnNpb25hbGl0eSByZWR1Y3Rpb24gbWV0aG9kLlxuICAgICAqL1xuICAgICpnZW5lcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSByZXNwZWN0aXZlIERSIG1ldGhvZCBoYXMgYW4gPGNvZGU+aW5pdDwvY29kZT4gZnVuY3Rpb24sIGNhbGwgaXQgYmVmb3JlIDxjb2RlPnRyYW5zZm9ybTwvY29kZT4uXG4gICAgICogQHJldHVybnMge0RSfVxuICAgICAqL1xuICAgIGNoZWNrX2luaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNfaW5pdGlhbGl6ZWQgJiYgdHlwZW9mIHRoaXMuaW5pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fE51bWJlcltdW119IFJldHVybnMgdGhlIHByb2plY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHByb2plY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KFwiWVwiKSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZSA9PT0gXCJtYXRyaXhcIiA/IHRoaXMuWSA6IHRoaXMuWS50bzJkQXJyYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YXNldCBpcyBub3QgdHJhbnNmb3JtZWQgeWV0IVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBbYXJnc10gLSBBcmd1bWVudHMgdGhlIHRyYW5zZm9ybSBtZXRob2Qgb2YgdGhlIHJlc3BlY3RpdmUgRFIgbWV0aG9kIHRha2VzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB5aWVsZGluZyB0aGUgZGltZW5zaW9uYWxpdHkgcmVkdWNlZCBkYXRhc2V0LlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybV9hc3luYyguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSguLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBbYXJnc10gLSBUYWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgb2YgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSByZXNwZWN0aXZlIERSIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fEFycmF5fSAtIFRoZSBkaW1lbnNpb25hbGl0eSByZWR1Y2VkIGRhdGFzZXQuXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zZm9ybSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBkciA9IG5ldyB0aGlzKC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gZHIudHJhbnNmb3JtKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSAgey4uLmFueX0gW2FyZ3NdIC0gVGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIG9mIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcmVzcGVjdGl2ZSBEUiBtZXRob2QuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IC0gQSBwcm9taXNlIHlpZWxkaW5nIHRoZSBkaW1lbnNpb25hbGl0eSByZWR1Y2VkIGRhdGFzZXQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHRyYW5zZm9ybV9hc3luYyguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSguLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBbYXJnc10gLSBUYWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgb2YgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSByZXNwZWN0aXZlIERSIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7R2VuZXJhdG9yfSAtIEEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSBpbnRlcm1lZGlhdGUgc3RlcHMgb2YgdGhlIGRpbWVuc2lvbmFsaXR5IHJlZHVjdGlvbiBtZXRob2QuXG4gICAgICovXG4gICAgc3RhdGljICpnZW5lcmF0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBkciA9IG5ldyB0aGlzKC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBkci5nZW5lcmF0b3IoKTtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICB5aWVsZCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBQQ0FcbiAqIEBhdWdtZW50cyBEUlxuICovXG5leHBvcnQgY2xhc3MgUENBIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZHJ1aWQvZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIFBDQVxuICAgICAqIEBwYXJhbSB7TWF0cml4fE51bWJlcltdW119IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5kID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmVpZ19hcmdzXSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBlaWdlbmRlY29tcG9zaXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEByZXR1cm5zIHtQQ0F9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IGQ6IDIsIHNlZWQ6IDEyMTIsIGVpZ19hcmdzOiB7fSB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLmhhc093blByb3BlcnR5KFwic2VlZFwiKSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVycy5laWdfYXJncy5zZWVkID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuc2lvbmFsaXR5IHtAbGluayBkfS4gSWYgcGFyYW1ldGVyIHtAbGluayBBfSBpcyBnaXZlbiwgdGhlbiBwcm9qZWN0IHtAbGluayBBfSB3aXRoIHRoZSBwcmluY2lwYWwgY29tcG9uZW50cyBvZiB7QGxpbmsgWH0uXG4gICAgICogQHBhcmFtIHtudWxsfE1hdHJpeHxBcnJheX0gW0EgPSBudWxsXSAtIElmIGdpdmVuLCB0aGUgZGF0YSB0byBwcm9qZWN0LlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh8QXJyYXl9IC0gVGhlIHByb2plY3RlZCBkYXRhLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybShBID0gbnVsbCkge1xuICAgICAgICBjb25zdCBWID0gdGhpcy5wcmluY2lwYWxfY29tcG9uZW50cygpO1xuICAgICAgICBpZiAoQSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICAgICAgdGhpcy5ZID0gWC5kb3QoVik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoQSkpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRyaXguZnJvbShBKS5kb3QoVikuYXNBcnJheTtcbiAgICAgICAgfSBlbHNlIGlmIChBIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICByZXR1cm4gQS5kb3QoVik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCB0eXBlIGZvciBBIVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSB7QGxpbmsgZH0gcHJpbmNpcGFsIGNvbXBvbmVudHMgb2YgTWF0cml4IHtAbGluayBYfS5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHByaW5jaXBhbF9jb21wb25lbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5WKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5WO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZCwgZWlnX2FyZ3MgfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IG1lYW5zID0gTWF0cml4LmZyb20oWC5tZWFuQ29scyk7XG4gICAgICAgIGNvbnN0IFhfY2VudCA9IFguc3ViKG1lYW5zKTtcbiAgICAgICAgY29uc3QgQyA9IFhfY2VudC50cmFuc3Bvc2UoKS5kb3QoWF9jZW50KTtcbiAgICAgICAgY29uc3QgeyBlaWdlbnZlY3RvcnM6IFYgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihDLCBkLCBlaWdfYXJncyk7XG4gICAgICAgIHRoaXMuViA9IE1hdHJpeC5mcm9tKFYpLnRyYW5zcG9zZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5WO1xuICAgIH1cblxuICAgIHN0YXRpYyBwcmluY2lwYWxfY29tcG9uZW50cyhYLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IGRyID0gbmV3IHRoaXMoWCwgcGFyYW1ldGVycyk7XG4gICAgICAgIHJldHVybiBkci5wcmluY2lwYWxfY29tcG9uZW50cygpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbiB9IGZyb20gXCIuLi9saW5lYXJfYWxnZWJyYS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGlzdGFuY2VfbWF0cml4LCBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIE1EUyBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKiBDbGFzc2ljYWwgTURTLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBuYW1lIGRydWlkLk1EU1xuICAgICAqIEBhbGlhcyBNRFNcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOkBkcnVpZC9kaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcml6YXRpb24gb2YgdGhlIERSIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbcGFyYW1ldGVycy5tZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzLmVpZ19hcmdzXSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBlaWdlbmRlY29tcG9zaXRpb24gYWxnb3JpdGhtLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiwgZWlnX2FyZ3M6IHt9IH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3BhcmFtZXRlcnMuZWlnX2FyZ3MuaGFzT3duUHJvcGVydHkoXCJzZWVkXCIpKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLnNlZWQgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0ZGF0YSB7QGxpbmsgWH0gdG8gZGltZW5zaW9uYWxpdHkge0BsaW5rIGR9LlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh8QXJyYXl9XG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCByb3dzID0gWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgeyBkLCBtZXRyaWMsIGVpZ19hcmdzIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBBID0gbWV0cmljID09PSBcInByZWNvbXB1dGVkXCIgPyBYIDogZGlzdGFuY2VfbWF0cml4KFgsIG1ldHJpYyk7XG4gICAgICAgIGNvbnN0IGFpXyA9IEEubWVhbkNvbHM7XG4gICAgICAgIGNvbnN0IGFfaiA9IEEubWVhblJvd3M7XG4gICAgICAgIGNvbnN0IGFfXyA9IEEubWVhbjtcblxuICAgICAgICB0aGlzLl9kX1ggPSBBO1xuICAgICAgICBjb25zdCBCID0gbmV3IE1hdHJpeChyb3dzLCByb3dzLCAoaSwgaikgPT4gQS5lbnRyeShpLCBqKSAtIGFpX1tpXSAtIGFfaltqXSArIGFfXyk7XG5cbiAgICAgICAgY29uc3QgeyBlaWdlbnZlY3RvcnM6IFYgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihCLCBkLCBlaWdfYXJncyk7XG4gICAgICAgIHRoaXMuWSA9IE1hdHJpeC5mcm9tKFYpLnRyYW5zcG9zZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge051bWJlcn0gLSB0aGUgc3RyZXNzIG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgIHN0cmVzcygpIHtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgWSA9IHRoaXMuWTtcbiAgICAgICAgY29uc3QgZF9YID0gdGhpcy5fZF9YO1xuICAgICAgICBjb25zdCBkX1kgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIGRfWS5zaGFwZSA9IFtcbiAgICAgICAgICAgIE4sXG4gICAgICAgICAgICBOLFxuICAgICAgICAgICAgKGksIGopID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IGogPyBldWNsaWRlYW4oWS5yb3coaSksIFkucm93KGopKSA6IGRfWS5lbnRyeShqLCBpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIGxldCB0b3Bfc3VtID0gMDtcbiAgICAgICAgbGV0IGJvdHRvbV9zdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgdG9wX3N1bSArPSBNYXRoLnBvdyhkX1guZW50cnkoaSwgaikgLSBkX1kuZW50cnkoaSwgaiksIDIpO1xuICAgICAgICAgICAgICAgIGJvdHRvbV9zdW0gKz0gTWF0aC5wb3coZF9YLmVudHJ5KGksIGopLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRvcF9zdW0gLyBib3R0b21fc3VtKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IEhlYXAgfSBmcm9tIFwiLi4vZGF0YXN0cnVjdHVyZS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuaW1wb3J0IGV1Y2xpZGVhbiBmcm9tIFwiLi4vbWV0cmljcy9ldWNsaWRlYW4uanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJU09NQVBcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBJU09NQVAgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogSXNvbWV0cmljIGZlYXR1cmUgbWFwcGluZyAoSVNPTUFQKS5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRydWlkL2RpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBJU09NQVBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtZXRlcnMubmVpZ2hib3JzIC0gdGhlIG51bWJlciBvZiBuZWlnaGJvcnMge0BsaW5rIElTT01BUH0gc2hvdWxkIHVzZSB0byBwcm9qZWN0IHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5kID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtZXRlcnMubWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5laWdfYXJnc10gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZWlnZW5kZWNvbXBvc2l0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvaS5vcmcvMTAuMTEyNi9zY2llbmNlLjI5MC41NTAwLjIzMTl9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IG5laWdoYm9yczogdW5kZWZpbmVkLCBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiwgZWlnX2FyZ3M6IHt9IH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcIm5laWdoYm9yc1wiLCBNYXRoLm1pbih0aGlzLl9wYXJhbWV0ZXJzLm5laWdoYm9ycyA/PyBNYXRoLm1heChNYXRoLmZsb29yKHRoaXMuWC5zaGFwZVswXSAvIDEwKSwgMiksIHRoaXMuX04gLSAxKSk7XG4gICAgICAgIGlmICghdGhpcy5fcGFyYW1ldGVycy5laWdfYXJncy5oYXNPd25Qcm9wZXJ0eShcInNlZWRcIikpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtZXRlcnMuZWlnX2FyZ3Muc2VlZCA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHJldHVybnMge01hdHJpeH0gUmV0dXJucyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgeyBkLCBtZXRyaWMsIGVpZ19hcmdzLCBuZWlnaGJvcnMgfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIC8vIFRPRE86IG1ha2Uga25uIGV4dGVybiBhbmQgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RvciBvciB0cmFuc2Zvcm0/XG4gICAgICAgIGNvbnN0IEQgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIEQuc2hhcGUgPSBbcm93cywgcm93cywgKGksIGopID0+IChpIDw9IGogPyBtZXRyaWMoWC5yb3coaSksIFgucm93KGopKSA6IEQuZW50cnkoaiwgaSkpXTtcbiAgICAgICAgY29uc3Qga05lYXJlc3ROZWlnaGJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dzOyArK2opIHtcbiAgICAgICAgICAgICAgICByb3cucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBqLFxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogRC5lbnRyeShpLCBqKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IEggPSBuZXcgSGVhcChyb3csIChkKSA9PiBkLmRpc3RhbmNlLCBcIm1pblwiKTtcbiAgICAgICAgICAgIGtOZWFyZXN0TmVpZ2hib3JzLnB1c2goSC50b0FycmF5KCkuc2xpY2UoMSwgbmVpZ2hib3JzICsgMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLypEID0gZGlqa3N0cmEoa05lYXJlc3ROZWlnaGJvcnMpOyovXG4gICAgICAgIC8vIGNvbXB1dGUgc2hvcnRlc3QgcGF0aHNcbiAgICAgICAgLy8gVE9ETzogbWFrZSBleHRlcm5cbiAgICAgICAgLyoqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zsb3lkJUUyJTgwJTkzV2Fyc2hhbGxfYWxnb3JpdGhtfSAqL1xuICAgICAgICBjb25zdCBHID0gbmV3IE1hdHJpeChyb3dzLCByb3dzLCAoaSwgaikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBrTmVhcmVzdE5laWdoYm9yc1tpXS5maW5kKChuKSA9PiBuLmluZGV4ID09PSBqKTtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA/IG90aGVyLmRpc3RhbmNlIDogSW5maW5pdHk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd3M7ICsraikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcm93czsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIEcuc2V0X2VudHJ5KGksIGosIE1hdGgubWluKEcuZW50cnkoaSwgaiksIEcuZW50cnkoaSwgaykgKyBHLmVudHJ5KGssIGopKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFpXyA9IG5ldyBGbG9hdDY0QXJyYXkocm93cyk7XG4gICAgICAgIGxldCBhX2ogPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MpO1xuICAgICAgICBsZXQgYV9fID0gMDtcbiAgICAgICAgY29uc3QgQSA9IG5ldyBNYXRyaXgocm93cywgcm93cywgKGksIGopID0+IHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBHLmVudHJ5KGksIGopO1xuICAgICAgICAgICAgdmFsID0gdmFsID09PSBJbmZpbml0eSA/IDAgOiB2YWw7XG4gICAgICAgICAgICBhaV9baV0gKz0gdmFsO1xuICAgICAgICAgICAgYV9qW2pdICs9IHZhbDtcbiAgICAgICAgICAgIGFfXyArPSB2YWw7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcblxuICAgICAgICBhaV8gPSBhaV8ubWFwKCh2KSA9PiB2IC8gcm93cyk7XG4gICAgICAgIGFfaiA9IGFfai5tYXAoKHYpID0+IHYgLyByb3dzKTtcbiAgICAgICAgYV9fIC89IHJvd3MgKiogMjtcbiAgICAgICAgY29uc3QgQiA9IG5ldyBNYXRyaXgocm93cywgcm93cywgKGksIGopID0+IEEuZW50cnkoaSwgaikgLSBhaV9baV0gLSBhX2pbal0gKyBhX18pO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgZCBlaWdlbnZlY3RvcnNcbiAgICAgICAgY29uc3QgeyBlaWdlbnZlY3RvcnM6IFYgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihCLCBkLCBlaWdfYXJncyk7XG4gICAgICAgIHRoaXMuWSA9IE1hdHJpeC5mcm9tKFYpLnRyYW5zcG9zZSgpO1xuICAgICAgICAvLyByZXR1cm4gZW1iZWRkaW5nXG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuZXhwb3J0IGNsYXNzIEZBU1RNQVAgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogRmFzdE1hcDogYSBmYXN0IGFsZ29yaXRobSBmb3IgaW5kZXhpbmcsIGRhdGEtbWluaW5nIGFuZCB2aXN1YWxpemF0aW9uIG9mIHRyYWRpdGlvbmFsIGFuZCBtdWx0aW1lZGlhIGRhdGFzZXRzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIGRydWlkL0ZBU1RNQVBcbiAgICAgKiBAYWxpYXMgRkFTVE1BUFxuICAgICAqIEB0eXBpY2FsbmFtZSBkcnVpZC5GQVNUTUFQXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVyc10gLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmQgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1ldGVycy5tZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RkFTVE1BUH1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvaS5vcmcvMTAuMTE0NS8yMjM3ODQuMjIzODEyfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hvb3NlcyB0d28gcG9pbnRzIHdoaWNoIGFyZSB0aGUgbW9zdCBkaXN0YW50IGluIHRoZSBhY3R1YWwgcHJvamVjdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgZmlyc3QgaW5kZXgsIHNlY29uZCBpbmRleCwgYW5kIGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXG4gICAgICovXG4gICAgX2Nob29zZV9kaXN0YW50X29iamVjdHMoZGlzdCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgbGV0IGFfaW5kZXggPSAodGhpcy5fcmFuZG9taXplci5yYW5kb21faW50ICUgTikgLSAxO1xuICAgICAgICBsZXQgYl9pbmRleCA9IG51bGw7XG4gICAgICAgIGxldCBtYXhfZGlzdCA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGRfYWkgPSBkaXN0KGFfaW5kZXgsIGkpO1xuICAgICAgICAgICAgaWYgKGRfYWkgPiBtYXhfZGlzdCkge1xuICAgICAgICAgICAgICAgIG1heF9kaXN0ID0gZF9haTtcbiAgICAgICAgICAgICAgICBiX2luZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXhfZGlzdCA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGRfYmkgPSBkaXN0KGJfaW5kZXgsIGkpO1xuICAgICAgICAgICAgaWYgKGRfYmkgPiBtYXhfZGlzdCkge1xuICAgICAgICAgICAgICAgIG1heF9kaXN0ID0gZF9iaTtcbiAgICAgICAgICAgICAgICBhX2luZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FfaW5kZXgsIGJfaW5kZXgsIG1heF9kaXN0XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSBUaGUgKipkKiotZGltZW5zaW9uYWwgcHJvamVjdGlvbiBvZiB0aGUgZGF0YSBtYXRyaXggPGNvZGU+WDwvY29kZT4uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgeyBkLCBtZXRyaWMgfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IFkgPSBuZXcgTWF0cml4KE4sIGQsIDApO1xuICAgICAgICBsZXQgZGlzdCA9IChhLCBiKSA9PiBtZXRyaWMoWC5yb3coYSksIFgucm93KGIpKTtcblxuICAgICAgICBmb3IgKGxldCBfY29sID0gMDsgX2NvbCA8IGQ7ICsrX2NvbCkge1xuICAgICAgICAgICAgbGV0IG9sZF9kaXN0ID0gZGlzdDtcbiAgICAgICAgICAgIC8vIGNob29zZSBwaXZvdCBvYmplY3RzXG4gICAgICAgICAgICBjb25zdCBbYV9pbmRleCwgYl9pbmRleCwgZF9hYl0gPSB0aGlzLl9jaG9vc2VfZGlzdGFudF9vYmplY3RzKGRpc3QpO1xuICAgICAgICAgICAgaWYgKGRfYWIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9qZWN0IHRoZSBvYmplY3RzIG9uIHRoZSBsaW5lIChPX2EsIE9fYilcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkX2FpID0gZGlzdChhX2luZGV4LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZF9iaSA9IGRpc3QoYl9pbmRleCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHlfaSA9IChkX2FpICoqIDIgKyBkX2FiICoqIDIgLSBkX2JpICoqIDIpIC8gKDIgKiBkX2FiKTtcbiAgICAgICAgICAgICAgICAgICAgWS5zZXRfZW50cnkoaSwgX2NvbCwgeV9pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY29uc2lkZXIgdGhlIHByb2plY3Rpb25zIG9mIHRoZSBvYmplY3RzIG9uIGFcbiAgICAgICAgICAgICAgICAvLyBoeXBlcnBsYW5lIHBlcnBlbmRpY2x1YXIgdG8gdGhlIGxpbmUgKGEsIGIpO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBkaXN0YW5jZSBmdW5jdGlvbiBEJygpIGJldHdlZW4gdHdvXG4gICAgICAgICAgICAgICAgLy8gcHJvamVjdGlvbnMgaXMgZ2l2ZW4gYnkgRXEuNFxuICAgICAgICAgICAgICAgIGRpc3QgPSAoYSwgYikgPT4gTWF0aC5zcXJ0KG9sZF9kaXN0KGEsIGIpICoqIDIgLSAoWS5lbnRyeShhLCBfY29sKSAtIFkuZW50cnkoYiwgX2NvbCkpICoqIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiBlbWJlZGRpbmcuXG4gICAgICAgIHRoaXMuWSA9IFk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uIH0gZnJvbSBcIi4uL2xpbmVhcl9hbGdlYnJhL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgTERBXG4gKiBAZXh0ZW5kcyBEUlxuICovXG5leHBvcnQgY2xhc3MgTERBIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIExpbmVhciBEaXNjcmltaW5hbnQgQW5hbHlzaXMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkcnVpZC9kaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgTERBXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSBUaGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtZXRlcnMubGFiZWxzIC0gVGhlIGxhYmVscyAvIGNsYXNzZXMgZm9yIGVhY2ggZGF0YSBwb2ludC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gVGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5laWdfYXJnc10gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZWlnZW5kZWNvbXBvc2l0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL29ubGluZWxpYnJhcnkud2lsZXkuY29tL2RvaS8xMC4xMTExL2ouMTQ2OS0xODA5LjE5MzYudGIwMjEzNy54fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBsYWJlbHM6IG51bGwsIGQ6IDIsIHNlZWQ6IDEyMTIsIGVpZ19hcmdzOiB7fSB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLmhhc093blByb3BlcnR5KFwic2VlZFwiKSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVycy5laWdfYXJncy5zZWVkID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuaW9uYWxpdHkge0BsaW5rIGR9LlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgW3Jvd3MsIGNvbHNdID0gWC5zaGFwZTtcbiAgICAgICAgY29uc3QgeyBkLCBsYWJlbHMsIGVpZ19hcmdzIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBpZiAobGFiZWxzID09PSBudWxsIHx8IGxhYmVscy5sZW5ndGggIT0gcm93cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTERBIG5lZWRzIHBhcmFtZXRlciBsYWJlbCB0byBldmVyeSBkYXRhcG9pbnQgdG8gd29yayFcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5pcXVlX2xhYmVscyA9IHt9O1xuICAgICAgICBsZXQgbGFiZWxfaWQgPSAwO1xuICAgICAgICBsYWJlbHMuZm9yRWFjaCgobCwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGwgaW4gdW5pcXVlX2xhYmVscykge1xuICAgICAgICAgICAgICAgIHVuaXF1ZV9sYWJlbHNbbF0uY291bnQrKztcbiAgICAgICAgICAgICAgICB1bmlxdWVfbGFiZWxzW2xdLnJvd3MucHVzaChYLnJvdyhpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuaXF1ZV9sYWJlbHNbbF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBsYWJlbF9pZCsrLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogMSxcbiAgICAgICAgICAgICAgICAgICAgcm93czogW1gucm93KGkpXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgWF9tZWFuIGFuZCB2ZWN0b3IgbWVhbnM7XG4gICAgICAgIGNvbnN0IFhfbWVhbiA9IFgubWVhbjtcbiAgICAgICAgY29uc3QgVl9tZWFuID0gbmV3IE1hdHJpeChsYWJlbF9pZCwgY29scyk7XG4gICAgICAgIGZvciAoY29uc3QgbGFiZWwgaW4gdW5pcXVlX2xhYmVscykge1xuICAgICAgICAgICAgY29uc3QgViA9IE1hdHJpeC5mcm9tKHVuaXF1ZV9sYWJlbHNbbGFiZWxdLnJvd3MpO1xuICAgICAgICAgICAgY29uc3Qgdl9tZWFuID0gVi5tZWFuQ29scztcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgKytqKSB7XG4gICAgICAgICAgICAgICAgVl9tZWFuLnNldF9lbnRyeSh1bmlxdWVfbGFiZWxzW2xhYmVsXS5pZCwgaiwgdl9tZWFuW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzY2F0dGVyX2JldHdlZW5cbiAgICAgICAgbGV0IFNfYiA9IG5ldyBNYXRyaXgoY29scywgY29scyk7XG4gICAgICAgIGZvciAoY29uc3QgbGFiZWwgaW4gdW5pcXVlX2xhYmVscykge1xuICAgICAgICAgICAgY29uc3QgdiA9IFZfbWVhbi5yb3codW5pcXVlX2xhYmVsc1tsYWJlbF0uaWQpO1xuICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXgoY29scywgMSwgKGopID0+IHZbal0gLSBYX21lYW4pO1xuICAgICAgICAgICAgY29uc3QgTiA9IHVuaXF1ZV9sYWJlbHNbbGFiZWxdLmNvdW50O1xuICAgICAgICAgICAgU19iID0gU19iLmFkZChtLmRvdChtLnRyYW5zcG9zZSgpKS5tdWx0KE4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjYXR0ZXJfd2l0aGluXG4gICAgICAgIGxldCBTX3cgPSBuZXcgTWF0cml4KGNvbHMsIGNvbHMpO1xuICAgICAgICBmb3IgKGNvbnN0IGxhYmVsIGluIHVuaXF1ZV9sYWJlbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBWX21lYW4ucm93KHVuaXF1ZV9sYWJlbHNbbGFiZWxdLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWF0cml4KGNvbHMsIDEsIChqKSA9PiB2W2pdKTtcbiAgICAgICAgICAgIGNvbnN0IFIgPSB1bmlxdWVfbGFiZWxzW2xhYmVsXS5yb3dzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB1bmlxdWVfbGFiZWxzW2xhYmVsXS5jb3VudDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd192ID0gbmV3IE1hdHJpeChjb2xzLCAxLCAoaiwgXykgPT4gUltpXVtqXSAtIG0uZW50cnkoaiwgMCkpO1xuICAgICAgICAgICAgICAgIFNfdyA9IFNfdy5hZGQocm93X3YuZG90KHJvd192LnRyYW5zcG9zZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeyBlaWdlbnZlY3RvcnM6IFYgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihTX3cuaW52ZXJzZSgpLmRvdChTX2IpLCBkLCBlaWdfYXJncyk7XG4gICAgICAgIFYgPSBNYXRyaXguZnJvbShWKS50cmFuc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5ZID0gWC5kb3QoVik7XG5cbiAgICAgICAgLy8gcmV0dXJuIGVtYmVkZGluZ1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24gfSBmcm9tIFwiLi4vbGluZWFyX2FsZ2VicmEvaW5kZXguanNcIjtcbmltcG9ydCB7IGtfbmVhcmVzdF9uZWlnaGJvcnMgfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBuZXVtYWlyX3N1bSB9IGZyb20gXCIuLi9udW1lcmljYWwvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBMTEVcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBMTEUgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogTG9jYWxseSBMaW5lYXIgRW1iZWRkaW5nLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZHJ1aWQvZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIExMRVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcml6YXRpb24gb2YgdGhlIERSIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbmVpZ2hib3JzIC0gdGhlIGxhYmVsIC8gY2xhc3Mgb2YgZWFjaCBkYXRhIHBvaW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWVkID0gMTIxMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmVpZ19hcmdzXSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBlaWdlbmRlY29tcG9zaXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9pLm9yZy8xMC4xMTI2L3NjaWVuY2UuMjkwLjU1MDAuMjMyM31cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKFgsIHsgbmVpZ2hib3JzOiB1bmRlZmluZWQsIGQ6IDIsIG1ldHJpYzogZXVjbGlkZWFuLCBzZWVkOiAxMjEyLCBlaWdfYXJnczoge30gfSwgcGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyKFwibmVpZ2hib3JzXCIsIE1hdGgubWluKHBhcmFtZXRlcnMubmVpZ2hib3JzID8/IE1hdGgubWF4KE1hdGguZmxvb3IodGhpcy5fTiAvIDEwKSwgMiksIHRoaXMuX04gLSAxKSk7XG4gICAgICAgIGlmICghdGhpcy5fcGFyYW1ldGVycy5laWdfYXJncy5oYXNPd25Qcm9wZXJ0eShcInNlZWRcIikpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtZXRlcnMuZWlnX2FyZ3Muc2VlZCA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXRkYXRhIHtAbGluayBYfSB0byBkaW1lbmlvbmFsaXR5IHtAbGluayBkfS5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5fRDtcbiAgICAgICAgY29uc3QgeyBuZWlnaGJvcnMsIGQsIGVpZ19hcmdzLCBtZXRyaWMgfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG5OID0ga19uZWFyZXN0X25laWdoYm9ycyhYLCBuZWlnaGJvcnMsIG1ldHJpYyk7XG4gICAgICAgIGNvbnN0IE8gPSBuZXcgTWF0cml4KG5laWdoYm9ycywgMSwgMSk7XG4gICAgICAgIGNvbnN0IFcgPSBuZXcgTWF0cml4KHJvd3MsIHJvd3MpO1xuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICBjb25zdCBuTl9yb3cgPSBuTltyb3ddO1xuICAgICAgICAgICAgY29uc3QgWiA9IG5ldyBNYXRyaXgobmVpZ2hib3JzLCBjb2xzLCAoaSwgaikgPT4gWC5lbnRyeShuTl9yb3dbaV0uaiwgaikgLSBYLmVudHJ5KHJvdywgaikpO1xuICAgICAgICAgICAgY29uc3QgQyA9IFouZG90KFouVCk7XG4gICAgICAgICAgICBpZiAobmVpZ2hib3JzID4gY29scykge1xuICAgICAgICAgICAgICAgIGNvbnN0IENfdHJhY2UgPSBuZXVtYWlyX3N1bShDLmRpYWcpIC8gMTAwMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5laWdoYm9yczsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIEMuc2V0X2VudHJ5KGosIGosIEMuZW50cnkoaiwgaikgKyBDX3RyYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWNvbnN0cnVjdDtcbiAgICAgICAgICAgIGxldCB3ID0gTWF0cml4LnNvbHZlX0NHKEMsIE8sIHRoaXMuX3JhbmRvbWl6ZXIpO1xuICAgICAgICAgICAgdyA9IHcuZGl2aWRlKHcuc3VtKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmVpZ2hib3JzOyArK2opIHtcbiAgICAgICAgICAgICAgICBXLnNldF9lbnRyeShyb3csIG5OX3Jvd1tqXS5qLCB3LmVudHJ5KGosIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wIGVtYmVkZGluZ1xuICAgICAgICBjb25zdCBJID0gbmV3IE1hdHJpeChyb3dzLCByb3dzLCBcImlkZW50aXR5XCIpO1xuICAgICAgICBjb25zdCBJVyA9IEkuc3ViKFcpO1xuICAgICAgICBjb25zdCBNID0gSVcuVC5kb3QoSVcpO1xuICAgICAgICBjb25zdCB7IGVpZ2VudmVjdG9yczogViB9ID0gc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uKE0uVC5pbnZlcnNlKCksIGQgKyAxLCBlaWdfYXJncyk7XG4gICAgICAgIHRoaXMuWSA9IE1hdHJpeC5mcm9tKFYuc2xpY2UoMSwgMSArIGQpKS5UO1xuXG4gICAgICAgIC8vIHJldHVybiBlbWJlZGRpbmdcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBNYXRyaXgsIGtfbmVhcmVzdF9uZWlnaGJvcnMgfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uIH0gZnJvbSBcIi4uL2xpbmVhcl9hbGdlYnJhL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBEUiB9IGZyb20gXCIuL0RSLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgTFRTQVxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIExUU0EgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogTG9jYWwgVGFuZ2VudCBTcGFjZSBBbGlnbm1lbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRydWlkL2RpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBMVFNBXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbWV0ZXJzLm5laWdoYm9ycyAtIHRoZSBudW1iZXIgb2YgbmVpZ2hib3JzIHtAbGluayBMVFNBfSBzaG91bGQgdXNlIHRvIHByb2plY3QgdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmQgPSAyXSAtIHRoZSBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1ldGVycy5tZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmVpZ19hcmdzXSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBlaWdlbmRlY29tcG9zaXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZXB1YnMuc2lhbS5vcmcvZG9pL2Ficy8xMC4xMTM3L1MxMDY0ODI3NTAyNDE5MTU0fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBuZWlnaGJvcnM6IHVuZGVmaW5lZCwgZDogMiwgbWV0cmljOiBldWNsaWRlYW4sIHNlZWQ6IDEyMTIsIGVpZ19hcmdzOiB7fSB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJuZWlnaGJvcnNcIiwgTWF0aC5taW4ocGFyYW1ldGVycy5uZWlnaGJvcnMgPz8gTWF0aC5tYXgoTWF0aC5mbG9vcih0aGlzLl9OIC8gMTApLCAyKSwgdGhpcy5fTiAtIDEpKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJhbWV0ZXJzLmVpZ19hcmdzLmhhc093blByb3BlcnR5KFwic2VlZFwiKSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVycy5laWdfYXJncy5zZWVkID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fRCA8PSB0aGlzLnBhcmFtZXRlcihcImRcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGltZW5zaW9uYWxpdHkgb2YgWCAoRCA9ICR7dGhpcy5fRH0pIG11c3QgYmUgZ3JlYXRlciB0aGFuIHRoZSByZXF1aXJlZCBkaW1lbnNpb25hbGl0eSBvZiB0aGUgcmVzdWx0IChkID0gJHt0aGlzLnBhcmFtZXRlcihcImRcIil9KSFgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuaW9uYWxpdHkge0BsaW5rIGR9LlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgW3Jvd3MsIERdID0gWC5zaGFwZTtcbiAgICAgICAgY29uc3QgeyBkLCBuZWlnaGJvcnMsIG1ldHJpYywgZWlnX2FyZ3MgfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIC8vIDEuMSBkZXRlcm1pbmUgayBuZWFyZXN0IG5laWdoYm9yc1xuICAgICAgICBjb25zdCBuTiA9IGtfbmVhcmVzdF9uZWlnaGJvcnMoWCwgbmVpZ2hib3JzLCBtZXRyaWMpO1xuICAgICAgICAvLyBjZW50ZXIgbWF0cml4XG4gICAgICAgIGNvbnN0IE8gPSBuZXcgTWF0cml4KEQsIEQsIFwiY2VudGVyXCIpO1xuICAgICAgICBjb25zdCBCID0gbmV3IE1hdHJpeChyb3dzLCByb3dzLCAwKTtcblxuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgLy8gMS4yIGNvbXB1dGUgdGhlIGQgbGFyZ2VzdCBlaWdlbnZlY3RvcnMgb2YgdGhlIGNvcnJlbGF0aW9uIG1hdHJpeFxuICAgICAgICAgICAgY29uc3QgSV9pID0gW3JvdywgLi4ubk5bcm93XS5tYXAoKG4pID0+IG4uaildO1xuICAgICAgICAgICAgbGV0IFhfaSA9IE1hdHJpeC5mcm9tKElfaS5tYXAoKG4pID0+IFgucm93KG4pKSk7XG4gICAgICAgICAgICAvLyBjZW50ZXIgWF9pXG4gICAgICAgICAgICBYX2kgPSBYX2kuZG90KE8pO1xuICAgICAgICAgICAgLy8gY29ycmVsYXRpb24gbWF0cml4XG4gICAgICAgICAgICBjb25zdCBDID0gWF9pLmRvdChYX2kudHJhbnNwb3NlKCkpO1xuICAgICAgICAgICAgY29uc3QgeyBlaWdlbnZlY3RvcnM6IGcgfSA9IHNpbXVsdGFuZW91c19wb3dlcml0ZXJhdGlvbihDLCBkLCBlaWdfYXJncyk7XG4gICAgICAgICAgICAvL2cucHVzaChsaW5zcGFjZSgwLCBrKS5tYXAoXyA9PiAxIC8gTWF0aC5zcXJ0KGsgKyAxKSkpO1xuICAgICAgICAgICAgY29uc3QgR19pX3QgPSBNYXRyaXguZnJvbShnKTtcbiAgICAgICAgICAgIC8vIDIuIENvbnN0cnVjdGluZyBhbGlnbm1lbnQgbWF0cml4XG4gICAgICAgICAgICBjb25zdCBXX2kgPSBHX2lfdC50cmFuc3Bvc2UoKVxuICAgICAgICAgICAgICAgIC5kb3QoR19pX3QpXG4gICAgICAgICAgICAgICAgLmFkZCgxIC8gTWF0aC5zcXJ0KG5laWdoYm9ycyArIDEpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3JzICsgMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuZWlnaGJvcnMgKyAxOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgQi5zZXRfZW50cnkoSV9pW2ldLCBJX2lbal0sIEIuZW50cnkoSV9pW2ldLCBJX2lbal0pIC0gKGkgPT09IGogPyAxIDogMCkgKyBXX2kuZW50cnkoaSwgaikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIEFsaWduaW5nIGdsb2JhbCBjb29yZGluYXRlc1xuICAgICAgICBjb25zdCB7IGVpZ2VudmVjdG9yczogWSB9ID0gc2ltdWx0YW5lb3VzX3Bvd2VyaXRlcmF0aW9uKEIsIGQgKyAxLCBlaWdfYXJncyk7XG4gICAgICAgIHRoaXMuWSA9IE1hdHJpeC5mcm9tKFkuc2xpY2UoMSkpLnRyYW5zcG9zZSgpO1xuXG4gICAgICAgIC8vIHJldHVybiBlbWJlZGRpbmdcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIFRTTkVcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBUU05FIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkcnVpZC9kaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgVFNORVxuICAgICAqIEBwYXJhbSB7TWF0cml4fE51bWJlcltdW119IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5wZXJwbGV4aXR5ID0gNTBdIC0gcGVycGxleGl0eS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZXBzaWxvbiA9IDEwXSAtIGxlYXJuaW5nIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbcGFyYW1ldGVycy5tZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge1RTTkV9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IHBlcnBsZXhpdHk6IDUwLCBlcHNpbG9uOiAxMCwgZDogMiwgbWV0cmljOiBldWNsaWRlYW4sIHNlZWQ6IDEyMTIgfSwgcGFyYW1ldGVycyk7XG4gICAgICAgIFt0aGlzLl9OLCB0aGlzLl9EXSA9IHRoaXMuWC5zaGFwZTtcbiAgICAgICAgdGhpcy5faXRlciA9IDA7XG4gICAgICAgIHRoaXMuWSA9IG5ldyBNYXRyaXgodGhpcy5fTiwgdGhpcy5wYXJhbWV0ZXIoXCJkXCIpLCAoKSA9PiB0aGlzLl9yYW5kb21pemVyLnJhbmRvbSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGRpc3RhbmNlX21hdHJpeCAtIGFjY2VwdHMgYSBwcmVjb21wdXRlZCBkaXN0YW5jZSBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB7VFNORX1cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICAvLyBpbml0XG4gICAgICAgIGNvbnN0IEh0YXJnZXQgPSBNYXRoLmxvZyh0aGlzLnBhcmFtZXRlcihcInBlcnBsZXhpdHlcIikpO1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgRCA9IHRoaXMuX0Q7XG4gICAgICAgIGNvbnN0IHttZXRyaWN9ID0gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgbGV0IERlbHRhO1xuICAgICAgICBpZiAobWV0cmljID09XCJwcmVjb21wdXRlZFwiKSB7XG4gICAgICAgICAgICBEZWx0YSA9IGRydWlkLk1hdHJpeC5mcm9tKFgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRGVsdGEgPSBuZXcgTWF0cml4KE4sIE4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBYX2kgPSBYLnJvdyhpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBtZXRyaWMoWF9pLCBYLnJvdyhqKSk7XG4gICAgICAgICAgICAgICAgICAgIERlbHRhLnNldF9lbnRyeShpLCBqLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIERlbHRhLnNldF9lbnRyeShqLCBpLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgUCA9IG5ldyBNYXRyaXgoTiwgTiwgXCJ6ZXJvc1wiKTtcblxuICAgICAgICB0aGlzLl95c3RlcCA9IG5ldyBNYXRyaXgoTiwgRCwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgdGhpcy5fZ2FpbnMgPSBuZXcgTWF0cml4KE4sIEQsIDEpO1xuXG4gICAgICAgIC8vIHNlYXJjaCBmb3IgZml0dGluZyBzaWdtYVxuICAgICAgICBsZXQgcHJvdyA9IG5ldyBGbG9hdDY0QXJyYXkoTilcbiAgICAgICAgY29uc3QgdG9sID0gMWUtNDtcbiAgICAgICAgY29uc3QgbWF4dHJpZXMgPSA1MDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBiZXRhbWluID0gLUluZmluaXR5O1xuICAgICAgICAgICAgbGV0IGJldGFtYXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBiZXRhID0gMTtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGxldCBudW0gPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaiA9IE1hdGguZXhwKC1EZWx0YS5lbnRyeShpLCBqKSAqIGJldGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaikgcGogPSAwO1xuICAgICAgICAgICAgICAgICAgICBwcm93W2pdID0gcGo7XG4gICAgICAgICAgICAgICAgICAgIHBzdW0gKz0gcGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBIaGVyZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBqID0gcHN1bSA9PT0gMCA/IDAgOiBwcm93W2pdIC8gcHN1bTtcbiAgICAgICAgICAgICAgICAgICAgcHJvd1tqXSA9IHBqO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGogPiAxZS03KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBIaGVyZSAtPSBwaiAqIE1hdGgubG9nKHBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoSGhlcmUgPiBIdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJldGFtaW4gPSBiZXRhO1xuICAgICAgICAgICAgICAgICAgICBiZXRhID0gYmV0YW1heCA9PT0gSW5maW5pdHkgPyBiZXRhICogMiA6IChiZXRhICsgYmV0YW1heCkgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJldGFtYXggPSBiZXRhO1xuICAgICAgICAgICAgICAgICAgICBiZXRhID0gYmV0YW1pbiA9PT0gLUluZmluaXR5ID8gYmV0YSAvIDIgOiAoYmV0YSArIGJldGFtaW4pIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytudW07XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKEhoZXJlIC0gSHRhcmdldCkgPCB0b2wpIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChudW0gPj0gbWF4dHJpZXMpIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIFAuc2V0X2VudHJ5KGksIGosIHByb3dbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9jb21wdXRlIHByb2JhYmlsaXRpZXNcbiAgICAgICAgY29uc3QgUG91dCA9IG5ldyBNYXRyaXgoTiwgTiwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgY29uc3QgTjIgPSBOICogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IE1hdGgubWF4KChQLmVudHJ5KGksIGopICsgUC5lbnRyeShqLCBpKSkgLyBOMiwgMWUtMTAwKTtcbiAgICAgICAgICAgICAgICBQb3V0LnNldF9lbnRyeShpLCBqLCBwKTtcbiAgICAgICAgICAgICAgICBQb3V0LnNldF9lbnRyeShqLCBpLCBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9QID0gUG91dDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2l0ZXJhdGlvbnM9NTAwXSAtIG51bWJlciBvZiBpdGVyYXRpb25zLlxuICAgICAqIEB5aWVsZHMge01hdHJpeHxBcnJheTxBcnJheT59IC0gdGhlIHByb2plY3Rpb24uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKGl0ZXJhdGlvbnMgPSA1MDApIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpdGVyYXRpb25zPTUwMF0gLSBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAgICAgKiBAeWllbGRzIHtNYXRyaXh8QXJyYXk8QXJyYXk+fSAtIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgICpnZW5lcmF0b3IoaXRlcmF0aW9ucyA9IDUwMCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGVyZm9ybXMgYSBvcHRpbWl6YXRpb24gc3RlcFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyID0gKyt0aGlzLl9pdGVyO1xuICAgICAgICBjb25zdCBQID0gdGhpcy5fUDtcbiAgICAgICAgY29uc3QgeXN0ZXAgPSB0aGlzLl95c3RlcDtcbiAgICAgICAgY29uc3QgZ2FpbnMgPSB0aGlzLl9nYWlucztcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IHsgZDogZGltLCBlcHNpbG9ufSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGxldCBZID0gdGhpcy5ZO1xuXG4gICAgICAgIC8vY2FsYyBjb3N0IGdyYWRpZW50O1xuICAgICAgICBjb25zdCBwbXVsID0gaXRlciA8IDEwMCA/IDQgOiAxO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgUSBkaXN0ICh1bm5vcm1hbGl6ZWQpXG4gICAgICAgIGNvbnN0IFF1ID0gbmV3IE1hdHJpeChOLCBOLCBcInplcm9zXCIpO1xuICAgICAgICBsZXQgcXN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgZHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaGVyZSA9IFkuZW50cnkoaSwgZCkgLSBZLmVudHJ5KGosIGQpO1xuICAgICAgICAgICAgICAgICAgICBkc3VtICs9IGRoZXJlICogZGhlcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHF1ID0gMSAvICgxICsgZHN1bSk7XG4gICAgICAgICAgICAgICAgUXUuc2V0X2VudHJ5KGksIGosIHF1KTtcbiAgICAgICAgICAgICAgICBRdS5zZXRfZW50cnkoaiwgaSwgcXUpO1xuICAgICAgICAgICAgICAgIHFzdW0gKz0gMiAqIHF1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIFEgZGlzdFxuICAgICAgICBjb25zdCBRID0gbmV3IE1hdHJpeChOLCBOLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IE1hdGgubWF4KFF1LmVudHJ5KGksIGopIC8gcXN1bSwgMWUtMTAwKTtcbiAgICAgICAgICAgICAgICBRLnNldF9lbnRyeShpLCBqLCB2YWwpO1xuICAgICAgICAgICAgICAgIFEuc2V0X2VudHJ5KGosIGksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBncmFkID0gbmV3IE1hdHJpeChOLCBkaW0sIFwiemVyb3NcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZW11bHQgPSA0ICogKHBtdWwgKiBQLmVudHJ5KGksIGopIC0gUS5lbnRyeShpLCBqKSkgKiBRdS5lbnRyeShpLCBqKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWQuc2V0X2VudHJ5KGksIGQsIGdyYWQuZW50cnkoaSwgZCkgKyBwcmVtdWx0ICogKFkuZW50cnkoaSwgZCkgLSBZLmVudHJ5KGosIGQpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVyZm9ybSBncmFkaWVudCBzdGVwXG4gICAgICAgIGxldCB5bWVhbiA9IG5ldyBGbG9hdDY0QXJyYXkoZGltKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnaWQgPSBncmFkLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZCA9IHlzdGVwLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhaW5pZCA9IGdhaW5zLmVudHJ5KGksIGQpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG5ld2dhaW4gPSBNYXRoLnNpZ24oZ2lkKSA9PT0gTWF0aC5zaWduKHNpZCkgPyBnYWluaWQgKiAwLjggOiBnYWluaWQgKyAwLjI7XG4gICAgICAgICAgICAgICAgaWYgKG5ld2dhaW4gPCAwLjAxKSBuZXdnYWluID0gMC4wMTtcbiAgICAgICAgICAgICAgICBnYWlucy5zZXRfZW50cnkoaSwgZCwgbmV3Z2Fpbik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtb212YWwgPSBpdGVyIDwgMjUwID8gMC41IDogMC44O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld3NpZCA9IG1vbXZhbCAqIHNpZCAtIGVwc2lsb24gKiBuZXdnYWluICogZ2lkO1xuICAgICAgICAgICAgICAgIHlzdGVwLnNldF9lbnRyeShpLCBkLCBuZXdzaWQpO1xuXG4gICAgICAgICAgICAgICAgWS5zZXRfZW50cnkoaSwgZCwgWS5lbnRyeShpLCBkKSArIG5ld3NpZCk7XG4gICAgICAgICAgICAgICAgeW1lYW5bZF0gKz0gWS5lbnRyeShpLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDI7ICsrZCkge1xuICAgICAgICAgICAgICAgIFkuc2V0X2VudHJ5KGksIGQsIFkuZW50cnkoaSwgZCkgLSB5bWVhbltkXSAvIE4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuWTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm9wdGltaXphdGlvblxuICogQGFsaWFzIHBvd2VsbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHtBcnJheX0geDBcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4X2l0ZXIgPSAzMDBdXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAc2VlIGh0dHA6Ly9vcHRpbWl6YXRpb24tanMuZ2l0aHViLmlvL29wdGltaXphdGlvbi1qcy9vcHRpbWl6YXRpb24uanMuaHRtbCNsaW5lNDM4XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChmLCB4MCwgbWF4X2l0ZXIgPSAzMDApIHtcbiAgICBjb25zdCBlcHNpbG9uID0gMWUtMjtcbiAgICBjb25zdCBuID0geDAubGVuZ3RoO1xuICAgIGxldCBhbHBoYSA9IDFlLTM7XG4gICAgbGV0IHBmeCA9IDEwMDAwO1xuICAgIGxldCB4ID0geDAuc2xpY2UoKTtcbiAgICBsZXQgZnggPSBmKHgpO1xuICAgIGxldCBjb252ZXJnZW5jZSA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKG1heF9pdGVyLS0gPj0gMCAmJiAhY29udmVyZ2VuY2UpIHtcbiAgICAgICAgY29udmVyZ2VuY2UgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgeFtpXSArPSAxZS02O1xuICAgICAgICAgICAgbGV0IGZ4aSA9IGYoeCk7XG4gICAgICAgICAgICB4W2ldIC09IDFlLTY7XG4gICAgICAgICAgICBsZXQgZHggPSAoZnhpIC0gZngpIC8gMWUtNjtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeCkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgY29udmVyZ2VuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhbaV0gLT0gYWxwaGEgKiBkeDtcbiAgICAgICAgICAgIGZ4ID0gZih4KTtcbiAgICAgICAgfVxuICAgICAgICBhbHBoYSAqPSBwZnggPj0gZnggPyAxLjA1IDogMC40O1xuICAgICAgICBwZnggPSBmeDtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4sIGV1Y2xpZGVhbl9zcXVhcmVkIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IEJhbGxUcmVlIH0gZnJvbSBcIi4uL2tubi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbmV1bWFpcl9zdW0gfSBmcm9tIFwiLi4vbnVtZXJpY2FsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBsaW5zcGFjZSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IHBvd2VsbCB9IGZyb20gXCIuLi9vcHRpbWl6YXRpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBLTk4gfSBmcm9tIFwiLi4va25uL2luZGV4LmpzXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgVU1BUFxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIFVNQVAgZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmRydWlkL2RpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBVTUFQXG4gICAgICogQHBhcmFtIHtNYXRyaXh8TnVtYmVyW11bXX0gWCAtIHRoZSBoaWdoLWRpbWVuc2lvbmFsIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBEUiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLm5fbmVpZ2hib3JzID0gMTVdIC0gc2l6ZSBvZiB0aGUgbG9jYWwgbmVpZ2hib3Job29kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5sb2NhbF9jb25uZWN0aXZpdHkgPSAxXSAtIG51bWJlciBvZiBuZWFyZXN0IG5laWdoYm9ycyBjb25uZWN0ZWQgaW4gdGhlIGxvY2FsIG5laWdoYm9yaG9vZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMubWluX2Rpc3QgPSAxXSAtIGNvbnRyb2xzIGhvdyB0aWdodGx5IHBvaW50cyBnZXQgcGFja2VkIHRvZ2V0aGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5kID0gMl0gLSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtZXRlcnMubWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzIGluIHRoZSBoaWdoLWRpbWVuc2lvbmFsIHNwYWNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5fc3ByZWFkID0gMV0gLSBUaGUgZWZmZWN0aXZlIHNjYWxlIG9mIGVtYmVkZGVkIHBvaW50cy4gKEluIGNvbWJpbmF0aW9uIHdpdGgge0BsaW5rIHBhcmFtZXRlcnMubWluX2Rpc3R9KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5fc2V0X29wX21peF9yYXRpbyA9IDFdIC0gSW50ZXJwb2xhdGUgYmV0d2VlbiB1bmlvbiBhbmQgaW50ZXJzZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5fcmVwdWxzaW9uX3N0cmVuZ3RoID0gMV0gIC0gV2VpZ2h0aW5nIGFwcGxpZWQgdG8gbmVnYXRpdmUgc2FtcGxlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuX25lZ2F0aXZlX3NhbXBsZV9yYXRlID0gNV0gLSBUaGUgbnVtYmVyIG9mIG5lZ2F0aXZlIHNhbXBsZXMgcGVyIHBvc2l0aXZlIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuX25fZXBvY2hzID0gMzUwXSAtIFRoZSBudW1iZXIgb2YgdHJhaW5pbmcgZXBvY2hzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVyLl9pbml0aWFsX2FscGhhID0gMV0gLSBUaGUgaW5pdGlhbCBsZWFybmluZyByYXRlIGZvciB0aGUgb3B0aW1pemF0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtVTUFQfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBuX25laWdoYm9yczogMTUsIGxvY2FsX2Nvbm5lY3Rpdml0eTogMSwgbWluX2Rpc3Q6IDEsIGQ6IDIsIG1ldHJpYzogZXVjbGlkZWFuLCBzZWVkOiAxMjEyLCBfc3ByZWFkOiAxLCBfc2V0X29wX21peF9yYXRpbzogMSwgX3JlcHVsc2lvbl9zdHJlbmd0aDogMSwgX25lZ2F0aXZlX3NhbXBsZV9yYXRlOiA1LCBfbl9lcG9jaHM6IDM1MCwgX2luaXRpYWxfYWxwaGE6IDEgfSwgcGFyYW1ldGVycyk7XG4gICAgICAgIFt0aGlzLl9OLCB0aGlzLl9EXSA9IHRoaXMuWC5zaGFwZTtcbiAgICAgICAgLyogbGV0IG5fbmVpZ2hib3JzID0gTWF0aC5taW4odGhpcy5fTiAtIDEsIHBhcmFtZXRlcnMubl9uZWlnaGJvcnMpO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcihcIm5fbmVpZ2hib3JzXCIsIG5fbmVpZ2hib3JzKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJsb2NhbF9jb25uZWN0aXZpdHlcIiwgTWF0aC5taW4odGhpcy5wYXJhbWV0ZXIoXCJsb2NhbF9jb25uZWN0aXZpdHlcIiksIG5fbmVpZ2hib3JzIC0gMSkpOyAqL1xuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXIoXCJuX25laWdoYm9yc1wiKSA+IHRoaXMuX04pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyYW1ldGVyIG5fbmVpZ2hib3JzICg9JHt0aGlzLnBhcmFtZXRlcihcIm5fbmVpZ2hib3JzXCIpfSkgbmVlZHMgdG8gYmUgc21hbGxlciB0aGFuIGRhdGFzZXQgc2l6ZSAoTj0ke3RoaXMuX059KSFgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXIoXCJsb2NhbF9jb25uZWN0aXZpdHlcIikgPiB0aGlzLnBhcmFtZXRlcihcIm5fbmVpZ2hib3JzXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBsb2NhbF9jb25uZWN0aXZpdHkgKD0ke3RoaXMucGFyYW1ldGVyKFwibG9jYWxfY29ubmVjdGl2aXR5XCIpfSkgbmVlZHMgdG8gYmUgc21hbGxlciB0aGFuIHBhcmFtZXRlciBuX25laWdoYm9ycyAoPSR7dGhpcy5wYXJhbWV0ZXIoXCJuX25laWdoYm9yc1wiKX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXRlciA9IDA7XG4gICAgICAgIGNvbnN0IHJhbmRvbWl6ZXIgPSB0aGlzLl9yYW5kb21pemVyO1xuICAgICAgICB0aGlzLlkgPSBuZXcgTWF0cml4KHRoaXMuX04sIHRoaXMucGFyYW1ldGVyKFwiZFwiKSwgKCkgPT4gcmFuZG9taXplci5yYW5kb20pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcHJlYWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluX2Rpc3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgX2ZpbmRfYWJfcGFyYW1zKHNwcmVhZCwgbWluX2Rpc3QpIHtcbiAgICAgICAgY29uc3QgY3VydmUgPSAoeCwgYSwgYikgPT4gMSAvICgxICsgYSAqIE1hdGgucG93KHgsIDIgKiBiKSk7XG4gICAgICAgIGNvbnN0IHh2ID0gbGluc3BhY2UoMCwgc3ByZWFkICogMywgMzAwKTtcbiAgICAgICAgY29uc3QgeXYgPSBsaW5zcGFjZSgwLCBzcHJlYWQgKiAzLCAzMDApO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0geHYubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB4dl9pID0geHZbaV07XG4gICAgICAgICAgICB5dltpXSA9IHh2X2kgPCBtaW5fZGlzdCA/IDEgOiBNYXRoLmV4cCgtKHh2X2kgLSBtaW5fZGlzdCkgLyBzcHJlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyID0gKHApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbGluc3BhY2UoMSwgMzAwKS5tYXAoKF8sIGkpID0+IHl2W2ldIC0gY3VydmUoeHZbaV0sIHBbMF0sIHBbMV0pKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQobmV1bWFpcl9zdW0oZXJyb3IubWFwKChlKSA9PiBlICogZSkpKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcG93ZWxsKGVyciwgWzEsIDFdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBkaXN0YW5jZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHNpZ21hc1xuICAgICAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gcmhvc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBfY29tcHV0ZV9tZW1iZXJzaGlwX3N0cmVuZ3RocyhkaXN0YW5jZXMsIHNpZ21hcywgcmhvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGRpc3RhbmNlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBtID0gZGlzdGFuY2VzW2ldLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBkaXN0YW5jZXNbaV1bal0udmFsdWUgLSByaG9zW2ldO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlc1tpXVtqXS52YWx1ZSA9IHYgPiAwID8gTWF0aC5leHAoLXYgLyBzaWdtYXNbaV0pIDogMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzdGFuY2VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtLTk58QmFsbFRyZWV9IGtublxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBfc21vb3RoX2tubl9kaXN0KGtubiwgaykge1xuICAgICAgICBjb25zdCBTTU9PVEhfS19UT0xFUkFOQ0UgPSAxZS01O1xuICAgICAgICBjb25zdCBNSU5fS19ESVNUX1NDQUxFID0gMWUtMztcbiAgICAgICAgY29uc3Qgbl9pdGVyID0gNjQ7XG4gICAgICAgIGNvbnN0IHsgbG9jYWxfY29ubmVjdGl2aXR5LCBtZXRyaWMgfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IE1hdGgubG9nMihrKTtcbiAgICAgICAgY29uc3QgcmhvcyA9IFtdO1xuICAgICAgICBjb25zdCBzaWdtYXMgPSBbXTtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgTiA9IFguc2hhcGVbMF07XG4gICAgICAgIC8vY29uc3QgZGlzdGFuY2VzID0gWy4uLlhdLm1hcCh4X2kgPT4ga25uLnNlYXJjaCh4X2ksIGspLnJhd19kYXRhKCkucmV2ZXJzZSgpKTtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSBbXTtcbiAgICAgICAgaWYgKG1ldHJpYyA9PT0gXCJwcmVjb21wdXRlZFwiKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlcy5wdXNoKGtubi5zZWFyY2goaSwgaykucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeF9pIG9mIFgpIHtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXMucHVzaChrbm4uc2VhcmNoKHhfaSwgaykucmF3X2RhdGEoKS5yZXZlcnNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBsbyA9IDA7XG4gICAgICAgICAgICBsZXQgaGkgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBtaWQgPSAxO1xuXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hfcmVzdWx0ID0gZGlzdGFuY2VzW2ldO1xuICAgICAgICAgICAgY29uc3Qgbm9uX3plcm9fZGlzdCA9IHNlYXJjaF9yZXN1bHQuZmlsdGVyKChkKSA9PiBkLnZhbHVlID4gMCk7XG4gICAgICAgICAgICBjb25zdCBub25femVyb19kaXN0X2xlbmd0aCA9IG5vbl96ZXJvX2Rpc3QubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG5vbl96ZXJvX2Rpc3RfbGVuZ3RoID49IGxvY2FsX2Nvbm5lY3Rpdml0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcihsb2NhbF9jb25uZWN0aXZpdHkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRpb24gPSBsb2NhbF9jb25uZWN0aXZpdHkgLSBpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJob3MucHVzaChub25femVyb19kaXN0W2luZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbiA+IFNNT09USF9LX1RPTEVSQU5DRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmhvc1tpXS52YWx1ZSArPSBpbnRlcnBvbGF0aW9uICogKG5vbl96ZXJvX2Rpc3RbaW5kZXhdLnZhbHVlIC0gbm9uX3plcm9fZGlzdFtpbmRleCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJob3NbaV0udmFsdWUgPSBpbnRlcnBvbGF0aW9uICogbm9uX3plcm9fZGlzdFswXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vbl96ZXJvX2Rpc3RfbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJob3NbaV0gPSBub25femVyb19kaXN0W25vbl96ZXJvX2Rpc3RfbGVuZ3RoIC0gMV0udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG5faXRlcjsgKyt4KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgazsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBzZWFyY2hfcmVzdWx0W2pdLnZhbHVlIC0gcmhvc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcHN1bSArPSBkID4gMCA/IE1hdGguZXhwKC0oZCAvIG1pZCkpIDogMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHBzdW0gLSB0YXJnZXQpIDwgU01PT1RIX0tfVE9MRVJBTkNFKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHN1bSA+IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBbaGksIG1pZF0gPSBbbWlkLCAobG8gKyBoaSkgLyAyXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGkgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbbG8sIG1pZF0gPSBbbWlkLCBtaWQgKiAyXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtsbywgbWlkXSA9IFttaWQsIChsbyArIGhpKSAvIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2lnbWFzW2ldID0gbWlkO1xuXG4gICAgICAgICAgICBjb25zdCBtZWFuX2l0aGQgPSBzZWFyY2hfcmVzdWx0LnJlZHVjZSgoYSwgYikgPT4gYSArIGIudmFsdWUsIDApIC8gc2VhcmNoX3Jlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICAvL2xldCBtZWFuX2QgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJob3NbaV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ21hc1tpXSA8IE1JTl9LX0RJU1RfU0NBTEUgKiBtZWFuX2l0aGQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbWFzW2ldID0gTUlOX0tfRElTVF9TQ0FMRSAqIG1lYW5faXRoZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lYW5fZCA9IGRpc3RhbmNlcy5yZWR1Y2UoKGFjYywgcmVzKSA9PiBhY2MgKyByZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYi52YWx1ZSwgMCkgLyByZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbWFzW2ldID4gTUlOX0tfRElTVF9TQ0FMRSAqIG1lYW5fZCkge1xuICAgICAgICAgICAgICAgICAgICBzaWdtYXNbaV0gPSBNSU5fS19ESVNUX1NDQUxFICogbWVhbl9kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlzdGFuY2VzOiBkaXN0YW5jZXMsXG4gICAgICAgICAgICBzaWdtYXM6IHNpZ21hcyxcbiAgICAgICAgICAgIHJob3M6IHJob3MsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX25laWdoYm9yc1xuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgX2Z1enp5X3NpbXBsaWNpYWxfc2V0KFgsIG5fbmVpZ2hib3JzKSB7XG4gICAgICAgIGNvbnN0IE4gPSBYLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCB7IG1ldHJpYywgX3NldF9vcF9taXhfcmF0aW8gfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IGtubiA9IG1ldHJpYyA9PT0gXCJwcmVjb21wdXRlZFwiID8gbmV3IEtOTihYLCBcInByZWNvbXB1dGVkXCIpIDogbmV3IEJhbGxUcmVlKFgudG8yZEFycmF5LCBtZXRyaWMpO1xuICAgICAgICBsZXQgeyBkaXN0YW5jZXMsIHNpZ21hcywgcmhvcyB9ID0gdGhpcy5fc21vb3RoX2tubl9kaXN0KGtubiwgbl9uZWlnaGJvcnMpO1xuICAgICAgICBkaXN0YW5jZXMgPSB0aGlzLl9jb21wdXRlX21lbWJlcnNoaXBfc3RyZW5ndGhzKGRpc3RhbmNlcywgc2lnbWFzLCByaG9zKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeChOLCBOLCBcInplcm9zXCIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VzX2kgPSBkaXN0YW5jZXNbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRpc3RhbmNlc19pLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldF9lbnRyeShpLCBkaXN0YW5jZXNfaVtqXS5lbGVtZW50LmluZGV4LCBkaXN0YW5jZXNfaVtqXS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0cmFuc3Bvc2VkX3Jlc3VsdCA9IHJlc3VsdC5UO1xuICAgICAgICBjb25zdCBwcm9kX21hdHJpeCA9IHJlc3VsdC5tdWx0KHRyYW5zcG9zZWRfcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgLmFkZCh0cmFuc3Bvc2VkX3Jlc3VsdClcbiAgICAgICAgICAgIC5zdWIocHJvZF9tYXRyaXgpXG4gICAgICAgICAgICAubXVsdChfc2V0X29wX21peF9yYXRpbylcbiAgICAgICAgICAgIC5hZGQocHJvZF9tYXRyaXgubXVsdCgxIC0gX3NldF9vcF9taXhfcmF0aW8pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX2Vwb2Noc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBfbWFrZV9lcG9jaHNfcGVyX3NhbXBsZShuX2Vwb2Nocykge1xuICAgICAgICBjb25zdCB3ZWlnaHRzID0gdGhpcy5fd2VpZ2h0cztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSh3ZWlnaHRzLmxlbmd0aCkuZmlsbCgtMSk7XG4gICAgICAgIGNvbnN0IHdlaWdodHNfbWF4ID0gbWF4KHdlaWdodHMpO1xuICAgICAgICBjb25zdCBuX3NhbXBsZXMgPSB3ZWlnaHRzLm1hcCgodykgPT4gbl9lcG9jaHMgKiAodyAvIHdlaWdodHNfbWF4KSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSBpZiAobl9zYW1wbGVzW2ldID4gMCkgcmVzdWx0W2ldID0gTWF0aC5yb3VuZChuX2Vwb2NocyAvIG5fc2FtcGxlc1tpXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gZ3JhcGhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIF90b2NvbyhncmFwaCkge1xuICAgICAgICBjb25zdCByb3dzID0gW107XG4gICAgICAgIGNvbnN0IGNvbHMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBjb25zdCBbcm93c19uLCBjb2xzX25dID0gZ3JhcGguc2hhcGU7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3NfbjsgKytyb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHNfbjsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGdyYXBoLmVudHJ5KHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbHMucHVzaChjb2wpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93czogcm93cyxcbiAgICAgICAgICAgIGNvbHM6IGNvbHMsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGFsbCBuZWNlc3NhcnlcbiAgICAgKiBAcmV0dXJucyB7VU1BUH1cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCB7IF9zcHJlYWQsIG1pbl9kaXN0LCBuX25laWdoYm9ycywgX25fZXBvY2hzLCBfbmVnYXRpdmVfc2FtcGxlX3JhdGUgfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IFthLCBiXSA9IHRoaXMuX2ZpbmRfYWJfcGFyYW1zKF9zcHJlYWQsIG1pbl9kaXN0KTtcbiAgICAgICAgdGhpcy5fYSA9IGE7XG4gICAgICAgIHRoaXMuX2IgPSBiO1xuICAgICAgICB0aGlzLl9ncmFwaCA9IHRoaXMuX2Z1enp5X3NpbXBsaWNpYWxfc2V0KHRoaXMuWCwgbl9uZWlnaGJvcnMpO1xuICAgICAgICBjb25zdCB7IHJvd3MsIGNvbHMsIGRhdGE6IHdlaWdodHMgfSA9IHRoaXMuX3RvY29vKHRoaXMuX2dyYXBoKTtcbiAgICAgICAgdGhpcy5faGVhZCA9IHJvd3M7XG4gICAgICAgIHRoaXMuX3RhaWwgPSBjb2xzO1xuICAgICAgICB0aGlzLl93ZWlnaHRzID0gd2VpZ2h0cztcbiAgICAgICAgdGhpcy5fZXBvY2hzX3Blcl9zYW1wbGUgPSB0aGlzLl9tYWtlX2Vwb2Noc19wZXJfc2FtcGxlKF9uX2Vwb2Nocyk7XG4gICAgICAgIHRoaXMuX2Vwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlID0gdGhpcy5fZXBvY2hzX3Blcl9zYW1wbGUubWFwKChkKSA9PiBkICogX25lZ2F0aXZlX3NhbXBsZV9yYXRlKTtcbiAgICAgICAgdGhpcy5fZXBvY2hfb2ZfbmV4dF9zYW1wbGUgPSB0aGlzLl9lcG9jaHNfcGVyX3NhbXBsZS5zbGljZSgpO1xuICAgICAgICB0aGlzLl9lcG9jaF9vZl9uZXh0X25lZ2F0aXZlX3NhbXBsZSA9IHRoaXMuX2Vwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdyYXBoKCkge1xuICAgICAgICB0aGlzLmNoZWNrX2luaXQoKTtcbiAgICAgICAgcmV0dXJuIHsgY29sczogdGhpcy5faGVhZCwgcm93czogdGhpcy5fdGFpbCwgd2VpZ2h0czogdGhpcy5fd2VpZ2h0cyB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpdGVyYXRpb25zPTM1MF0gLSBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fEFycmF5fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybShpdGVyYXRpb25zID0gMzUwKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcihcIl9uX2Vwb2Noc1wiKSAhPSBpdGVyYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcihcIl9uX2Vwb2Noc1wiLCBpdGVyYXRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaXRlcmF0aW9ucz0zNTBdIC0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gICAgICogQHJldHVybnMge01hdHJpeHxBcnJheX1cbiAgICAgKi9cbiAgICAqZ2VuZXJhdG9yKGl0ZXJhdGlvbnMgPSAzNTApIHtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVyKFwiX25fZXBvY2hzXCIpICE9IGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyKFwiX25fZXBvY2hzXCIsIGl0ZXJhdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucHJvamVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIF9jbGlwKHgpIHtcbiAgICAgICAgaWYgKHggPiA0KSByZXR1cm4gNDtcbiAgICAgICAgaWYgKHggPCAtNCkgcmV0dXJuIC00O1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwZXJmb3JtcyB0aGUgb3B0aW1pemF0aW9uIHN0ZXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gaGVhZF9lbWJlZGRpbmdcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gdGFpbF9lbWJlZGRpbmdcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gaGVhZFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSB0YWlsXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBfb3B0aW1pemVfbGF5b3V0KGhlYWRfZW1iZWRkaW5nLCB0YWlsX2VtYmVkZGluZywgaGVhZCwgdGFpbCkge1xuICAgICAgICBjb25zdCByYW5kb21pemVyID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgY29uc3QgeyBfcmVwdWxzaW9uX3N0cmVuZ3RoLCBkOiBkaW0gfSA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IHsgX2FscGhhOiBhbHBoYSwgX2E6IGEsIF9iOiBiLCBfZXBvY2hzX3Blcl9zYW1wbGU6IGVwb2Noc19wZXJfc2FtcGxlLCBfZXBvY2hzX3Blcl9uZWdhdGl2ZV9zYW1wbGU6IGVwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlLCBfZXBvY2hfb2ZfbmV4dF9uZWdhdGl2ZV9zYW1wbGU6IGVwb2NoX29mX25leHRfbmVnYXRpdmVfc2FtcGxlLCBfZXBvY2hfb2ZfbmV4dF9zYW1wbGU6IGVwb2NoX29mX25leHRfc2FtcGxlLCBfY2xpcDogY2xpcCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdGFpbF9sZW5ndGggPSB0YWlsLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGVwb2Noc19wZXJfc2FtcGxlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgaWYgKGVwb2NoX29mX25leHRfc2FtcGxlW2ldIDw9IHRoaXMuX2l0ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqID0gaGVhZFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBrID0gdGFpbFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gaGVhZF9lbWJlZGRpbmcucm93KGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyID0gdGFpbF9lbWJlZGRpbmcucm93KGspO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBldWNsaWRlYW5fc3F1YXJlZChjdXJyZW50LCBvdGhlcik7XG4gICAgICAgICAgICAgICAgbGV0IGdyYWRfY29lZmYgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBncmFkX2NvZWZmID0gKC0yICogYSAqIGIgKiBNYXRoLnBvdyhkaXN0LCBiIC0gMSkpIC8gKGEgKiBNYXRoLnBvdyhkaXN0LCBiKSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyYWRfZCA9IGNsaXAoZ3JhZF9jb2VmZiAqIChjdXJyZW50W2RdIC0gb3RoZXJbZF0pKSAqIGFscGhhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gY3VycmVudFtkXSArIGdyYWRfZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbyA9IG90aGVyW2RdIC0gZ3JhZF9kO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50W2RdID0gYztcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJbZF0gPSBvO1xuICAgICAgICAgICAgICAgICAgICBoZWFkX2VtYmVkZGluZy5zZXRfZW50cnkoaiwgZCwgYyk7XG4gICAgICAgICAgICAgICAgICAgIHRhaWxfZW1iZWRkaW5nLnNldF9lbnRyeShrLCBkLCBvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXBvY2hfb2ZfbmV4dF9zYW1wbGVbaV0gKz0gZXBvY2hzX3Blcl9zYW1wbGVbaV07XG4gICAgICAgICAgICAgICAgY29uc3Qgbl9uZWdfc2FtcGxlcyA9ICh0aGlzLl9pdGVyIC0gZXBvY2hfb2ZfbmV4dF9uZWdhdGl2ZV9zYW1wbGVbaV0pIC8gZXBvY2hzX3Blcl9uZWdhdGl2ZV9zYW1wbGVbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBuX25lZ19zYW1wbGVzOyArK3ApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgayA9IHJhbmRvbWl6ZXIucmFuZG9tX2ludCAlIHRhaWxfbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlciA9IHRhaWxfZW1iZWRkaW5nLnJvdyh0YWlsW2tdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IGV1Y2xpZGVhbl9zcXVhcmVkKGN1cnJlbnQsIG90aGVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGdyYWRfY29lZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRfY29lZmYgPSAoMiAqIF9yZXB1bHNpb25fc3RyZW5ndGggKiBiKSAvICgoMC4wMSArIGRpc3QpICogKGEgKiBNYXRoLnBvdyhkaXN0LCBiKSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqID09PSBrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBncmFkX2QgPSBjbGlwKGdyYWRfY29lZmYgKiAoY3VycmVudFtkXSAtIG90aGVyW2RdKSkgKiBhbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBjdXJyZW50W2RdICsgZ3JhZF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbyA9IG90aGVyW2RdIC0gZ3JhZF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFtkXSA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlcltkXSA9IG87XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkX2VtYmVkZGluZy5zZXRfZW50cnkoaiwgZCwgYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWlsX2VtYmVkZGluZy5zZXRfZW50cnkodGFpbFtrXSwgZCwgbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXBvY2hfb2ZfbmV4dF9uZWdhdGl2ZV9zYW1wbGVbaV0gKz0gbl9uZWdfc2FtcGxlcyAqIGVwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkX2VtYmVkZGluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgaXRlciA9ICsrdGhpcy5faXRlcjtcbiAgICAgICAgY29uc3QgWSA9IHRoaXMuWTtcbiAgICAgICAgY29uc3QgeyBfaW5pdGlhbF9hbHBoYSwgX25fZXBvY2hzIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9hbHBoYSA9IF9pbml0aWFsX2FscGhhICogKDEgLSBpdGVyIC8gX25fZXBvY2hzKTtcbiAgICAgICAgdGhpcy5ZID0gdGhpcy5fb3B0aW1pemVfbGF5b3V0KFksIFksIHRoaXMuX2hlYWQsIHRoaXMuX3RhaWwpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLlk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTWF0cml4LCBsaW5zcGFjZSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcbmltcG9ydCB7IGV1Y2xpZGVhbiB9IGZyb20gXCIuLi9tZXRyaWNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBQQ0EgfSBmcm9tIFwiLi9QQ0EuanNcIjtcbmltcG9ydCB7IEJhbGxUcmVlIH0gZnJvbSBcIi4uL2tubi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIFRyaU1hcFxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIFRyaU1hcCBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZHJ1aWQvZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIFRyaU1hcFxuICAgICAqIEBwYXJhbSB7TWF0cml4fE51bWJlcltdW119IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy53ZWlnaHRfYWRqID0gNTAwXSAtIHNjYWxpbmcgZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5jID0gNV0gLSBudW1iZXIgb2YgdHJpcGxldHMgbXVsdGlwbGllci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy50b2wgPSAxZS04XSAtXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtZXRlcnMubWV0cmljID0gZXVjbGlkZWFuXSAtIHRoZSBtZXRyaWMgd2hpY2ggZGVmaW5lcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtUcmlNYXB9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE5MTAuMDAyMDR2MS5wZGZ9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VhbWlkL3RyaW1hcH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihYLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKFgsIHsgd2VpZ2h0X2FkajogNTAwLCBjOiA1LCBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgdG9sOiAxZS04LCBzZWVkOiAxMjEyIH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBbcGNhID0gbnVsbF0gLSBJbml0aWFsIEVtYmVkZGluZyAoaWYgbnVsbCB0aGVuIFBDQSBnZXRzIHVzZWQpLlxuICAgICAqIEBwYXJhbSB7S05OfSBba25uID0gbnVsbF0gLSBLTk4gT2JqZWN0IChpZiBudWxsIHRoZW4gQmFsbFRyZWUgZ2V0cyB1c2VkKS5cbiAgICAgKi9cbiAgICBpbml0KHBjYSA9IG51bGwsIGtubiA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgTiA9IFguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHsgZCwgbWV0cmljLCBjIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLm5faW5saWVycyA9IDIgKiBjO1xuICAgICAgICB0aGlzLm5fb3V0bGllcnMgPSAxICogYztcbiAgICAgICAgdGhpcy5uX3JhbmRvbSA9IDEgKiBjO1xuICAgICAgICB0aGlzLlkgPSBwY2EgfHwgbmV3IFBDQShYLCBkKS50cmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5rbm4gPSBrbm4gfHwgbmV3IEJhbGxUcmVlKFgudG8yZEFycmF5LCBtZXRyaWMpO1xuICAgICAgICBjb25zdCB7IHRyaXBsZXRzLCB3ZWlnaHRzIH0gPSB0aGlzLl9nZW5lcmF0ZV90cmlwbGV0cyh0aGlzLm5faW5saWVycywgdGhpcy5uX291dGxpZXJzLCB0aGlzLm5fcmFuZG9tKTtcbiAgICAgICAgdGhpcy50cmlwbGV0cyA9IHRyaXBsZXRzO1xuICAgICAgICB0aGlzLndlaWdodHMgPSB3ZWlnaHRzO1xuICAgICAgICB0aGlzLmxyID0gKDEwMDAgKiBOKSAvIHRyaXBsZXRzLnNoYXBlWzBdO1xuICAgICAgICB0aGlzLkMgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy52ZWwgPSBuZXcgTWF0cml4KE4sIGQsIDApO1xuICAgICAgICB0aGlzLmdhaW4gPSBuZXcgTWF0cml4KE4sIGQsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMge0BsaW5rIG5faW5saWVyc30geCB7QGxpbmsgbl9vdXRsaWVyc30geCB7QGxpbmsgbl9yYW5kb219IHRyaXBsZXRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX2lubGllcnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbl9vdXRsaWVyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX3JhbmRvbVxuICAgICAqL1xuICAgIF9nZW5lcmF0ZV90cmlwbGV0cyhuX2lubGllcnMsIG5fb3V0bGllcnMsIG5fcmFuZG9tKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0cmljLCB3ZWlnaHRfYWRqIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBYID0gdGhpcy5YO1xuICAgICAgICBjb25zdCBOID0gWC5zaGFwZVswXTtcbiAgICAgICAgY29uc3Qga25uID0gdGhpcy5rbm47XG4gICAgICAgIGNvbnN0IG5fZXh0cmEgPSBNYXRoLm1pbihuX2lubGllcnMgKyAyMCwgTik7XG4gICAgICAgIGNvbnN0IG5icnMgPSBuZXcgTWF0cml4KE4sIG5fZXh0cmEpO1xuICAgICAgICBjb25zdCBrbm5fZGlzdGFuY2VzID0gbmV3IE1hdHJpeChOLCBuX2V4dHJhKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGtubi5zZWFyY2goWC5yb3coaSksIG5fZXh0cmEgKyAxKVxuICAgICAgICAgICAgICAgIC5yYXdfZGF0YSgpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZCkgPT4gZC52YWx1ZSAhPSAwKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnZhbHVlIC0gYi52YWx1ZSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoZCwgaikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBuYnJzLnNldF9lbnRyeShpLCBqLCBkLmVsZW1lbnQuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBrbm5fZGlzdGFuY2VzLnNldF9lbnRyeShpLCBqLCBkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzY2FsZSBwYXJhbWV0ZXJcbiAgICAgICAgY29uc3Qgc2lnID0gbmV3IEZsb2F0NjRBcnJheShOKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIHNpZ1tpXSA9IE1hdGgubWF4KChrbm5fZGlzdGFuY2VzLmVudHJ5KGksIDMpICsga25uX2Rpc3RhbmNlcy5lbnRyeShpLCA0KSArIGtubl9kaXN0YW5jZXMuZW50cnkoaSwgNSkgKyBrbm5fZGlzdGFuY2VzLmVudHJ5KGksIDYpKSAvIDQsIDFlLTEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFAgPSB0aGlzLl9maW5kX3Aoa25uX2Rpc3RhbmNlcywgc2lnLCBuYnJzKTtcblxuICAgICAgICBsZXQgdHJpcGxldHMgPSB0aGlzLl9zYW1wbGVfa25uX3RyaXBsZXRzKFAsIG5icnMsIG5faW5saWVycywgbl9vdXRsaWVycyk7XG4gICAgICAgIGxldCBuX3RyaXBsZXRzID0gdHJpcGxldHMuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IG91dGxpZXJfZGlzdGFuY2VzID0gbmV3IEZsb2F0NjRBcnJheShuX3RyaXBsZXRzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuX3RyaXBsZXRzOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSB0cmlwbGV0cy5lbnRyeShpLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGsgPSB0cmlwbGV0cy5lbnRyeShpLCAyKTtcbiAgICAgICAgICAgIG91dGxpZXJfZGlzdGFuY2VzW2ldID0gbWV0cmljKFgucm93KGopLCBYLnJvdyhrKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdlaWdodHMgPSB0aGlzLl9maW5kX3dlaWdodHModHJpcGxldHMsIFAsIG5icnMsIG91dGxpZXJfZGlzdGFuY2VzLCBzaWcpO1xuXG4gICAgICAgIGlmIChuX3JhbmRvbSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZG9tX3RyaXBsZXRzLCByYW5kb21fd2VpZ2h0cyB9ID0gdGhpcy5fc2FtcGxlX3JhbmRvbV90cmlwbGV0cyhYLCBuX3JhbmRvbSwgc2lnKTtcbiAgICAgICAgICAgIHRyaXBsZXRzID0gdHJpcGxldHMuY29uY2F0KHJhbmRvbV90cmlwbGV0cywgXCJ2ZXJ0aWNhbFwiKTtcbiAgICAgICAgICAgIHdlaWdodHMgPSBGbG9hdDY0QXJyYXkuZnJvbShbLi4ud2VpZ2h0cywgLi4ucmFuZG9tX3dlaWdodHNdKTtcbiAgICAgICAgfVxuICAgICAgICBuX3RyaXBsZXRzID0gdHJpcGxldHMuc2hhcGVbMF07XG4gICAgICAgIGxldCBtYXhfd2VpZ2h0ID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5fdHJpcGxldHM7ICsraSkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHdlaWdodHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0c1tpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4X3dlaWdodCA8IHdlaWdodHNbaV0pIG1heF93ZWlnaHQgPSB3ZWlnaHRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXhfd2VpZ2h0XzIgPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbl90cmlwbGV0czsgKytpKSB7XG4gICAgICAgICAgICB3ZWlnaHRzW2ldIC89IG1heF93ZWlnaHQ7XG4gICAgICAgICAgICB3ZWlnaHRzW2ldICs9IDAuMDAwMTtcbiAgICAgICAgICAgIHdlaWdodHNbaV0gPSBNYXRoLmxvZygxICsgd2VpZ2h0X2FkaiAqIHdlaWdodHNbaV0pO1xuICAgICAgICAgICAgaWYgKG1heF93ZWlnaHRfMiA8IHdlaWdodHNbaV0pIG1heF93ZWlnaHRfMiA9IHdlaWdodHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuX3RyaXBsZXRzOyArK2kpIHtcbiAgICAgICAgICAgIHdlaWdodHNbaV0gLz0gbWF4X3dlaWdodF8yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmlwbGV0czogdHJpcGxldHMsXG4gICAgICAgICAgICB3ZWlnaHRzOiB3ZWlnaHRzLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNpbWlsYXJpdHkgbWF0cml4IFBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBrbm5fZGlzdGFuY2VzIC0gbWF0cml4IG9mIHBhaXJ3aXNlIGtubiBkaXN0YW5jZXNcbiAgICAgKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gc2lnIC0gc2NhbGluZyBmYWN0b3IgZm9yIHRoZSBkaXN0YW5jZXNcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbmJycyAtIG5lYXJlc3QgbmVpZ2hib3JzXG4gICAgICogQHJldHVybnMge01hdHJpeH0gcGFpcndpc2Ugc2ltaWxhcml0eSBtYXRyaXhcbiAgICAgKi9cbiAgICBfZmluZF9wKGtubl9kaXN0YW5jZXMsIHNpZywgbmJycykge1xuICAgICAgICBjb25zdCBbTiwgbl9uZWlnaGJvcnNdID0ga25uX2Rpc3RhbmNlcy5zaGFwZTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoTiwgbl9uZWlnaGJvcnMsIChpLCBqKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5leHAoLShrbm5fZGlzdGFuY2VzLmVudHJ5KGksIGopICoqIDIgLyBzaWdbaV0gLyBzaWdbbmJycy5lbnRyeShpLCBqKV0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2FtcGxlIG5lYXJlc3QgbmVpZ2hib3JzIHRyaXBsZXRzIGJhc2VkIG9uIHRoZSBzaW1pbGFyaXR5IHZhbHVlcyBnaXZlbiBpbiBQLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFAgLSBNYXRyaXggb2YgcGFpcndpc2Ugc2ltaWxhcml0aWVzIGJldHdlZW4gZWFjaCBwb2ludCBhbmQgaXRzIG5laWdoYm9ycyBnaXZlbiBpbiBtYXRyaXggbmJycy5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbmJycyAtIE5lYXJlc3QgbmVpZ2hib3JzIGluZGljZXMgZm9yIGVhY2ggcG9pbnQuIFRoZSBzaW1pbGFyaXR5IHZhbHVlcyBhcmUgZ2l2ZW4gaW4gbWF0cml4IHtAbGluayBQfS4gUm93IGkgY29ycmVzcG9uZHMgdG8gdGhlIGktdGggcG9pbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5faW5saWVycyAtIE51bWJlciBvZiBpbmxpZXIgcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX291dGxpZXJzIC0gTnVtYmVyIG9mIG91dGxpZXIgcG9pbnRzLlxuICAgICAqXG4gICAgICovXG4gICAgX3NhbXBsZV9rbm5fdHJpcGxldHMoUCwgbmJycywgbl9pbmxpZXJzLCBuX291dGxpZXJzKSB7XG4gICAgICAgIGNvbnN0IE4gPSBuYnJzLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCB0cmlwbGV0cyA9IG5ldyBNYXRyaXgoTiAqIG5faW5saWVycyAqIG5fb3V0bGllcnMsIDMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgbGV0IG5faSA9IGkgKiBuX2lubGllcnMgKiBuX291dGxpZXJzO1xuICAgICAgICAgICAgY29uc3Qgc29ydF9pbmRpY2VzID0gdGhpcy5fX2FyZ3NvcnQoUC5yb3coaSkubWFwKChkKSA9PiAtZCkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuX2lubGllcnM7ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBuX2ogPSBqICogbl9vdXRsaWVycztcbiAgICAgICAgICAgICAgICBjb25zdCBzaW0gPSBuYnJzLmVudHJ5KGksIHNvcnRfaW5kaWNlc1tqXSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FtcGxlcyA9IHRoaXMuX3JlamVjdGlvbl9zYW1wbGUobl9vdXRsaWVycywgTiwgc29ydF9pbmRpY2VzLnNsaWNlKDAsIGogKyAxKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuX291dGxpZXJzOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBuX2kgKyBuX2ogKyBrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSBzYW1wbGVzW2tdO1xuICAgICAgICAgICAgICAgICAgICB0cmlwbGV0cy5zZXRfZW50cnkoaW5kZXgsIDAsIGkpO1xuICAgICAgICAgICAgICAgICAgICB0cmlwbGV0cy5zZXRfZW50cnkoaW5kZXgsIDEsIHNpbSk7XG4gICAgICAgICAgICAgICAgICAgIHRyaXBsZXRzLnNldF9lbnRyeShpbmRleCwgMiwgb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyaXBsZXRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3VsZCBkbyB0aGUgc2FtZSBhcyBucC5hcmdzb3J0KClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IEFcbiAgICAgKi9cbiAgICBfX2FyZ3NvcnQoQSkge1xuICAgICAgICByZXR1cm4gQS5tYXAoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGQ6IGQsIGk6IGkgfTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmQgLSBiLmQpXG4gICAgICAgICAgICAubWFwKChkKSA9PiBkLmkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhbXBsZXMge0BsaW5rIG5fc2FtcGxlc30gaW50ZWdlcnMgZnJvbSBhIGdpdmVuIGludGVydmFsIFswLCB7QGxpbmsgbWF4X2ludH1dIHdoaWxlIHJlamVjdGlvbiB0aGUgdmFsdWVzIHRoYXQgYXJlIGluIHRoZSB7QGxpbmsgcmVqZWN0c30uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG5fc2FtcGxlc1xuICAgICAqIEBwYXJhbSB7Kn0gbWF4X2ludFxuICAgICAqIEBwYXJhbSB7Kn0gcmVqZWN0c1xuICAgICAqL1xuICAgIF9yZWplY3Rpb25fc2FtcGxlKG5fc2FtcGxlcywgbWF4X2ludCwgcmVqZWN0cykge1xuICAgICAgICBjb25zdCByYW5kb21pemVyID0gdGhpcy5fcmFuZG9taXplcjtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBsaW5zcGFjZSgwLCBtYXhfaW50IC0gMSkuZmlsdGVyKChkKSA9PiByZWplY3RzLmluZGV4T2YoZCkgPCAwKTtcbiAgICAgICAgcmV0dXJuIHJhbmRvbWl6ZXIuY2hvaWNlKGludGVydmFsLCBNYXRoLm1pbihuX3NhbXBsZXMsIGludGVydmFsLmxlbmd0aCAtIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB3ZWlnaHRzIGZvciB0aGUgc2FtcGxlZCBuZWFyZXN0IG5laWdoYm9ycyB0cmlwbGV0c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IHRyaXBsZXRzIC0gU2FtcGxlZCBUcmlwbGV0cy5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gUCAtIFBhaXJ3aXNlIHNpbWlsYXJpdHkgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBuYnJzIC0gbmVhcmVzdCBOZWlnaGJvcnNcbiAgICAgKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gb3V0bGllcl9kaXN0YW5jZXMgLSBNYXRyaXggb2YgcGFpcndpc2Ugb3V0bGllciBkaXN0YW5jZXNcbiAgICAgKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gc2lnIC0gc2NhbGluZyBmYWN0b3IgZm9yIHRoZSBkaXN0YW5jZXMuXG4gICAgICovXG4gICAgX2ZpbmRfd2VpZ2h0cyh0cmlwbGV0cywgUCwgbmJycywgb3V0bGllcl9kaXN0YW5jZXMsIHNpZykge1xuICAgICAgICBjb25zdCBuX3RyaXBsZXRzID0gdHJpcGxldHMuc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHdlaWdodHMgPSBuZXcgRmxvYXQ2NEFycmF5KG5fdHJpcGxldHMpO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IG5fdHJpcGxldHM7ICsrdCkge1xuICAgICAgICAgICAgY29uc3QgaSA9IHRyaXBsZXRzLmVudHJ5KHQsIDApO1xuICAgICAgICAgICAgY29uc3Qgc2ltID0gbmJycy5yb3coaSkuaW5kZXhPZih0cmlwbGV0cy5lbnRyeSh0LCAxKSk7XG4gICAgICAgICAgICBjb25zdCBwX3NpbSA9IFAuZW50cnkoaSwgc2ltKTtcbiAgICAgICAgICAgIGxldCBwX291dCA9IE1hdGguZXhwKC0ob3V0bGllcl9kaXN0YW5jZXNbdF0gKiogMiAvIChzaWdbaV0gKiBzaWdbdHJpcGxldHMuZW50cnkodCwgMildKSkpO1xuICAgICAgICAgICAgaWYgKHBfb3V0IDwgMWUtMjApIHBfb3V0ID0gMWUtMjA7XG4gICAgICAgICAgICB3ZWlnaHRzW3RdID0gcF9zaW0gLyBwX291dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2VpZ2h0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYW1wbGUgdW5pZm9ybWx5IHJhbm9tIHRyaXBsZXRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWCAtIERhdGEgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuX3JhbmRvbSAtIE51bWJlciBvZiByYW5kb20gdHJpcGxldHMgcGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IHNpZyAtIFNjYWxpbmcgZmFjdG9yIGZvciB0aGUgZGlzdGFuY2VzXG4gICAgICovXG4gICAgX3NhbXBsZV9yYW5kb21fdHJpcGxldHMoWCwgbl9yYW5kb20sIHNpZykge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLnBhcmFtZXRlcihcIm1ldHJpY1wiKTtcbiAgICAgICAgY29uc3QgcmFuZG9taXplciA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIGNvbnN0IE4gPSBYLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCByYW5kb21fdHJpcGxldHMgPSBuZXcgTWF0cml4KE4gKiBuX3JhbmRvbSwgMyk7XG4gICAgICAgIGNvbnN0IHJhbmRvbV93ZWlnaHRzID0gbmV3IEZsb2F0NjRBcnJheShOICogbl9yYW5kb20pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgbl9pID0gaSAqIG5fcmFuZG9tO1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IFsuLi5saW5zcGFjZSgwLCBpIC0gMSksIC4uLmxpbnNwYWNlKGkgKyAxLCBOIC0gMSldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuX3JhbmRvbTsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IFtzaW0sIG91dF0gPSByYW5kb21pemVyLmNob2ljZShpbmRpY2VzLCAyKTtcbiAgICAgICAgICAgICAgICBsZXQgcF9zaW0gPSBNYXRoLmV4cCgtKG1ldHJpYyhYLnJvdyhpKSwgWC5yb3coc2ltKSkgKiogMiAvIChzaWdbaV0gKiBzaWdbc2ltXSkpKTtcbiAgICAgICAgICAgICAgICBpZiAocF9zaW0gPCAxZS0yMCkgcF9zaW0gPSAxZS0yMDtcbiAgICAgICAgICAgICAgICBsZXQgcF9vdXQgPSBNYXRoLmV4cCgtKG1ldHJpYyhYLnJvdyhpKSwgWC5yb3cob3V0KSkgKiogMiAvIChzaWdbaV0gKiBzaWdbb3V0XSkpKTtcbiAgICAgICAgICAgICAgICBpZiAocF9vdXQgPCAxZS0yMCkgcF9vdXQgPSAxZS0yMDtcblxuICAgICAgICAgICAgICAgIGlmIChwX3NpbSA8IHBfb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIFtzaW0sIG91dF0gPSBbb3V0LCBzaW1dO1xuICAgICAgICAgICAgICAgICAgICBbcF9zaW0sIHBfb3V0XSA9IFtwX291dCwgcF9zaW1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG5faSArIGo7XG4gICAgICAgICAgICAgICAgcmFuZG9tX3RyaXBsZXRzLnNldF9lbnRyeShpbmRleCwgMCwgaSk7XG4gICAgICAgICAgICAgICAgcmFuZG9tX3RyaXBsZXRzLnNldF9lbnRyeShpbmRleCwgMSwgc2ltKTtcbiAgICAgICAgICAgICAgICByYW5kb21fdHJpcGxldHMuc2V0X2VudHJ5KGluZGV4LCAyLCBvdXQpO1xuICAgICAgICAgICAgICAgIHJhbmRvbV93ZWlnaHRzW2luZGV4XSA9IHBfc2ltIC8gcF9vdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhbmRvbV90cmlwbGV0czogcmFuZG9tX3RyaXBsZXRzLFxuICAgICAgICAgICAgcmFuZG9tX3dlaWdodHM6IHJhbmRvbV93ZWlnaHRzLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBncmFkaWVudCBmb3IgdXBkYXRpbmcgdGhlIGVtYmVkZGluZy5cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWSAtIFRoZSBlbWJlZGRpbmdcbiAgICAgKi9cbiAgICBfZ3JhZChZKSB7XG4gICAgICAgIGNvbnN0IG5faW5saWVycyA9IHRoaXMubl9pbmxpZXJzO1xuICAgICAgICBjb25zdCBuX291dGxpZXJzID0gdGhpcy5uX291dGxpZXJzO1xuICAgICAgICBjb25zdCB0cmlwbGV0cyA9IHRoaXMudHJpcGxldHM7XG4gICAgICAgIGNvbnN0IHdlaWdodHMgPSB0aGlzLndlaWdodHM7XG4gICAgICAgIGNvbnN0IFtOLCBkaW1dID0gWS5zaGFwZTtcbiAgICAgICAgY29uc3Qgbl90cmlwbGV0cyA9IHRyaXBsZXRzLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCBncmFkID0gbmV3IE1hdHJpeChOLCBkaW0sIDApO1xuICAgICAgICBsZXQgeV9paiA9IG5ldyBGbG9hdDY0QXJyYXkoZGltKTtcbiAgICAgICAgbGV0IHlfaWsgPSBuZXcgRmxvYXQ2NEFycmF5KGRpbSk7XG4gICAgICAgIGxldCBkX2lqID0gMTtcbiAgICAgICAgbGV0IGRfaWsgPSAxO1xuICAgICAgICBsZXQgbl92aW9sID0gMDtcbiAgICAgICAgbGV0IGxvc3MgPSAwO1xuICAgICAgICBjb25zdCBuX2tubl90cmlwbGV0cyA9IE4gKiBuX2lubGllcnMgKiBuX291dGxpZXJzO1xuXG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgbl90cmlwbGV0czsgKyt0KSB7XG4gICAgICAgICAgICBjb25zdCBbaSwgaiwga10gPSB0cmlwbGV0cy5yb3codCk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgeV9paiwgeV9paywgZF9paiwgZF9pa1xuICAgICAgICAgICAgaWYgKHQgJSBuX291dGxpZXJzID09IDAgfHwgdCA+PSBuX2tubl90cmlwbGV0cykge1xuICAgICAgICAgICAgICAgIGRfaWogPSAxO1xuICAgICAgICAgICAgICAgIGRfaWsgPSAxO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWV9pZCA9IFkuZW50cnkoaSwgZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFlfamQgPSBZLmVudHJ5KGosIGQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBZX2tkID0gWS5lbnRyeShrLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgeV9paltkXSA9IFlfaWQgLSBZX2pkO1xuICAgICAgICAgICAgICAgICAgICB5X2lrW2RdID0gWV9pZCAtIFlfa2Q7XG4gICAgICAgICAgICAgICAgICAgIGRfaWogKz0geV9paltkXSAqKiAyO1xuICAgICAgICAgICAgICAgICAgICBkX2lrICs9IHlfaWtbZF0gKiogMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHlfaWsgYW5kIGRfaWsgb25seVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkX2lrID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFlfaWQgPSBZLmVudHJ5KGksIGQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBZX2tkID0gWS5lbnRyeShrLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgeV9pa1tkXSA9IFlfaWQgLSBZX2tkO1xuICAgICAgICAgICAgICAgICAgICBkX2lrICs9IHlfaWtbZF0gKiogMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkX2lqID4gZF9paykgKytuX3Zpb2w7XG4gICAgICAgICAgICBsb3NzICs9IHdlaWdodHNbdF0gLyAoMSArIGRfaWsgLyBkX2lqKTtcbiAgICAgICAgICAgIGNvbnN0IHcgPSAod2VpZ2h0c1t0XSAvIChkX2lqICsgZF9paykpICoqIDI7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3MgPSB5X2lqW2RdICogZF9payAqIHc7XG4gICAgICAgICAgICAgICAgY29uc3QgZ28gPSB5X2lrW2RdICogZF9paiAqIHc7XG4gICAgICAgICAgICAgICAgZ3JhZC5zZXRfZW50cnkoaSwgZCwgZ3JhZC5lbnRyeShpLCBkKSArIGdzIC0gZ28pO1xuICAgICAgICAgICAgICAgIGdyYWQuc2V0X2VudHJ5KGosIGQsIGdyYWQuZW50cnkoaiwgZCkgLSBncyk7XG4gICAgICAgICAgICAgICAgZ3JhZC5zZXRfZW50cnkoaywgZCwgZ3JhZC5lbnRyeShrLCBkKSArIGdvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBncmFkLCBsb3NzLCBuX3Zpb2wgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhfaXRlcmF0aW9uXG4gICAgICovXG4gICAgdHJhbnNmb3JtKG1heF9pdGVyYXRpb24gPSA0MDApIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGl0ZXIgPSAwOyBpdGVyIDwgbWF4X2l0ZXJhdGlvbjsgKytpdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGl0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heF9pdGVyYXRpb25cbiAgICAgKiBAeWllbGRzIHtNYXRyaXh9XG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICAqZ2VuZXJhdG9yKG1heF9pdGVyYXRpb24gPSA4MDApIHtcbiAgICAgICAgdGhpcy5jaGVja19pbml0KCk7XG4gICAgICAgIGZvciAobGV0IGl0ZXIgPSAwOyBpdGVyIDwgbWF4X2l0ZXJhdGlvbjsgKytpdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGl0ZXIpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgaXRlcmF0aW9uIHN0ZXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaXRlclxuICAgICAqL1xuICAgIF9uZXh0KGl0ZXIpIHtcbiAgICAgICAgY29uc3QgZ2FtbWEgPSBpdGVyID4gMTUwID8gMC41IDogMC4zO1xuICAgICAgICBjb25zdCBvbGRfQyA9IHRoaXMuQztcbiAgICAgICAgY29uc3QgdmVsID0gdGhpcy52ZWw7XG4gICAgICAgIGNvbnN0IFkgPSB0aGlzLlkuYWRkKHZlbC5tdWx0KGdhbW1hKSk7XG4gICAgICAgIGNvbnN0IHsgZ3JhZCwgbG9zcywgbl92aW9sIH0gPSB0aGlzLl9ncmFkKFkpO1xuICAgICAgICB0aGlzLkMgPSBsb3NzO1xuICAgICAgICB0aGlzLlkgPSB0aGlzLl91cGRhdGVfZW1iZWRkaW5nKFksIGl0ZXIsIGdyYWQpO1xuICAgICAgICB0aGlzLmxyICo9IG9sZF9DID4gbG9zcyArIHRoaXMuX3BhcmFtZXRlcnMudG9sID8gMS4wMSA6IDAuOTtcbiAgICAgICAgcmV0dXJuIHRoaXMuWTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBlbWJlZGRpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gWVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGdyYWRcbiAgICAgKi9cbiAgICBfdXBkYXRlX2VtYmVkZGluZyhZLCBpdGVyLCBncmFkKSB7XG4gICAgICAgIGNvbnN0IFtOLCBkaW1dID0gWS5zaGFwZTtcbiAgICAgICAgY29uc3QgZ2FtbWEgPSBpdGVyID4gMTUwID8gMC45IDogMC41OyAvLyBtb21lbnQgcGFyYW1ldGVyXG4gICAgICAgIGNvbnN0IG1pbl9nYWluID0gMC4wMTtcbiAgICAgICAgY29uc3QgZ2FpbiA9IHRoaXMuZ2FpbjtcbiAgICAgICAgY29uc3QgdmVsID0gdGhpcy52ZWw7XG4gICAgICAgIGNvbnN0IGxyID0gdGhpcy5scjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdfZ2FpbiA9IE1hdGguc2lnbih2ZWwuZW50cnkoaSwgZCkpICE9IE1hdGguc2lnbihncmFkLmVudHJ5KGksIGQpKSA/IGdhaW4uZW50cnkoaSwgZCkgKyAwLjIgOiBNYXRoLm1heChnYWluLmVudHJ5KGksIGQpICogMC44LCBtaW5fZ2Fpbik7XG4gICAgICAgICAgICAgICAgZ2Fpbi5zZXRfZW50cnkoaSwgZCwgbmV3X2dhaW4pO1xuICAgICAgICAgICAgICAgIHZlbC5zZXRfZW50cnkoaSwgZCwgZ2FtbWEgKiB2ZWwuZW50cnkoaSwgZCkgLSBsciAqIGdhaW4uZW50cnkoaSwgZCkgKiBncmFkLmVudHJ5KGksIGQpKTtcbiAgICAgICAgICAgICAgICBZLnNldF9lbnRyeShpLCBkLCBZLmVudHJ5KGksIGQpICsgdmVsLmVudHJ5KGksIGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBIaWVyYXJjaGljYWxfQ2x1c3RlcmluZ1xuICovXG5leHBvcnQgY2xhc3MgSGllcmFyY2hpY2FsX0NsdXN0ZXJpbmcge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y2x1c3RlcmluZ1xuICAgICAqIEBhbGlhcyBIaWVyYXJjaGljYWxfQ2x1c3RlcmluZ1xuICAgICAqIEB0b2RvIG5lZWRzIHJlc3RydWN0dXJpbmcuXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IC0gRGF0YSBvciBkaXN0YW5jZSBtYXRyaXggaWYgbWV0cmljIGlzICdwcmVjb21wdXRlZCdcbiAgICAgKiBAcGFyYW0geyhcInNpbmdsZVwifFwiY29tcGxldGVcInxcImF2ZXJhZ2VcIil9IFtsaW5rYWdlID0gXCJjb21wbGV0ZVwiXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbbWV0cmljID0gZXVjbGlkZWFuXVxuICAgICAqIEByZXR1cm5zIHtIaWVyYXJjaGljYWxfQ2x1c3RlcmluZ31cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIGxpbmthZ2UgPSBcImNvbXBsZXRlXCIsIG1ldHJpYyA9IGV1Y2xpZGVhbikge1xuICAgICAgICB0aGlzLl9pZCA9IDA7XG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeCBpbnN0YW5jZW9mIE1hdHJpeCA/IG1hdHJpeCA6IE1hdHJpeC5mcm9tKG1hdHJpeCk7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcbiAgICAgICAgdGhpcy5fbGlua2FnZSA9IGxpbmthZ2U7XG4gICAgICAgIGlmIChtZXRyaWMgPT09IFwicHJlY29tcHV0ZWRcIiAmJiB0aGlzLl9tYXRyaXguc2hhcGVbMF0gIT09IHRoaXMuX21hdHJpeC5zaGFwZVsxXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWYgbWV0cmljIGlzICdwcmVjb21wdXRlZCcsIHRoZW4gbWF0cml4IGhhcyB0byBiZSBzcXVhcmUhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLmRvKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdmFsdWUgd2hlcmUgdG8gY3V0IHRoZSB0cmVlLlxuICAgICAqIEBwYXJhbSB7KFwiZGlzdGFuY2VcInxcImRlcHRoXCIpfSBbdHlwZSA9IFwiZGlzdGFuY2VcIl0gLSB0eXBlIG9mIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IC0gQXJyYXkgb2YgY2x1c3RlcnMgd2l0aCB0aGUgaW5kaWNlcyBvZiB0aGUgcm93cyBpbiBnaXZlbiB7QGxpbmsgbWF0cml4fS5cbiAgICAgKi9cbiAgICBnZXRfY2x1c3RlcnModmFsdWUsIHR5cGUgPSBcImRpc3RhbmNlXCIpIHtcbiAgICAgICAgbGV0IGNsdXN0ZXJzID0gW107XG4gICAgICAgIGxldCBhY2Nlc3NvcjtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGlzdGFuY2VcIjpcbiAgICAgICAgICAgICAgICBhY2Nlc3NvciA9IChkKSA9PiBkLmRpc3Q7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVwdGhcIjpcbiAgICAgICAgICAgICAgICBhY2Nlc3NvciA9IChkKSA9PiBkLmRlcHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhdmVyc2UodGhpcy5yb290LCBhY2Nlc3NvciwgdmFsdWUsIGNsdXN0ZXJzKTtcbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IG5vZGVcbiAgICAgKiBAcGFyYW0geyp9IGZcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSByZXN1bHRcbiAgICAgKi9cbiAgICBfdHJhdmVyc2Uobm9kZSwgZiwgdmFsdWUsIHJlc3VsdCkge1xuICAgICAgICBpZiAoZihub2RlKSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZS5sZWF2ZXMoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmF2ZXJzZShub2RlLmxlZnQsIGYsIHZhbHVlLCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5fdHJhdmVyc2Uobm9kZS5yaWdodCwgZiwgdmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlcyB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9tYXRyaXg7XG4gICAgICAgIGNvbnN0IG4gPSAodGhpcy5fbiA9IEEuc2hhcGVbMF0pO1xuICAgICAgICBjb25zdCBkX21pbiA9ICh0aGlzLl9kX21pbiA9IG5ldyBGbG9hdDY0QXJyYXkobikpO1xuICAgICAgICBsZXQgZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICBpZiAobWV0cmljICE9PSBcInByZWNvbXB1dGVkXCIpIHtcbiAgICAgICAgICAgIGRpc3RhbmNlX21hdHJpeCA9IG5ldyBNYXRyaXgobiwgbiwgMCk7IC8vbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkX21pbltpXSA9IDA7XG4gICAgICAgICAgICAgICAgLy9kaXN0YW5jZV9tYXRyaXhbaV0gPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlX21hdHJpeC5zZXRfZW50cnkoaSwgaiwgaSA9PT0gaiA/IEluZmluaXR5IDogbWV0cmljKEEucm93KGkpLCBBLnJvdyhqKSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VfbWF0cml4LmVudHJ5KGksIGRfbWluW2ldKSA+IGRpc3RhbmNlX21hdHJpeC5lbnRyeShpLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZF9taW5baV0gPSBqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzdGFuY2VfbWF0cml4ID0gdGhpcy5fbWF0cml4LmNsb25lKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZV9tYXRyaXguc2V0X2VudHJ5KGksIGosIEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZV9tYXRyaXguZW50cnkoaSwgZF9taW5baV0pID4gZGlzdGFuY2VfbWF0cml4LmVudHJ5KGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkX21pbltpXSA9IGo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzdGFuY2VfbWF0cml4ID0gZGlzdGFuY2VfbWF0cml4O1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9ICh0aGlzLl9jbHVzdGVycyA9IG5ldyBBcnJheShuKSk7XG4gICAgICAgIGNvbnN0IGNfc2l6ZSA9ICh0aGlzLl9jX3NpemUgPSBuZXcgVWludDE2QXJyYXkobikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgY2x1c3RlcnNbaV0gPSBbXTtcbiAgICAgICAgICAgIGNsdXN0ZXJzW2ldWzBdID0gbmV3IENsdXN0ZXIodGhpcy5faWQrKywgbnVsbCwgbnVsbCwgMCwgQS5yb3coaSksIGksIDEsIDApO1xuICAgICAgICAgICAgY19zaXplW2ldID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlcyB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBkbygpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX247XG4gICAgICAgIGNvbnN0IGRfbWluID0gdGhpcy5fZF9taW47XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9kaXN0YW5jZV9tYXRyaXg7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gdGhpcy5fY2x1c3RlcnM7XG4gICAgICAgIGNvbnN0IGNfc2l6ZSA9IHRoaXMuX2Nfc2l6ZTtcbiAgICAgICAgY29uc3QgbGlua2FnZSA9IHRoaXMuX2xpbmthZ2U7XG4gICAgICAgIGxldCByb290ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgcCA9IDAsIHBfbWF4ID0gbiAtIDE7IHAgPCBwX21heDsgKytwKSB7XG4gICAgICAgICAgICBsZXQgYzEgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgRF9pX21pbiA9IEQuZW50cnkoaSwgZF9taW5baV0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRF9pX21pbiA+IEQuZW50cnkoaSwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRfbWluW2ldID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIERfaV9taW4gPSBELmVudHJ5KGksIGRfbWluW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEQuZW50cnkoaSwgZF9taW5baV0pIDwgRC5lbnRyeShjMSwgZF9taW5bYzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBjMSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGMyID0gZF9taW5bYzFdO1xuICAgICAgICAgICAgbGV0IGMxX2NsdXN0ZXIgPSBjbHVzdGVyc1tjMV1bMF07XG4gICAgICAgICAgICBsZXQgYzJfY2x1c3RlciA9IGNsdXN0ZXJzW2MyXVswXTtcbiAgICAgICAgICAgIGxldCBjMV9jbHVzdGVyX2luZGljZXMgPSBjMV9jbHVzdGVyLmlzTGVhZiA/IFtjMV9jbHVzdGVyLmluZGV4XSA6IGMxX2NsdXN0ZXIuaW5kZXg7XG4gICAgICAgICAgICBsZXQgYzJfY2x1c3Rlcl9pbmRpY2VzID0gYzJfY2x1c3Rlci5pc0xlYWYgPyBbYzJfY2x1c3Rlci5pbmRleF0gOiBjMl9jbHVzdGVyLmluZGV4O1xuICAgICAgICAgICAgbGV0IGluZGljZXMgPSBjMV9jbHVzdGVyX2luZGljZXMuY29uY2F0KGMyX2NsdXN0ZXJfaW5kaWNlcyk7XG4gICAgICAgICAgICBsZXQgbmV3X2NsdXN0ZXIgPSBuZXcgQ2x1c3Rlcih0aGlzLl9pZCsrLCBjMV9jbHVzdGVyLCBjMl9jbHVzdGVyLCBELmVudHJ5KGMxLCBjMiksIG51bGwsIGluZGljZXMpO1xuICAgICAgICAgICAgYzFfY2x1c3Rlci5wYXJlbnQgPSBuZXdfY2x1c3RlcjtcbiAgICAgICAgICAgIGMyX2NsdXN0ZXIucGFyZW50ID0gbmV3X2NsdXN0ZXI7XG4gICAgICAgICAgICBjbHVzdGVyc1tjMV0udW5zaGlmdChuZXdfY2x1c3Rlcik7XG4gICAgICAgICAgICBjX3NpemVbYzFdICs9IGNfc2l6ZVtjMl07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IERfYzFfaiA9IEQuZW50cnkoYzEsIGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IERfYzJfaiA9IEQuZW50cnkoYzIsIGopO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGxpbmthZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNpbmdsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihEX2MxX2osIERfYzJfaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KERfYzFfaiwgRF9jMl9qKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXZlcmFnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoY19zaXplW2MxXSAqIERfYzFfaiArIGNfc2l6ZVtjMl0gKiBEX2MyX2opIC8gKGNfc2l6ZVtjMV0gKyBjX3NpemVbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEQuc2V0X2VudHJ5KGosIGMxLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgRC5zZXRfZW50cnkoYzEsIGosIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgRC5zZXRfZW50cnkoYzEsIGMxLCBJbmZpbml0eSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIEQuc2V0X2VudHJ5KGksIGMyLCBJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgRC5zZXRfZW50cnkoYzIsIGksIEluZmluaXR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogZm9yIChsZXQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAoZF9taW5bal0gPT09IGMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRfbWluW2pdID0gYzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChELmVudHJ5KGMxLCBqKSA8IEQuZW50cnkoYzEsIGRfbWluW2MxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZF9taW5bYzFdID0gajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICovXG4gICAgICAgICAgICByb290ID0gbmV3X2NsdXN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxufVxuXG5jbGFzcyBDbHVzdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgbGVmdCwgcmlnaHQsIGRpc3QsIGNlbnRyb2lkLCBpbmRleCwgc2l6ZSwgZGVwdGgpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuZGlzdCA9IGRpc3Q7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZSA/PyBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGggPz8gMSArIE1hdGgubWF4KGxlZnQuZGVwdGgsIHJpZ2h0LmRlcHRoKTtcbiAgICAgICAgdGhpcy5jZW50cm9pZCA9IGNlbnRyb2lkID8/IHRoaXMuX2NhbGN1bGF0ZV9jZW50cm9pZChsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZV9jZW50cm9pZChsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBsX3NpemUgPSBsZWZ0LnNpemU7XG4gICAgICAgIGNvbnN0IHJfc2l6ZSA9IHJpZ2h0LnNpemU7XG4gICAgICAgIGNvbnN0IGxfY2VudHJvaWQgPSBsZWZ0LmNlbnRyb2lkO1xuICAgICAgICBjb25zdCByX2NlbnRyb2lkID0gcmlnaHQuY2VudHJvaWQ7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGNvbnN0IG4gPSBsZWZ0LmNlbnRyb2lkLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3X2NlbnRyb2lkID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIG5ld19jZW50cm9pZFtpXSA9IChsX3NpemUgKiBsX2NlbnRyb2lkW2ldICsgcl9zaXplICogcl9jZW50cm9pZFtpXSkgLyBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdfY2VudHJvaWQ7XG4gICAgfVxuXG4gICAgZ2V0IGlzTGVhZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGggPT09IDA7XG4gICAgfVxuXG4gICAgbGVhdmVzKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xlYWYpIHJldHVybiBbdGhpc107XG4gICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodDtcbiAgICAgICAgcmV0dXJuIChsZWZ0LmlzTGVhZiA/IFtsZWZ0XSA6IGxlZnQubGVhdmVzKCkpLmNvbmNhdChyaWdodC5pc0xlYWYgPyBbcmlnaHRdIDogcmlnaHQubGVhdmVzKCkpO1xuICAgIH1cblxuICAgIGRlc2NlbmRhbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xlYWYpIHJldHVybiBbdGhpc107XG4gICAgICAgIGNvbnN0IGxlZnRfZGVzY2VuZGFudHMgPSB0aGlzLmxlZnQuZGVzY2VuZGFudHMoKTtcbiAgICAgICAgY29uc3QgcmlnaHRfZGVzY2VuZGFudHMgPSB0aGlzLnJpZ2h0LmRlc2NlbmRhbnRzKCk7XG4gICAgICAgIHJldHVybiBsZWZ0X2Rlc2NlbmRhbnRzLmNvbmNhdChyaWdodF9kZXNjZW5kYW50cykuY29uY2F0KFt0aGlzXSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFJhbmRvbWl6ZXIgfSBmcm9tIFwiLi4vdXRpbC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSGVhcCB9IGZyb20gXCIuLi9kYXRhc3RydWN0dXJlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBsaW5zcGFjZSB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBLTWVhbnNcbiAqL1xuZXhwb3J0IGNsYXNzIEtNZWFucyB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjbHVzdGVyaW5nXG4gICAgICogQGFsaWFzIEtNZWFuc1xuICAgICAqIEB0b2RvIG5lZWRzIHJlc3RydWN0dXJpbmcuIFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXggXG4gICAgICogQHBhcmFtIHtOdW1iZXJzfSBLIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFttZXRyaWMgPSBldWNsaWRlYW5dIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VlZCA9IDE5ODddXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5pdCA9IHRydWVdXG4gICAgICogQHJldHVybnMge0tNZWFuc31cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIEssIG1ldHJpYyA9IGV1Y2xpZGVhbiwgc2VlZD0xOTg3LCBpbml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9tZXRyaWMgPSBtZXRyaWM7XG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeDtcbiAgICAgICAgdGhpcy5fSyA9IEs7XG4gICAgICAgIGNvbnN0IFtOLCBEXSA9IG1hdHJpeC5zaGFwZTtcbiAgICAgICAgdGhpcy5fTiA9IE47XG4gICAgICAgIHRoaXMuX0QgPSBEO1xuICAgICAgICBpZiAoSyA+IE4pIEsgPSBOO1xuICAgICAgICB0aGlzLl9yYW5kb21pemVyID0gbmV3IFJhbmRvbWl6ZXIoc2VlZCk7XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJzID0gbmV3IEFycmF5KE4pLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fY2x1c3Rlcl9jZW50cm9pZHMgPSB0aGlzLl9nZXRfcmFuZG9tX2NlbnRyb2lkcyhLKTtcbiAgICAgICAgaWYgKGluaXQpIHRoaXMuaW5pdChLLCB0aGlzLl9jbHVzdGVyX2NlbnRyb2lkcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IC0gQXJyYXkgb2YgY2x1c3RlcnMgd2l0aCB0aGUgaW5kaWNlcyBvZiB0aGUgcm93cyBpbiBnaXZlbiB7QGxpbmsgbWF0cml4fS4gXG4gICAgICovXG4gICAgZ2V0X2NsdXN0ZXJzKCkge1xuICAgICAgICBjb25zdCBLID0gdGhpcy5fSztcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSB0aGlzLl9jbHVzdGVycztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KEspLmZpbGwoKS5tYXAoKCkgPT4gbmV3IEFycmF5KCkpO1xuICAgICAgICBjbHVzdGVycy5mb3JFYWNoKChjLCBpKSA9PiByZXN1bHRbY10ucHVzaChpKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2FuZGlkYXRlcyBcbiAgICAgKi9cbiAgICBfZnVydGhlc3RfcG9pbnQocG9pbnRzLCBjYW5kaWRhdGVzKSB7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9tYXRyaXg7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgbGV0IGkgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBsZXQgSCA9IEhlYXAuaGVhcGlmeShcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMsIFxuICAgICAgICAgICAgKGQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBBZCA9IEEucm93KGQpXG4gICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IG1ldHJpYyhBZCwgcG9pbnRzW2pdKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICBcIm1heFwiXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIEgucG9wKCkuZWxlbWVudDtcbiAgICB9XG5cbiAgICBfZ2V0X3JhbmRvbV9jZW50cm9pZHMoSykge1xuICAgICAgICBjb25zdCBOID0gdGhpcy5fTjtcbiAgICAgICAgY29uc3QgcmFuZG9taXplciA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9tYXRyaXg7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJfY2VudHJvaWRzID0gbmV3IEFycmF5KEspLmZpbGwoKVxuICAgICAgICBjb25zdCBpbmRpY2VzID0gbGluc3BhY2UoMCwgTiAtIDEpO1xuICAgICAgICBjb25zdCByYW5kb21fcG9pbnQgPSByYW5kb21pemVyLnJhbmRvbV9pbnQgJSAoTiAtIDEpO1xuICAgICAgICBjbHVzdGVyX2NlbnRyb2lkc1swXSA9IEEucm93KHJhbmRvbV9wb2ludCk7XG4gICAgICAgIGNvbnN0IGluaXRfcG9pbnRzID0gW3JhbmRvbV9wb2ludF07XG4gICAgICAgIGNvbnN0IHNhbXBsZV9zaXplID0gTWF0aC5mbG9vcigoTiAtIEspIC8gSyk7Ly8gLyBLXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgSzsgKytpKSB7XG4gICAgICAgICAgICAvLyBzYW1wbGluZyArIGttZWFucysrIGltcHJvdmVtZW50P1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlID0gcmFuZG9taXplci5jaG9pY2UoaW5kaWNlcy5maWx0ZXIoZCA9PiBpbml0X3BvaW50cy5pbmRleE9mKGQpID09IC0xKSwgc2FtcGxlX3NpemUpO1xuICAgICAgICAgICAgY29uc3QgZnVydGhlc3RfcG9pbnQgPSB0aGlzLl9mdXJ0aGVzdF9wb2ludChjbHVzdGVyX2NlbnRyb2lkcy5zbGljZSgwLCBpKSwgc2FtcGxlKTtcbiAgICAgICAgICAgIGluaXRfcG9pbnRzLnB1c2goZnVydGhlc3RfcG9pbnQpO1xuICAgICAgICAgICAgY2x1c3Rlcl9jZW50cm9pZHNbaV0gPSBBLnJvdyhmdXJ0aGVzdF9wb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJfY2VudHJvaWRzO1xuICAgIH1cblxuICAgIF9pdGVyYXRpb24oY2x1c3Rlcl9jZW50cm9pZHMpIHtcbiAgICAgICAgY29uc3QgSyA9IGNsdXN0ZXJfY2VudHJvaWRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9EO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fbWF0cml4O1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gdGhpcy5fY2x1c3RlcnM7XG4gICAgICAgIGxldCBjbHVzdGVyc19jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIC8vIGZpbmQgbmVhcmVzdCBjbHVzdGVyIGNlbnRyb2lkLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgQWkgPSBBLnJvdyhpKVxuICAgICAgICAgICAgbGV0IG1pbl9kaXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBsZXQgbWluX2NsdXN0ZXIgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBLOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgZCA9IG1ldHJpYyhjbHVzdGVyX2NlbnRyb2lkc1tqXSwgQWkpO1xuICAgICAgICAgICAgICAgIGlmIChkIDwgbWluX2Rpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluX2Rpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICBtaW5fY2x1c3RlciA9IGo7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbHVzdGVyc1tpXSAhPT0gbWluX2NsdXN0ZXIpIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyc19jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsdXN0ZXJzW2ldID0gbWluX2NsdXN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGNsdXN0ZXIgY2VudHJvaWRcbiAgICAgICAgLy8gcmVzZXQgY2x1c3RlciBjZW50cm9pZHMgdG8gMFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEs7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY2VudHJvaWQgPSBjbHVzdGVyX2NlbnRyb2lkc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgRDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2VudHJvaWRbal0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXB1dGUgY2VudHJvaWRcbiAgICAgICAgdGhpcy5fY29tcHV0ZV9jZW50cm9pZChjbHVzdGVyX2NlbnRyb2lkcyk7XG5cbiAgICAgICAgcmV0dXJuIHsgICBcbiAgICAgICAgICAgIFwiY2x1c3RlcnNfY2hhbmdlZFwiOiBjbHVzdGVyc19jaGFuZ2VkLFxuICAgICAgICAgICAgXCJjbHVzdGVyX2NlbnRyb2lkc1wiOiBjbHVzdGVyX2NlbnRyb2lkc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9jb21wdXRlX2NlbnRyb2lkKGNsdXN0ZXJfY2VudHJvaWRzKSB7XG4gICAgICAgIGNvbnN0IEsgPSBjbHVzdGVyX2NlbnRyb2lkcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBEID0gdGhpcy5fRDtcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX21hdHJpeDtcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSB0aGlzLl9jbHVzdGVycztcbiAgICAgICAgY29uc3QgY2x1c3Rlcl9jb3VudGVyID0gbmV3IEFycmF5KEspLmZpbGwoMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IEFpID0gQS5yb3coaSk7XG4gICAgICAgICAgICBjb25zdCBjaSA9IGNsdXN0ZXJzW2ldO1xuICAgICAgICAgICAgY2x1c3Rlcl9jb3VudGVyW2NpXSsrO1xuICAgICAgICAgICAgY29uc3QgY2VudHJvaWQgPSBjbHVzdGVyX2NlbnRyb2lkc1tjaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IEQ7ICsraikge1xuICAgICAgICAgICAgICAgIGNlbnRyb2lkW2pdICs9IEFpW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSzsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gY2x1c3Rlcl9jb3VudGVyW2ldO1xuICAgICAgICAgICAgY2x1c3Rlcl9jZW50cm9pZHNbaV0gPSBjbHVzdGVyX2NlbnRyb2lkc1tpXS5tYXAoYyA9PiBjIC8gbik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMge0BsaW5rIEt9IGNsdXN0ZXJzIG91dCBvZiB0aGUge0BsaW5rIG1hdHJpeH0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IEsgLSBudW1iZXIgb2YgY2x1c3RlcnMuXG4gICAgICovXG4gICAgaW5pdChLLCBjbHVzdGVyX2NlbnRyb2lkcykge1xuICAgICAgICBpZiAoIUspIEsgPSB0aGlzLl9LO1xuICAgICAgICBpZiAoIWNsdXN0ZXJfY2VudHJvaWRzKSBjbHVzdGVyX2NlbnRyb2lkcyA9IHRoaXMuX2dldF9yYW5kb21fY2VudHJvaWRzKEspO1xuICAgICAgICBsZXQgY2x1c3RlcnNfY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBpdGVyYXRpb25fcmVzdWx0ID0gdGhpcy5faXRlcmF0aW9uKGNsdXN0ZXJfY2VudHJvaWRzKVxuICAgICAgICAgICAgY2x1c3Rlcl9jZW50cm9pZHMgPSBpdGVyYXRpb25fcmVzdWx0LmNsdXN0ZXJfY2VudHJvaWRzO1xuICAgICAgICAgICAgY2x1c3RlcnNfY2hhbmdlZCA9IGl0ZXJhdGlvbl9yZXN1bHQuY2x1c3RlcnNfY2hhbmdlZDtcbiAgICAgICAgfSB3aGlsZSAoY2x1c3RlcnNfY2hhbmdlZClcbiAgICB9XG4gICAgXG59XG4iLCJpbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUmFuZG9taXplciB9IGZyb20gXCIuLi91dGlsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBsaW5zcGFjZSwgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbWluIH0gZnJvbSBcIi4uL3V0aWwvaW5kZXguanNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgS01lZG9pZHNcbiAqL1xuZXhwb3J0IGNsYXNzIEtNZWRvaWRzIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNsdXN0ZXJpbmdcbiAgICAgKiBAYWxpYXMgS01lZG9pZHNcbiAgICAgKiBAdG9kbyBuZWVkcyByZXN0cnVjdHVyaW5nLiBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4IC0gZGF0YSBtYXRyaXhcbiAgICAgKiBAcGFyYW0ge051bWJlcnN9IEsgLSBudW1iZXIgb2YgY2x1c3RlcnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heF9pdGVyPW51bGxdIC0gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucy4gRGVmYXVsdCBpcyAxMCAqIE1hdGgubG9nMTAoTilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWV0cmljID0gZXVjbGlkZWFuXSAtIG1ldHJpYyBkZWZpbmluZyB0aGUgZGlzc2ltaWxhcml0eSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlZWQgPSAxMjEyXSAtIHNlZWQgdmFsdWUgZm9yIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gICAgICogQHJldHVybnMge0tNZWRvaWRzfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbGluay5zcHJpbmdlci5jb20vY2hhcHRlci8xMC4xMDA3Lzk3OC0zLTAzMC0zMjA0Ny04XzE2fSBGYXN0ZXIgay1NZWRvaWRzIENsdXN0ZXJpbmc6IEltcHJvdmluZyB0aGUgUEFNLCBDTEFSQSwgYW5kIENMQVJBTlMgQWxnb3JpdGhtc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1hdHJpeCwgSywgbWF4X2l0ZXI9bnVsbCwgbWV0cmljID0gZXVjbGlkZWFuLCBzZWVkPTEyMTIpIHtcbiAgICAgICAgdGhpcy5fbWV0cmljID0gbWV0cmljO1xuICAgICAgICB0aGlzLl9tYXRyaXggPSBtYXRyaXg7XG4gICAgICAgIHRoaXMuX0EgPSB0aGlzLl9tYXRyaXgudG8yZEFycmF5O1xuICAgICAgICB0aGlzLl9LID0gSztcbiAgICAgICAgY29uc3QgW04sIERdID0gbWF0cml4LnNoYXBlO1xuICAgICAgICB0aGlzLl9OID0gTjtcbiAgICAgICAgdGhpcy5fRCA9IEQ7XG4gICAgICAgIHRoaXMuX21heF9pdGVyID0gbWF4X2l0ZXIgfHwgMTAgKiBNYXRoLmxvZzEwKE4pIFxuICAgICAgICB0aGlzLl9kaXN0YW5jZV9tYXRyaXggPSBuZXcgTWF0cml4KE4sIE4sIFwiemVyb3NcIik7XG4gICAgICAgIC8qIGZvciAobGV0IGkgPSAxOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IG1ldHJpYyh0aGlzLl9BW2ldLCB0aGlzLl9BW2pdKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZV9tYXRyaXguc2V0X2VudHJ5KGksIGosIGRpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlX21hdHJpeC5zZXRfZW50cnkoaiwgaSwgZGlzdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAqL1xuICAgICAgICBpZiAoSyA+IE4pIEsgPSBOO1xuICAgICAgICB0aGlzLl9yYW5kb21pemVyID0gbmV3IFJhbmRvbWl6ZXIoc2VlZCk7XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJzID0gbmV3IEFycmF5KE4pLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fY2x1c3Rlcl9tZWRvaWRzID0gdGhpcy5fZ2V0X3JhbmRvbV9tZWRvaWRzKEspO1xuICAgICAgICAvL2lmIChpbml0KSB0aGlzLmluaXQoSywgdGhpcy5fY2x1c3Rlcl9tZWRvaWRzKTtcbiAgICAgICAgdGhpcy5faXNfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gLSBBcnJheSBvZiBjbHVzdGVycyB3aXRoIHRoZSBpbmRpY2VzIG9mIHRoZSByb3dzIGluIGdpdmVuIHtAbGluayBtYXRyaXh9LiBcbiAgICAgKi9cbiAgICBnZXRfY2x1c3RlcnMoKSB7XG4gICAgICAgIGNvbnN0IEsgPSB0aGlzLl9LO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc19pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0KEssIHRoaXMuX2NsdXN0ZXJfbWVkb2lkcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KEspLmZpbGwoKS5tYXAoKCkgPT4gbmV3IEFycmF5KCkpO1xuICAgICAgICBBLmZvckVhY2goKHhfaiwgaikgPT4ge1xuICAgICAgICAgICAgcmVzdWx0W3RoaXMuX25lYXJlc3RfbWVkb2lkKHhfaiwgaikuaW5kZXhfbmVhcmVzdF0ucHVzaChqKTtcbiAgICAgICAgfSlcbiAgICAgICAgcmVzdWx0Lm1lZG9pZHMgPSB0aGlzLl9jbHVzdGVyX21lZG9pZHM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMqIGdlbmVyYXRvcigpIHtcbiAgICAgICAgY29uc3QgbWF4X2l0ZXIgPSB0aGlzLl9tYXhfaXRlcjtcbiAgICAgICAgeWllbGQgdGhpcy5nZXRfY2x1c3RlcnMoKVxuICAgICAgICBsZXQgZmluaXNoID0gZmFsc2U7XG4gICAgICAgIGxldCBpID0gMFxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBmaW5pc2ggPSB0aGlzLl9pdGVyYXRpb24oKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0X2NsdXN0ZXJzKCk7XG4gICAgICAgIH0gd2hpbGUgKCFmaW5pc2ggJiYgKytpIDwgbWF4X2l0ZXIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxnb3JpdGhtIDEuIEZhc3RQQU0xOiBJbXByb3ZlZCBTV0FQIGFsZ29yaXRobVxuICAgICAqL1xuICAgIC8qIF9pdGVyYXRpb25fMSgpIHtcbiAgICAgICAgY29uc3QgQSA9IHRoaXMuX0E7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBLID0gdGhpcy5fSztcbiAgICAgICAgY29uc3QgbWVkb2lkcyA9IHRoaXMuX2NsdXN0ZXJfbWVkb2lkcztcbiAgICAgICAgbGV0IERlbHRhVEQgPSAwO1xuICAgICAgICBsZXQgbTAgPSBudWxsO1xuICAgICAgICBsZXQgeDAgPSBudWxsO1xuICAgICAgICBBLmZvckVhY2goKHhfaiwgaikgPT4ge1xuICAgICAgICAgICAgaWYgKG1lZG9pZHMuZmluZEluZGV4KG0gPT4gbSA9PT0gaikgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmVhcmVzdF9tZWRvaWQgPSB0aGlzLl9uZWFyZXN0X21lZG9pZCh4X2osIGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRfaiA9IG5lYXJlc3RfbWVkb2lkLmRpc3RhbmNlX25lYXJlc3Q7IC8vIGRpc3RhbmNlIHRvIGN1cnJlbnQgbWVkb2lkXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFURCA9IG5ldyBBcnJheShLKS5maWxsKC1kX2opOyAvLyBjaGFuZ2UgaWYgbWFraW5nIGogYSBtZWRvaWRcbiAgICAgICAgICAgICAgICBBLmZvckVhY2goKHhfbywgbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBkaXNhbmNlIHRvIG5ldyBtZWRvaWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZF9vaiA9IHRoaXMuX2dldF9kaXN0YW5jZShvLCBqLCB4X28sIHhfaik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5kZXhfbmVhcmVzdFwiOiBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXN0YW5jZV9uZWFyZXN0XCI6IGRfbixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzdGFuY2Vfc2Vjb25kXCI6IGRfcyxcbiAgICAgICAgICAgICAgICAgICAgfSA9IHRoaXMuX25lYXJlc3RfbWVkb2lkKHhfbywgbyk7IFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbHVzdGVyc1tvXSA9IG47IC8vIGNhY2hlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFURFtuXSArPSBNYXRoLm1pbihkX29qLCBkX3MpIC0gZF9uOyAvLyBsb3NzIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZF9vaiA8IGRfbikgeyAvLyByZWFzc2lnbm1lbnQgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVEQuZm9yRWFjaCgoZF9pLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFURFtpXSA9IGRfaSArIGRfb2ogLSBkX247IC8vIHVwZGF0ZSBsb3NzIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gY2hvb3NlIGJlc3QgbWVkb2lkIGk7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IGRlbHRhVERcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoZCwgaSkgPT4gW2QsIGldKVxuICAgICAgICAgICAgICAgICAgICAuc29ydCgoZDEsIGQyKSA9PiBkMVswXSAtIGQyWzBdKVswXVsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVREX2kgPSBkZWx0YVREW2ldO1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlXG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhVERfaSA8IERlbHRhVEQpIHtcbiAgICAgICAgICAgICAgICAgICAgRGVsdGFURCA9IGRlbHRhVERfaTtcbiAgICAgICAgICAgICAgICAgICAgbTAgPSBpO1xuICAgICAgICAgICAgICAgICAgICB4MCA9IGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoRGVsdGFURCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZSAvLyBicmVhayBsb29wIGlmIERlbHRhVEQgPj0gMFxuICAgICAgICB9XG4gICAgICAgIC8vIHN3YXAgcm9sZXMgb2YgbWVkb2lkIG0gYW5kIG5vbi1tZWRvaWQgeDtcbiAgICAgICAgbWVkb2lkc1ttMF0gPSB4MDtcbiAgICAgICAgdGhpcy5fY2x1c3Rlcl9tZWRvaWRzID0gbWVkb2lkcztcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSAqL1xuXG4gICAgLyoqIEFsZ29yaXRobSAyLiBGYXN0UEFNMjogU1dBUCB3aXRoIG11bHRpcGxlIGNhbmRpZGF0ZXNcbiAgICAgKiBcbiAgICAgKi9cbiAgICBfaXRlcmF0aW9uKCkge1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgSyA9IHRoaXMuX0s7XG4gICAgICAgIGNvbnN0IG1lZG9pZHMgPSB0aGlzLl9jbHVzdGVyX21lZG9pZHM7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gQS5tYXAoKHhfbywgbykgPT4gdGhpcy5fbmVhcmVzdF9tZWRvaWQoeF9vLCBvKSk7XG4gICAgICAgIC8vIGVtcHR5IGJlc3QgY2FuZGlkYXRlcyBhcnJheVxuICAgICAgICBjb25zdCBEZWx0YVREID0gbmV3IEFycmF5KEspLmZpbGwoMCk7XG4gICAgICAgIGNvbnN0IHhzID0gbmV3IEFycmF5KEspLmZpbGwobnVsbCk7XG4gICAgICAgIEEuZm9yRWFjaCgoeF9qLCBqKSA9PiB7XG4gICAgICAgICAgICBpZiAobWVkb2lkcy5maW5kSW5kZXgobSA9PiBtID09PSBqKSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkX2ogPSBjYWNoZVtqXS5kaXN0YW5jZV9uZWFyZXN0OyAvLyBkaXN0YW5jZSB0byBjdXJyZW50IG1lZG9pZFxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhVEQgPSBuZXcgQXJyYXkoSykuZmlsbCgtZF9qKTsgLy8gY2hhbmdlIGlmIG1ha2luZyBqIGEgbWVkb2lkXG4gICAgICAgICAgICAgICAgQS5mb3JFYWNoKCh4X28sIG8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IG8pIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZF9vaiA9IHRoaXMuX2dldF9kaXN0YW5jZShvLCBqLCB4X28sIHhfaik7IC8vIGRpc3RhbmNlIHRvIG5ldyBtZWRvaWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qge1wiaW5kZXhfbmVhcmVzdFwiOiBuLCBcImRpc3RhbmNlX25lYXJlc3RcIjogZF9uLCBcImRpc3RhbmNlX3NlY29uZFwiOiBkX3N9ID0gY2FjaGVbb107IC8vIGNhY2hlZFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVREW25dICs9IE1hdGgubWluKGRfb2osIGRfcykgLSBkX247IC8vIGxvc3MgY2hhbmdlIGZvciB4X29cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhc3NpZ25tZW50IGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChkX29qIDwgZF9uKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGxvc3MgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEs7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBuKSBkZWx0YVREW2ldICs9IGRfb2ogLSBkX247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyByZW1lbWJlciBiZXN0IHN3YXAgZm9yIGk7XG4gICAgICAgICAgICAgICAgZGVsdGFURFxuICAgICAgICAgICAgICAgICAgICAubWFwKChkLCBpKSA9PiBbZCwgaV0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtkLCBpXSkgPT4gZCA8IERlbHRhVERbaV0pXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKChbZCwgaV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgRGVsdGFURFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlbHRhVERbaV0gPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhzW2ldID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLy8gc3RvcCBpZiBubyBpbXByb3ZlbWVudHMgd2VyZSBmb3VuZFxuICAgICAgICBpZiAobWluKERlbHRhVEQpID49IDApIHJldHVybiB0cnVlOyBcblxuICAgICAgICAvLyBleGVjdXRlIGFsbCBpbXByb3ZlbWVudHNcbiAgICAgICAgd2hpbGUgKG1pbihEZWx0YVREKSA8IDApIHtcbiAgICAgICAgICAgIC8vIHN3YXAgcm9sZXMgb2YgbWVkb2lkIG1faSBhbmQgbm9uX21lZG9pZCB4c19pXG4gICAgICAgICAgICBjb25zdCBpID0gRGVsdGFURFxuICAgICAgICAgICAgICAgIC5tYXAoKGQsIGkpID0+IFtkLCBpXSlcbiAgICAgICAgICAgICAgICAuc29ydCgoW2FdLCBbYl0pID0+IGEgLSBiKVswXVsxXTtcbiAgICAgICAgICAgIGlmIChtZWRvaWRzLmZpbHRlcihtID0+IG0gPT0geHNbaV0pLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbWVkb2lkc1tpXSA9IHhzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGlzYWJsZSB0aGUgc3dhcCBqdXN0IHBlcmZvcm1lZFxuICAgICAgICAgICAgRGVsdGFURFtpXSA9IDA7IFxuICAgICAgICAgICAgLy8gcmVjb21wdXRlIFREIGZvciByZW1haW5pbmcgc3dhcCBjYW5kaWRhdGVzXG4gICAgICAgICAgICBEZWx0YVREXG4gICAgICAgICAgICAgICAgLm1hcCgoZF9qLCBqKSA9PiBbZF9qLCBqXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbZF9qXSkgPT4gZF9qIDwgMClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoW18sIGpdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhfaiA9IEFbal07XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBBLmZvckVhY2goKHhfbywgbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lZG9pZHMuZmluZEluZGV4KG0gPT4gbSAhPSBqICYmIG0gPT0gbykgPj0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gaikgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlW29dLmluZGV4X25lYXJlc3QgPT09IG1lZG9pZHNbal0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IChNYXRoLm1pbih0aGlzLl9nZXRfZGlzdGFuY2UobywgaiwgeF9vLCB4X2opLCBjYWNoZVtvXS5kaXN0YW5jZV9zZWNvbmQpIC0gY2FjaGVbb10uZGlzdGFuY2VfbmVhcmVzdCk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IChNYXRoLm1pbih0aGlzLl9nZXRfZGlzdGFuY2UobywgaiwgeF9vLCB4X2opIC0gY2FjaGVbb10uZGlzdGFuY2VfbmVhcmVzdCwgMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgRGVsdGFURFtqXSA9IHN1bTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsdXN0ZXJfbWVkb2lkcyA9IG1lZG9pZHM7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBfZ2V0X2Rpc3RhbmNlKGksIGosIHhfaT1udWxsLCB4X2o9bnVsbCkge1xuICAgICAgICBpZiAoaSA9PT0gaikgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9kaXN0YW5jZV9tYXRyaXg7XG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLl9BO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGxldCBkX2lqID0gRC5lbnRyeShpLCBqKTtcbiAgICAgICAgaWYgKGRfaWogPT09IDApIHtcbiAgICAgICAgICAgIGRfaWogPSBtZXRyaWMoeF9pIHx8IEFbaV0sIHhfaiB8fCBBW2pdKTtcbiAgICAgICAgICAgIEQuc2V0X2VudHJ5KGksIGosIGRfaWopO1xuICAgICAgICAgICAgRC5zZXRfZW50cnkoaiwgaSwgZF9paik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRfaWo7XG4gICAgfVxuXG4gICAgX25lYXJlc3RfbWVkb2lkKHhfaiwgaikge1xuICAgICAgICBjb25zdCBtZWRvaWRzID0gdGhpcy5fY2x1c3Rlcl9tZWRvaWRzO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgW25lYXJlc3QsIHNlY29uZF0gPSBtZWRvaWRzXG4gICAgICAgICAgICAubWFwKChtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeF9tID0gQVttXTsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLl9nZXRfZGlzdGFuY2UoaiwgbSwgeF9qLCB4X20pLCBpXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc29ydCgobTEsIG0yKSA9PiBtMVswXSAtIG0yWzBdKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgXCJkaXN0YW5jZV9uZWFyZXN0XCI6IG5lYXJlc3RbMF0sIFxuICAgICAgICAgICAgXCJpbmRleF9uZWFyZXN0XCI6IG5lYXJlc3RbMV0sXG4gICAgICAgICAgICBcImRpc3RhbmNlX3NlY29uZFwiOiBzZWNvbmRbMF0sXG4gICAgICAgICAgICBcImluZGV4X3NlY29uZFwiOiBzZWNvbmRbMV0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMge0BsaW5rIEt9IGNsdXN0ZXJzIG91dCBvZiB0aGUge0BsaW5rIG1hdHJpeH0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IEsgLSBudW1iZXIgb2YgY2x1c3RlcnMuXG4gICAgICovXG4gICAgaW5pdChLLCBjbHVzdGVyX21lZG9pZHMpIHtcbiAgICAgICAgaWYgKCFLKSBLID0gdGhpcy5fSztcbiAgICAgICAgaWYgKCFjbHVzdGVyX21lZG9pZHMpIGNsdXN0ZXJfbWVkb2lkcyA9IHRoaXMuX2dldF9yYW5kb21fbWVkb2lkcyhLKTtcbiAgICAgICAgY29uc3QgbWF4X2l0ZXIgPSB0aGlzLl9tYXhfaXRlcjtcbiAgICAgICAgbGV0IGZpbmlzaCA9IGZhbHNlO1xuICAgICAgICBsZXQgaSA9IDBcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZmluaXNoID0gdGhpcy5faXRlcmF0aW9uKCk7XG4gICAgICAgIH0gd2hpbGUgKCFmaW5pc2ggJiYgKytpIDwgbWF4X2l0ZXIpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsZ29yaXRobSAzLiBGYXN0UEFNIExBQjogTGluZWFyIEFwcHJveGltYXRlIEJVSUxEIGluaXRpYWxpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBLIC0gbnVtYmVyIG9mIGNsdXN0ZXJzXG4gICAgICogXG4gICAgICovXG4gICAgX2dldF9yYW5kb21fbWVkb2lkcyhLKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9OO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IGxpbnNwYWNlKDAsIE4gLSAxKTtcbiAgICAgICAgY29uc3QgcmFuZG9taXplciA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihOLCAxMCArIE1hdGguY2VpbChNYXRoLnNxcnQoTikpKTtcbiAgICAgICAgY29uc3QgVEQgPSBuZXcgQXJyYXkobikuZmlsbChJbmZpbml0eSk7XG4gICAgICAgIGNvbnN0IG1lZG9pZHMgPSBbXTtcbiAgICAgICAgLy8gZmlyc3QgbWVkb2lkXG4gICAgICAgIGxldCBURDAgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IFMgPSByYW5kb21pemVyLmNob2ljZShpbmRpY2VzLCBuKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IFNfaiA9IFNbal07XG4gICAgICAgICAgICBjb25zdCB4X2ogPSBBW1Nfal07XG4gICAgICAgICAgICBmb3IgKGxldCBvID0gMDsgbyA8IG47ICsrbykge1xuICAgICAgICAgICAgICAgIGlmIChvID09PSBqKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB4X28gPSBBW1Nbb11dO1xuICAgICAgICAgICAgICAgIFREW2pdICs9IHRoaXMuX2dldF9kaXN0YW5jZShqLCBvLCB4X2osIHhfbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVERbal0gPCBURDApIHtcbiAgICAgICAgICAgICAgICBURDAgPSBURFtqXTsgLy8gc21hbGxlc3QgZGlzdGFuY2Ugc3VtXG4gICAgICAgICAgICAgICAgbWVkb2lkcy5wdXNoKFNfaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXIgbWVkb2lkc1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEs7ICsraSkge1xuICAgICAgICAgICAgbGV0IERlbHRhVEQgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIFMgPSByYW5kb21pemVyLmNob2ljZShpbmRpY2VzLmZpbHRlcihpbmRleCA9PiBtZWRvaWRzLmZpbmRJbmRleChkID0+IGQgPT09IGluZGV4KSA8IDApLCBuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlbHRhVEQgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IFNfaiA9IFNbal07XG4gICAgICAgICAgICAgICAgY29uc3QgeF9qID0gQVtTX2pdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgbjsgKytvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvID09PSBqKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgU19vID0gU1tvXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeF9vID0gQVtTX29dO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGEgPSB0aGlzLl9nZXRfZGlzdGFuY2UoU19qLCBTX28sIHhfaiwgeF9vKSAtIG1pbihtZWRvaWRzLm1hcChtID0+IHRoaXMuX2dldF9kaXN0YW5jZShTX28sIG0sIHhfbykpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFURCA9IGRlbHRhVEQgKyBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBiZXN0IHJlZHVjdGlvblxuICAgICAgICAgICAgICAgIGlmIChkZWx0YVREIDwgRGVsdGFURCkge1xuICAgICAgICAgICAgICAgICAgICBEZWx0YVREID0gZGVsdGFURDtcbiAgICAgICAgICAgICAgICAgICAgbWVkb2lkcy5wdXNoKFNfaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVEQwICs9IERlbHRhVEQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lZG9pZHMuc2xpY2UoMCwgSyk7XG4gICAgfVxuICAgIFxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IEhlYXAgfSBmcm9tIFwiLi4vZGF0YXN0cnVjdHVyZS9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIE9QVElDU1xuICovXG5leHBvcnQgY2xhc3MgT1BUSUNTIHtcbiAgICAvKipcbiAgICAgKiAqKk8qKnJkZXJpbmcgKipQKipvaW50cyAqKlQqKm8gKipJKipkZW50aWZ5IHRoZSAqKkMqKmx1c3RlcmluZyAqKlMqKnRydWN0dXJlLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y2x1c3RlcmluZ1xuICAgICAqIEBhbGlhcyBPUFRJQ1NcbiAgICAgKiBAdG9kbyBuZWVkcyByZXN0cnVjdHVyaW5nLiBcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4IC0gdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVwc2lsb24gLSB0aGUgbWluaW11bSBkaXN0YW5jZSB3aGljaCBkZWZpbmVzIHdoZXRoZXIgYSBwb2ludCBpcyBhIG5laWdoYm9yIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluX3BvaW50cyAtIHRoZSBtaW5pbXVtIG51bWJlciBvZiBwb2ludHMgd2hpY2ggYSBwb2ludCBuZWVkcyB0byBjcmVhdGUgYSBjbHVzdGVyLiAoU2hvdWxkIGJlIGhpZ2hlciB0aGFuIDEsIGVsc2UgZWFjaCBwb2ludCBjcmVhdGVzIGEgY2x1c3Rlci4pXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW21ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgZGlzdGFuY2UgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBvZiB0aGUge0BsaW5rIG1hdHJpeH0uXG4gICAgICogQHJldHVybnMge09QVElDU31cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5kYnMuaWZpLmxtdS5kZS9QdWJsaWthdGlvbmVuL1BhcGVycy9PUFRJQ1MucGRmfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09QVElDU19hbGdvcml0aG19XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF0cml4LCBlcHNpbG9uLCBtaW5fcG9pbnRzLCBtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbWF0cml4O1xuICAgICAgICB0aGlzLl9lcHNpbG9uID0gZXBzaWxvbjtcbiAgICAgICAgdGhpcy5fbWluX3BvaW50cyA9IG1pbl9wb2ludHM7XG4gICAgICAgIHRoaXMuX21ldHJpYyA9IG1ldHJpYztcblxuICAgICAgICB0aGlzLl9vcmRlcmVkX2xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fREIgPSBuZXcgQXJyYXkobWF0cml4LnNoYXBlWzBdKS5maWxsKCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgY2x1c3RlcmluZy5cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBvcmRlcmVkX2xpc3QgPSB0aGlzLl9vcmRlcmVkX2xpc3Q7XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcbiAgICAgICAgY29uc3QgTiA9IG1hdHJpeC5zaGFwZVswXTtcbiAgICAgICAgY29uc3QgREIgPSB0aGlzLl9EQjtcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSB0aGlzLl9jbHVzdGVycztcbiAgICAgICAgbGV0IGNsdXN0ZXJfaW5kZXggPSB0aGlzLl9jbHVzdGVyX2luZGV4ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgREJbaV0gPSB7XG4gICAgICAgICAgICAgICAgXCJlbGVtZW50XCI6IG1hdHJpeC5yb3coaSksXG4gICAgICAgICAgICAgICAgXCJpbmRleFwiOiBpLFxuICAgICAgICAgICAgICAgIFwicmVhY2hhYmlsaXR5X2Rpc3RhbmNlXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcInByb2Nlc3NlZFwiOiBmYWxzZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgREIpIHtcbiAgICAgICAgICAgIGlmIChwLnByb2Nlc3NlZCkgY29udGludWU7XG4gICAgICAgICAgICBwLm5laWdoYm9ycyA9IHRoaXMuX2dldF9uZWlnaGJvcnMocCk7XG4gICAgICAgICAgICBwLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICBjbHVzdGVycy5wdXNoKFtwLmluZGV4XSlcbiAgICAgICAgICAgIGNsdXN0ZXJfaW5kZXggPSBjbHVzdGVycy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgb3JkZXJlZF9saXN0LnB1c2gocCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29yZV9kaXN0YW5jZShwKSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWVkcyA9IG5ldyBIZWFwKG51bGwsIGQgPT4gZC5yZWFjaGFiaWxpdHlfZGlzdGFuY2UsIFwibWluXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKHAsIHNlZWRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRfY2x1c3RlcihzZWVkcywgY2x1c3RlcnNbY2x1c3Rlcl9pbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHAgLSBhIHBvaW50IG9mIHtAbGluayBtYXRyaXh9LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgY29uc2lzdGluZyBvZiB0aGUge0BsaW5rIGVwc2lsb259LW5laWdoYm9yaG9vZCBvZiB7QGxpbmsgcH0uXG4gICAgICovXG4gICAgX2dldF9uZWlnaGJvcnMocCkge1xuICAgICAgICBpZiAoXCJuZWlnaGJvcnNcIiBpbiBwKSByZXR1cm4gcC5uZWlnaGJvcnM7XG4gICAgICAgIGNvbnN0IERCID0gdGhpcy5fREI7XG4gICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMuX21ldHJpYztcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuX2Vwc2lsb247XG4gICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHEgb2YgREIpIHtcbiAgICAgICAgICAgIGlmIChxLmluZGV4ID09IHAuaW5kZXgpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG1ldHJpYyhwLmVsZW1lbnQsIHEuZWxlbWVudCkgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5laWdoYm9ycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwIC0gYSBwb2ludCBvZiB7QGxpbmsgbWF0cml4fS5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZGlzdGFuY2UgdG8gdGhlIHtAbGluayBtaW5fcG9pbnRzfS10aCBuZWFyZXN0IHBvaW50IG9mIHtAbGluayBwfSwgb3IgdW5kZWZpbmVkIGlmIHRoZSB7QGxpbmsgZXBzaWxvbn0tbmVpZ2hib3Job29kIGhhcyBmZXdlciBlbGVtZW50cyB0aGFuIHtAbGluayBtaW5fcG9pbnRzfS5cbiAgICAgKi9cbiAgICBfY29yZV9kaXN0YW5jZShwKSB7XG4gICAgICAgIGNvbnN0IG1pbl9wb2ludHMgPSB0aGlzLl9taW5fcG9pbnRzO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSB0aGlzLl9tZXRyaWM7XG4gICAgICAgIGlmIChwLm5laWdoYm9ycyAmJiBwLm5laWdoYm9ycy5sZW5ndGggPD0gbWluX3BvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0cmljKHAuZWxlbWVudCwgcC5uZWlnaGJvcnNbbWluX3BvaW50c10uZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVhY2hhYmlsaXR5IGRpc3RhbmNlIG9mIHRoZSBwb2ludHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcCBcbiAgICAgKiBAcGFyYW0ge0hlYXB9IHNlZWRzIFxuICAgICAqL1xuICAgIF91cGRhdGUocCwgc2VlZHMpIHtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5fbWV0cmljO1xuICAgICAgICBjb25zdCBjb3JlX2Rpc3RhbmNlID0gdGhpcy5fY29yZV9kaXN0YW5jZShwKTtcbiAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gdGhpcy5fZ2V0X25laWdoYm9ycyhwKTsvL3AubmVpZ2hib3JzO1xuICAgICAgICBmb3IgKGNvbnN0IHEgb2YgbmVpZ2hib3JzKSB7XG4gICAgICAgICAgICBpZiAocS5wcm9jZXNzZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbmV3X3JlYWNoYWJpbGl0eV9kaXN0YW5jZSA9IE1hdGgubWF4KGNvcmVfZGlzdGFuY2UsIG1ldHJpYyhwLmVsZW1lbnQsIHEuZWxlbWVudCkpO1xuICAgICAgICAgICAgLy9pZiAocS5yZWFjaGFiaWxpdHlfZGlzdGFuY2UgPT0gdW5kZWZpbmVkKSB7IC8vIHEgaXMgbm90IGluIHNlZWRzXG4gICAgICAgICAgICBpZiAoc2VlZHMucmF3X2RhdGEoKS5maW5kSW5kZXgoZCA9PiBkLmVsZW1lbnQgPT0gcSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcS5yZWFjaGFiaWxpdHlfZGlzdGFuY2UgPSBuZXdfcmVhY2hhYmlsaXR5X2Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHNlZWRzLnB1c2gocSk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBxIGlzIGluIHNlZWRzXG4gICAgICAgICAgICAgICAgaWYgKG5ld19yZWFjaGFiaWxpdHlfZGlzdGFuY2UgPCBxLnJlYWNoYWJpbGl0eV9kaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBxLnJlYWNoYWJpbGl0eV9kaXN0YW5jZSA9IG5ld19yZWFjaGFiaWxpdHlfZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIHNlZWRzID0gSGVhcC5oZWFwaWZ5KHNlZWRzLmRhdGEoKSwgZCA9PiBkLnJlYWNoYWJpbGl0eV9kaXN0YW5jZSwgXCJtaW5cIik7IC8vIHNlZWRzIGNoYW5nZSBrZXkgPS9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSB7QGxpbmsgY2x1c3Rlcn0gd2l0aCBwb2ludHMgaW4ge0BsaW5rIHNlZWRzfS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SGVhcH0gc2VlZHMgXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2x1c3RlciBcbiAgICAgKi9cbiAgICBfZXhwYW5kX2NsdXN0ZXIoc2VlZHMsIGNsdXN0ZXIpIHtcbiAgICAgICAgY29uc3Qgb3JkZXJlZF9saXN0ID0gdGhpcy5fb3JkZXJlZF9saXN0O1xuICAgICAgICB3aGlsZSAoIXNlZWRzLmVtcHR5KSB7XG4gICAgICAgICAgICBjb25zdCBxID0gc2VlZHMucG9wKCkuZWxlbWVudDtcbiAgICAgICAgICAgIHEubmVpZ2hib3JzID0gdGhpcy5fZ2V0X25laWdoYm9ycyhxKTtcbiAgICAgICAgICAgIHEucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsdXN0ZXIucHVzaChxLmluZGV4KTtcbiAgICAgICAgICAgIG9yZGVyZWRfbGlzdC5wdXNoKHEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvcmVfZGlzdGFuY2UocSkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKHEsIHNlZWRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRfY2x1c3RlcihzZWVkcywgY2x1c3Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNsdXN0ZXJzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IEFycmF5IG9mIGNsdXN0ZXJzIHdpdGggdGhlIGluZGljZXMgb2YgdGhlIHJvd3MgaW4gZ2l2ZW4ge0BsaW5rIG1hdHJpeH0uXG4gICAgICovXG4gICAgZ2V0X2NsdXN0ZXJzKCkge1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9IFtdO1xuICAgICAgICBjb25zdCBvdXRsaWVycyA9IFtdO1xuICAgICAgICBjb25zdCBtaW5fcG9pbnRzID0gdGhpcy5fbWluX3BvaW50cztcbiAgICAgICAgZm9yIChjb25zdCBjbHVzdGVyIG9mIHRoaXMuX2NsdXN0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoY2x1c3Rlci5sZW5ndGggPCBtaW5fcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgb3V0bGllcnMucHVzaCguLi5jbHVzdGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2x1c3RlcnMucHVzaChjbHVzdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbHVzdGVycy5wdXNoKG91dGxpZXJzKTtcbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSwgd2hlcmUgdGhlIGl0aCBlbnRyeSBkZWZpbmVzIHRoZSBjbHVzdGVyIGFmZmlybWF0aW9uIG9mIHRoZSBpdGggcG9pbnQgb2Yge0BsaW5rIG1hdHJpeH0uICgtMSBzdGFuZHMgZm9yIG91dGxpZXIpXG4gICAgICovXG4gICAgZ2V0X2NsdXN0ZXJfYWZmaXJtYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLl9tYXRyaXguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShOKS5maWxsKCk7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gdGhpcy5nZXRfY2x1c3RlcnMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBjbHVzdGVycy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBjbHVzdGVyc1tpXVxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBjbHVzdGVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IChpIDwgbiAtIDEpID8gaSA6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuaW1wb3J0IHsgTURTIH0gZnJvbSBcIi4vTURTLmpzXCI7XG5pbXBvcnQgeyBLTWVkb2lkcyB9IGZyb20gXCIuLi9jbHVzdGVyaW5nL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQmFsbFRyZWUgfSBmcm9tIFwiLi4va25uL2luZGV4LmpzXCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIExTUFxuICogQGV4dGVuZHMgRFJcbiAqL1xuZXhwb3J0IGNsYXNzIExTUCBleHRlbmRzIERSIHtcbiAgICAvKipcbiAgICAgKiBMZWFzdCBTcXVhcmVzIFByb2plY3Rpb24uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpkcnVpZC9kaW1lbnNpb25hbGl0eV9yZWR1Y3Rpb25cbiAgICAgKiBAYWxpYXMgTFNQXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IFggLSB0aGUgaGlnaC1kaW1lbnNpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyaXphdGlvbiBvZiB0aGUgRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5uZWlnaGJvcnMgPSBNYXRoLm1heChNYXRoLmZsb29yKE4gLyAxMCksIDIpXSAtIG51bWJlciBvZiBuZWlnaGJvcnMgdG8gY29uc2lkZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLmNvbnRyb2xfcG9pbnRzID0gTWF0aC5jZWlsKE1hdGguc3FydChOKSldIC0gbnVtYmVyIG9mIGNvbnRyb2xwb2ludHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbWV0ZXJzLm1ldHJpYyA9IGV1Y2xpZGVhbl0gLSB0aGUgbWV0cmljIHdoaWNoIGRlZmluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuc2VlZCA9IDEyMTJdIC0gdGhlIHNlZWQgZm9yIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7TFNQfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vaWVlZXhwbG9yZS5pZWVlLm9yZy9kb2N1bWVudC80Mzc4MzcwfVxuICAgICAqIEB0b2RvIGFjY2VwdCBwcmVjb21wdXRlZCBkaXN0YW5jZSBtYXRyaXguXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoWCwgcGFyYW1ldGVycykge1xuICAgICAgICBzdXBlcihYLCB7IG5laWdoYm9yczogdW5kZWZpbmVkLCBjb250cm9sX3BvaW50czogdW5kZWZpbmVkLCBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJuZWlnaGJvcnNcIiwgTWF0aC5taW4ocGFyYW1ldGVycy5uZWlnaGJvcnMgPz8gTWF0aC5tYXgoTWF0aC5mbG9vcih0aGlzLl9OIC8gMTApLCAyKSwgdGhpcy5fTiAtIDEpKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXIoXCJjb250cm9sX3BvaW50c1wiLCBNYXRoLm1pbihwYXJhbWV0ZXJzLmNvbnRyb2xfcG9pbnRzID8/IE1hdGguY2VpbChNYXRoLnNxcnQodGhpcy5fTikpLCB0aGlzLl9OIC0gMSkpO1xuICAgICAgICB0aGlzLl9pc19pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RFJ9IERSIC0gbWV0aG9kIHVzZWQgZm9yIHBvc2l0aW9uIGNvbnRyb2wgcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBEUl9wYXJhbWV0ZXJzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBmb3IgdGhlIERSIG1ldGhvZCB3aGljaCBwcm9qZWN0cyB0aGUgY29udHJvbCBwb2ludHNcbiAgICAgKiBAcmV0dXJucyB7TFNQfVxuICAgICAqL1xuICAgIGluaXQoRFIgPSBNRFMsIERSX3BhcmFtZXRlcnMgPSB7fSwgS05OID0gQmFsbFRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzX2luaXRpYWxpemVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgY29uc3QgWCA9IHRoaXMuWDtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IEsgPSB0aGlzLnBhcmFtZXRlcihcIm5laWdoYm9yc1wiKTtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMucGFyYW1ldGVyKFwiZFwiKTtcbiAgICAgICAgY29uc3Qgc2VlZCA9IHRoaXMucGFyYW1ldGVyKFwic2VlZFwiKTtcbiAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5wYXJhbWV0ZXIoXCJtZXRyaWNcIik7XG4gICAgICAgIERSX3BhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHtkLCBtZXRyaWMsIHNlZWQgfSwgRFJfcGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IG5jID0gdGhpcy5wYXJhbWV0ZXIoXCJjb250cm9sX3BvaW50c1wiKTtcbiAgICAgICAgY29uc3QgY29udHJvbF9wb2ludHMgPSBuZXcgS01lZG9pZHMoWCwgbmMsIG51bGwsIG1ldHJpYykuZ2V0X2NsdXN0ZXJzKCkubWVkb2lkcztcbiAgICAgICAgY29uc3QgQyA9IG5ldyBNYXRyaXgobmMsIE4sIFwiemVyb3NcIik7XG4gICAgICAgIGNvbnRyb2xfcG9pbnRzLmZvckVhY2goKGNfaSwgaSkgPT4ge1xuICAgICAgICAgICAgQy5zZXRfZW50cnkoaSwgY19pLCAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IFlfQyA9IG5ldyBEUihNYXRyaXguZnJvbShjb250cm9sX3BvaW50cy5tYXAoKGNfaSkgPT4gWC5yb3coY19pKSkpLCBEUl9wYXJhbWV0ZXJzKS50cmFuc2Zvcm0oKTtcblxuICAgICAgICBjb25zdCBYQSA9IFgudG8yZEFycmF5O1xuICAgICAgICBjb25zdCBrbm4gPSBuZXcgS05OKFhBLCBtZXRyaWMpO1xuICAgICAgICBjb25zdCBMID0gbmV3IE1hdHJpeChOLCBOLCBcIklcIik7XG4gICAgICAgIGNvbnN0IGFscGhhID0gLTEgLyBLO1xuICAgICAgICBYQS5mb3JFYWNoKCh4X2ksIGkpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBpbmRleDogaiB9IG9mIGtubi5zZWFyY2goeF9pLCBLKS5pdGVyYXRlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaikgY29udGludWU7XG4gICAgICAgICAgICAgICAgTC5zZXRfZW50cnkoaSwgaiwgYWxwaGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgQSA9IEwuY29uY2F0KEMsIFwidmVydGljYWxcIik7XG5cbiAgICAgICAgY29uc3QgeiA9IG5ldyBNYXRyaXgoTiwgZCwgXCJ6ZXJvc1wiKTtcbiAgICAgICAgY29uc3QgYiA9IHouY29uY2F0KFlfQywgXCJ2ZXJ0aWNhbFwiKTtcblxuICAgICAgICB0aGlzLl9BID0gQTtcbiAgICAgICAgdGhpcy5fYiA9IGI7XG4gICAgICAgIHRoaXMuX2lzX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHJldHVybnMge01hdHJpeH0gUmV0dXJucyB0aGUgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfaW5pdCgpO1xuICAgICAgICBjb25zdCBBID0gdGhpcy5fQTtcbiAgICAgICAgY29uc3QgQVQgPSBBLlQ7XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLl9iO1xuICAgICAgICBjb25zdCBBVEEgPSBBVC5kb3QoQSk7XG4gICAgICAgIGNvbnN0IEFUYiA9IEFULmRvdChiKTtcbiAgICAgICAgdGhpcy5ZID0gTWF0cml4LnNvbHZlX0NHKEFUQSwgQVRiLCB0aGlzLl9yYW5kb21pemVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0cml4L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi4vbWV0cmljcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRFIgfSBmcm9tIFwiLi9EUi5qc1wiO1xuaW1wb3J0IHsgRGlzam9pbnRTZXQgfSBmcm9tIFwiLi4vZGF0YXN0cnVjdHVyZS9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIFRvcG9NYXBcbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBUb3BvTWFwIGV4dGVuZHMgRFIge1xuICAgIC8qKlxuICAgICAqIFRvcG9NYXA6IEEgMC1kaW1lbnNpb25hbCBIb21vbG9neSBQcmVzZXJ2aW5nIFByb2plY3Rpb24gb2YgSGlnaC1EaW1lbnNpb25hbCBEYXRhLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6ZHJ1aWQvZGltZW5zaW9uYWxpdHlfcmVkdWN0aW9uXG4gICAgICogQGFsaWFzIFRvcG9NYXBcbiAgICAgKiBAcGFyYW0ge01hdHJpeHxOdW1iZXJbXVtdfSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcml6YXRpb24gb2YgdGhlIERSIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1ldGVycy5tZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnNlZWQgPSAxMjEyXSAtIHRoZSBzZWVkIGZvciB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge1RvcG9NYXB9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIwMDkuMDE1MTIucGRmfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgW3RoaXMuX04sIHRoaXMuX0RdID0gdGhpcy5YLnNoYXBlO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZV9tYXRyaXggPSBuZXcgTWF0cml4KHRoaXMuX04sIHRoaXMuX04sIDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fbGF6eV9kaXN0YW5jZV9tYXRyaXgoaSwgaiwgbWV0cmljKSB7XG4gICAgICAgIGNvbnN0IEQgPSB0aGlzLl9kaXN0YW5jZV9tYXRyaXg7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLlg7XG4gICAgICAgIGNvbnN0IERfaWogPSBELmVudHJ5KGksIGopO1xuICAgICAgICBpZiAoRF9paiA9PT0gMCkge1xuICAgICAgICAgICAgbGV0IGRpc3QgPSBtZXRyaWMoWC5yb3coaSksIFgucm93KGopKTtcbiAgICAgICAgICAgIEQuc2V0X2VudHJ5KGksIGosIGRpc3QpO1xuICAgICAgICAgICAgRC5zZXRfZW50cnkoaiwgaSwgZGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRF9pajtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSBzcGFubmluZyB0cmVlLCB1c2luZyBhIGdpdmVuIG1ldHJpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0cmljXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS3J1c2thbCUyN3NfYWxnb3JpdGhtfVxuICAgICAqL1xuICAgIF9tYWtlX21pbmltdW1fc3Bhbm5pbmdfdHJlZShtZXRyaWMgPSBldWNsaWRlYW4pIHtcbiAgICAgICAgY29uc3QgTiA9IHRoaXMuX047XG4gICAgICAgIGNvbnN0IFggPSBbLi4udGhpcy5YXTtcblxuICAgICAgICBsZXQgZGlzam9pbnRfc2V0ID0gbmV3IERpc2pvaW50U2V0KFgpO1xuICAgICAgICBjb25zdCBGID0gW107XG4gICAgICAgIGxldCBFID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBOOyArK2opIHtcbiAgICAgICAgICAgICAgICBFLnB1c2goW2ksIGosIHRoaXMuX19sYXp5X2Rpc3RhbmNlX21hdHJpeChpLCBqLCBtZXRyaWMpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgRSA9IEUuc29ydCgoYSwgYikgPT4gYVsyXSAtIGJbMl0pO1xuXG4gICAgICAgIGZvciAoY29uc3QgW3UsIHYsIHddIG9mIEUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldF91ID0gZGlzam9pbnRfc2V0LmZpbmQoWFt1XSk7XG4gICAgICAgICAgICBjb25zdCBzZXRfdiA9IGRpc2pvaW50X3NldC5maW5kKFhbdl0pO1xuICAgICAgICAgICAgaWYgKHNldF91ICE9PSBzZXRfdikge1xuICAgICAgICAgICAgICAgIEYucHVzaChbdSwgdiwgd10pO1xuICAgICAgICAgICAgICAgIGRpc2pvaW50X3NldC51bmlvbihzZXRfdSwgc2V0X3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEYuc29ydCgoYSwgYikgPT4gYVsyXSAtIGJbMl0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemVzIFRvcG9NYXAuIFNldHMgYWxsIHByb2pjdGVkIHBvaW50cyB0byB6ZXJvLCBhbmQgY29tcHV0ZXMgYSBtaW5pbXVtIHNwYW5uaW5nIHRyZWUuXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3QgeyBtZXRyaWN9ID0gdGhpcy5fcGFyYW1ldGVyc1xuICAgICAgICB0aGlzLlkgPSBuZXcgTWF0cml4KHRoaXMuX04sIDIsIDApO1xuICAgICAgICB0aGlzLl9FbXN0ID0gdGhpcy5fbWFrZV9taW5pbXVtX3NwYW5uaW5nX3RyZWUobWV0cmljKTtcbiAgICAgICAgdGhpcy5faXNfaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgUG9pbnQgQyBpcyBsZWZ0IG9mIGxpbmUgQUIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBQb2ludEEgLSBQb2ludCBBIG9mIGxpbmUgQUJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBQb2ludEIgLSBQb2ludCBCIG9mIGxpbmUgQUJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBQb2ludEMgLSBQb2ludCBDXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgX19odWxsX2Nyb3NzKFtheCwgYXldLCBbYngsIGJ5XSwgW3N4LCBzeV0pIHtcbiAgICAgICAgcmV0dXJuIChieCAtIGF4KSAqIChzeSAtIGF5KSAtIChieSAtIGF5KSAqIChzeCAtIGF4KSA8PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgc2V0IG9mIFBvaW50cyBTXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBTIC0gU2V0IG9mIFBvaW50cy5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2VuLndpa2lib29rcy5vcmcvd2lraS9BbGdvcml0aG1fSW1wbGVtZW50YXRpb24vR2VvbWV0cnkvQ29udmV4X2h1bGwvTW9ub3RvbmVfY2hhaW4jSmF2YVNjcmlwdH1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGNvbnZleCBodWxsIG9mIFMuIFN0YXJ0cyBhdCB0aGUgYm90dG9tLW1vc3QgcG9pbnQgYW5kIGNvbnRpbnVlcyBjb3VudGVyLWNsb2Nrd2lzZS5cbiAgICAgKi9cbiAgICBfX2h1bGwoUykge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBTLnNvcnQoKFt4MSwgeTFdLCBbeDIsIHkyXSkgPT4geTEgLSB5MiB8fCB4MSAtIHgyKTtcbiAgICAgICAgY29uc3QgTiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChOIDw9IDIpIHJldHVybiBwb2ludHM7XG5cbiAgICAgICAgY29uc3QgbG93ZXIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgICAgIHdoaWxlIChsb3dlci5sZW5ndGggPj0gMiAmJiB0aGlzLl9faHVsbF9jcm9zcyhsb3dlcltsb3dlci5sZW5ndGggLSAyXSwgbG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0sIHBvaW50c1tpXSkpIHtcbiAgICAgICAgICAgICAgICBsb3dlci5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvd2VyLnB1c2gocG9pbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cHBlciA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gTiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICB3aGlsZSAodXBwZXIubGVuZ3RoID49IDIgJiYgdGhpcy5fX2h1bGxfY3Jvc3ModXBwZXJbdXBwZXIubGVuZ3RoIC0gMl0sIHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdLCBwb2ludHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgdXBwZXIucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cHBlci5wdXNoKHBvaW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBwZXIucG9wKCk7XG4gICAgICAgIGxvd2VyLnBvcCgpO1xuICAgICAgICByZXR1cm4gbG93ZXIuY29uY2F0KHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgYW5nbGUgdG8gcm90YXRlIFBvaW50IEEgYW5kIEIgdG8gbGllIG9uIGEgbGluZSBwYXJhbGxlbCB0byB0aGUgeC1heGlzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gUG9pbnRBXG4gICAgICogQHBhcmFtIHtBcnJheX0gUG9pbnRCXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgc2ludXMtIGFuZCBjb3NpbnVzLXZhbHVlcyBmb3IgYSByb3RhdGlvbi5cbiAgICAgKi9cbiAgICBfX2ZpbmRBbmdsZShbcDF4LCBwMXldLCBbcDJ4LCBwMnldKSB7XG4gICAgICAgIGNvbnN0IG4gPSBldWNsaWRlYW4oW3AxeCwgcDF5XSwgW3AyeCwgcDJ5XSk7XG4gICAgICAgIGlmIChuID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzaW46IDAsXG4gICAgICAgICAgICAgICAgY29zOiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdmVjID0gWyhwMnggLSBwMXgpIC8gbiwgKHAyeSAtIHAxeSkgLyBuXTtcbiAgICAgICAgY29uc3QgY29zID0gdmVjWzBdO1xuICAgICAgICBsZXQgc2luID0gTWF0aC5zcXJ0KDEgLSBjb3MgKiBjb3MpO1xuICAgICAgICBzaW4gPSB2ZWNbMV0gPj0gMCA/IC1zaW4gOiBzaW47XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaW46IHNpbixcbiAgICAgICAgICAgIGNvczogY29zLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gaHVsbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBcbiAgICAgKiBAcGFyYW0ge0Jvb2x9IHRvcEVkZ2VcbiAgICAgKi9cbiAgICBfX2FsaWduX2h1bGwoaHVsbCwgcCwgdG9wRWRnZSkge1xuICAgICAgICBsZXQgdiA9IC0xO1xuICAgICAgICBsZXQgZDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaHVsbC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZCA9IGV1Y2xpZGVhbihodWxsW2ldLCBwKTtcbiAgICAgICAgICAgIGlmICh2ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGQyID0gZDtcbiAgICAgICAgICAgICAgICB2ID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGQyID4gZCkge1xuICAgICAgICAgICAgICAgICAgICBkMiA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIHYgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgbGV0IHYyO1xuICAgICAgICBpZiAodG9wRWRnZSkge1xuICAgICAgICAgICAgdjEgPSBodWxsW3ZdO1xuICAgICAgICAgICAgdjIgPSBodWxsWyh2ICsgMSkgJSBodWxsLmxlbmd0aF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodiA9PSAwKSB2ID0gaHVsbC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdjEgPSBodWxsW3ZdO1xuICAgICAgICAgICAgdjIgPSBodWxsWyh2IC0gMSkgJSBodWxsLmxlbmd0aF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbiA9IHtcbiAgICAgICAgICAgIHR4OiAtaHVsbFt2XVswXSxcbiAgICAgICAgICAgIHR5OiAtaHVsbFt2XVsxXSxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaHVsbC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgY29uc3QgeyBzaW4sIGNvcyB9ID0gdGhpcy5fX2ZpbmRBbmdsZSh2MSwgdjIpO1xuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24uc2luID0gc2luO1xuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24uY29zID0gY29zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24uc2luID0gMDtcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uLmNvcyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtYXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBQb2ludCAtIFRoZSBwb2ludCB3aGljaCBzaG91bGQgZ2V0IHRyYW5zZm9ybWVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBUcmFuc2Zvcm1hdGlvbiAtIGNvbnRhaW5zIHRoZSB2YWx1ZXMgZm9yIHRyYW5zbGF0aW9uIGFuZCByb3RhdGlvbi5cbiAgICAgKi9cbiAgICBfX3RyYW5zZm9ybShbcHgsIHB5XSwgeyB0eCwgdHksIHNpbiwgY29zIH0pIHtcbiAgICAgICAgbGV0IHggPSBweCArIHR4O1xuICAgICAgICBsZXQgeSA9IHB5ICsgdHk7XG4gICAgICAgIGxldCB4eCA9IHggKiBjb3MgLSB5ICogc2luO1xuICAgICAgICBsZXQgeXkgPSB4ICogc2luICsgeSAqIGNvcztcbiAgICAgICAgcmV0dXJuIFt4eCwgeXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIHtAbGluayBfX3RyYW5zZm9ybX0gZm9yIGVhY2ggcG9pbnQgaW4gU2V0IENcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IEMgLSBTZXQgb2YgcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0IC0gVHJhbnNmb3JtIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geU9mZnNldCAtIHZhbHVlIHRvIG9mZnNldCBzZXQgQy5cbiAgICAgKi9cbiAgICBfX3RyYW5zZm9ybV9jb21wb25lbnQoQywgdCwgeU9mZnNldCkge1xuICAgICAgICBjb25zdCBOID0gQy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gQ1tpXTtcbiAgICAgICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5fX3RyYW5zZm9ybShjLCB0KTtcbiAgICAgICAgICAgIGNbMF0gPSBjeDtcbiAgICAgICAgICAgIGNbMV0gPSBjeSArIHlPZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHUgLSBwb2ludCB1XG4gICAgICogQHBhcmFtIHtBcnJheX0gdiAtIHBvaW50IHZcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdyAtIGVkZ2Ugd2VpZ2h0IHdcbiAgICAgKi9cbiAgICBfX2FsaWduX2NvbXBvbmVudHModSwgdiwgdykge1xuICAgICAgICBjb25zdCBwb2ludHNfdSA9IFsuLi51Ll9fZGlzam9pbnRfc2V0LmNoaWxkcmVuXTtcbiAgICAgICAgY29uc3QgcG9pbnRzX3YgPSBbLi4udi5fX2Rpc2pvaW50X3NldC5jaGlsZHJlbl07XG5cbiAgICAgICAgY29uc3QgaHVsbF91ID0gdGhpcy5fX2h1bGwocG9pbnRzX3UpO1xuICAgICAgICBjb25zdCBodWxsX3YgPSB0aGlzLl9faHVsbChwb2ludHNfdik7XG5cbiAgICAgICAgY29uc3QgdF91ID0gdGhpcy5fX2FsaWduX2h1bGwoaHVsbF91LCB1LCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRfdiA9IHRoaXMuX19hbGlnbl9odWxsKGh1bGxfdiwgdiwgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fX3RyYW5zZm9ybV9jb21wb25lbnQocG9pbnRzX3UsIHRfdSwgMCk7XG4gICAgICAgIHRoaXMuX190cmFuc2Zvcm1fY29tcG9uZW50KHBvaW50c192LCB0X3YsIHcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0ZGF0YSB7QGxpbmsgWH0gdG8gZGltZW5zaW9uYWxpdHkgMi5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNfaW5pdGlhbGl6ZWQpIHRoaXMuaW5pdCgpO1xuICAgICAgICBjb25zdCBFbXN0ID0gdGhpcy5fRW1zdDtcbiAgICAgICAgY29uc3QgWSA9IHRoaXMuWS50bzJkQXJyYXk7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBuZXcgRGlzam9pbnRTZXQoXG4gICAgICAgICAgICBZLm1hcCgoeSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHkuaSA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGZvciAoY29uc3QgW3UsIHYsIHddIG9mIEVtc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudF91ID0gY29tcG9uZW50cy5maW5kKFlbdV0pO1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50X3YgPSBjb21wb25lbnRzLmZpbmQoWVt2XSk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50X3UgPT09IGNvbXBvbmVudF92KSBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMuX19hbGlnbl9jb21wb25lbnRzKGNvbXBvbmVudF91LCBjb21wb25lbnRfdiwgdyk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnVuaW9uKGNvbXBvbmVudF91LCBjb21wb25lbnRfdik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICAqZ2VuZXJhdG9yKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzX2luaXRpYWxpemVkKSB0aGlzLmluaXQoKTtcbiAgICAgICAgY29uc3QgRW1zdCA9IHRoaXMuX0Vtc3Q7XG4gICAgICAgIGNvbnN0IFkgPSB0aGlzLlkudG8yZEFycmF5O1xuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gbmV3IERpc2pvaW50U2V0KFxuICAgICAgICAgICAgWS5tYXAoKHksIGkpID0+IHtcbiAgICAgICAgICAgICAgICB5LmkgPSBpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGNvbnN0IFt1LCB2LCB3XSBvZiBFbXN0KSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRfdSA9IGNvbXBvbmVudHMuZmluZChZW3VdKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudF92ID0gY29tcG9uZW50cy5maW5kKFlbdl0pO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudF91ID09PSBjb21wb25lbnRfdikgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLl9fYWxpZ25fY29tcG9uZW50cyhjb21wb25lbnRfdSwgY29tcG9uZW50X3YsIHcpO1xuICAgICAgICAgICAgY29tcG9uZW50cy51bmlvbihjb21wb25lbnRfdSwgY29tcG9uZW50X3YpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL21hdHJpeC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXVjbGlkZWFuIH0gZnJvbSBcIi4uL21ldHJpY3MvaW5kZXguanNcIjtcbmltcG9ydCB7IERSIH0gZnJvbSBcIi4vRFIuanNcIjtcbmltcG9ydCB7IFBDQSwgTURTIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7IGRpc3RhbmNlX21hdHJpeCB9IGZyb20gXCIuLi9tYXRyaXgvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBTQU1NT05cbiAqIEBleHRlbmRzIERSXG4gKi9cbmV4cG9ydCBjbGFzcyBTQU1NT04gZXh0ZW5kcyBEUiB7XG4gICAgLyoqXG4gICAgICogU0FNTU9OJ3MgTWFwcGluZ1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6QGRydWlkL2RpbWVuc2lvbmFsaXR5X3JlZHVjdGlvblxuICAgICAqIEBhbGlhcyBTQU1NT05cbiAgICAgKiBAcGFyYW0ge01hdHJpeHxOdW1iZXJbXVtdfSBYIC0gdGhlIGhpZ2gtZGltZW5zaW9uYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcml6YXRpb24gb2YgdGhlIERSIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuZCA9IDJdIC0gdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258XCJwcmVjb21wdXRlZFwifSBbcGFyYW1ldGVycy5tZXRyaWMgPSBldWNsaWRlYW5dIC0gdGhlIG1ldHJpYyB3aGljaCBkZWZpbmVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICogQHBhcmFtIHtcIlBDQVwifFwiTURTXCJ8XCJyYW5kb21cIn0gW3BhcmFtZXRlcnMuaW5pdCA9IFwicmFuZG9tXCJdIC0gRWl0aGVyIFwiUENBXCIgb3IgXCJNRFNcIiwgd2l0aCB3aGljaCBTQU1NT04gaW5pdGlhbGlhdGVzIHRoZSBwcm9qZWN0aW9uLiBXaXRoIFwicmFuZG9tXCIgYSByYW5kb20gbWF0cml4IGdldHMgdXNlZCBhcyBzdGFydGluZyBwb2ludC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnMuaW5pdF9wYXJhbWV0ZXJzXSAtIFBhcmFtZXRlcnMgZm9yIHRoZSB7QGxpbmsgaW5pdH0tRFIgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zZWVkID0gMTIxMl0gLSB0aGUgc2VlZCBmb3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtTQU1NT059XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIwMDkuMDE1MTIucGRmfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFgsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIoWCwgeyBtYWdpYzogMC4xLCBkOiAyLCBtZXRyaWM6IGV1Y2xpZGVhbiwgc2VlZDogMTIxMiwgaW5pdF9EUjogXCJyYW5kb21cIiwgaW5pdF9wYXJhbWV0ZXJzOiB7fSB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZXMgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBOID0gdGhpcy5YLnNoYXBlWzBdO1xuICAgICAgICBjb25zdCB7IGQsIG1ldHJpYywgaW5pdF9EUjogaW5pdF9EUiwgaW5pdF9wYXJhbWV0ZXJzOiBEUl9wYXJhbWV0ZXJzIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBpZiAoaW5pdF9EUiA9PT0gXCJyYW5kb21cIikge1xuICAgICAgICAgICAgY29uc3QgcmFuZG9taXplciA9IHRoaXMuX3JhbmRvbWl6ZXI7XG4gICAgICAgICAgICB0aGlzLlkgPSBuZXcgTWF0cml4KE4sIGQsICgpID0+IHJhbmRvbWl6ZXIucmFuZG9tKTtcbiAgICAgICAgfSBlbHNlIGlmIChbXCJQQ0FcIiwgXCJNRFNcIl0uaW5jbHVkZXMoaW5pdF9EUikpIHtcbiAgICAgICAgICAgIHRoaXMuWSA9IE1hdHJpeC5mcm9tKGluaXRfRFIgPT0gXCJQQ0FcIiA/IFBDQS50cmFuc2Zvcm0odGhpcy5YLCBEUl9wYXJhbWV0ZXJzKSA6IE1EUy50cmFuc2Zvcm0odGhpcy5YLCBEUl9wYXJhbWV0ZXJzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXRfRFIgbmVlZHMgdG8gYmUgZWl0aGVyIFwicmFuZG9tXCIgb3IgYSBEUiBtZXRob2QhJylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3RhbmNlX21hdHJpeCA9IG1ldHJpYyA9PSBcInByZWNvbXB1dGVkXCIgPyBNYXRyaXguZnJvbSh0aGlzLlgpIDogZGlzdGFuY2VfbWF0cml4KHRoaXMuWCwgbWV0cmljKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXRkYXRhIHtAbGluayBYfSB0byBkaW1lbmlvbmFsaXR5IDIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhfaXRlcj0yMDBdIC0gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9uIHN0ZXBzLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh8QXJyYXl9IC0gVGhlIHByb2plY3Rpb24gb2Yge0BsaW5rIFh9LlxuICAgICAqL1xuICAgIHRyYW5zZm9ybShtYXhfaXRlciA9IDIwMCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzX2luaXRpYWxpemVkKSB0aGlzLmluaXQoKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXhfaXRlcjsgKytqKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dGRhdGEge0BsaW5rIFh9IHRvIGRpbWVuaW9uYWxpdHkgMi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW21heF9pdGVyPTIwMF0gLSBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb24gc3RlcHMuXG4gICAgICogQHJldHVybnMge0dlbmVyYXRvcn0gLSBBIGdlbmVyYXRvciB5aWVsZGluZyB0aGUgaW50ZXJtZWRpYXRlIHN0ZXBzIG9mIHRoZSBwcm9qZWN0aW9uIG9mIHtAbGluayBYfS5cbiAgICAgKi9cbiAgICAqZ2VuZXJhdG9yKG1heF9pdGVyID0gMjAwKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNfaW5pdGlhbGl6ZWQpIHRoaXMuaW5pdCgpO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF4X2l0ZXI7ICsraikge1xuICAgICAgICAgICAgdGhpcy5fc3RlcCgpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm9qZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICBfc3RlcCgpIHtcbiAgICAgICAgY29uc3QgTUFHSUMgPSB0aGlzLnBhcmFtZXRlcihcIm1hZ2ljXCIpO1xuICAgICAgICBjb25zdCBEID0gdGhpcy5kaXN0YW5jZV9tYXRyaXg7XG4gICAgICAgIGNvbnN0IE4gPSB0aGlzLlguc2hhcGVbMF07XG4gICAgICAgIGNvbnN0IHsgZCwgbWV0cmljIH0gPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgICAgICBsZXQgWSA9IHRoaXMuWTtcblxuICAgICAgICBsZXQgRyA9IG5ldyBNYXRyaXgoTiwgZCwgMCk7XG5cbiAgICAgICAgbGV0IHN1bSA9IG5ldyBGbG9hdDY0QXJyYXkoZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICBsZXQgZTEgPSBuZXcgRmxvYXQ2NEFycmF5KGQpO1xuICAgICAgICAgICAgbGV0IGUyID0gbmV3IEZsb2F0NjRBcnJheShkKTtcbiAgICAgICAgICAgIGNvbnN0IFlpID0gWS5yb3coaSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBZaiA9IFkucm93KGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gbmV3IEZsb2F0NjRBcnJheShkKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGQ7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVtrXSA9IFlpW2tdIC0gWWpba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRZID0gbWV0cmljKFlpLCBZaik7XG4gICAgICAgICAgICAgICAgY29uc3QgZFggPSBELmVudHJ5KGksIGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRxID0gZFggLSBkWTtcbiAgICAgICAgICAgICAgICBjb25zdCBkciA9IE1hdGgubWF4KGRYICogZFksIDFlLTIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIGUxW2tdICs9IChkZWx0YVtrXSAqIGRxKSAvIGRyO1xuICAgICAgICAgICAgICAgICAgICBlMltrXSArPSAoZHEgLSAoTWF0aC5wb3coZGVsdGFba10sIDIpICogKDEgKyBkcSAvIGRZKSkgLyBkWSkgLyBkcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGQ7ICsraykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IFkuZW50cnkoaSwgaykgKyAoKE1BR0lDICogZTFba10pIC8gTWF0aC5hYnMoZTJba10pIHx8IDApO1xuICAgICAgICAgICAgICAgIEcuc2V0X2VudHJ5KGksIGssIHZhbCk7XG4gICAgICAgICAgICAgICAgc3VtW2tdICs9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGQ7ICsraykge1xuICAgICAgICAgICAgc3VtW2tdIC89IE47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkOyArK2spIHtcbiAgICAgICAgICAgICAgICBZLnNldF9lbnRyeShpLCBrLCBHLmVudHJ5KGksIGspIC0gc3VtW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiYSIsImIiLCJNYXRoIiwic3FydCIsImV1Y2xpZGVhbl9zcXVhcmVkIiwic3VtbWFuZHMiLCJ5IiwidCIsIm4iLCJsZW5ndGgiLCJzdW0iLCJjb21wZW5zYXRpb24iLCJpIiwic3VtbWFuZCIsImFicyIsInMiLCJBcnJheSIsIngiLCJuZXVtYWlyX3N1bSIsInN1bV9hIiwic3VtX2IiLCJhY29zIiwicmVzIiwicHVzaCIsIm1heCIsIm51bV9ub25femVybyIsIm51bV9lcXVhbCIsImRpc2FncmVlIiwibnVtX25vdF9lcXVhbCIsIm51bV90cnVlX3RydWUiLCJudW1fdHJ1ZV9mYWxzZSIsIm51bV9mYWxzZV90cnVlIiwiQSIsImsiLCJtZXRyaWMiLCJldWNsaWRlYW4iLCJyb3dzIiwic2hhcGUiLCJEIiwiZGlzdGFuY2VfbWF0cml4Iiwibk4iLCJyb3ciLCJmcm9tIiwibWFwIiwiZGlzdGFuY2UiLCJjb2wiLCJqIiwic29ydCIsInNsaWNlIiwiTWF0cml4IiwiQV9pIiwiZGlzdCIsInNldF9lbnRyeSIsInN0YXJ0IiwiZW5kIiwibnVtYmVyIiwicm91bmQiLCJyZXN1bHQiLCJ2IiwidmVjdG9yIiwiY29scyIsIkVycm9yIiwiRmxvYXQ2NEFycmF5Iiwidl9ub3JtIiwibm9ybSIsInZhbHVlIiwiUSIsIlIiLCJxIiwicV9kb3RfdiIsInFfIiwidl8iLCJjbG9uZSIsInhfbm9ybSIsIngwIiwiZW50cnkiLCJyaG8iLCJzaWduIiwidTEiLCJ1IiwiZGl2aWRlIiwiYmV0YSIsInVfb3V0ZXJfdSIsIm91dGVyIiwiUl9ibG9jayIsImdldF9ibG9jayIsIm5ld19SIiwic3ViIiwiZG90IiwibXVsdCIsIlFfYmxvY2siLCJuZXdfUSIsInNldF9ibG9jayIsInNlZWQiLCJtYXhfaXRlcmF0aW9ucyIsInFyIiwicXJfZ3JhbXNjaG1pZHQiLCJ0b2wiLCJyYW5kb21pemVyIiwiUmFuZG9taXplciIsInJhbmRvbSIsIm9sZFEiLCJRUiIsInZhbHVlcyIsImVpZ2VudmFsdWVzIiwiZGlhZyIsImVpZ2VudmVjdG9ycyIsInRyYW5zcG9zZSIsInRvMmRBcnJheSIsIk4iLCJjb25zdHJ1Y3RvciIsInRoaXMiLCJfcm93cyIsIl9jb2xzIiwiX2RhdGEiLCJzdGF0aWMiLCJ0eXBlIiwiaXNBcnJheSIsIm0iLCJfIiwiZGF0YSIsInN1YmFycmF5IiwiaXRlcmF0ZV9yb3dzIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJzZXRfcm93Iiwib2Zmc2V0IiwicmVzdWx0X2NvbCIsIlQiLCJpbnZlcnNlIiwiQiIsImgiLCJpX21heCIsIm1heF92YWwiLCJJbmZpbml0eSIsInZhbCIsImhfdmFsIiwiaV92YWwiLCJmIiwiQl9yb3dfcm93IiwiQl9pX2oiLCJqb2luIiwiSSIsIkJfaSIsIkMiLCJlIiwibCIsImNvbmNhdCIsInJvd3NfQSIsImNvbHNfQSIsInJvd3NfQiIsImNvbHNfQiIsIlgiLCJvZmZzZXRfcm93Iiwib2Zmc2V0X2NvbCIsInN0YXJ0X3JvdyIsInN0YXJ0X2NvbCIsImVuZF9yb3ciLCJlbmRfY29sIiwibmV3X3JvdyIsIm5ld19jb2wiLCJnYXRoZXIiLCJyb3dfaW5kaWNlcyIsImNvbF9pbmRpY2VzIiwicm93X2luZGV4IiwiY29sX2luZGV4IiwiX2FwcGx5X2FycmF5IiwiX2FwcGx5X3Jvd3dpc2VfYXJyYXkiLCJfYXBwbHlfY29sd2lzZV9hcnJheSIsIl9hcHBseSIsInZhbHVlX3Jvd3MiLCJ2YWx1ZV9jb2xzIiwiYWRkIiwiYXNBcnJheSIsIm1pbl9yb3dfY29sIiwibWluIiwibWVhbiIsIm1lYW5Sb3dzIiwibWVhbkNvbHMiLCJiX2kiLCJyIiwiZCIsInoiLCJhbHBoYSIsInJfbmV4dCIsIkwiLCJVIiwiTFUiLCJMX2RpYWciLCJVX2RpYWciLCJkZXQiLCJNIiwiTVQiLCJNdE0iLCJNTXQiLCJWIiwiU2lnbWEiLCJzaW11bHRhbmVvdXNfcG93ZXJpdGVyYXRpb24iLCJzaWdtYSIsIl9zZWVkIiwiX04iLCJfTSIsIl9NQVRSSVhfQSIsIl9VUFBFUl9NQVNLIiwiX0xPV0VSX01BU0siLCJfbXQiLCJfbXRpIiwiRGF0ZSIsImdldFRpbWUiLCJtdCIsIm10aSIsInJhbmRvbV9pbnQiLCJtYWcwMSIsImtrIiwiTl9NIiwiTV9OIiwiY2hvaWNlIiwic2FtcGxlIiwiaW5kZXhfbGlzdCIsImxpbnNwYWNlIiwicmFuZG9tX2luZGV4Iiwic3BsaWNlIiwidW5kZWZpbmVkIiwiSGVhcCIsImVsZW1lbnRzIiwiYWNjZXNzb3IiLCJjb21wYXJhdG9yIiwiaGVhcGlmeSIsIl9hY2Nlc3NvciIsIl9jb250YWluZXIiLCJfY29tcGFyYXRvciIsImhlYXAiLCJjb250YWluZXIiLCJlbGVtZW50IiwiZmxvb3IiLCJfaGVhcGlmeV9kb3duIiwiX3N3YXAiLCJpbmRleF9hIiwiaW5kZXhfYiIsIl9oZWFwaWZ5X3VwIiwiaW5kZXgiLCJwYXJlbnRJbmRleCIsIm5vZGUiLCJzdGFydF9pbmRleCIsImxlZnQiLCJyaWdodCIsInBvcCIsIml0ZW0iLCJmaXJzdCIsIml0ZXJhdGUiLCJ0b0FycmF5IiwicmF3X2RhdGEiLCJlbXB0eSIsIkRpc2pvaW50U2V0IiwiX2xpc3QiLCJTZXQiLCJtYWtlX3NldCIsImxpc3QiLCJoYXMiLCJfX2Rpc2pvaW50X3NldCIsInBhcmVudCIsImNoaWxkcmVuIiwic2l6ZSIsImZpbmQiLCJ1bmlvbiIsIm5vZGVfeCIsIm5vZGVfeSIsImZvckVhY2giLCJCYWxsVHJlZSIsIl9Ob2RlIiwicGl2b3QiLCJjaGlsZDEiLCJjaGlsZDIiLCJyYWRpdXMiLCJfTGVhZiIsInBvaW50cyIsIl9tZXRyaWMiLCJfcm9vdCIsIl9jb25zdHJ1Y3QiLCJjIiwiX2dyZWF0ZXN0X3NwcmVhZCIsInNvcnRlZF9lbGVtZW50cyIsInBfaW5kZXgiLCJwIiwic3ByZWFkIiwicmVkdWNlIiwiYWNjIiwiY3VycmVudCIsInNlYXJjaCIsIl9zZWFyY2giLCJLTk4iLCJfZWxlbWVudHMiLCJfRCIsImRpc3RhbmNlcyIsIkgiLCJuZWFyZXN0X2VsZW1lbnRfaW5kZXgiLCJuZWFyZXN0X2Rpc3QiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJEUiIsImRlZmF1bHRfcGFyYW1ldGVycyIsInBhcmFtZXRlcnMiLCJfcGFyYW1ldGVycyIsIk9iamVjdCIsImFzc2lnbiIsInNlYWwiLCJfdHlwZSIsIl9yYW5kb21pemVyIiwiX2lzX2luaXRpYWxpemVkIiwicGFyYW1ldGVyIiwibmFtZSIsImhhc093blByb3BlcnR5IiwicGFyYSIsInRyYW5zZm9ybSIsImNoZWNrX2luaXQiLCJwcm9qZWN0aW9uIiwiZ2VuZXJhdG9yIiwiaW5pdCIsIlkiLCJhc3luYyIsImFyZ3MiLCJQQ0EiLCJzdXBlciIsImVpZ19hcmdzIiwicHJpbmNpcGFsX2NvbXBvbmVudHMiLCJtZWFucyIsIlhfY2VudCIsIk1EUyIsImFpXyIsImFfaiIsImFfXyIsIl9kX1giLCJzdHJlc3MiLCJkX1giLCJkX1kiLCJ0b3Bfc3VtIiwiYm90dG9tX3N1bSIsInBvdyIsIklTT01BUCIsIm5laWdoYm9ycyIsImtOZWFyZXN0TmVpZ2hib3JzIiwiRyIsIm90aGVyIiwiRkFTVE1BUCIsIl9jaG9vc2VfZGlzdGFudF9vYmplY3RzIiwiYV9pbmRleCIsImJfaW5kZXgiLCJtYXhfZGlzdCIsImRfYWkiLCJkX2JpIiwiX2NvbCIsIm9sZF9kaXN0IiwiZF9hYiIsInlfaSIsIkxEQSIsImxhYmVscyIsInVuaXF1ZV9sYWJlbHMiLCJsYWJlbF9pZCIsImNvdW50IiwiaWQiLCJYX21lYW4iLCJWX21lYW4iLCJsYWJlbCIsInZfbWVhbiIsIlNfYiIsIlNfdyIsInJvd192IiwiTExFIiwia19uZWFyZXN0X25laWdoYm9ycyIsIk8iLCJXIiwibk5fcm93IiwiWiIsIkNfdHJhY2UiLCJ3Iiwic29sdmVfQ0ciLCJJVyIsIkxUU0EiLCJJX2kiLCJYX2kiLCJnIiwiR19pX3QiLCJXX2kiLCJUU05FIiwicGVycGxleGl0eSIsImVwc2lsb24iLCJfaXRlciIsIkh0YXJnZXQiLCJsb2ciLCJEZWx0YSIsImRydWlkIiwiUCIsIl95c3RlcCIsIl9nYWlucyIsInByb3ciLCJiZXRhbWluIiwiYmV0YW1heCIsImRvbmUiLCJudW0iLCJwc3VtIiwicGoiLCJleHAiLCJIaGVyZSIsIlBvdXQiLCJOMiIsIl9QIiwiaXRlcmF0aW9ucyIsIm5leHQiLCJpdGVyIiwieXN0ZXAiLCJnYWlucyIsImRpbSIsInBtdWwiLCJRdSIsInFzdW0iLCJkc3VtIiwiZGhlcmUiLCJxdSIsImdyYWQiLCJwcmVtdWx0IiwieW1lYW4iLCJnaWQiLCJzaWQiLCJnYWluaWQiLCJuZXdnYWluIiwibmV3c2lkIiwibWF4X2l0ZXIiLCJwZngiLCJmeCIsImNvbnZlcmdlbmNlIiwiZnhpIiwiZHgiLCJVTUFQIiwibl9uZWlnaGJvcnMiLCJsb2NhbF9jb25uZWN0aXZpdHkiLCJtaW5fZGlzdCIsIl9zcHJlYWQiLCJfc2V0X29wX21peF9yYXRpbyIsIl9yZXB1bHNpb25fc3RyZW5ndGgiLCJfbmVnYXRpdmVfc2FtcGxlX3JhdGUiLCJfbl9lcG9jaHMiLCJfaW5pdGlhbF9hbHBoYSIsIl9maW5kX2FiX3BhcmFtcyIsInh2IiwieXYiLCJ4dl9pIiwicG93ZWxsIiwiZXJyb3IiLCJfY29tcHV0ZV9tZW1iZXJzaGlwX3N0cmVuZ3RocyIsInNpZ21hcyIsInJob3MiLCJfc21vb3RoX2tubl9kaXN0Iiwia25uIiwiU01PT1RIX0tfVE9MRVJBTkNFIiwiTUlOX0tfRElTVF9TQ0FMRSIsInRhcmdldCIsImxvZzIiLCJyZXZlcnNlIiwieF9pIiwibG8iLCJoaSIsIm1pZCIsInNlYXJjaF9yZXN1bHQiLCJub25femVyb19kaXN0IiwiZmlsdGVyIiwibm9uX3plcm9fZGlzdF9sZW5ndGgiLCJpbnRlcnBvbGF0aW9uIiwibWVhbl9pdGhkIiwibWVhbl9kIiwiX2Z1enp5X3NpbXBsaWNpYWxfc2V0IiwiZGlzdGFuY2VzX2kiLCJ0cmFuc3Bvc2VkX3Jlc3VsdCIsInByb2RfbWF0cml4IiwiX21ha2VfZXBvY2hzX3Blcl9zYW1wbGUiLCJuX2Vwb2NocyIsIndlaWdodHMiLCJfd2VpZ2h0cyIsIkZsb2F0MzJBcnJheSIsImZpbGwiLCJ3ZWlnaHRzX21heCIsIm5fc2FtcGxlcyIsIl90b2NvbyIsImdyYXBoIiwicm93c19uIiwiY29sc19uIiwiX2EiLCJfYiIsIl9ncmFwaCIsIl9oZWFkIiwiX3RhaWwiLCJfZXBvY2hzX3Blcl9zYW1wbGUiLCJfZXBvY2hzX3Blcl9uZWdhdGl2ZV9zYW1wbGUiLCJfZXBvY2hfb2ZfbmV4dF9zYW1wbGUiLCJfZXBvY2hfb2ZfbmV4dF9uZWdhdGl2ZV9zYW1wbGUiLCJfY2xpcCIsIl9vcHRpbWl6ZV9sYXlvdXQiLCJoZWFkX2VtYmVkZGluZyIsInRhaWxfZW1iZWRkaW5nIiwiaGVhZCIsInRhaWwiLCJfYWxwaGEiLCJlcG9jaHNfcGVyX3NhbXBsZSIsImVwb2Noc19wZXJfbmVnYXRpdmVfc2FtcGxlIiwiZXBvY2hfb2ZfbmV4dF9uZWdhdGl2ZV9zYW1wbGUiLCJlcG9jaF9vZl9uZXh0X3NhbXBsZSIsImNsaXAiLCJ0YWlsX2xlbmd0aCIsImdyYWRfY29lZmYiLCJncmFkX2QiLCJvIiwibl9uZWdfc2FtcGxlcyIsIlRyaU1hcCIsIndlaWdodF9hZGoiLCJwY2EiLCJuX2lubGllcnMiLCJuX291dGxpZXJzIiwibl9yYW5kb20iLCJ0cmlwbGV0cyIsIl9nZW5lcmF0ZV90cmlwbGV0cyIsImxyIiwidmVsIiwiZ2FpbiIsIm5fZXh0cmEiLCJuYnJzIiwia25uX2Rpc3RhbmNlcyIsInNpZyIsIl9maW5kX3AiLCJfc2FtcGxlX2tubl90cmlwbGV0cyIsIm5fdHJpcGxldHMiLCJvdXRsaWVyX2Rpc3RhbmNlcyIsIl9maW5kX3dlaWdodHMiLCJyYW5kb21fdHJpcGxldHMiLCJyYW5kb21fd2VpZ2h0cyIsIl9zYW1wbGVfcmFuZG9tX3RyaXBsZXRzIiwibWF4X3dlaWdodCIsImlzTmFOIiwibWF4X3dlaWdodF8yIiwibl9pIiwic29ydF9pbmRpY2VzIiwiX19hcmdzb3J0Iiwibl9qIiwic2ltIiwic2FtcGxlcyIsIl9yZWplY3Rpb25fc2FtcGxlIiwib3V0IiwibWF4X2ludCIsInJlamVjdHMiLCJpbnRlcnZhbCIsImluZGV4T2YiLCJwX3NpbSIsInBfb3V0IiwiaW5kaWNlcyIsIl9ncmFkIiwieV9paiIsInlfaWsiLCJkX2lqIiwiZF9payIsIm5fdmlvbCIsImxvc3MiLCJuX2tubl90cmlwbGV0cyIsIllfaWQiLCJZX2pkIiwiWV9rZCIsImdzIiwiZ28iLCJtYXhfaXRlcmF0aW9uIiwiX25leHQiLCJnYW1tYSIsIm9sZF9DIiwiX3VwZGF0ZV9lbWJlZGRpbmciLCJuZXdfZ2FpbiIsIkhpZXJhcmNoaWNhbF9DbHVzdGVyaW5nIiwibWF0cml4IiwibGlua2FnZSIsIl9pZCIsIl9tYXRyaXgiLCJfbGlua2FnZSIsInJvb3QiLCJkbyIsImdldF9jbHVzdGVycyIsImNsdXN0ZXJzIiwiZGVwdGgiLCJfdHJhdmVyc2UiLCJsZWF2ZXMiLCJfbiIsImRfbWluIiwiX2RfbWluIiwiX2Rpc3RhbmNlX21hdHJpeCIsIl9jbHVzdGVycyIsImNfc2l6ZSIsIl9jX3NpemUiLCJVaW50MTZBcnJheSIsIkNsdXN0ZXIiLCJwX21heCIsImMxIiwiRF9pX21pbiIsImMyIiwiYzFfY2x1c3RlciIsImMyX2NsdXN0ZXIiLCJjMV9jbHVzdGVyX2luZGljZXMiLCJpc0xlYWYiLCJjMl9jbHVzdGVyX2luZGljZXMiLCJuZXdfY2x1c3RlciIsInVuc2hpZnQiLCJEX2MxX2oiLCJEX2MyX2oiLCJjZW50cm9pZCIsIl9jYWxjdWxhdGVfY2VudHJvaWQiLCJsX3NpemUiLCJyX3NpemUiLCJsX2NlbnRyb2lkIiwicl9jZW50cm9pZCIsIm5ld19jZW50cm9pZCIsImRlc2NlbmRhbnRzIiwibGVmdF9kZXNjZW5kYW50cyIsInJpZ2h0X2Rlc2NlbmRhbnRzIiwiS01lYW5zIiwiSyIsIl9LIiwiX2NsdXN0ZXJfY2VudHJvaWRzIiwiX2dldF9yYW5kb21fY2VudHJvaWRzIiwiX2Z1cnRoZXN0X3BvaW50IiwiY2FuZGlkYXRlcyIsIkFkIiwiY2x1c3Rlcl9jZW50cm9pZHMiLCJyYW5kb21fcG9pbnQiLCJpbml0X3BvaW50cyIsInNhbXBsZV9zaXplIiwiZnVydGhlc3RfcG9pbnQiLCJfaXRlcmF0aW9uIiwiY2x1c3RlcnNfY2hhbmdlZCIsIkFpIiwibWluX2NsdXN0ZXIiLCJfY29tcHV0ZV9jZW50cm9pZCIsImNsdXN0ZXJfY291bnRlciIsImNpIiwiaXRlcmF0aW9uX3Jlc3VsdCIsIktNZWRvaWRzIiwiX0EiLCJfbWF4X2l0ZXIiLCJsb2cxMCIsIl9jbHVzdGVyX21lZG9pZHMiLCJfZ2V0X3JhbmRvbV9tZWRvaWRzIiwieF9qIiwiX25lYXJlc3RfbWVkb2lkIiwiaW5kZXhfbmVhcmVzdCIsIm1lZG9pZHMiLCJmaW5pc2giLCJjYWNoZSIsInhfbyIsIkRlbHRhVEQiLCJ4cyIsImZpbmRJbmRleCIsImRfaiIsImRpc3RhbmNlX25lYXJlc3QiLCJkZWx0YVREIiwiZF9vaiIsIl9nZXRfZGlzdGFuY2UiLCJkX24iLCJkaXN0YW5jZV9zZWNvbmQiLCJkX3MiLCJuZWFyZXN0Iiwic2Vjb25kIiwieF9tIiwibTEiLCJtMiIsImluZGV4X3NlY29uZCIsImNsdXN0ZXJfbWVkb2lkcyIsImNlaWwiLCJURCIsIlREMCIsIlMiLCJTX2oiLCJTX28iLCJkZWx0YSIsIk9QVElDUyIsIm1pbl9wb2ludHMiLCJfZXBzaWxvbiIsIl9taW5fcG9pbnRzIiwiX29yZGVyZWRfbGlzdCIsIl9EQiIsIm9yZGVyZWRfbGlzdCIsIkRCIiwiY2x1c3Rlcl9pbmRleCIsIl9jbHVzdGVyX2luZGV4IiwicmVhY2hhYmlsaXR5X2Rpc3RhbmNlIiwicHJvY2Vzc2VkIiwiX2dldF9uZWlnaGJvcnMiLCJfY29yZV9kaXN0YW5jZSIsInNlZWRzIiwiX3VwZGF0ZSIsIl9leHBhbmRfY2x1c3RlciIsImNvcmVfZGlzdGFuY2UiLCJuZXdfcmVhY2hhYmlsaXR5X2Rpc3RhbmNlIiwiY2x1c3RlciIsIm91dGxpZXJzIiwiZ2V0X2NsdXN0ZXJfYWZmaXJtYXRpb24iLCJMU1AiLCJjb250cm9sX3BvaW50cyIsIkRSX3BhcmFtZXRlcnMiLCJuYyIsImNfaSIsIllfQyIsIlhBIiwiQVQiLCJBVEEiLCJBVGIiLCJUb3BvTWFwIiwiX19sYXp5X2Rpc3RhbmNlX21hdHJpeCIsIkRfaWoiLCJfbWFrZV9taW5pbXVtX3NwYW5uaW5nX3RyZWUiLCJkaXNqb2ludF9zZXQiLCJGIiwiRSIsInNldF91Iiwic2V0X3YiLCJfRW1zdCIsIl9faHVsbF9jcm9zcyIsImF4IiwiYXkiLCJieCIsImJ5Iiwic3giLCJzeSIsIl9faHVsbCIsIngxIiwieTEiLCJ4MiIsInkyIiwibG93ZXIiLCJ1cHBlciIsIl9fZmluZEFuZ2xlIiwicDF4IiwicDF5IiwicDJ4IiwicDJ5Iiwic2luIiwiY29zIiwidmVjIiwiX19hbGlnbl9odWxsIiwiaHVsbCIsInRvcEVkZ2UiLCJkMiIsInYxIiwidjIiLCJ0cmFuc2Zvcm1hdGlvbiIsInR4IiwidHkiLCJfX3RyYW5zZm9ybSIsInB4IiwicHkiLCJfX3RyYW5zZm9ybV9jb21wb25lbnQiLCJ5T2Zmc2V0IiwiY3giLCJjeSIsIl9fYWxpZ25fY29tcG9uZW50cyIsInBvaW50c191IiwicG9pbnRzX3YiLCJodWxsX3UiLCJodWxsX3YiLCJ0X3UiLCJ0X3YiLCJFbXN0IiwiY29tcG9uZW50cyIsImNvbXBvbmVudF91IiwiY29tcG9uZW50X3YiLCJTQU1NT04iLCJtYWdpYyIsImluaXRfRFIiLCJpbml0X3BhcmFtZXRlcnMiLCJpbmNsdWRlcyIsIl9zdGVwIiwiTUFHSUMiLCJlMSIsImUyIiwiWWkiLCJZaiIsImRZIiwiZFgiLCJkcSIsImRyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFTZSxtQkFBVUEsRUFBR0MsR0FDeEIsT0FBT0MsS0FBS0MsS0FBS0Msa0JBQWtCSixFQUFHQzs7Ozs7Ozs7R0NGM0IsbUJBQVVJLEdBQ3JCLElBR0lDLEVBQUdD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
